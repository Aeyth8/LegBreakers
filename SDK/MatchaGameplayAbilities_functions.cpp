#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MatchaGameplayAbilities

#include "Basic.hpp"

#include "MatchaGameplayAbilities_classes.hpp"
#include "MatchaGameplayAbilities_parameters.hpp"


namespace SDK
{

// Function MatchaGameplayAbilities.MatchaGameplayEffectOwner.ApplyGameplayEffectClassToSelf
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UMatchaGameplayEffect>GameplayEffectClass                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMatchaActiveGameplayEffectHandleReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMatchaActiveGameplayEffectHandle IMatchaGameplayEffectOwner::ApplyGameplayEffectClassToSelf(const TSubclassOf<class UMatchaGameplayEffect>& GameplayEffectClass, float Level, const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwner", "ApplyGameplayEffectClassToSelf");

	Params::MatchaGameplayEffectOwner_ApplyGameplayEffectClassToSelf Parms{};

	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.Level = Level;
	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectOwner.ApplyGameplayEffectSpecHandleToSelf
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  GameplayEffectHandle                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMatchaActiveGameplayEffectHandleReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMatchaActiveGameplayEffectHandle IMatchaGameplayEffectOwner::ApplyGameplayEffectSpecHandleToSelf(const struct FMatchaGameplayEffectSpecHandle& GameplayEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwner", "ApplyGameplayEffectSpecHandleToSelf");

	Params::MatchaGameplayEffectOwner_ApplyGameplayEffectSpecHandleToSelf Parms{};

	Parms.GameplayEffectHandle = std::move(GameplayEffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectOwner.ApplyGameplayEffectSpecToSelf
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpec        GameplayEffect                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMatchaActiveGameplayEffectHandleReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMatchaActiveGameplayEffectHandle IMatchaGameplayEffectOwner::ApplyGameplayEffectSpecToSelf(const struct FMatchaGameplayEffectSpec& GameplayEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwner", "ApplyGameplayEffectSpecToSelf");

	Params::MatchaGameplayEffectOwner_ApplyGameplayEffectSpecToSelf Parms{};

	Parms.GameplayEffect = std::move(GameplayEffect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectOwner.ApplyGameplayEffectToSelf
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMatchaGameplayEffect*            GameplayEffect                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMatchaActiveGameplayEffectHandleReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMatchaActiveGameplayEffectHandle IMatchaGameplayEffectOwner::ApplyGameplayEffectToSelf(const class UMatchaGameplayEffect* GameplayEffect, float Level, const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwner", "ApplyGameplayEffectToSelf");

	Params::MatchaGameplayEffectOwner_ApplyGameplayEffectToSelf Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.Level = Level;
	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectOwner.RemoveGameplayEffectFromSelf
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleHandle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMatchaGameplayEffectOwner::RemoveGameplayEffectFromSelf(const struct FMatchaActiveGameplayEffectHandle& Handle, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwner", "RemoveGameplayEffectFromSelf");

	Params::MatchaGameplayEffectOwner_RemoveGameplayEffectFromSelf Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectOwner.RemoveGameplayEffectFromSelfByClass
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UMatchaGameplayEffect>GameplayEffectClass                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMatchaGameplayEffectOwner::RemoveGameplayEffectFromSelfByClass(const TSubclassOf<class UMatchaGameplayEffect>& GameplayEffectClass, int32 Level, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwner", "RemoveGameplayEffectFromSelfByClass");

	Params::MatchaGameplayEffectOwner_RemoveGameplayEffectFromSelfByClass Parms{};

	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.Level = Level;
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectOwner.GetAggregatedStackCount
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMatchaGameplayEffectQuery       Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IMatchaGameplayEffectOwner::GetAggregatedStackCount(const struct FMatchaGameplayEffectQuery& Query) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwner", "GetAggregatedStackCount");

	Params::MatchaGameplayEffectOwner_GetAggregatedStackCount Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectOwner.MakeEffectContext
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMatchaGameplayEffectContextHandleReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectContextHandle IMatchaGameplayEffectOwner::MakeEffectContext() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwner", "MakeEffectContext");

	Params::MatchaGameplayEffectOwner_MakeEffectContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectOwnerProvider.GetGameplayEffectOwner
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class IMatchaGameplayEffectOwner>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IMatchaGameplayEffectOwner> IMatchaGameplayEffectOwnerProvider::GetGameplayEffectOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectOwnerProvider", "GetGameplayEffectOwner");

	Params::MatchaGameplayEffectOwnerProvider_GetGameplayEffectOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.AddAssetTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NewGameplayTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::AddAssetTag(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& NewGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "AddAssetTag");

	Params::MatchaAbilitySystemBlueprintLibrary_AddAssetTag Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.NewGameplayTag = std::move(NewGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.AddAssetTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            NewGameplayTags                                        (Parm, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::AddAssetTags(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTagContainer& NewGameplayTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "AddAssetTags");

	Params::MatchaAbilitySystemBlueprintLibrary_AddAssetTags Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.NewGameplayTags = std::move(NewGameplayTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.AddGrantedTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NewGameplayTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::AddGrantedTag(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& NewGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "AddGrantedTag");

	Params::MatchaAbilitySystemBlueprintLibrary_AddGrantedTag Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.NewGameplayTag = std::move(NewGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.AddGrantedTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            NewGameplayTags                                        (Parm, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::AddGrantedTags(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTagContainer& NewGameplayTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "AddGrantedTags");

	Params::MatchaAbilitySystemBlueprintLibrary_AddGrantedTags Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.NewGameplayTags = std::move(NewGameplayTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.AssignSetByCallerMagnitude
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// class FName                             DataName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::AssignSetByCallerMagnitude(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, class FName DataName, float Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "AssignSetByCallerMagnitude");

	Params::MatchaAbilitySystemBlueprintLibrary_AssignSetByCallerMagnitude Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.DataName = DataName;
	Parms.Magnitude = Magnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.AssignTagSetByCallerMagnitude
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DataTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& DataTag, float Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "AssignTagSetByCallerMagnitude");

	Params::MatchaAbilitySystemBlueprintLibrary_AssignTagSetByCallerMagnitude Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.DataTag = std::move(DataTag);
	Parms.Magnitude = Magnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.CloneSpecHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InNewInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InEffectCauser                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  GameplayEffectSpecHandle_Clone                         (Parm, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::CloneSpecHandle(class AActor* InNewInstigator, class AActor* InEffectCauser, const struct FMatchaGameplayEffectSpecHandle& GameplayEffectSpecHandle_Clone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "CloneSpecHandle");

	Params::MatchaAbilitySystemBlueprintLibrary_CloneSpecHandle Parms{};

	Parms.InNewInstigator = InNewInstigator;
	Parms.InEffectCauser = InEffectCauser;
	Parms.GameplayEffectSpecHandle_Clone = std::move(GameplayEffectSpecHandle_Clone);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextAddHitResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaAbilitySystemBlueprintLibrary::EffectContextAddHitResult(const struct FMatchaGameplayEffectContextHandle& EffectContext, const struct FHitResult& HitResult, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextAddHitResult");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextAddHitResult Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.HitResult = std::move(HitResult);
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextGetEffectCauser
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMatchaAbilitySystemBlueprintLibrary::EffectContextGetEffectCauser(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextGetEffectCauser");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextGetEffectCauser Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextGetHitResult
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UMatchaAbilitySystemBlueprintLibrary::EffectContextGetHitResult(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextGetHitResult");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextGetHitResult Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextGetInstigatorActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMatchaAbilitySystemBlueprintLibrary::EffectContextGetInstigatorActor(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextGetInstigatorActor");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextGetInstigatorActor Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextGetOrigin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMatchaAbilitySystemBlueprintLibrary::EffectContextGetOrigin(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextGetOrigin");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextGetOrigin Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextGetOriginalInstigatorActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMatchaAbilitySystemBlueprintLibrary::EffectContextGetOriginalInstigatorActor(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextGetOriginalInstigatorActor");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextGetOriginalInstigatorActor Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextGetSourceObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UMatchaAbilitySystemBlueprintLibrary::EffectContextGetSourceObject(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextGetSourceObject");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextGetSourceObject Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextHasHitResult
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaAbilitySystemBlueprintLibrary::EffectContextHasHitResult(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextHasHitResult");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextHasHitResult Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextIsInstigatorLocallyControlled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaAbilitySystemBlueprintLibrary::EffectContextIsInstigatorLocallyControlled(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextIsInstigatorLocallyControlled");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextIsInstigatorLocallyControlled Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextIsValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaAbilitySystemBlueprintLibrary::EffectContextIsValid(const struct FMatchaGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextIsValid");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextIsValid Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EffectContextSetOrigin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectContextHandleEffectContext                                          (Parm, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaAbilitySystemBlueprintLibrary::EffectContextSetOrigin(const struct FMatchaGameplayEffectContextHandle& EffectContext, const struct FVector& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EffectContextSetOrigin");

	Params::MatchaAbilitySystemBlueprintLibrary_EffectContextSetOrigin Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EqualEqual_ActiveGameplayEffectHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleA                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaActiveGameplayEffectHandleB                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaAbilitySystemBlueprintLibrary::EqualEqual_ActiveGameplayEffectHandle(const struct FMatchaActiveGameplayEffectHandle& A, const struct FMatchaActiveGameplayEffectHandle& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EqualEqual_ActiveGameplayEffectHandle");

	Params::MatchaAbilitySystemBlueprintLibrary_EqualEqual_ActiveGameplayEffectHandle Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EqualEqual_GameplayAttributeGameplayAttribute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayAttribute         AttributeA                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayAttribute         AttributeB                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaAbilitySystemBlueprintLibrary::EqualEqual_GameplayAttributeGameplayAttribute(const struct FMatchaGameplayAttribute& AttributeA, const struct FMatchaGameplayAttribute& AttributeB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EqualEqual_GameplayAttributeGameplayAttribute");

	Params::MatchaAbilitySystemBlueprintLibrary_EqualEqual_GameplayAttributeGameplayAttribute Parms{};

	Parms.AttributeA = std::move(AttributeA);
	Parms.AttributeB = std::move(AttributeB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EvaluateAttributeValueWithTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayAttribute         Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            SourceTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TargetTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::EvaluateAttributeValueWithTags(class AActor* Actor, const struct FMatchaGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EvaluateAttributeValueWithTags");

	Params::MatchaAbilitySystemBlueprintLibrary_EvaluateAttributeValueWithTags Parms{};

	Parms.Actor = Actor;
	Parms.Attribute = std::move(Attribute);
	Parms.SourceTags = std::move(SourceTags);
	Parms.TargetTags = std::move(TargetTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.EvaluateAttributeValueWithTagsAndBase
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayAttribute         Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            SourceTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TargetTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   BaseValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::EvaluateAttributeValueWithTagsAndBase(class AActor* Actor, const struct FMatchaGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags, float BaseValue, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "EvaluateAttributeValueWithTagsAndBase");

	Params::MatchaAbilitySystemBlueprintLibrary_EvaluateAttributeValueWithTagsAndBase Parms{};

	Parms.Actor = Actor;
	Parms.Attribute = std::move(Attribute);
	Parms.SourceTags = std::move(SourceTags);
	Parms.TargetTags = std::move(TargetTags);
	Parms.BaseValue = BaseValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetActiveGameplayEffectDebugString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatchaAbilitySystemBlueprintLibrary::GetActiveGameplayEffectDebugString(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetActiveGameplayEffectDebugString");

	Params::MatchaAbilitySystemBlueprintLibrary_GetActiveGameplayEffectDebugString Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetActiveGameplayEffectExpectedEndTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::GetActiveGameplayEffectExpectedEndTime(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetActiveGameplayEffectExpectedEndTime");

	Params::MatchaAbilitySystemBlueprintLibrary_GetActiveGameplayEffectExpectedEndTime Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetActiveGameplayEffectRemainingDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaActiveGameplayEffectHandleActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::GetActiveGameplayEffectRemainingDuration(class UObject* WorldContextObject, const struct FMatchaActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetActiveGameplayEffectRemainingDuration");

	Params::MatchaAbilitySystemBlueprintLibrary_GetActiveGameplayEffectRemainingDuration Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetActiveGameplayEffectStackCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaAbilitySystemBlueprintLibrary::GetActiveGameplayEffectStackCount(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetActiveGameplayEffectStackCount");

	Params::MatchaAbilitySystemBlueprintLibrary_GetActiveGameplayEffectStackCount Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetActiveGameplayEffectStackLimitCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaAbilitySystemBlueprintLibrary::GetActiveGameplayEffectStackLimitCount(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetActiveGameplayEffectStackLimitCount");

	Params::MatchaAbilitySystemBlueprintLibrary_GetActiveGameplayEffectStackLimitCount Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetActiveGameplayEffectStartTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::GetActiveGameplayEffectStartTime(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetActiveGameplayEffectStartTime");

	Params::MatchaAbilitySystemBlueprintLibrary_GetActiveGameplayEffectStartTime Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetActiveGameplayEffectTotalDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::GetActiveGameplayEffectTotalDuration(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetActiveGameplayEffectTotalDuration");

	Params::MatchaAbilitySystemBlueprintLibrary_GetActiveGameplayEffectTotalDuration Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetDebugStringFromGameplayAttribute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayAttribute         Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatchaAbilitySystemBlueprintLibrary::GetDebugStringFromGameplayAttribute(const struct FMatchaGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetDebugStringFromGameplayAttribute");

	Params::MatchaAbilitySystemBlueprintLibrary_GetDebugStringFromGameplayAttribute Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetEffectContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectContextHandleReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectContextHandle UMatchaAbilitySystemBlueprintLibrary::GetEffectContext(const struct FMatchaGameplayEffectSpecHandle& SpecHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetEffectContext");

	Params::MatchaAbilitySystemBlueprintLibrary_GetEffectContext Parms{};

	Parms.SpecHandle = std::move(SpecHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetFloatAttribute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayAttribute         Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccessfullyFoundAttribute                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::GetFloatAttribute(const class AActor* Actor, const struct FMatchaGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetFloatAttribute");

	Params::MatchaAbilitySystemBlueprintLibrary_GetFloatAttribute Parms{};

	Parms.Actor = Actor;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccessfullyFoundAttribute != nullptr)
		*bSuccessfullyFoundAttribute = Parms.bSuccessfullyFoundAttribute;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetFloatAttributeBase
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayAttribute         Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccessfullyFoundAttribute                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::GetFloatAttributeBase(const class AActor* Actor, const struct FMatchaGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetFloatAttributeBase");

	Params::MatchaAbilitySystemBlueprintLibrary_GetFloatAttributeBase Parms{};

	Parms.Actor = Actor;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccessfullyFoundAttribute != nullptr)
		*bSuccessfullyFoundAttribute = Parms.bSuccessfullyFoundAttribute;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetGameplayEffectFromActiveEffectHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleActiveHandle                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UMatchaGameplayEffect*      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMatchaGameplayEffect* UMatchaAbilitySystemBlueprintLibrary::GetGameplayEffectFromActiveEffectHandle(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetGameplayEffectFromActiveEffectHandle");

	Params::MatchaAbilitySystemBlueprintLibrary_GetGameplayEffectFromActiveEffectHandle Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetGameplayEffectUIData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UMatchaGameplayEffect>EffectClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UMatchaGameplayEffectUIData>DataType                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UMatchaGameplayEffectUIData*ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMatchaGameplayEffectUIData* UMatchaAbilitySystemBlueprintLibrary::GetGameplayEffectUIData(TSubclassOf<class UMatchaGameplayEffect> EffectClass, TSubclassOf<class UMatchaGameplayEffectUIData> DataType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetGameplayEffectUIData");

	Params::MatchaAbilitySystemBlueprintLibrary_GetGameplayEffectUIData Parms{};

	Parms.EffectClass = EffectClass;
	Parms.DataType = DataType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.GetModifiedAttributeMagnitude
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FMatchaGameplayAttribute         Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaAbilitySystemBlueprintLibrary::GetModifiedAttributeMagnitude(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FMatchaGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "GetModifiedAttributeMagnitude");

	Params::MatchaAbilitySystemBlueprintLibrary_GetModifiedAttributeMagnitude Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayAttribute         Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaAbilitySystemBlueprintLibrary::IsValid(const struct FMatchaGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "IsValid");

	Params::MatchaAbilitySystemBlueprintLibrary_IsValid Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.MakeSpecHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMatchaGameplayEffect*            InGameplayEffect                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InEffectCauser                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::MakeSpecHandle(class UMatchaGameplayEffect* InGameplayEffect, class AActor* InInstigator, class AActor* InEffectCauser, float InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "MakeSpecHandle");

	Params::MatchaAbilitySystemBlueprintLibrary_MakeSpecHandle Parms{};

	Parms.InGameplayEffect = InGameplayEffect;
	Parms.InInstigator = InInstigator;
	Parms.InEffectCauser = InEffectCauser;
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.MakeSpecHandle_EffectCDO
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UMatchaGameplayEffect>InGameplayEffectClass                                  (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InEffectCauser                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::MakeSpecHandle_EffectCDO(TSubclassOf<class UMatchaGameplayEffect> InGameplayEffectClass, class AActor* InInstigator, class AActor* InEffectCauser, float InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "MakeSpecHandle_EffectCDO");

	Params::MatchaAbilitySystemBlueprintLibrary_MakeSpecHandle_EffectCDO Parms{};

	Parms.InGameplayEffectClass = InGameplayEffectClass;
	Parms.InInstigator = InInstigator;
	Parms.InEffectCauser = InEffectCauser;
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.NotEqual_ActiveGameplayEffectHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaActiveGameplayEffectHandleA                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaActiveGameplayEffectHandleB                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaAbilitySystemBlueprintLibrary::NotEqual_ActiveGameplayEffectHandle(const struct FMatchaActiveGameplayEffectHandle& A, const struct FMatchaActiveGameplayEffectHandle& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "NotEqual_ActiveGameplayEffectHandle");

	Params::MatchaAbilitySystemBlueprintLibrary_NotEqual_ActiveGameplayEffectHandle Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.NotEqual_GameplayAttributeGameplayAttribute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaGameplayAttribute         AttributeA                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayAttribute         AttributeB                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaAbilitySystemBlueprintLibrary::NotEqual_GameplayAttributeGameplayAttribute(const struct FMatchaGameplayAttribute& AttributeA, const struct FMatchaGameplayAttribute& AttributeB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "NotEqual_GameplayAttributeGameplayAttribute");

	Params::MatchaAbilitySystemBlueprintLibrary_NotEqual_GameplayAttributeGameplayAttribute Parms{};

	Parms.AttributeA = std::move(AttributeA);
	Parms.AttributeB = std::move(AttributeB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.SetDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::SetDuration(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "SetDuration");

	Params::MatchaAbilitySystemBlueprintLibrary_SetDuration Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.SetStackCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::SetStackCount(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, int32 StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "SetStackCount");

	Params::MatchaAbilitySystemBlueprintLibrary_SetStackCount Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary.SetStackCountToMax
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMatchaGameplayEffectSpecHandle  SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpecHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaGameplayEffectSpecHandle UMatchaAbilitySystemBlueprintLibrary::SetStackCountToMax(const struct FMatchaGameplayEffectSpecHandle& SpecHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAbilitySystemBlueprintLibrary", "SetStackCountToMax");

	Params::MatchaAbilitySystemBlueprintLibrary_SetStackCountToMax Parms{};

	Parms.SpecHandle = std::move(SpecHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectCustomApplicationRequirement.CanApplyGameplayEffect
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class UMatchaGameplayEffect*            GameplayEffect                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectSpec        Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TScriptInterface<class IMatchaGameplayEffectOwner>GameplayEffectOwner                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayEffectCustomApplicationRequirement::CanApplyGameplayEffect(const class UMatchaGameplayEffect* GameplayEffect, const struct FMatchaGameplayEffectSpec& Spec, const TScriptInterface<class IMatchaGameplayEffectOwner>& GameplayEffectOwner) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectCustomApplicationRequirement", "CanApplyGameplayEffect");

	Params::MatchaGameplayEffectCustomApplicationRequirement_CanApplyGameplayEffect Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.Spec = std::move(Spec);
	Parms.GameplayEffectOwner = GameplayEffectOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayEffectExecutionCalculation.Execute
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FMatchaGameplayEffectCustomExecutionParametersExecutionParams                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEffectCustomExecutionOutputOutExecutionOutput                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UMatchaGameplayEffectExecutionCalculation::Execute(const struct FMatchaGameplayEffectCustomExecutionParameters& ExecutionParams, struct FMatchaGameplayEffectCustomExecutionOutput* OutExecutionOutput) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEffectExecutionCalculation", "Execute");

	Params::MatchaGameplayEffectExecutionCalculation_Execute Parms{};

	Parms.ExecutionParams = std::move(ExecutionParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutExecutionOutput != nullptr)
		*OutExecutionOutput = std::move(Parms.OutExecutionOutput);
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.CalculateBaseMagnitude
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaGameplayModMagnitudeCalculation::CalculateBaseMagnitude(const struct FMatchaGameplayEffectSpec& Spec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "CalculateBaseMagnitude");

	Params::MatchaGameplayModMagnitudeCalculation_CalculateBaseMagnitude Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.GetSetByCallerMagnitudeByName
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             MagnitudeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaGameplayModMagnitudeCalculation::GetSetByCallerMagnitudeByName(const struct FMatchaGameplayEffectSpec& EffectSpec, const class FName& MagnitudeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "GetSetByCallerMagnitudeByName");

	Params::MatchaGameplayModMagnitudeCalculation_GetSetByCallerMagnitudeByName Parms{};

	Parms.EffectSpec = std::move(EffectSpec);
	Parms.MagnitudeName = MagnitudeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.GetSetByCallerMagnitudeByTag
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaGameplayModMagnitudeCalculation::GetSetByCallerMagnitudeByTag(const struct FMatchaGameplayEffectSpec& EffectSpec, const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "GetSetByCallerMagnitudeByTag");

	Params::MatchaGameplayModMagnitudeCalculation_GetSetByCallerMagnitudeByTag Parms{};

	Parms.EffectSpec = std::move(EffectSpec);
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.GetSourceActorTags
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UMatchaGameplayModMagnitudeCalculation::GetSourceActorTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "GetSourceActorTags");

	Params::MatchaGameplayModMagnitudeCalculation_GetSourceActorTags Parms{};

	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.GetSourceAggregatedTags
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UMatchaGameplayModMagnitudeCalculation::GetSourceAggregatedTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "GetSourceAggregatedTags");

	Params::MatchaGameplayModMagnitudeCalculation_GetSourceAggregatedTags Parms{};

	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.GetSourceSpecTags
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UMatchaGameplayModMagnitudeCalculation::GetSourceSpecTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "GetSourceSpecTags");

	Params::MatchaGameplayModMagnitudeCalculation_GetSourceSpecTags Parms{};

	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.GetTargetActorTags
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UMatchaGameplayModMagnitudeCalculation::GetTargetActorTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "GetTargetActorTags");

	Params::MatchaGameplayModMagnitudeCalculation_GetTargetActorTags Parms{};

	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.GetTargetAggregatedTags
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UMatchaGameplayModMagnitudeCalculation::GetTargetAggregatedTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "GetTargetAggregatedTags");

	Params::MatchaGameplayModMagnitudeCalculation_GetTargetAggregatedTags Parms{};

	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.GetTargetSpecTags
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UMatchaGameplayModMagnitudeCalculation::GetTargetSpecTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "GetTargetSpecTags");

	Params::MatchaGameplayModMagnitudeCalculation_GetTargetSpecTags Parms{};

	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation.K2_GetCapturedAttributeMagnitude
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FMatchaGameplayEffectSpec        EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMatchaGameplayAttribute         Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            SourceTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TargetTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaGameplayModMagnitudeCalculation::K2_GetCapturedAttributeMagnitude(const struct FMatchaGameplayEffectSpec& EffectSpec, const struct FMatchaGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayModMagnitudeCalculation", "K2_GetCapturedAttributeMagnitude");

	Params::MatchaGameplayModMagnitudeCalculation_K2_GetCapturedAttributeMagnitude Parms{};

	Parms.EffectSpec = std::move(EffectSpec);
	Parms.Attribute = std::move(Attribute);
	Parms.SourceTags = std::move(SourceTags);
	Parms.TargetTags = std::move(TargetTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MatchaGameplayAbilities.MatchaGameplayTagReponseTable.TagResponseEvent
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IMatchaGameplayEffectOwner>GameplayEffectOwner                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayTagReponseTable::TagResponseEvent(const struct FGameplayTag& Tag, int32 NewCount, TScriptInterface<class IMatchaGameplayEffectOwner> GameplayEffectOwner, int32 Idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayTagReponseTable", "TagResponseEvent");

	Params::MatchaGameplayTagReponseTable_TagResponseEvent Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;
	Parms.GameplayEffectOwner = GameplayEffectOwner;
	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

