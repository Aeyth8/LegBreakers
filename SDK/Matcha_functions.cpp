#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Matcha

#include "Basic.hpp"

#include "Matcha_classes.hpp"
#include "Matcha_parameters.hpp"


namespace SDK
{

// Function Matcha.LegacyMatchaServicesConfiguration.GetWebSocketUrlClient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULegacyMatchaServicesConfiguration::GetWebSocketUrlClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaServicesConfiguration", "GetWebSocketUrlClient");

	Params::LegacyMatchaServicesConfiguration_GetWebSocketUrlClient Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.LegacyMatchaServicesConfiguration.GetWebSocketUrlServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULegacyMatchaServicesConfiguration::GetWebSocketUrlServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaServicesConfiguration", "GetWebSocketUrlServer");

	Params::LegacyMatchaServicesConfiguration_GetWebSocketUrlServer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.LegacyMatchaServicesConfiguration.GetWebSocketUrlServices
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULegacyMatchaServicesConfiguration::GetWebSocketUrlServices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaServicesConfiguration", "GetWebSocketUrlServices");

	Params::LegacyMatchaServicesConfiguration_GetWebSocketUrlServices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.LegacyMatchaQueueServices.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULegacyMatchaQueueServices*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULegacyMatchaQueueServices* ULegacyMatchaQueueServices::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LegacyMatchaQueueServices", "Get");

	Params::LegacyMatchaQueueServices_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.LegacyMatchaQueueServices.GetServicesConfiguration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ULegacyMatchaServicesConfiguration*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ULegacyMatchaServicesConfiguration* ULegacyMatchaQueueServices::GetServicesConfiguration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LegacyMatchaQueueServices", "GetServicesConfiguration");

	Params::LegacyMatchaQueueServices_GetServicesConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.LegacyMatchaQueueServices.AcceptInvite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Target                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegacyMatchaQueueServices::AcceptInvite(const class FString& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "AcceptInvite");

	Params::LegacyMatchaQueueServices_AcceptInvite Parms{};

	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.CancelInvite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Target                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegacyMatchaQueueServices::CancelInvite(const class FString& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "CancelInvite");

	Params::LegacyMatchaQueueServices_CancelInvite Parms{};

	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.JoinDropIn
// (Final, Native, Public, BlueprintCallable)

void ULegacyMatchaQueueServices::JoinDropIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "JoinDropIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.JoinQueue
// (Final, Native, Public, BlueprintCallable)

void ULegacyMatchaQueueServices::JoinQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "JoinQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.LeaveQueue
// (Final, Native, Public, BlueprintCallable)

void ULegacyMatchaQueueServices::LeaveQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "LeaveQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.LeaveTeam
// (Final, Native, Public, BlueprintCallable)

void ULegacyMatchaQueueServices::LeaveTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "LeaveTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.RejectInvite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Target                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegacyMatchaQueueServices::RejectInvite(const class FString& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "RejectInvite");

	Params::LegacyMatchaQueueServices_RejectInvite Parms{};

	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.SendInvite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Target                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegacyMatchaQueueServices::SendInvite(const class FString& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "SendInvite");

	Params::LegacyMatchaQueueServices_SendInvite Parms{};

	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.SendPing
// (Final, Native, Public, BlueprintCallable)

void ULegacyMatchaQueueServices::SendPing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "SendPing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.SetConnectedPlayerIds
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     PlayerIds                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULegacyMatchaQueueServices::SetConnectedPlayerIds(const TArray<class FName>& PlayerIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "SetConnectedPlayerIds");

	Params::LegacyMatchaQueueServices_SetConnectedPlayerIds Parms{};

	Parms.PlayerIds = std::move(PlayerIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.SetIdentification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsMatchServer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegacyMatchaQueueServices::SetIdentification(const class FString& Name_0, const class FString& URL, bool IsMatchServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "SetIdentification");

	Params::LegacyMatchaQueueServices_SetIdentification Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.URL = std::move(URL);
	Parms.IsMatchServer = IsMatchServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.SetMatchPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMatchaMatchPhase                       MatchPhase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegacyMatchaQueueServices::SetMatchPhase(EMatchaMatchPhase MatchPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "SetMatchPhase");

	Params::LegacyMatchaQueueServices_SetMatchPhase Parms{};

	Parms.MatchPhase = MatchPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.LegacyMatchaQueueServices.SetName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegacyMatchaQueueServices::SetName(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegacyMatchaQueueServices", "SetName");

	Params::LegacyMatchaQueueServices_SetName Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaAICharacterEntity.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaAICharacterEntity*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaAICharacterEntity* AMatchaAICharacterEntity::Get(int32 PlayerIndex, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAICharacterEntity", "Get");

	Params::MatchaAICharacterEntity_Get Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaAICharacterEntity.GetFromSimulation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USnapNetSimulation*               SnapNetSimulation                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaAICharacterEntity*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaAICharacterEntity* AMatchaAICharacterEntity::GetFromSimulation(int32 PlayerIndex, const class USnapNetSimulation* SnapNetSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaAICharacterEntity", "GetFromSimulation");

	Params::MatchaAICharacterEntity_GetFromSimulation Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.SnapNetSimulation = SnapNetSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaAICharacterEntity.CharacterTeleport
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DestinationLocation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         DestinationRotation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIsATest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoCheck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaAICharacterEntity::CharacterTeleport(const struct FVector& DestinationLocation, const struct FRotator& DestinationRotation, bool bIsATest, bool bNoCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAICharacterEntity", "CharacterTeleport");

	Params::MatchaAICharacterEntity_CharacterTeleport Parms{};

	Parms.DestinationLocation = std::move(DestinationLocation);
	Parms.DestinationRotation = std::move(DestinationRotation);
	Parms.bIsATest = bIsATest;
	Parms.bNoCheck = bNoCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaAICharacterEntity.PlayAnimationAtIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaAICharacterEntity::PlayAnimationAtIndex(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAICharacterEntity", "PlayAnimationAtIndex");

	Params::MatchaAICharacterEntity_PlayAnimationAtIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaAICharacterEntity.ResetDamage
// (Final, Native, Public, BlueprintCallable)

void AMatchaAICharacterEntity::ResetDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAICharacterEntity", "ResetDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaAICharacterEntity.SetInvulnerable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBeInvulnerable                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaAICharacterEntity::SetInvulnerable(bool bShouldBeInvulnerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAICharacterEntity", "SetInvulnerable");

	Params::MatchaAICharacterEntity_SetInvulnerable Parms{};

	Parms.bShouldBeInvulnerable = bShouldBeInvulnerable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaAICharacterEntity.GetAggroDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaAICharacterEntity::GetAggroDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAICharacterEntity", "GetAggroDistance");

	Params::MatchaAICharacterEntity_GetAggroDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaAICharacterEntity.GetSpawnLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMatchaAICharacterEntity::GetSpawnLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAICharacterEntity", "GetSpawnLocation");

	Params::MatchaAICharacterEntity_GetSpawnLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaAICharacterEntity.ToggleBehaviorTree
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    bShouldEnable                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaAICharacterEntity::ToggleBehaviorTree(const bool bShouldEnable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAICharacterEntity", "ToggleBehaviorTree");

	Params::MatchaAICharacterEntity_ToggleBehaviorTree Parms{};

	Parms.bShouldEnable = bShouldEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetEntity.OnEnabledChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bOldEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetEntity::OnEnabledChanged(bool bOldEnabled, bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetEntity", "OnEnabledChanged");

	Params::MatchaSnapNetEntity_OnEnabledChanged Parms{};

	Parms.bOldEnabled = bOldEnabled;
	Parms.bNewEnabled = bNewEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetEntity.OnSpawnFinished
// (Event, Protected, BlueprintEvent)

void AMatchaSnapNetEntity::OnSpawnFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetEntity", "OnSpawnFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Matcha.MatchaSnapNetEntity.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldEnable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetEntity::SetEnabled(bool bShouldEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetEntity", "SetEnabled");

	Params::MatchaSnapNetEntity_SetEnabled Parms{};

	Parms.bShouldEnable = bShouldEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetEntity.GetCurrentEntityTimeInMilliseconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetEntity::GetCurrentEntityTimeInMilliseconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetEntity", "GetCurrentEntityTimeInMilliseconds");

	Params::MatchaSnapNetEntity_GetCurrentEntityTimeInMilliseconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetEntity.GetMillisecondsSinceCreation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetEntity::GetMillisecondsSinceCreation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetEntity", "GetMillisecondsSinceCreation");

	Params::MatchaSnapNetEntity_GetMillisecondsSinceCreation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetEntity.GetOwnerEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMatchaSnapNetEntity::GetOwnerEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetEntity", "GetOwnerEntity");

	Params::MatchaSnapNetEntity_GetOwnerEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetEntity.GetOwnerEntityIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetEntity::GetOwnerEntityIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetEntity", "GetOwnerEntityIndex");

	Params::MatchaSnapNetEntity_GetOwnerEntityIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetEntity.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetEntity::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetEntity", "IsEnabled");

	Params::MatchaSnapNetEntity_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameEntity.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetGameEntity*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetGameEntity* AMatchaSnapNetGameEntity::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetGameEntity", "Get");

	Params::MatchaSnapNetGameEntity_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameEntity.OnAnyActorDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetGameEntity::OnAnyActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameEntity", "OnAnyActorDestroyed");

	Params::MatchaSnapNetGameEntity_OnAnyActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetGameEntity.OnAnyActorSpawned
// (Final, Native, Protected)
// Parameters:
// class AActor*                           SpawnedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetGameEntity::OnAnyActorSpawned(class AActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameEntity", "OnAnyActorSpawned");

	Params::MatchaSnapNetGameEntity_OnAnyActorSpawned Parms{};

	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetGameEntity.GetCurrentMatchPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMatchaMatchPhase                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMatchaMatchPhase AMatchaSnapNetGameEntity::GetCurrentMatchPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameEntity", "GetCurrentMatchPhase");

	Params::MatchaSnapNetGameEntity_GetCurrentMatchPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaAnalyticsManager.OnCharacterMontageStarted
// (Final, Native, Protected)
// Parameters:
// class AMatchaCharacterBase*             CharacterEntity                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MontageDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             MontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             PreviousMontageType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaAnalyticsManager::OnCharacterMontageStarted(class AMatchaCharacterBase* CharacterEntity, float MontageDuration, EMatchaCharacterMontageType MontageType, EMatchaCharacterMontageType PreviousMontageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAnalyticsManager", "OnCharacterMontageStarted");

	Params::MatchaAnalyticsManager_OnCharacterMontageStarted Parms{};

	Parms.CharacterEntity = CharacterEntity;
	Parms.MontageDuration = MontageDuration;
	Parms.MontageType = MontageType;
	Parms.PreviousMontageType = PreviousMontageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaAnalyticsManager.OnMatchPhaseChanged
// (Final, Native, Protected)
// Parameters:
// EMatchaMatchPhase                       MatchPhase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaAnalyticsManager::OnMatchPhaseChanged(EMatchaMatchPhase MatchPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAnalyticsManager", "OnMatchPhaseChanged");

	Params::MatchaAnalyticsManager_OnMatchPhaseChanged Parms{};

	Parms.MatchPhase = MatchPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.AddHitBox
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatchaHitBoxData                HitBoxData                                             (Parm, NativeAccessSpecifierPublic)
// class UObject*                          Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::AddHitBox(const struct FMatchaHitBoxData& HitBoxData, class UObject* Source, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "AddHitBox");

	Params::MatchaCharacterBase_AddHitBox Parms{};

	Parms.HitBoxData = std::move(HitBoxData);
	Parms.Source = Source;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.CharacterMovementUpdated
// (Native, Protected, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::CharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "CharacterMovementUpdated");

	Params::MatchaCharacterBase_CharacterMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.CharacterTeleport
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DestinationLocation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         DestinationRotation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIsATest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoCheck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaCharacterBase::CharacterTeleport(const struct FVector& DestinationLocation, const struct FRotator& DestinationRotation, bool bIsATest, bool bNoCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "CharacterTeleport");

	Params::MatchaCharacterBase_CharacterTeleport Parms{};

	Parms.DestinationLocation = std::move(DestinationLocation);
	Parms.DestinationRotation = std::move(DestinationRotation);
	Parms.bIsATest = bIsATest;
	Parms.bNoCheck = bNoCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.ClearTargetedGlitchDash
// (Final, Native, Public, BlueprintCallable)

void AMatchaCharacterBase::ClearTargetedGlitchDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "ClearTargetedGlitchDash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.DestroyTrackedEntity
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EntityTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::DestroyTrackedEntity(const struct FGameplayTag& EntityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "DestroyTrackedEntity");

	Params::MatchaCharacterBase_DestroyTrackedEntity Parms{};

	Parms.EntityTag = std::move(EntityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.GetTrackedEntity
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EntityTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AActor* AMatchaCharacterBase::GetTrackedEntity(const struct FGameplayTag& EntityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetTrackedEntity");

	Params::MatchaCharacterBase_GetTrackedEntity Parms{};

	Parms.EntityTag = std::move(EntityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.InflictDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamageInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::InflictDamage(class AActor* DamageInstigator, float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "InflictDamage");

	Params::MatchaCharacterBase_InflictDamage Parms{};

	Parms.DamageInstigator = DamageInstigator;
	Parms.Damage = Damage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.PerformAoEHeal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActorFilterInfo                 ActorFilterInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::PerformAoEHeal(const struct FActorFilterInfo& ActorFilterInfo, float HealAmount, float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "PerformAoEHeal");

	Params::MatchaCharacterBase_PerformAoEHeal Parms{};

	Parms.ActorFilterInfo = std::move(ActorFilterInfo);
	Parms.HealAmount = HealAmount;
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.PerformAoEStun
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FActorFilterInfo                 ActorFilterInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   StunTimeInSeconds                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OffsetFromCharacter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::PerformAoEStun(const struct FActorFilterInfo& ActorFilterInfo, float StunTimeInSeconds, float Range, const struct FVector2D& OffsetFromCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "PerformAoEStun");

	Params::MatchaCharacterBase_PerformAoEStun Parms{};

	Parms.ActorFilterInfo = std::move(ActorFilterInfo);
	Parms.StunTimeInSeconds = StunTimeInSeconds;
	Parms.Range = Range;
	Parms.OffsetFromCharacter = std::move(OffsetFromCharacter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.PerformCharacterLaunchAngleSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELaunchType                             LaunchType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELaunchActionRestrictionType            ActionRestrictionType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Acceleration_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Gravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ActionRestrictionDuration                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyIntangibility                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::PerformCharacterLaunchAngleSpeed(ELaunchType LaunchType, ELaunchActionRestrictionType ActionRestrictionType, float LaunchSpeed, float LaunchAngle, float Acceleration_0, float Gravity, float ActionRestrictionDuration, bool bApplyIntangibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "PerformCharacterLaunchAngleSpeed");

	Params::MatchaCharacterBase_PerformCharacterLaunchAngleSpeed Parms{};

	Parms.LaunchType = LaunchType;
	Parms.ActionRestrictionType = ActionRestrictionType;
	Parms.LaunchSpeed = LaunchSpeed;
	Parms.LaunchAngle = LaunchAngle;
	Parms.Acceleration_0 = Acceleration_0;
	Parms.Gravity = Gravity;
	Parms.ActionRestrictionDuration = ActionRestrictionDuration;
	Parms.bApplyIntangibility = bApplyIntangibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.PerformCharacterLaunchVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// ELaunchType                             LaunchType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELaunchActionRestrictionType            ActionRestrictionType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Acceleration_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Gravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ActionRestrictionDuration                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyIntangibility                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearCurrentMontage                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::PerformCharacterLaunchVelocity(ELaunchType LaunchType, ELaunchActionRestrictionType ActionRestrictionType, const struct FVector& LaunchVelocity, float Acceleration_0, float Gravity, float ActionRestrictionDuration, bool bApplyIntangibility, bool bClearCurrentMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "PerformCharacterLaunchVelocity");

	Params::MatchaCharacterBase_PerformCharacterLaunchVelocity Parms{};

	Parms.LaunchType = LaunchType;
	Parms.ActionRestrictionType = ActionRestrictionType;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.Acceleration_0 = Acceleration_0;
	Parms.Gravity = Gravity;
	Parms.ActionRestrictionDuration = ActionRestrictionDuration;
	Parms.bApplyIntangibility = bApplyIntangibility;
	Parms.bClearCurrentMontage = bClearCurrentMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.RequestHitFreeze
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   HitFreezeMilliseconds                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldShake                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldPetrify                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::RequestHitFreeze(int32 HitFreezeMilliseconds, bool bShouldShake, bool bShouldPetrify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "RequestHitFreeze");

	Params::MatchaCharacterBase_RequestHitFreeze Parms{};

	Parms.HitFreezeMilliseconds = HitFreezeMilliseconds;
	Parms.bShouldShake = bShouldShake;
	Parms.bShouldPetrify = bShouldPetrify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.RequestStun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::RequestStun(float DurationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "RequestStun");

	Params::MatchaCharacterBase_RequestStun Parms{};

	Parms.DurationSeconds = DurationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.RequestTargetedGlitchDash
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   TargetEntityIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AirStallTimeMilliseconds                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TravelTimeMilliseconds                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OffsetVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETargetedGlitchDashFacingType           FacingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             MontageToPlayOnRequest                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             PostTravelMontage                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaRootMotionType                   PostTravelRootMotion                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::RequestTargetedGlitchDash(int32 TargetEntityIndex, int32 AirStallTimeMilliseconds, int32 TravelTimeMilliseconds, const struct FVector2D& OffsetVector, ETargetedGlitchDashFacingType FacingType, EMatchaCharacterMontageType MontageToPlayOnRequest, EMatchaCharacterMontageType PostTravelMontage, EMatchaRootMotionType PostTravelRootMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "RequestTargetedGlitchDash");

	Params::MatchaCharacterBase_RequestTargetedGlitchDash Parms{};

	Parms.TargetEntityIndex = TargetEntityIndex;
	Parms.AirStallTimeMilliseconds = AirStallTimeMilliseconds;
	Parms.TravelTimeMilliseconds = TravelTimeMilliseconds;
	Parms.OffsetVector = std::move(OffsetVector);
	Parms.FacingType = FacingType;
	Parms.MontageToPlayOnRequest = MontageToPlayOnRequest;
	Parms.PostTravelMontage = PostTravelMontage;
	Parms.PostTravelRootMotion = PostTravelRootMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.RequestTraversalEntityRootMotionForce
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AMatchaSplineTraversalEntity*     TraversalEntity                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TravelSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestedDisable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestedIntangibility                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableCapsuleCollision                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::RequestTraversalEntityRootMotionForce(const class AMatchaSplineTraversalEntity* TraversalEntity, float TravelSpeed, bool bRequestedDisable, bool bRequestedIntangibility, bool bDisableCapsuleCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "RequestTraversalEntityRootMotionForce");

	Params::MatchaCharacterBase_RequestTraversalEntityRootMotionForce Parms{};

	Parms.TraversalEntity = TraversalEntity;
	Parms.TravelSpeed = TravelSpeed;
	Parms.bRequestedDisable = bRequestedDisable;
	Parms.bRequestedIntangibility = bRequestedIntangibility;
	Parms.bDisableCapsuleCollision = bDisableCapsuleCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.SetShouldBeRevealedToAllPlayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBeRevealed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::SetShouldBeRevealedToAllPlayers(bool bShouldBeRevealed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "SetShouldBeRevealedToAllPlayers");

	Params::MatchaCharacterBase_SetShouldBeRevealedToAllPlayers Parms{};

	Parms.bShouldBeRevealed = bShouldBeRevealed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.SpawnTrackedEntity
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EntityTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::SpawnTrackedEntity(const struct FGameplayTag& EntityTag, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "SpawnTrackedEntity");

	Params::MatchaCharacterBase_SpawnTrackedEntity Parms{};

	Parms.EntityTag = std::move(EntityTag);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.ToggleStunImmunity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldEnable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaCharacterBase::ToggleStunImmunity(bool bShouldEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "ToggleStunImmunity");

	Params::MatchaCharacterBase_ToggleStunImmunity Parms{};

	Parms.bShouldEnable = bShouldEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaCharacterBase.GetAliveState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAliveState                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAliveState AMatchaCharacterBase::GetAliveState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetAliveState");

	Params::MatchaCharacterBase_GetAliveState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetCurrentAutoTravelType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAutoTravelRootMotionType               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAutoTravelRootMotionType AMatchaCharacterBase::GetCurrentAutoTravelType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetCurrentAutoTravelType");

	Params::MatchaCharacterBase_GetCurrentAutoTravelType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetCurrentFallType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFallType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFallType AMatchaCharacterBase::GetCurrentFallType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetCurrentFallType");

	Params::MatchaCharacterBase_GetCurrentFallType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetCurrentJumpType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EJumpType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EJumpType AMatchaCharacterBase::GetCurrentJumpType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetCurrentJumpType");

	Params::MatchaCharacterBase_GetCurrentJumpType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetCurrentlyPlayingMontageTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaCharacterBase::GetCurrentlyPlayingMontageTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetCurrentlyPlayingMontageTime");

	Params::MatchaCharacterBase_GetCurrentlyPlayingMontageTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetCurrentMontageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMatchaCharacterMontageType             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMatchaCharacterMontageType AMatchaCharacterBase::GetCurrentMontageType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetCurrentMontageType");

	Params::MatchaCharacterBase_GetCurrentMontageType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetCurrentTraversalEntityType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETraversalEntityType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETraversalEntityType AMatchaCharacterBase::GetCurrentTraversalEntityType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetCurrentTraversalEntityType");

	Params::MatchaCharacterBase_GetCurrentTraversalEntityType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetEntityIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaCharacterBase::GetEntityIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetEntityIndex");

	Params::MatchaCharacterBase_GetEntityIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMovementMode                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMovementMode AMatchaCharacterBase::GetMovementMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetMovementMode");

	Params::MatchaCharacterBase_GetMovementMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetOwnerPlayerIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaCharacterBase::GetOwnerPlayerIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetOwnerPlayerIndex");

	Params::MatchaCharacterBase_GetOwnerPlayerIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.GetVisibilityOverrides
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FVisibilityOverride>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FVisibilityOverride> AMatchaCharacterBase::GetVisibilityOverrides() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "GetVisibilityOverrides");

	Params::MatchaCharacterBase_GetVisibilityOverrides Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.IsTargetedGlitchDashing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaCharacterBase::IsTargetedGlitchDashing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "IsTargetedGlitchDashing");

	Params::MatchaCharacterBase_IsTargetedGlitchDashing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBase.ShouldBeRevealedToAllPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaCharacterBase::ShouldBeRevealedToAllPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBase", "ShouldBeRevealedToAllPlayers");

	Params::MatchaCharacterBase_ShouldBeRevealedToAllPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaAttachableCompanionEntity.GetOwnerEntityIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaAttachableCompanionEntity::GetOwnerEntityIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAttachableCompanionEntity", "GetOwnerEntityIndex");

	Params::MatchaAttachableCompanionEntity_GetOwnerEntityIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaAttachableCompanionEntity.IsAttachedToOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaAttachableCompanionEntity::IsAttachedToOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaAttachableCompanionEntity", "IsAttachedToOwner");

	Params::MatchaAttachableCompanionEntity_IsAttachedToOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetPlayerEntity*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetPlayerEntity* AMatchaSnapNetPlayerEntity::Get(int32 PlayerIndex, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetPlayerEntity", "Get");

	Params::MatchaSnapNetPlayerEntity_Get Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GetByTeamIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamNumber_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMatchaSnapNetPlayerEntity*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AMatchaSnapNetPlayerEntity*> AMatchaSnapNetPlayerEntity::GetByTeamIndex(int32 TeamNumber_0, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetPlayerEntity", "GetByTeamIndex");

	Params::MatchaSnapNetPlayerEntity_GetByTeamIndex Parms{};

	Parms.TeamNumber_0 = TeamNumber_0;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GetFromSimulation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USnapNetSimulation*               SnapNetSimulation                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetPlayerEntity*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetPlayerEntity* AMatchaSnapNetPlayerEntity::GetFromSimulation(int32 PlayerIndex, const class USnapNetSimulation* SnapNetSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetPlayerEntity", "GetFromSimulation");

	Params::MatchaSnapNetPlayerEntity_GetFromSimulation Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.SnapNetSimulation = SnapNetSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GiveTeamCoins
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerEntity::GiveTeamCoins(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "GiveTeamCoins");

	Params::MatchaSnapNetPlayerEntity_GiveTeamCoins Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GiveTeamPowerSparks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerEntity::GiveTeamPowerSparks(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "GiveTeamPowerSparks");

	Params::MatchaSnapNetPlayerEntity_GiveTeamPowerSparks Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayerEntity.SetSharedTeamCoins
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SharedTeamCoins_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerEntity::SetSharedTeamCoins(int32 SharedTeamCoins_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "SetSharedTeamCoins");

	Params::MatchaSnapNetPlayerEntity_SetSharedTeamCoins Parms{};

	Parms.SharedTeamCoins_0 = SharedTeamCoins_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayerEntity.SetSharedTeamPowerSparks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSharedTeamPowerSparks                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerEntity::SetSharedTeamPowerSparks(int32 InSharedTeamPowerSparks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "SetSharedTeamPowerSparks");

	Params::MatchaSnapNetPlayerEntity_SetSharedTeamPowerSparks Parms{};

	Parms.InSharedTeamPowerSparks = InSharedTeamPowerSparks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AMatchaSnapNetPlayerEntity::GetDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "GetDisplayName");

	Params::MatchaSnapNetPlayerEntity_GetDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GetInventoryComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMatchaInventoryComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaInventoryComponent* AMatchaSnapNetPlayerEntity::GetInventoryComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "GetInventoryComponent");

	Params::MatchaSnapNetPlayerEntity_GetInventoryComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GetOwnedCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetCharacterEntity* AMatchaSnapNetPlayerEntity::GetOwnedCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "GetOwnedCharacter");

	Params::MatchaSnapNetPlayerEntity_GetOwnedCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GetOwnerPlayerIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetPlayerEntity::GetOwnerPlayerIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "GetOwnerPlayerIndex");

	Params::MatchaSnapNetPlayerEntity_GetOwnerPlayerIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GetSharedTeamCoins
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetPlayerEntity::GetSharedTeamCoins() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "GetSharedTeamCoins");

	Params::MatchaSnapNetPlayerEntity_GetSharedTeamCoins Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerEntity.GetSharedTeamPowerSparks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetPlayerEntity::GetSharedTeamPowerSparks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerEntity", "GetSharedTeamPowerSparks");

	Params::MatchaSnapNetPlayerEntity_GetSharedTeamPowerSparks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetRenderer.GetInstigatorRenderer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMatchaSnapNetCharacterRenderer*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetCharacterRenderer* AMatchaSnapNetRenderer::GetInstigatorRenderer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetRenderer", "GetInstigatorRenderer");

	Params::MatchaSnapNetRenderer_GetInstigatorRenderer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaServerScript.ClearItems
// (Final, Native, Public, BlueprintCallable)

void UMatchaServerScript::ClearItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "ClearItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaServerScript.InflictDamageActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaServerScript::InflictDamageActors(float DamageAmount, class AActor* Victim, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "InflictDamageActors");

	Params::MatchaServerScript_InflictDamageActors Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.Victim = Victim;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaServerScript.OnCharacterKnockedOut
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    CharacterThatWasKnockedOut                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaKnockoutData              KnockoutData                                           (Parm, NativeAccessSpecifierPublic)

void UMatchaServerScript::OnCharacterKnockedOut(class AMatchaSnapNetCharacterEntity* CharacterThatWasKnockedOut, const struct FMatchaKnockoutData& KnockoutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "OnCharacterKnockedOut");

	Params::MatchaServerScript_OnCharacterKnockedOut Parms{};

	Parms.CharacterThatWasKnockedOut = CharacterThatWasKnockedOut;
	Parms.KnockoutData = std::move(KnockoutData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaServerScript.OnCharacterKnockedOutOtherCharacter
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    CharacterThatKnocked                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaServerScript::OnCharacterKnockedOutOtherCharacter(class AMatchaSnapNetCharacterEntity* CharacterThatKnocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "OnCharacterKnockedOutOtherCharacter");

	Params::MatchaServerScript_OnCharacterKnockedOutOtherCharacter Parms{};

	Parms.CharacterThatKnocked = CharacterThatKnocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaServerScript.OnGameInfoRequestCompleted
// (Final, Native, Protected, HasOutParams)
// Parameters:
// bool                                    Succeeded                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RequestID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaApiV1GamesInfoResponse    GameInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FErrorResponseV1                 ErrorResponse                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaServerScript::OnGameInfoRequestCompleted(bool Succeeded, const class FString& RequestID, const struct FMatchaApiV1GamesInfoResponse& GameInfo, const struct FErrorResponseV1& ErrorResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "OnGameInfoRequestCompleted");

	Params::MatchaServerScript_OnGameInfoRequestCompleted Parms{};

	Parms.Succeeded = Succeeded;
	Parms.RequestID = std::move(RequestID);
	Parms.GameInfo = std::move(GameInfo);
	Parms.ErrorResponse = std::move(ErrorResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaServerScript.RespawnPlayer
// (Native, Protected, BlueprintCallable)
// Parameters:
// class AMatchaSnapNetPlayerEntity*       PlayerEntity                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaServerScript::RespawnPlayer(class AMatchaSnapNetPlayerEntity* PlayerEntity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "RespawnPlayer");

	Params::MatchaServerScript_RespawnPlayer Parms{};

	Parms.PlayerEntity = PlayerEntity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaServerScript.SetPlayerName
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaServerScript::SetPlayerName(int32 PlayerIndex, const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "SetPlayerName");

	Params::MatchaServerScript_SetPlayerName Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaServerScript.SpawnBot
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AMatchaSnapNetCharacterEntity>CharacterEntityClass                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         SpawnRotation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMatchaServerScript::SpawnBot(const TSubclassOf<class AMatchaSnapNetCharacterEntity>& CharacterEntityClass, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "SpawnBot");

	Params::MatchaServerScript_SpawnBot Parms{};

	Parms.CharacterEntityClass = CharacterEntityClass;
	Parms.SpawnLocation = std::move(SpawnLocation);
	Parms.SpawnRotation = std::move(SpawnRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaServerScript.TrySpectatePlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RequestingPlayerIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetPlayerIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaServerScript::TrySpectatePlayer(int32 RequestingPlayerIndex, int32 TargetPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "TrySpectatePlayer");

	Params::MatchaServerScript_TrySpectatePlayer Parms{};

	Parms.RequestingPlayerIndex = RequestingPlayerIndex;
	Parms.TargetPlayerIndex = TargetPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaServerScript.ValidateDTLSToken
// (Native, Protected)
// Parameters:
// class FString                           Token                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaServerScript::ValidateDTLSToken(const class FString& Token)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "ValidateDTLSToken");

	Params::MatchaServerScript_ValidateDTLSToken Parms{};

	Parms.Token = std::move(Token);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaServerScript.FindPlayerEntityForPlayerIndex
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetPlayerEntity*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetPlayerEntity* UMatchaServerScript::FindPlayerEntityForPlayerIndex(int32 PlayerIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "FindPlayerEntityForPlayerIndex");

	Params::MatchaServerScript_FindPlayerEntityForPlayerIndex Parms{};

	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaServerScript.FindPlayerIndexForPlayerId
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaServerScript::FindPlayerIndexForPlayerId(class FName PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "FindPlayerIndexForPlayerId");

	Params::MatchaServerScript_FindPlayerIndexForPlayerId Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaServerScript.FindTeamNumberForPlayerIndex
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaServerScript::FindTeamNumberForPlayerIndex(int32 PlayerIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "FindTeamNumberForPlayerIndex");

	Params::MatchaServerScript_FindTeamNumberForPlayerIndex Parms{};

	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaServerScript.GetDefaultCharacterEntityClass
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AMatchaSnapNetCharacterEntity>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AMatchaSnapNetCharacterEntity> UMatchaServerScript::GetDefaultCharacterEntityClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "GetDefaultCharacterEntityClass");

	Params::MatchaServerScript_GetDefaultCharacterEntityClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaServerScript.GetNewPlayerTeamNumber
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaServerScript::GetNewPlayerTeamNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "GetNewPlayerTeamNumber");

	Params::MatchaServerScript_GetNewPlayerTeamNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaServerScript.GetPlayersOnTeam
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TeamNumber                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMatchaSnapNetPlayerEntity*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AMatchaSnapNetPlayerEntity*> UMatchaServerScript::GetPlayersOnTeam(int32 TeamNumber) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaServerScript", "GetPlayersOnTeam");

	Params::MatchaServerScript_GetPlayersOnTeam Parms{};

	Parms.TeamNumber = TeamNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBattleRoyaleServerScript.FindRandomSpawnPointInRegion
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ESpawnRegion                            SpawnRegion                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamNumber                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldFindPointWithTeammates                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaPlayerStart*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaPlayerStart* UMatchaBattleRoyaleServerScript::FindRandomSpawnPointInRegion(ESpawnRegion SpawnRegion, int32 TeamNumber, bool bShouldFindPointWithTeammates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBattleRoyaleServerScript", "FindRandomSpawnPointInRegion");

	Params::MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion Parms{};

	Parms.SpawnRegion = SpawnRegion;
	Parms.TeamNumber = TeamNumber;
	Parms.bShouldFindPointWithTeammates = bShouldFindPointWithTeammates;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBattleRoyaleServerScript.ProcessSoulOrbRevival
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    ReviverCharacter                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReviveLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReviveRotation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMatchaBattleRoyaleServerScript::ProcessSoulOrbRevival(class AMatchaSnapNetCharacterEntity* ReviverCharacter, const struct FVector& ReviveLocation, const struct FRotator& ReviveRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBattleRoyaleServerScript", "ProcessSoulOrbRevival");

	Params::MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival Parms{};

	Parms.ReviverCharacter = ReviverCharacter;
	Parms.ReviveLocation = std::move(ReviveLocation);
	Parms.ReviveRotation = std::move(ReviveRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaBattleRoyaleServerScript.TrySpendCoins
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    SpenderCharacter                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CoinsToSpend                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaBattleRoyaleServerScript::TrySpendCoins(const class AMatchaSnapNetCharacterEntity* SpenderCharacter, int32 CoinsToSpend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBattleRoyaleServerScript", "TrySpendCoins");

	Params::MatchaBattleRoyaleServerScript_TrySpendCoins Parms{};

	Parms.SpenderCharacter = SpenderCharacter;
	Parms.CoinsToSpend = CoinsToSpend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBattleRoyaleServerScript.TrySpendCurrency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    SpenderCharacter                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmountToSpend                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInGameCurrencyType                     CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaBattleRoyaleServerScript::TrySpendCurrency(const class AMatchaSnapNetCharacterEntity* SpenderCharacter, int32 AmountToSpend, EInGameCurrencyType CurrencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBattleRoyaleServerScript", "TrySpendCurrency");

	Params::MatchaBattleRoyaleServerScript_TrySpendCurrency Parms{};

	Parms.SpenderCharacter = SpenderCharacter;
	Parms.AmountToSpend = AmountToSpend;
	Parms.CurrencyType = CurrencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBattleRoyaleServerScript.ChooseSpawnFurthestFromPlayers
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FTransform>               SpawnPoints                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AMatchaSnapNetCharacterEntity*    CharacterEntity                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UMatchaBattleRoyaleServerScript::ChooseSpawnFurthestFromPlayers(const TArray<struct FTransform>& SpawnPoints, const class AMatchaSnapNetCharacterEntity* CharacterEntity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBattleRoyaleServerScript", "ChooseSpawnFurthestFromPlayers");

	Params::MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers Parms{};

	Parms.SpawnPoints = std::move(SpawnPoints);
	Parms.CharacterEntity = CharacterEntity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBattleRoyaleServerScript.FindSpawnPointsWithTag
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SpawnTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTransform> UMatchaBattleRoyaleServerScript::FindSpawnPointsWithTag(class FName SpawnTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBattleRoyaleServerScript", "FindSpawnPointsWithTag");

	Params::MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag Parms{};

	Parms.SpawnTag = SpawnTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBattleRoyaleServerScript.HasEnoughCoins
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CoinAmountToCheck                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaBattleRoyaleServerScript::HasEnoughCoins(const class AMatchaSnapNetCharacterEntity* Character, int32 CoinAmountToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBattleRoyaleServerScript", "HasEnoughCoins");

	Params::MatchaBattleRoyaleServerScript_HasEnoughCoins Parms{};

	Parms.Character = Character;
	Parms.CoinAmountToCheck = CoinAmountToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBattleRoyaleServerScript.HasEnoughCurrencyOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmountToCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInGameCurrencyType                     CurrencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaBattleRoyaleServerScript::HasEnoughCurrencyOfType(const class AMatchaSnapNetCharacterEntity* Character, int32 AmountToCheck, EInGameCurrencyType CurrencyType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBattleRoyaleServerScript", "HasEnoughCurrencyOfType");

	Params::MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType Parms{};

	Parms.Character = Character;
	Parms.AmountToCheck = AmountToCheck;
	Parms.CurrencyType = CurrencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBreakableEntity.OnBroken
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AMatchaBreakableEntity::OnBroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBreakableEntity", "OnBroken");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Matcha.MatchaBreakableEntity.GetDamage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaBreakableEntity::GetDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBreakableEntity", "GetDamage");

	Params::MatchaBreakableEntity_GetDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBreakableEntity.GetMaxDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaBreakableEntity::GetMaxDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBreakableEntity", "GetMaxDamage");

	Params::MatchaBreakableEntity_GetMaxDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBreakableEntity.IsAlive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaBreakableEntity::IsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBreakableEntity", "IsAlive");

	Params::MatchaBreakableEntity_IsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBreakableEntity.IsBroken
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaBreakableEntity::IsBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBreakableEntity", "IsBroken");

	Params::MatchaBreakableEntity_IsBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaBreakableRenderer.OnIsAliveChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bNewIsAlive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaBreakableRenderer::OnIsAliveChanged(bool bNewIsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaBreakableRenderer", "OnIsAliveChanged");

	Params::MatchaBreakableRenderer_OnIsAliveChanged Parms{};

	Parms.bNewIsAlive = bNewIsAlive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaClientServicesConfiguration.GetWebSocketUrl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatchaClientServicesConfiguration::GetWebSocketUrl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaClientServicesConfiguration", "GetWebSocketUrl");

	Params::MatchaClientServicesConfiguration_GetWebSocketUrl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaChallengeHandlerBase.OnGameplayEvent
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMatchaGameplayEvent             MatchaGameplayEvent                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMatchaChallengeHandlerBase::OnGameplayEvent(const struct FMatchaGameplayEvent& MatchaGameplayEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaChallengeHandlerBase", "OnGameplayEvent");

	Params::MatchaChallengeHandlerBase_OnGameplayEvent Parms{};

	Parms.MatchaGameplayEvent = std::move(MatchaGameplayEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.ModifyOutGoingHitBoxDamage
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseHitBoxDamage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaCharacterBuff::ModifyOutGoingHitBoxDamage(class AMatchaSnapNetCharacterEntity* BuffedCharacter, float BaseHitBoxDamage, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "ModifyOutGoingHitBoxDamage");

	Params::MatchaCharacterBuff_ModifyOutGoingHitBoxDamage Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BaseHitBoxDamage = BaseHitBoxDamage;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaCharacterBuff.OnBuffApplied
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnBuffApplied(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnBuffApplied");

	Params::MatchaCharacterBuff_OnBuffApplied Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnBuffRefreshed
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnBuffRefreshed(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnBuffRefreshed");

	Params::MatchaCharacterBuff_OnBuffRefreshed Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnBuffRemoved
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnBuffRemoved(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnBuffRemoved");

	Params::MatchaCharacterBuff_OnBuffRemoved Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterCrouchEnd
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterCrouchEnd(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterCrouchEnd");

	Params::MatchaCharacterBuff_OnCharacterCrouchEnd Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterCrouchStart
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterCrouchStart(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterCrouchStart");

	Params::MatchaCharacterBuff_OnCharacterCrouchStart Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterEnteredKOZone
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterEnteredKOZone(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterEnteredKOZone");

	Params::MatchaCharacterBuff_OnCharacterEnteredKOZone Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterExitedKOZone
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterExitedKOZone(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterExitedKOZone");

	Params::MatchaCharacterBuff_OnCharacterExitedKOZone Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterJump
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJumpType                               JumpType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterJump(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EJumpType JumpType, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterJump");

	Params::MatchaCharacterBuff_OnCharacterJump Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.JumpType = JumpType;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterLand
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFallType                               FallTypeBeforeLand                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             MontageBeforeLand                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MillisecondsInAirBeforeLand                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterLand(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EFallType FallTypeBeforeLand, EMatchaCharacterMontageType MontageBeforeLand, int32 MillisecondsInAirBeforeLand, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterLand");

	Params::MatchaCharacterBuff_OnCharacterLand Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.FallTypeBeforeLand = FallTypeBeforeLand;
	Parms.MontageBeforeLand = MontageBeforeLand;
	Parms.MillisecondsInAirBeforeLand = MillisecondsInAirBeforeLand;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterMontageEnd
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             MontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterMontageEnd(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EMatchaCharacterMontageType MontageType, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterMontageEnd");

	Params::MatchaCharacterBuff_OnCharacterMontageEnd Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.MontageType = MontageType;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterMontageStart
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MontageDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             MontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             PreviousMontageType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterMontageStart(class AMatchaSnapNetCharacterEntity* BuffedCharacter, float MontageDuration, EMatchaCharacterMontageType MontageType, EMatchaCharacterMontageType PreviousMontageType, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterMontageStart");

	Params::MatchaCharacterBuff_OnCharacterMontageStart Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.MontageDuration = MontageDuration;
	Parms.MontageType = MontageType;
	Parms.PreviousMontageType = PreviousMontageType;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterPeformedTech
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterPeformedTech(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterPeformedTech");

	Params::MatchaCharacterBuff_OnCharacterPeformedTech Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterShieldStateChanged
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaShieldState                      PreviousShieldState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaShieldState                      NewShieldState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterShieldStateChanged(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EMatchaShieldState PreviousShieldState, EMatchaShieldState NewShieldState, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterShieldStateChanged");

	Params::MatchaCharacterBuff_OnCharacterShieldStateChanged Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.PreviousShieldState = PreviousShieldState;
	Parms.NewShieldState = NewShieldState;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterStartDash
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterStartDash(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterStartDash");

	Params::MatchaCharacterBuff_OnCharacterStartDash Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterStartDodge
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterStartDodge(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterStartDodge");

	Params::MatchaCharacterBuff_OnCharacterStartDodge Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnCharacterStartGroundedJump
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnCharacterStartGroundedJump(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnCharacterStartGroundedJump");

	Params::MatchaCharacterBuff_OnCharacterStartGroundedJump Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnKnockedOutAnEnemyCharacter
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           EnemyCharacter                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnKnockedOutAnEnemyCharacter(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* EnemyCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnKnockedOutAnEnemyCharacter");

	Params::MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.EnemyCharacter = EnemyCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnMontageSpawnedHitBox
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             MontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageHitBoxCount                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnMontageSpawnedHitBox(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EMatchaCharacterMontageType MontageType, int32 MontageHitBoxCount, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnMontageSpawnedHitBox");

	Params::MatchaCharacterBuff_OnMontageSpawnedHitBox Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.MontageType = MontageType;
	Parms.MontageHitBoxCount = MontageHitBoxCount;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnOtherBuffApplied
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaCharacterBuff*             OtherBuff                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           OtherBuffRarity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnOtherBuffApplied(class AMatchaSnapNetCharacterEntity* BuffedCharacter, const class UMatchaCharacterBuff* OtherBuff, EObjectRarity OtherBuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnOtherBuffApplied");

	Params::MatchaCharacterBuff_OnOtherBuffApplied Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.OtherBuff = OtherBuff;
	Parms.OtherBuffRarity = OtherBuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnOtherBuffRemoved
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaCharacterBuff*             OtherBuff                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnOtherBuffRemoved(class AMatchaSnapNetCharacterEntity* BuffedCharacter, const class UMatchaCharacterBuff* OtherBuff, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnOtherBuffRemoved");

	Params::MatchaCharacterBuff_OnOtherBuffRemoved Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.OtherBuff = OtherBuff;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnPerfectShield
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnPerfectShield(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnPerfectShield");

	Params::MatchaCharacterBuff_OnPerfectShield Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnPostApplyIncomingHit
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitInstigator                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaHitData                   TakenHitData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bDidResistWithSuperArmor                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasStunHitInsteadOfKnockBack                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CombinedDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CombinedShieldDamage                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnPostApplyIncomingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* HitInstigator, const struct FMatchaHitData& TakenHitData, bool bDidResistWithSuperArmor, bool bWasStunHitInsteadOfKnockBack, float CombinedDamage, float CombinedShieldDamage, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnPostApplyIncomingHit");

	Params::MatchaCharacterBuff_OnPostApplyIncomingHit Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.HitInstigator = HitInstigator;
	Parms.TakenHitData = std::move(TakenHitData);
	Parms.bDidResistWithSuperArmor = bDidResistWithSuperArmor;
	Parms.bWasStunHitInsteadOfKnockBack = bWasStunHitInsteadOfKnockBack;
	Parms.CombinedDamage = CombinedDamage;
	Parms.CombinedShieldDamage = CombinedShieldDamage;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnPostApplyOutgoingHit
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetHit                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PreviousTargetHit                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaHitData                   HitData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// uint8                                   AppliedHitFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaCharacterMontageType             MontageDuringHit                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnPostApplyOutgoingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* TargetHit, class AActor* PreviousTargetHit, const struct FMatchaHitData& HitData, uint8 AppliedHitFlags, EMatchaCharacterMontageType MontageDuringHit, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnPostApplyOutgoingHit");

	Params::MatchaCharacterBuff_OnPostApplyOutgoingHit Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.TargetHit = TargetHit;
	Parms.PreviousTargetHit = PreviousTargetHit;
	Parms.HitData = std::move(HitData);
	Parms.AppliedHitFlags = AppliedHitFlags;
	Parms.MontageDuringHit = MontageDuringHit;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnPreApplyIncomingHit
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnPreApplyIncomingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnPreApplyIncomingHit");

	Params::MatchaCharacterBuff_OnPreApplyIncomingHit Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnPreApplyOutgoingHit
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnPreApplyOutgoingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnPreApplyOutgoingHit");

	Params::MatchaCharacterBuff_OnPreApplyOutgoingHit Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnShieldBlockedAHit
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitInstigator                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreHitShieldHealth                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDidShieldBreak                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageShielded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDidPerfectShieldHit                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnShieldBlockedAHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* HitInstigator, float PreHitShieldHealth, bool bDidShieldBreak, float DamageShielded, bool bDidPerfectShieldHit, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnShieldBlockedAHit");

	Params::MatchaCharacterBuff_OnShieldBlockedAHit Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.HitInstigator = HitInstigator;
	Parms.PreHitShieldHealth = PreHitShieldHealth;
	Parms.bDidShieldBreak = bDidShieldBreak;
	Parms.DamageShielded = DamageShielded;
	Parms.bDidPerfectShieldHit = bDidPerfectShieldHit;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnSpawnedOwnedEntity
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnedEntity                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnSpawnedOwnedEntity(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* SpawnedEntity, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnSpawnedOwnedEntity");

	Params::MatchaCharacterBuff_OnSpawnedOwnedEntity Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.SpawnedEntity = SpawnedEntity;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterBuff.OnTechCanceledTumbling
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectRarity                           BuffRarity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterBuff::OnTechCanceledTumbling(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterBuff", "OnTechCanceledTumbling");

	Params::MatchaCharacterBuff_OnTechCanceledTumbling Parms{};

	Parms.BuffedCharacter = BuffedCharacter;
	Parms.BuffRarity = BuffRarity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaCharacterLaunchComponent.PerformLaunch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMatchaCharacterBase*             Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaCharacterLaunchComponent::PerformLaunch(class AMatchaCharacterBase* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaCharacterLaunchComponent", "PerformLaunch");

	Params::MatchaCharacterLaunchComponent_PerformLaunch Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaClientServices.OnLivenessTimerFired
// (Final, Native, Protected)

void UMatchaClientServices::OnLivenessTimerFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaClientServices", "OnLivenessTimerFired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaClientServices.OnWebsocketConnectionStateChanged
// (Final, Native, Protected)
// Parameters:
// class UOdyServicesModelBase*            ModelBase                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaClientServices::OnWebsocketConnectionStateChanged(class UOdyServicesModelBase* ModelBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaClientServices", "OnWebsocketConnectionStateChanged");

	Params::MatchaClientServices_OnWebsocketConnectionStateChanged Parms{};

	Parms.ModelBase = ModelBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetStatics.Conv_SnapNetPropertyVector2DToVector2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSnapNetPropertyVector2D         SnapNetPropertyVector2D                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UMatchaSnapNetStatics::Conv_SnapNetPropertyVector2DToVector2D(const struct FSnapNetPropertyVector2D& SnapNetPropertyVector2D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "Conv_SnapNetPropertyVector2DToVector2D");

	Params::MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D Parms{};

	Parms.SnapNetPropertyVector2D = std::move(SnapNetPropertyVector2D);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.DestroyEntity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EntityIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaSnapNetStatics::DestroyEntity(const class UObject* WorldContextObject, int32 EntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "DestroyEntity");

	Params::MatchaSnapNetStatics_DestroyEntity Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EntityIndex = EntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetStatics.GetCharacterEntityClassFromIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ClassIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UMatchaSnapNetStatics::GetCharacterEntityClassFromIndex(const class UObject* WorldContextObject, int32 ClassIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetCharacterEntityClassFromIndex");

	Params::MatchaSnapNetStatics_GetCharacterEntityClassFromIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ClassIndex = ClassIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetCharacterEntityClassIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetCharacterEntity*    CharacterEntity                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetCharacterEntityClassIndex(const class UObject* WorldContextObject, const class AMatchaSnapNetCharacterEntity* CharacterEntity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetCharacterEntityClassIndex");

	Params::MatchaSnapNetStatics_GetCharacterEntityClassIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterEntity = CharacterEntity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetCharacterEntityForFirstLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetCharacterEntity*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetCharacterEntity* UMatchaSnapNetStatics::GetCharacterEntityForFirstLocalPlayer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetCharacterEntityForFirstLocalPlayer");

	Params::MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetCharacterEntityForLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULocalPlayer*                     LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetCharacterEntity*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetCharacterEntity* UMatchaSnapNetStatics::GetCharacterEntityForLocalPlayer(class ULocalPlayer* LocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetCharacterEntityForLocalPlayer");

	Params::MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer Parms{};

	Parms.LocalPlayer = LocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetCharacterRendererForFirstLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetCharacterRenderer*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetCharacterRenderer* UMatchaSnapNetStatics::GetCharacterRendererForFirstLocalPlayer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetCharacterRendererForFirstLocalPlayer");

	Params::MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetCharacterRendererForLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULocalPlayer*                     LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetCharacterRenderer*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetCharacterRenderer* UMatchaSnapNetStatics::GetCharacterRendererForLocalPlayer(class ULocalPlayer* LocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetCharacterRendererForLocalPlayer");

	Params::MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer Parms{};

	Parms.LocalPlayer = LocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetDebugVisualizerWorld
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* UMatchaSnapNetStatics::GetDebugVisualizerWorld(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetDebugVisualizerWorld");

	Params::MatchaSnapNetStatics_GetDebugVisualizerWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetEntityByClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           EntityClass                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMatchaSnapNetStatics::GetEntityByClass(const class UObject* WorldContextObject, const class UClass* EntityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetEntityByClass");

	Params::MatchaSnapNetStatics_GetEntityByClass Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EntityClass = EntityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetEntityByIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EntityIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMatchaSnapNetStatics::GetEntityByIndex(const class UObject* WorldContextObject, int32 EntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetEntityByIndex");

	Params::MatchaSnapNetStatics_GetEntityByIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EntityIndex = EntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetEntityIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetEntityIndex(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetEntityIndex");

	Params::MatchaSnapNetStatics_GetEntityIndex Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetEntityRendererByIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EntityIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMatchaSnapNetStatics::GetEntityRendererByIndex(const class UObject* WorldContextObject, int32 EntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetEntityRendererByIndex");

	Params::MatchaSnapNetStatics_GetEntityRendererByIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EntityIndex = EntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetEntityRendererComponentByIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EntityIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USnapNetEntityRendererComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USnapNetEntityRendererComponent* UMatchaSnapNetStatics::GetEntityRendererComponentByIndex(const class UObject* WorldContextObject, int32 EntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetEntityRendererComponentByIndex");

	Params::MatchaSnapNetStatics_GetEntityRendererComponentByIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EntityIndex = EntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetFirstLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULocalPlayer*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayer* UMatchaSnapNetStatics::GetFirstLocalPlayer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetFirstLocalPlayer");

	Params::MatchaSnapNetStatics_GetFirstLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetListenPort
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetListenPort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetListenPort");

	Params::MatchaSnapNetStatics_GetListenPort Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetLocalPlayerIndexForFirstLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetLocalPlayerIndexForFirstLocalPlayer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetLocalPlayerIndexForFirstLocalPlayer");

	Params::MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetLocalPlayerIndexForLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULocalPlayer*                     LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetLocalPlayerIndexForLocalPlayer(class ULocalPlayer* LocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetLocalPlayerIndexForLocalPlayer");

	Params::MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer Parms{};

	Parms.LocalPlayer = LocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetPlayerEntityForFirstLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetPlayerEntity*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetPlayerEntity* UMatchaSnapNetStatics::GetPlayerEntityForFirstLocalPlayer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetPlayerEntityForFirstLocalPlayer");

	Params::MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetPlayerEntityForLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULocalPlayer*                     LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetPlayerEntity*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetPlayerEntity* UMatchaSnapNetStatics::GetPlayerEntityForLocalPlayer(class ULocalPlayer* LocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetPlayerEntityForLocalPlayer");

	Params::MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer Parms{};

	Parms.LocalPlayer = LocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetPlayerIndexForFirstLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetPlayerIndexForFirstLocalPlayer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetPlayerIndexForFirstLocalPlayer");

	Params::MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetPlayerIndexForLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULocalPlayer*                     LocalPlayer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetPlayerIndexForLocalPlayer(class ULocalPlayer* LocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetPlayerIndexForLocalPlayer");

	Params::MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer Parms{};

	Parms.LocalPlayer = LocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetSnapNetSimulationFrameType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESnapNetSimulationFrameType             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESnapNetSimulationFrameType UMatchaSnapNetStatics::GetSnapNetSimulationFrameType(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetSnapNetSimulationFrameType");

	Params::MatchaSnapNetStatics_GetSnapNetSimulationFrameType Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetSnapNetWorldType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESnapNetWorldType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESnapNetWorldType UMatchaSnapNetStatics::GetSnapNetWorldType(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetSnapNetWorldType");

	Params::MatchaSnapNetStatics_GetSnapNetWorldType Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetSpectatedCharacterEntityIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetSpectatedCharacterEntityIndex(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetSpectatedCharacterEntityIndex");

	Params::MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetSpectatedPlayerIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetSpectatedPlayerIndex(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetSpectatedPlayerIndex");

	Params::MatchaSnapNetStatics_GetSpectatedPlayerIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetSpectatedTeamNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaSnapNetStatics::GetSpectatedTeamNumber(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetSpectatedTeamNumber");

	Params::MatchaSnapNetStatics_GetSpectatedTeamNumber Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetWorldRenderPositionForEntity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EntityIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaSnapNetStatics::GetWorldRenderPositionForEntity(const class UObject* WorldContextObject, int32 EntityIndex, struct FVector* OutPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetWorldRenderPositionForEntity");

	Params::MatchaSnapNetStatics_GetWorldRenderPositionForEntity Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EntityIndex = EntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.GetWorldRenderPositionForPlayer
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaSnapNetStatics::GetWorldRenderPositionForPlayer(const class UObject* WorldContextObject, int32 PlayerIndex, struct FVector* OutPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "GetWorldRenderPositionForPlayer");

	Params::MatchaSnapNetStatics_GetWorldRenderPositionForPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.IsEntityIndexPropertyValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSnapNetPropertyEntityIndex      EntityIndex                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaSnapNetStatics::IsEntityIndexPropertyValid(const struct FSnapNetPropertyEntityIndex& EntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "IsEntityIndexPropertyValid");

	Params::MatchaSnapNetStatics_IsEntityIndexPropertyValid Parms{};

	Parms.EntityIndex = std::move(EntityIndex);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.IsEntityIndexValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   EntityIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaSnapNetStatics::IsEntityIndexValid(int32 EntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "IsEntityIndexValid");

	Params::MatchaSnapNetStatics_IsEntityIndexValid Parms{};

	Parms.EntityIndex = EntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.IsEntityOnSpectatedTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   EntityIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaSnapNetStatics::IsEntityOnSpectatedTeam(int32 EntityIndex, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "IsEntityOnSpectatedTeam");

	Params::MatchaSnapNetStatics_IsEntityOnSpectatedTeam Parms{};

	Parms.EntityIndex = EntityIndex;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.SpawnEntity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               EntityTemplate                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   OwnerPlayerIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMatchaSnapNetStatics::SpawnEntity(const class UObject* WorldContextObject, const TSubclassOf<class AActor>& EntityTemplate, const struct FVector& Location, const struct FRotator& Rotation, int32 OwnerPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "SpawnEntity");

	Params::MatchaSnapNetStatics_SpawnEntity Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EntityTemplate = EntityTemplate;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.OwnerPlayerIndex = OwnerPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.SpawnOwnedEntity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               EntityTemplate                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OwnerActor                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMatchaSnapNetStatics::SpawnOwnedEntity(const TSubclassOf<class AActor>& EntityTemplate, const class AActor* OwnerActor, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "SpawnOwnedEntity");

	Params::MatchaSnapNetStatics_SpawnOwnedEntity Parms{};

	Parms.EntityTemplate = EntityTemplate;
	Parms.OwnerActor = OwnerActor;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetStatics.SwitchSnapNetWorldType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESnapNetWorldType                       WorldType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaSnapNetStatics::SwitchSnapNetWorldType(const class UObject* WorldContextObject, ESnapNetWorldType* WorldType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetStatics", "SwitchSnapNetWorldType");

	Params::MatchaSnapNetStatics_SwitchSnapNetWorldType Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WorldType != nullptr)
		*WorldType = Parms.WorldType;
}


// Function Matcha.MatchaProjectileEntity.ManualDetonateProjectile
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bDisableAfterDetonation                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaProjectileEntity::ManualDetonateProjectile(bool bDisableAfterDetonation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaProjectileEntity", "ManualDetonateProjectile");

	Params::MatchaProjectileEntity_ManualDetonateProjectile Parms{};

	Parms.bDisableAfterDetonation = bDisableAfterDetonation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaProjectileEntity.OnProjectileExplosion
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           TargetHit                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaProjectileEntity::OnProjectileExplosion(class AActor* TargetHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaProjectileEntity", "OnProjectileExplosion");

	Params::MatchaProjectileEntity_OnProjectileExplosion Parms{};

	Parms.TargetHit = TargetHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaProjectileEntity.OnProjectileHit
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaHitData                   HitData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaProjectileEntity::OnProjectileHit(class AActor* HitActor, const struct FMatchaHitData& HitData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaProjectileEntity", "OnProjectileHit");

	Params::MatchaProjectileEntity_OnProjectileHit Parms{};

	Parms.HitActor = HitActor;
	Parms.HitData = std::move(HitData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaProjectileEntity.SetVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Velocity_0                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaProjectileEntity::SetVelocity(const struct FVector& Velocity_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaProjectileEntity", "SetVelocity");

	Params::MatchaProjectileEntity_SetVelocity Parms{};

	Parms.Velocity_0 = std::move(Velocity_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaEnvironmentHazardsCommon.CharacterHazardOverlap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMatchaEnvironmentHazardsCommon::CharacterHazardOverlap(class AMatchaSnapNetCharacterEntity* Character, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaEnvironmentHazardsCommon", "CharacterHazardOverlap");

	Params::MatchaEnvironmentHazardsCommon_CharacterHazardOverlap Parms{};

	Parms.Character = Character;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaEnvironmentHazardsCommon.GetAlwaysKnockoutTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMatchaEnvironmentHazardsCommon::GetAlwaysKnockoutTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaEnvironmentHazardsCommon", "GetAlwaysKnockoutTag");

	Params::MatchaEnvironmentHazardsCommon_GetAlwaysKnockoutTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaEnvironmentHazardsCommon.GetMinimumDamageTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMatchaEnvironmentHazardsCommon::GetMinimumDamageTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaEnvironmentHazardsCommon", "GetMinimumDamageTag");

	Params::MatchaEnvironmentHazardsCommon_GetMinimumDamageTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPlayerControllerBase.OnInputMethodChanged
// (Final, Native, Protected)
// Parameters:
// EInputMethod                            InputMethod                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaPlayerControllerBase::OnInputMethodChanged(EInputMethod InputMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPlayerControllerBase", "OnInputMethodChanged");

	Params::MatchaPlayerControllerBase_OnInputMethodChanged Parms{};

	Parms.InputMethod = InputMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPlayerControllerBase.SetImguiEnabled
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bImguiEnabled                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaPlayerControllerBase::SetImguiEnabled(bool bImguiEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPlayerControllerBase", "SetImguiEnabled");

	Params::MatchaPlayerControllerBase_SetImguiEnabled Parms{};

	Parms.bImguiEnabled = bImguiEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPlayerControllerBase.SetSelectedCharacter
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             CharacterClass                                         (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaPlayerControllerBase::SetSelectedCharacter(const TSoftClassPtr<class UClass>& CharacterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPlayerControllerBase", "SetSelectedCharacter");

	Params::MatchaPlayerControllerBase_SetSelectedCharacter Parms{};

	Parms.CharacterClass = CharacterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPlayerControllerBase.TravelTo
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaPlayerControllerBase::TravelTo(const class FString& URL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPlayerControllerBase", "TravelTo");

	Params::MatchaPlayerControllerBase_TravelTo Parms{};

	Parms.URL = std::move(URL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPlayerControllerBase.GetCurrentInputMappingContext
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UInputMappingContext*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputMappingContext* AMatchaPlayerControllerBase::GetCurrentInputMappingContext() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPlayerControllerBase", "GetCurrentInputMappingContext");

	Params::MatchaPlayerControllerBase_GetCurrentInputMappingContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameEntityRenderer.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaGameEntityRenderer*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaGameEntityRenderer* AMatchaGameEntityRenderer::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameEntityRenderer", "Get");

	Params::MatchaGameEntityRenderer_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayAction.HandleGameplayEvent
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FMatchaGameplayEvent             Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMatchaGameplayAction::HandleGameplayEvent(const struct FMatchaGameplayEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayAction", "HandleGameplayEvent");

	Params::MatchaGameplayAction_HandleGameplayEvent Parms{};

	Parms.Event = std::move(Event);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaTrapEntity.OnCharacterOverlapContinued
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    OverlappedCharacter                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ElapsedOverlapTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaTrapEntity::OnCharacterOverlapContinued(class AMatchaSnapNetCharacterEntity* OverlappedCharacter, float ElapsedOverlapTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaTrapEntity", "OnCharacterOverlapContinued");

	Params::MatchaTrapEntity_OnCharacterOverlapContinued Parms{};

	Parms.OverlappedCharacter = OverlappedCharacter;
	Parms.ElapsedOverlapTime = ElapsedOverlapTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaTrapEntity.OnCharacterOverlapEnded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    OverlappedCharacter                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaTrapEntity::OnCharacterOverlapEnded(class AMatchaSnapNetCharacterEntity* OverlappedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaTrapEntity", "OnCharacterOverlapEnded");

	Params::MatchaTrapEntity_OnCharacterOverlapEnded Parms{};

	Parms.OverlappedCharacter = OverlappedCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaTrapEntity.OnCharacterOverlapStarted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    OverlappedCharacter                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaTrapEntity::OnCharacterOverlapStarted(class AMatchaSnapNetCharacterEntity* OverlappedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaTrapEntity", "OnCharacterOverlapStarted");

	Params::MatchaTrapEntity_OnCharacterOverlapStarted Parms{};

	Parms.OverlappedCharacter = OverlappedCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaTrapEntity.GetOverlappingCharacters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMatchaSnapNetCharacterEntity*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AMatchaSnapNetCharacterEntity*> AMatchaTrapEntity::GetOverlappingCharacters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaTrapEntity", "GetOverlappingCharacters");

	Params::MatchaTrapEntity_GetOverlappingCharacters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayEventSubsystem.BroadcastGameplayEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Channel                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaGameplayEvent             GameplayEvent                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMatchaGameplayEventSubsystem::BroadcastGameplayEvent(const struct FGameplayTag& Channel, const struct FMatchaGameplayEvent& GameplayEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameplayEventSubsystem", "BroadcastGameplayEvent");

	Params::MatchaGameplayEventSubsystem_BroadcastGameplayEvent Parms{};

	Parms.Channel = std::move(Channel);
	Parms.GameplayEvent = std::move(GameplayEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBeKnockedOut.ProcessKnockout
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Instigator                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          KnockoutNormal                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceDirection                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICanBeKnockedOut::ProcessKnockout(const class AActor* Instigator, const struct FVector& KnockoutNormal, const struct FVector& TraceDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeKnockedOut", "ProcessKnockout");

	Params::CanBeKnockedOut_ProcessKnockout Parms{};

	Parms.Instigator = Instigator;
	Parms.KnockoutNormal = std::move(KnockoutNormal);
	Parms.TraceDirection = std::move(TraceDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBeKnockedOut.CanBeKnockedOut
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICanBeKnockedOut::CanBeKnockedOut() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeKnockedOut", "CanBeKnockedOut");

	Params::CanBeKnockedOut_CanBeKnockedOut Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.CanBeInteractedWith.AfterInteractionCancelledOrCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasCancelled                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICanBeInteractedWith::AfterInteractionCancelledOrCompleted(class AActor* InteractingActor, bool bWasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeInteractedWith", "AfterInteractionCancelledOrCompleted");

	Params::CanBeInteractedWith_AfterInteractionCancelledOrCompleted Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.bWasCancelled = bWasCancelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBeInteractedWith.AfterInteractionStarted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICanBeInteractedWith::AfterInteractionStarted(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeInteractedWith", "AfterInteractionStarted");

	Params::CanBeInteractedWith_AfterInteractionStarted Parms{};

	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBeInteractedWith.InteractionCancelled
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICanBeInteractedWith::InteractionCancelled(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeInteractedWith", "InteractionCancelled");

	Params::CanBeInteractedWith_InteractionCancelled Parms{};

	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBeInteractedWith.InteractionCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICanBeInteractedWith::InteractionCompleted(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeInteractedWith", "InteractionCompleted");

	Params::CanBeInteractedWith_InteractionCompleted Parms{};

	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBeInteractedWith.InteractionProgressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InteractionProgressTimeSeconds                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICanBeInteractedWith::InteractionProgressed(class AActor* InteractingActor, float InteractionProgressTimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeInteractedWith", "InteractionProgressed");

	Params::CanBeInteractedWith_InteractionProgressed Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.InteractionProgressTimeSeconds = InteractionProgressTimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBeInteractedWith.CanStartInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICanBeInteractedWith::CanStartInteraction(class AActor* InteractingActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeInteractedWith", "CanStartInteraction");

	Params::CanBeInteractedWith_CanStartInteraction Parms{};

	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.CanBeInteractedWith.GetInteractionPriority
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICanBeInteractedWith::GetInteractionPriority(class AActor* InteractingActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeInteractedWith", "GetInteractionPriority");

	Params::CanBeInteractedWith_GetInteractionPriority Parms{};

	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.CanBeInteractedWith.GetInteractionRequirements
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FMatchaInteractionRequirements   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMatchaInteractionRequirements ICanBeInteractedWith::GetInteractionRequirements() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeInteractedWith", "GetInteractionRequirements");

	Params::CanBeInteractedWith_GetInteractionRequirements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.InteractionTargetRenderer.SetTargeted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bNewTargeted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractionTargetRenderer::SetTargeted(bool bNewTargeted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionTargetRenderer", "SetTargeted");

	Params::InteractionTargetRenderer_SetTargeted Parms{};

	Parms.bNewTargeted = bNewTargeted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.InteractionTargetRenderer.GetInteractionProgressData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           InteractingRenderer                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractionProgressData         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInteractionProgressData IInteractionTargetRenderer::GetInteractionProgressData(const class AActor* InteractingRenderer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionTargetRenderer", "GetInteractionProgressData");

	Params::InteractionTargetRenderer_GetInteractionProgressData Parms{};

	Parms.InteractingRenderer = InteractingRenderer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.InteractionTargetRenderer.GetInteractionPromptLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           InteractingRenderer                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IInteractionTargetRenderer::GetInteractionPromptLocation(const class AActor* InteractingRenderer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionTargetRenderer", "GetInteractionPromptLocation");

	Params::InteractionTargetRenderer_GetInteractionPromptLocation Parms{};

	Parms.InteractingRenderer = InteractingRenderer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.CameraTarget.GetCameraViewTargetOffset
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ICameraTarget::GetCameraViewTargetOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraTarget", "GetCameraViewTargetOffset");

	Params::CameraTarget_GetCameraViewTargetOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.CanAttachFX.GetFXAttachmentComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ICanAttachFX::GetFXAttachmentComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanAttachFX", "GetFXAttachmentComponent");

	Params::CanAttachFX_GetFXAttachmentComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.CanBeTriggered.OnTriggered
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICanBeTriggered::OnTriggered(class AActor* OverlappingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeTriggered", "OnTriggered");

	Params::CanBeTriggered_OnTriggered Parms{};

	Parms.OverlappingActor = OverlappingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBeReset.HandleReset
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICanBeReset::HandleReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeReset", "HandleReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.CanBroadcastGameplayEvents.GetBroadcastChannel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ICanBroadcastGameplayEvents::GetBroadcastChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBroadcastGameplayEvents", "GetBroadcastChannel");

	Params::CanBroadcastGameplayEvents_GetBroadcastChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.InventoryProvider.GetInventoryComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMatchaInventoryComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaInventoryComponent* IInventoryProvider::GetInventoryComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryProvider", "GetInventoryComponent");

	Params::InventoryProvider_GetInventoryComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.ContextReceiver.OnReceiveIntContext
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IContextReceiver::OnReceiveIntContext(int32 Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextReceiver", "OnReceiveIntContext");

	Params::ContextReceiver_OnReceiveIntContext Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.ScheduledObjective.BeginScheduledObjective
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IScheduledObjective::BeginScheduledObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScheduledObjective", "BeginScheduledObjective");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.ScheduledObjective.GetScheduledObjectiveDisplayText
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString IScheduledObjective::GetScheduledObjectiveDisplayText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScheduledObjective", "GetScheduledObjectiveDisplayText");

	Params::ScheduledObjective_GetScheduledObjectiveDisplayText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.ScheduledObjective.GetScheduledObjectiveType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EScheduledObjectiveType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EScheduledObjectiveType IScheduledObjective::GetScheduledObjectiveType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScheduledObjective", "GetScheduledObjectiveType");

	Params::ScheduledObjective_GetScheduledObjectiveType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.CharacterIndexToCharacterClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIdx                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UMatchaGameplayStatics::CharacterIndexToCharacterClass(const class UObject* WorldContextObject, int32 CharacterIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "CharacterIndexToCharacterClass");

	Params::MatchaGameplayStatics_CharacterIndexToCharacterClass Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CharacterIdx = CharacterIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.ConvertFramesToMilliseconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Frames                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaGameplayStatics::ConvertFramesToMilliseconds(int32 Frames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "ConvertFramesToMilliseconds");

	Params::MatchaGameplayStatics_ConvertFramesToMilliseconds Parms{};

	Parms.Frames = Frames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.ConvertSecondsToFrames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaGameplayStatics::ConvertSecondsToFrames(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "ConvertSecondsToFrames");

	Params::MatchaGameplayStatics_ConvertSecondsToFrames Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.ConvertSecondsToMilliseconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaGameplayStatics::ConvertSecondsToMilliseconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "ConvertSecondsToMilliseconds");

	Params::MatchaGameplayStatics_ConvertSecondsToMilliseconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.DestroyAttachedFXFromEntity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           SpawningEntity                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NiagaraSystemId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AudioEventId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::DestroyAttachedFXFromEntity(const class AActor* SpawningEntity, const class FName& NiagaraSystemId, const class FName& AudioEventId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "DestroyAttachedFXFromEntity");

	Params::MatchaGameplayStatics_DestroyAttachedFXFromEntity Parms{};

	Parms.SpawningEntity = SpawningEntity;
	Parms.NiagaraSystemId = NiagaraSystemId;
	Parms.AudioEventId = AudioEventId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaGameplayStatics.FilterActorsFromArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InputTeamNumber                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InputActors                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   FilteredActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// ETeamFilter                             TeamFilter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAliveState                             AliveStateFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldFilterForShieldState                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchaShieldState                      ShieldStateFilter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFilterNotIntangible                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::FilterActorsFromArray(int32 InputTeamNumber, const TArray<class AActor*>& InputActors, TArray<class AActor*>* FilteredActors, ETeamFilter TeamFilter, EAliveState AliveStateFilter, bool bShouldFilterForShieldState, EMatchaShieldState ShieldStateFilter, bool bFilterNotIntangible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "FilterActorsFromArray");

	Params::MatchaGameplayStatics_FilterActorsFromArray Parms{};

	Parms.InputTeamNumber = InputTeamNumber;
	Parms.InputActors = std::move(InputActors);
	Parms.TeamFilter = TeamFilter;
	Parms.AliveStateFilter = AliveStateFilter;
	Parms.bShouldFilterForShieldState = bShouldFilterForShieldState;
	Parms.ShieldStateFilter = ShieldStateFilter;
	Parms.bFilterNotIntangible = bFilterNotIntangible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FilteredActors != nullptr)
		*FilteredActors = std::move(Parms.FilteredActors);
}


// Function Matcha.MatchaGameplayStatics.FilterActorsFromArrayWithFilterInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InputTeamNumber                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InputActors                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FActorFilterInfo                 ActorFilterInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutFilteredActors                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::FilterActorsFromArrayWithFilterInfo(int32 InputTeamNumber, const TArray<class AActor*>& InputActors, const struct FActorFilterInfo& ActorFilterInfo, TArray<class AActor*>* OutFilteredActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "FilterActorsFromArrayWithFilterInfo");

	Params::MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo Parms{};

	Parms.InputTeamNumber = InputTeamNumber;
	Parms.InputActors = std::move(InputActors);
	Parms.ActorFilterInfo = std::move(ActorFilterInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFilteredActors != nullptr)
		*OutFilteredActors = std::move(Parms.OutFilteredActors);
}


// Function Matcha.MatchaGameplayStatics.FindClosestEmptySpaceBetweenLocationsForCharacter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InitialDesiredLocation                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          FinalDesiredLocation                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleHalfHeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAvoidInstantKOZones                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAvoidTwoWayPlatforms                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAvoidCharacters                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowDebug                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::FindClosestEmptySpaceBetweenLocationsForCharacter(const class UObject* WorldContextObject, struct FVector* OutLocation, const struct FVector& InitialDesiredLocation, const struct FVector& FinalDesiredLocation, const struct FQuat& Rotation, float CapsuleRadius, float CapsuleHalfHeight, const TArray<class AActor*>& ActorsToIgnore, bool bAvoidInstantKOZones, bool bAvoidTwoWayPlatforms, bool bAvoidCharacters, bool bShowDebug, float DebugTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "FindClosestEmptySpaceBetweenLocationsForCharacter");

	Params::MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InitialDesiredLocation = std::move(InitialDesiredLocation);
	Parms.FinalDesiredLocation = std::move(FinalDesiredLocation);
	Parms.Rotation = std::move(Rotation);
	Parms.CapsuleRadius = CapsuleRadius;
	Parms.CapsuleHalfHeight = CapsuleHalfHeight;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bAvoidInstantKOZones = bAvoidInstantKOZones;
	Parms.bAvoidTwoWayPlatforms = bAvoidTwoWayPlatforms;
	Parms.bAvoidCharacters = bAvoidCharacters;
	Parms.bShowDebug = bShowDebug;
	Parms.DebugTime = DebugTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.FindFilteredActorsInRadius
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InputTeamNumber                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActorFilterInfo                 ActorFilterInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   FilteredActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::FindFilteredActorsInRadius(const class UObject* WorldContextObject, const class AActor* Instigator, const struct FVector& Location, float Radius, int32 InputTeamNumber, const struct FActorFilterInfo& ActorFilterInfo, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* FilteredActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "FindFilteredActorsInRadius");

	Params::MatchaGameplayStatics_FindFilteredActorsInRadius Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Instigator = Instigator;
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.InputTeamNumber = InputTeamNumber;
	Parms.ActorFilterInfo = std::move(ActorFilterInfo);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FilteredActors != nullptr)
		*FilteredActors = std::move(Parms.FilteredActors);
}


// Function Matcha.MatchaGameplayStatics.Get2DLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UMatchaGameplayStatics::Get2DLocation(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "Get2DLocation");

	Params::MatchaGameplayStatics_Get2DLocation Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetAllyRTPC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAkRtpc*                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAkRtpc* UMatchaGameplayStatics::GetAllyRTPC(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetAllyRTPC");

	Params::MatchaGameplayStatics_GetAllyRTPC Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetAudioEventFromId
// (Final, Native, Static, Public)
// Parameters:
// class FName                             AudioEventId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectEventType                        EffectEventType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawningRenderer                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AssociatedEntityIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* UMatchaGameplayStatics::GetAudioEventFromId(class FName AudioEventId, EEffectEventType EffectEventType, const class AActor* SpawningRenderer, int32 AssociatedEntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetAudioEventFromId");

	Params::MatchaGameplayStatics_GetAudioEventFromId Parms{};

	Parms.AudioEventId = AudioEventId;
	Parms.EffectEventType = EffectEventType;
	Parms.SpawningRenderer = SpawningRenderer;
	Parms.AssociatedEntityIndex = AssociatedEntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetAvailableCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSoftClassPtr<class UClass>>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TArray<TSoftClassPtr<class UClass>> UMatchaGameplayStatics::GetAvailableCharacters(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetAvailableCharacters");

	Params::MatchaGameplayStatics_GetAvailableCharacters Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetClientServies
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaClientServices*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaClientServices* UMatchaGameplayStatics::GetClientServies(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetClientServies");

	Params::MatchaGameplayStatics_GetClientServies Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetClosestAngleBetweenNormalizedVectors
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaGameplayStatics::GetClosestAngleBetweenNormalizedVectors(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetClosestAngleBetweenNormalizedVectors");

	Params::MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetColorForTeamNumber
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamNumber                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor UMatchaGameplayStatics::GetColorForTeamNumber(const class UObject* WorldContextObject, int32 TeamNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetColorForTeamNumber");

	Params::MatchaGameplayStatics_GetColorForTeamNumber Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TeamNumber = TeamNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetCurrentTeamForActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           AActor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaGameplayStatics::GetCurrentTeamForActor(const class AActor* AActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetCurrentTeamForActor");

	Params::MatchaGameplayStatics_GetCurrentTeamForActor Parms{};

	Parms.AActor = AActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetDisplayNameForRegion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpawnRegion                            SpawnRegion                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMatchaGameplayStatics::GetDisplayNameForRegion(const class UObject* WorldContextObject, ESpawnRegion SpawnRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetDisplayNameForRegion");

	Params::MatchaGameplayStatics_GetDisplayNameForRegion Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SpawnRegion = SpawnRegion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetEnvironmentHazardOverlapsBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FEnvironmentOverlapResult>Results                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxHalfSize                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     IgnoreTags                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           IgnoreActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::GetEnvironmentHazardOverlapsBox(const class UObject* WorldContextObject, TArray<struct FEnvironmentOverlapResult>* Results, const struct FVector& Position, const struct FQuat& Rotation, const struct FVector& BoxHalfSize, const TArray<class FName>& IgnoreTags, const class AActor* IgnoreActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetEnvironmentHazardOverlapsBox");

	Params::MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.BoxHalfSize = std::move(BoxHalfSize);
	Parms.IgnoreTags = std::move(IgnoreTags);
	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Matcha.MatchaGameplayStatics.GetEnvironmentHazardOverlapsCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FEnvironmentOverlapResult>Results                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleHalfHeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     IgnoreTags                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           IgnoreActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::GetEnvironmentHazardOverlapsCapsule(const class UObject* WorldContextObject, TArray<struct FEnvironmentOverlapResult>* Results, const struct FVector& Position, const struct FQuat& Rotation, float CapsuleRadius, float CapsuleHalfHeight, const TArray<class FName>& IgnoreTags, const class AActor* IgnoreActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetEnvironmentHazardOverlapsCapsule");

	Params::MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.CapsuleRadius = CapsuleRadius;
	Parms.CapsuleHalfHeight = CapsuleHalfHeight;
	Parms.IgnoreTags = std::move(IgnoreTags);
	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Matcha.MatchaGameplayStatics.GetEnvironmentHazardOverlapsSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FEnvironmentOverlapResult>Results                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     IgnoreTags                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           IgnoreActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::GetEnvironmentHazardOverlapsSphere(const class UObject* WorldContextObject, TArray<struct FEnvironmentOverlapResult>* Results, const struct FVector& Position, const struct FQuat& Rotation, float SphereRadius, const TArray<class FName>& IgnoreTags, const class AActor* IgnoreActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetEnvironmentHazardOverlapsSphere");

	Params::MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.SphereRadius = SphereRadius;
	Parms.IgnoreTags = std::move(IgnoreTags);
	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Matcha.MatchaGameplayStatics.GetKnockBackUnitDirectionForAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   HitAngle                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFacingRight                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMatchaGameplayStatics::GetKnockBackUnitDirectionForAngle(const float HitAngle, const bool bIsFacingRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetKnockBackUnitDirectionForAngle");

	Params::MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle Parms{};

	Parms.HitAngle = HitAngle;
	Parms.bIsFacingRight = bIsFacingRight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetLocallySpectatedRTPC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAkRtpc*                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAkRtpc* UMatchaGameplayStatics::GetLocallySpectatedRTPC(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetLocallySpectatedRTPC");

	Params::MatchaGameplayStatics_GetLocallySpectatedRTPC Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetMatchaSnapNetGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaSnapNetGameInstance*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaSnapNetGameInstance* UMatchaGameplayStatics::GetMatchaSnapNetGameInstance(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetMatchaSnapNetGameInstance");

	Params::MatchaGameplayStatics_GetMatchaSnapNetGameInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetNiagaraSystemFromId
// (Final, Native, Static, Public)
// Parameters:
// class FName                             NiagaraSystemId                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectEventType                        EffectEventType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawningRenderer                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AssociatedEntityIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* UMatchaGameplayStatics::GetNiagaraSystemFromId(class FName NiagaraSystemId, EEffectEventType EffectEventType, const class AActor* SpawningRenderer, int32 AssociatedEntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetNiagaraSystemFromId");

	Params::MatchaGameplayStatics_GetNiagaraSystemFromId Parms{};

	Parms.NiagaraSystemId = NiagaraSystemId;
	Parms.EffectEventType = EffectEventType;
	Parms.SpawningRenderer = SpawningRenderer;
	Parms.AssociatedEntityIndex = AssociatedEntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetNormalizedAngleBetweenNormalizedVectors
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaGameplayStatics::GetNormalizedAngleBetweenNormalizedVectors(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetNormalizedAngleBetweenNormalizedVectors");

	Params::MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetOfflineMapPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatchaGameplayStatics::GetOfflineMapPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetOfflineMapPath");

	Params::MatchaGameplayStatics_GetOfflineMapPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetRendererFXAttachComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RendererActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UMatchaGameplayStatics::GetRendererFXAttachComponent(const class AActor* RendererActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetRendererFXAttachComponent");

	Params::MatchaGameplayStatics_GetRendererFXAttachComponent Parms{};

	Parms.RendererActor = RendererActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetRotationTowards
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMatchaGameplayStatics::GetRotationTowards(const class AActor* Actor, const class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetRotationTowards");

	Params::MatchaGameplayStatics_GetRotationTowards Parms{};

	Parms.Actor = Actor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetTickRateIntendedDeltaMilliseconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaGameplayStatics::GetTickRateIntendedDeltaMilliseconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetTickRateIntendedDeltaMilliseconds");

	Params::MatchaGameplayStatics_GetTickRateIntendedDeltaMilliseconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetTickRateIntendedDeltaTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaGameplayStatics::GetTickRateIntendedDeltaTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetTickRateIntendedDeltaTime");

	Params::MatchaGameplayStatics_GetTickRateIntendedDeltaTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.GetUISelectableSpawnRegions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ESpawnRegion>                    OutSelectableSpawnRegions                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeRandom                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::GetUISelectableSpawnRegions(const class UObject* WorldContextObject, TArray<ESpawnRegion>* OutSelectableSpawnRegions, bool bIncludeRandom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetUISelectableSpawnRegions");

	Params::MatchaGameplayStatics_GetUISelectableSpawnRegions Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bIncludeRandom = bIncludeRandom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSelectableSpawnRegions != nullptr)
		*OutSelectableSpawnRegions = std::move(Parms.OutSelectableSpawnRegions);
}


// Function Matcha.MatchaGameplayStatics.GetVectorSideFromAnotherCCW
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchaGameplayStatics::GetVectorSideFromAnotherCCW(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "GetVectorSideFromAnotherCCW");

	Params::MatchaGameplayStatics_GetVectorSideFromAnotherCCW Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.HasQueuedJump
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   QueuedJumpFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::HasQueuedJump(uint8 QueuedJumpFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "HasQueuedJump");

	Params::MatchaGameplayStatics_HasQueuedJump Parms{};

	Parms.QueuedJumpFlags = QueuedJumpFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsActorFacingTowardsOtherActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsActorFacingTowardsOtherActor(const class AActor* Actor, const class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsActorFacingTowardsOtherActor");

	Params::MatchaGameplayStatics_IsActorFacingTowardsOtherActor Parms{};

	Parms.Actor = Actor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsActorWithin2DExtents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           AActor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           Extents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsActorWithin2DExtents(const class AActor* AActor, const struct FBox2D& Extents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsActorWithin2DExtents");

	Params::MatchaGameplayStatics_IsActorWithin2DExtents Parms{};

	Parms.AActor = AActor;
	Parms.Extents = std::move(Extents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsCapsuleOverlappingCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        CapsuleAStart                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CapsuleAEnd                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleARadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CapsuleBStart                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CapsuleBEnd                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleBRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsCapsuleOverlappingCapsule(const struct FVector2D& CapsuleAStart, const struct FVector2D& CapsuleAEnd, float CapsuleARadius, const struct FVector2D& CapsuleBStart, const struct FVector2D& CapsuleBEnd, float CapsuleBRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsCapsuleOverlappingCapsule");

	Params::MatchaGameplayStatics_IsCapsuleOverlappingCapsule Parms{};

	Parms.CapsuleAStart = std::move(CapsuleAStart);
	Parms.CapsuleAEnd = std::move(CapsuleAEnd);
	Parms.CapsuleARadius = CapsuleARadius;
	Parms.CapsuleBStart = std::move(CapsuleBStart);
	Parms.CapsuleBEnd = std::move(CapsuleBEnd);
	Parms.CapsuleBRadius = CapsuleBRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsCircleOverlappingCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        CircleCenter                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CircleRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CapsuleStart                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CapsuleEnd                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsCircleOverlappingCapsule(const struct FVector2D& CircleCenter, float CircleRadius, const struct FVector2D& CapsuleStart, const struct FVector2D& CapsuleEnd, float CapsuleRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsCircleOverlappingCapsule");

	Params::MatchaGameplayStatics_IsCircleOverlappingCapsule Parms{};

	Parms.CircleCenter = std::move(CircleCenter);
	Parms.CircleRadius = CircleRadius;
	Parms.CapsuleStart = std::move(CapsuleStart);
	Parms.CapsuleEnd = std::move(CapsuleEnd);
	Parms.CapsuleRadius = CapsuleRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsCircleOverlappingCircle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        CenterA                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RadiusA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CenterB                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RadiusB                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsCircleOverlappingCircle(const struct FVector2D& CenterA, float RadiusA, const struct FVector2D& CenterB, float RadiusB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsCircleOverlappingCircle");

	Params::MatchaGameplayStatics_IsCircleOverlappingCircle Parms{};

	Parms.CenterA = std::move(CenterA);
	Parms.RadiusA = RadiusA;
	Parms.CenterB = std::move(CenterB);
	Parms.RadiusB = RadiusB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsCounterHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   AppliedHitFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsCounterHit(uint8 AppliedHitFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsCounterHit");

	Params::MatchaGameplayStatics_IsCounterHit Parms{};

	Parms.AppliedHitFlags = AppliedHitFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsLedgeGrantsIntangibility
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   LedgePropertyFlags                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsLedgeGrantsIntangibility(uint8 LedgePropertyFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsLedgeGrantsIntangibility");

	Params::MatchaGameplayStatics_IsLedgeGrantsIntangibility Parms{};

	Parms.LedgePropertyFlags = LedgePropertyFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsLedgeOnlyAllowsJump
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   LedgePropertyFlags                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsLedgeOnlyAllowsJump(uint8 LedgePropertyFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsLedgeOnlyAllowsJump");

	Params::MatchaGameplayStatics_IsLedgeOnlyAllowsJump Parms{};

	Parms.LedgePropertyFlags = LedgePropertyFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsLethalKnockBackHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   AppliedHitFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsLethalKnockBackHit(uint8 AppliedHitFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsLethalKnockBackHit");

	Params::MatchaGameplayStatics_IsLethalKnockBackHit Parms{};

	Parms.AppliedHitFlags = AppliedHitFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsOwnedEntityHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   AppliedHitFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsOwnedEntityHit(uint8 AppliedHitFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsOwnedEntityHit");

	Params::MatchaGameplayStatics_IsOwnedEntityHit Parms{};

	Parms.AppliedHitFlags = AppliedHitFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsPerfectShieldHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   AppliedHitFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsPerfectShieldHit(uint8 AppliedHitFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsPerfectShieldHit");

	Params::MatchaGameplayStatics_IsPerfectShieldHit Parms{};

	Parms.AppliedHitFlags = AppliedHitFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsQueuedJumpFullGroundJump
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   QueuedJumpFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsQueuedJumpFullGroundJump(uint8 QueuedJumpFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsQueuedJumpFullGroundJump");

	Params::MatchaGameplayStatics_IsQueuedJumpFullGroundJump Parms{};

	Parms.QueuedJumpFlags = QueuedJumpFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsQueuedJumpLedgeJump
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   QueuedJumpFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsQueuedJumpLedgeJump(uint8 QueuedJumpFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsQueuedJumpLedgeJump");

	Params::MatchaGameplayStatics_IsQueuedJumpLedgeJump Parms{};

	Parms.QueuedJumpFlags = QueuedJumpFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsQueuedJumpShortGroundJump
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   QueuedJumpFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsQueuedJumpShortGroundJump(uint8 QueuedJumpFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsQueuedJumpShortGroundJump");

	Params::MatchaGameplayStatics_IsQueuedJumpShortGroundJump Parms{};

	Parms.QueuedJumpFlags = QueuedJumpFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsRectangleOverlappingRectangle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        CenterA                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ExtentsA                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CenterB                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ExtentsB                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsRectangleOverlappingRectangle(const struct FVector2D& CenterA, const struct FVector2D& ExtentsA, const struct FVector2D& CenterB, const struct FVector2D& ExtentsB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsRectangleOverlappingRectangle");

	Params::MatchaGameplayStatics_IsRectangleOverlappingRectangle Parms{};

	Parms.CenterA = std::move(CenterA);
	Parms.ExtentsA = std::move(ExtentsA);
	Parms.CenterB = std::move(CenterB);
	Parms.ExtentsB = std::move(ExtentsB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsRectangleOverlappingRectangleByEdges
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   TopA                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BottomA                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LeftA                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RightA                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TopB                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BottomB                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LeftB                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RightB                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsRectangleOverlappingRectangleByEdges(const float TopA, const float BottomA, const float LeftA, const float RightA, const float TopB, const float BottomB, const float LeftB, const float RightB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsRectangleOverlappingRectangleByEdges");

	Params::MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges Parms{};

	Parms.TopA = TopA;
	Parms.BottomA = BottomA;
	Parms.LeftA = LeftA;
	Parms.RightA = RightA;
	Parms.TopB = TopB;
	Parms.BottomB = BottomB;
	Parms.LeftB = LeftB;
	Parms.RightB = RightB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.IsShieldHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   AppliedHitFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::IsShieldHit(uint8 AppliedHitFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "IsShieldHit");

	Params::MatchaGameplayStatics_IsShieldHit Parms{};

	Parms.AppliedHitFlags = AppliedHitFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.SmoothVectorLerp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Current                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Precision                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMatchaGameplayStatics::SmoothVectorLerp(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float Precision, float LerpTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "SmoothVectorLerp");

	Params::MatchaGameplayStatics_SmoothVectorLerp Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.Precision = Precision;
	Parms.LerpTime = LerpTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.SpawnFXFromEntity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SpawningEntity                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectEventType                        EffectEventType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombinedFXInfo                  EffectInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AssociatedEntityIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::SpawnFXFromEntity(const class AActor* SpawningEntity, EEffectEventType EffectEventType, const struct FCombinedFXInfo& EffectInfo, int32 AssociatedEntityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "SpawnFXFromEntity");

	Params::MatchaGameplayStatics_SpawnFXFromEntity Parms{};

	Parms.SpawningEntity = SpawningEntity;
	Parms.EffectEventType = EffectEventType;
	Parms.EffectInfo = std::move(EffectInfo);
	Parms.AssociatedEntityIndex = AssociatedEntityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaGameplayStatics.SpawnRenderActorFromEntity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           SpawningEntity                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ActorClass                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnForEveryone                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameplayStatics::SpawnRenderActorFromEntity(const class AActor* SpawningEntity, TSoftClassPtr<class UClass> ActorClass, const struct FVector& LocationOffset, bool bSpawnForEveryone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "SpawnRenderActorFromEntity");

	Params::MatchaGameplayStatics_SpawnRenderActorFromEntity Parms{};

	Parms.SpawningEntity = SpawningEntity;
	Parms.ActorClass = ActorClass;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.bSpawnForEveryone = bSpawnForEveryone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaGameplayStatics.TryFindVisibilityOverrideInList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVisibilityOverride>      OverridesList                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Identifier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVisibilityOverrideTargetType           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVisibilityOverride              OutOverride                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaGameplayStatics::TryFindVisibilityOverrideInList(const TArray<struct FVisibilityOverride>& OverridesList, class FName Identifier, EVisibilityOverrideTargetType Type, struct FVisibilityOverride* OutOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "TryFindVisibilityOverrideInList");

	Params::MatchaGameplayStatics_TryFindVisibilityOverrideInList Parms{};

	Parms.OverridesList = std::move(OverridesList);
	Parms.Identifier = Identifier;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOverride != nullptr)
		*OutOverride = std::move(Parms.OutOverride);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameplayStatics.TryGetEquippedHackItem
// (Final, Native, Static, Public)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    CharacterEntity                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UMatchaItemAsset*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMatchaItemAsset* UMatchaGameplayStatics::TryGetEquippedHackItem(const class AMatchaSnapNetCharacterEntity* CharacterEntity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaGameplayStatics", "TryGetEquippedHackItem");

	Params::MatchaGameplayStatics_TryGetEquippedHackItem Parms{};

	Parms.CharacterEntity = CharacterEntity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameWorldUIData.BindPlayerController
// (Final, Native, Protected)

void UMatchaGameWorldUIData::BindPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "BindPlayerController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaGameWorldUIData.FindPlayerUIDataForPlayerIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddIfNotFound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaPlayerUIData*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaPlayerUIData* UMatchaGameWorldUIData::FindPlayerUIDataForPlayerIndex(int32 PlayerIndex, bool bAddIfNotFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "FindPlayerUIDataForPlayerIndex");

	Params::MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.bAddIfNotFound = bAddIfNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameWorldUIData.FindTeamUIDataForPlayerIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaTeamUIData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaTeamUIData* UMatchaGameWorldUIData::FindTeamUIDataForPlayerIndex(int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "FindTeamUIDataForPlayerIndex");

	Params::MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex Parms{};

	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameWorldUIData.FindTeamUIDataForTeamNumber
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamNumber                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddIfNotFound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaTeamUIData*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaTeamUIData* UMatchaGameWorldUIData::FindTeamUIDataForTeamNumber(int32 TeamNumber, bool bAddIfNotFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "FindTeamUIDataForTeamNumber");

	Params::MatchaGameWorldUIData_FindTeamUIDataForTeamNumber Parms{};

	Parms.TeamNumber = TeamNumber;
	Parms.bAddIfNotFound = bAddIfNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameWorldUIData.GetPlayerUIDataForSpectatedPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMatchaPlayerUIData*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaPlayerUIData* UMatchaGameWorldUIData::GetPlayerUIDataForSpectatedPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "GetPlayerUIDataForSpectatedPlayer");

	Params::MatchaGameWorldUIData_GetPlayerUIDataForSpectatedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameWorldUIData.OnSpectatedPlayerIndexChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   InPlayerIndexForLocalPlayer                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PreviousPlayerIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentPlayerIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameWorldUIData::OnSpectatedPlayerIndexChanged(int32 InPlayerIndexForLocalPlayer, int32 PreviousPlayerIndex, int32 CurrentPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "OnSpectatedPlayerIndexChanged");

	Params::MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged Parms{};

	Parms.InPlayerIndexForLocalPlayer = InPlayerIndexForLocalPlayer;
	Parms.PreviousPlayerIndex = PreviousPlayerIndex;
	Parms.CurrentPlayerIndex = CurrentPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaGameWorldUIData.RegisterActiveHackChest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHackType                               HackType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameWorldUIData::RegisterActiveHackChest(EHackType HackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "RegisterActiveHackChest");

	Params::MatchaGameWorldUIData_RegisterActiveHackChest Parms{};

	Parms.HackType = HackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaGameWorldUIData.UnregisterActiveHackChest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHackType                               HackType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaGameWorldUIData::UnregisterActiveHackChest(EHackType HackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "UnregisterActiveHackChest");

	Params::MatchaGameWorldUIData_UnregisterActiveHackChest Parms{};

	Parms.HackType = HackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaGameWorldUIData.GetAlivePlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaGameWorldUIData::GetAlivePlayerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "GetAlivePlayerCount");

	Params::MatchaGameWorldUIData_GetAlivePlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaGameWorldUIData.GetTotalPlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaGameWorldUIData::GetTotalPlayerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaGameWorldUIData", "GetTotalPlayerCount");

	Params::MatchaGameWorldUIData_GetTotalPlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetInteractiveEntity.GetPlayerColliderBounds
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          OutOrigin                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutBounds                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetInteractiveEntity::GetPlayerColliderBounds(struct FVector* OutOrigin, struct FVector* OutBounds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetInteractiveEntity", "GetPlayerColliderBounds");

	Params::MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutOrigin != nullptr)
		*OutOrigin = std::move(Parms.OutOrigin);

	if (OutBounds != nullptr)
		*OutBounds = std::move(Parms.OutBounds);
}


// Function Matcha.MatchaHittableInteractiveEntity.OnHitReceived
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           HitInstigator                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaHitData                   HitData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaHittableInteractiveEntity::OnHitReceived(const class AActor* HitInstigator, const class AActor* HitActor, const struct FMatchaHitData& HitData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaHittableInteractiveEntity", "OnHitReceived");

	Params::MatchaHittableInteractiveEntity_OnHitReceived Parms{};

	Parms.HitInstigator = HitInstigator;
	Parms.HitActor = HitActor;
	Parms.HitData = std::move(HitData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaHitVolumeEntity.OnVolumeHitATarget
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           TargetHit                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaHitData                   HitData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaHitVolumeEntity::OnVolumeHitATarget(class AActor* TargetHit, const struct FMatchaHitData& HitData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaHitVolumeEntity", "OnVolumeHitATarget");

	Params::MatchaHitVolumeEntity_OnVolumeHitATarget Parms{};

	Parms.TargetHit = TargetHit;
	Parms.HitData = std::move(HitData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaIdentityServiceModel.DeleteAccount
// (Final, Native, Public, BlueprintCallable)

void UMatchaIdentityServiceModel::DeleteAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "DeleteAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaIdentityServiceModel.HandleFailedLoginResponse
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FErrorResponseV1                 LoginError                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::HandleFailedLoginResponse(const struct FErrorResponseV1& LoginError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "HandleFailedLoginResponse");

	Params::MatchaIdentityServiceModel_HandleFailedLoginResponse Parms{};

	Parms.LoginError = std::move(LoginError);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaIdentityServiceModel.HandleSuccessfulLoginResponse
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FLoginResponseV1                 LoginResponse                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::HandleSuccessfulLoginResponse(const struct FLoginResponseV1& LoginResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "HandleSuccessfulLoginResponse");

	Params::MatchaIdentityServiceModel_HandleSuccessfulLoginResponse Parms{};

	Parms.LoginResponse = std::move(LoginResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaIdentityServiceModel.RegisterPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SelfRating                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::RegisterPlayer(const class FString& Name_0, const class FString& SelfRating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "RegisterPlayer");

	Params::MatchaIdentityServiceModel_RegisterPlayer Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.SelfRating = std::move(SelfRating);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaIdentityServiceModel.SendLoginSteamV1Request
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           SteamAuthSessionTicket                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrentGameLanguage                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DisplayName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WasSent                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::SendLoginSteamV1Request(const class FString& SteamAuthSessionTicket, const class FString& CurrentGameLanguage, const class FString& DisplayName, bool* WasSent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "SendLoginSteamV1Request");

	Params::MatchaIdentityServiceModel_SendLoginSteamV1Request Parms{};

	Parms.SteamAuthSessionTicket = std::move(SteamAuthSessionTicket);
	Parms.CurrentGameLanguage = std::move(CurrentGameLanguage);
	Parms.DisplayName = std::move(DisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WasSent != nullptr)
		*WasSent = Parms.WasSent;
}


// Function Matcha.MatchaIdentityServiceModel.SendLoginTokenV1Request
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    WasSent                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Token                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutRequestId                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::SendLoginTokenV1Request(bool* WasSent, const class FString& Token, class FString* OutRequestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "SendLoginTokenV1Request");

	Params::MatchaIdentityServiceModel_SendLoginTokenV1Request Parms{};

	Parms.Token = std::move(Token);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WasSent != nullptr)
		*WasSent = Parms.WasSent;

	if (OutRequestId != nullptr)
		*OutRequestId = std::move(Parms.OutRequestId);
}


// Function Matcha.MatchaIdentityServiceModel.SetIdentityState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIdentityState                          NextState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::SetIdentityState(EIdentityState NextState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "SetIdentityState");

	Params::MatchaIdentityServiceModel_SetIdentityState Parms{};

	Parms.NextState = NextState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaIdentityServiceModel.SetName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::SetName(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "SetName");

	Params::MatchaIdentityServiceModel_SetName Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaIdentityServiceModel.TryLogin
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    Attempted                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DisplayName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::TryLogin(bool* Attempted, const class FString& DisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "TryLogin");

	Params::MatchaIdentityServiceModel_TryLogin Parms{};

	Parms.DisplayName = std::move(DisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Attempted != nullptr)
		*Attempted = Parms.Attempted;
}


// Function Matcha.MatchaIdentityServiceModel.UpdateAccessTokens
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FAccessTokens                    Tokens                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::UpdateAccessTokens(const struct FAccessTokens& Tokens)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "UpdateAccessTokens");

	Params::MatchaIdentityServiceModel_UpdateAccessTokens Parms{};

	Parms.Tokens = std::move(Tokens);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaIdentityServiceModel.GetAccessTokens
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAccessTokens                    Tokens                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::GetAccessTokens(bool* Success, struct FAccessTokens* Tokens) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "GetAccessTokens");

	Params::MatchaIdentityServiceModel_GetAccessTokens Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	if (Tokens != nullptr)
		*Tokens = std::move(Parms.Tokens);
}


// Function Matcha.MatchaIdentityServiceModel.GetCachedLoginResponse
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLoginResponseV1                 LoginResponse                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UMatchaIdentityServiceModel::GetCachedLoginResponse(bool* Success, struct FLoginResponseV1* LoginResponse) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "GetCachedLoginResponse");

	Params::MatchaIdentityServiceModel_GetCachedLoginResponse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	if (LoginResponse != nullptr)
		*LoginResponse = std::move(Parms.LoginResponse);
}


// Function Matcha.MatchaIdentityServiceModel.GetIdentityState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EIdentityState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EIdentityState UMatchaIdentityServiceModel::GetIdentityState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaIdentityServiceModel", "GetIdentityState");

	Params::MatchaIdentityServiceModel_GetIdentityState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInteractionUtils.TryCancelInteraction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInProgressInteraction           InProgressInteraction                                  (Parm, OutParm, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInteractionUtils::TryCancelInteraction(struct FInProgressInteraction* InProgressInteraction, const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaInteractionUtils", "TryCancelInteraction");

	Params::MatchaInteractionUtils_TryCancelInteraction Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InProgressInteraction != nullptr)
		*InProgressInteraction = std::move(Parms.InProgressInteraction);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInteractionUtils.TryProgressInteraction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInProgressInteraction           InProgressInteraction                                  (Parm, OutParm, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInteractionUtils::TryProgressInteraction(struct FInProgressInteraction* InProgressInteraction, const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaInteractionUtils", "TryProgressInteraction");

	Params::MatchaInteractionUtils_TryProgressInteraction Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InProgressInteraction != nullptr)
		*InProgressInteraction = std::move(Parms.InProgressInteraction);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInteractionUtils.TryStartInteraction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USnapNetEntityComponent*          InstigatorEntityComponent                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetEntityIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetChannelTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInProgressInteraction           CurrentInteraction                                     (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInteractionUtils::TryStartInteraction(const class USnapNetEntityComponent* InstigatorEntityComponent, int32 TargetEntityIndex, float TargetChannelTime, const class UWorld* World, struct FInProgressInteraction* CurrentInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaInteractionUtils", "TryStartInteraction");

	Params::MatchaInteractionUtils_TryStartInteraction Parms{};

	Parms.InstigatorEntityComponent = InstigatorEntityComponent;
	Parms.TargetEntityIndex = TargetEntityIndex;
	Parms.TargetChannelTime = TargetChannelTime;
	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurrentInteraction != nullptr)
		*CurrentInteraction = std::move(Parms.CurrentInteraction);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryStatics.FromItemAsset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMatchaItemAsset*                 ItemAsset                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaInventoryItem             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchaInventoryItem UMatchaInventoryStatics::FromItemAsset(const class UMatchaItemAsset* ItemAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaInventoryStatics", "FromItemAsset");

	Params::MatchaInventoryStatics_FromItemAsset Parms{};

	Parms.ItemAsset = ItemAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryStatics.GetValue_ItemAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaInventoryItem             InventoryItem                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UMatchaItemAsset*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMatchaItemAsset* UMatchaInventoryStatics::GetValue_ItemAsset(const struct FMatchaInventoryItem& InventoryItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaInventoryStatics", "GetValue_ItemAsset");

	Params::MatchaInventoryStatics_GetValue_ItemAsset Parms{};

	Parms.InventoryItem = std::move(InventoryItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.CanCombineAnyItemStacksWithInventory
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SourceSlotCategory                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaInventoryComponent*        DestinationInventoryComponent                          (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DestinationSlotCategory                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::CanCombineAnyItemStacksWithInventory(const struct FGameplayTag& SourceSlotCategory, const class UMatchaInventoryComponent* DestinationInventoryComponent, const struct FGameplayTag& DestinationSlotCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "CanCombineAnyItemStacksWithInventory");

	Params::MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory Parms{};

	Parms.SourceSlotCategory = std::move(SourceSlotCategory);
	Parms.DestinationInventoryComponent = DestinationInventoryComponent;
	Parms.DestinationSlotCategory = std::move(DestinationSlotCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.CanCombineSlots
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SourceSlotCategory                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceSlotIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DestinationSlotCategory                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DestinationSlotIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::CanCombineSlots(const struct FGameplayTag& SourceSlotCategory, int32 SourceSlotIndex, const struct FGameplayTag& DestinationSlotCategory, int32 DestinationSlotIndex, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "CanCombineSlots");

	Params::MatchaInventoryComponent_CanCombineSlots Parms{};

	Parms.SourceSlotCategory = std::move(SourceSlotCategory);
	Parms.SourceSlotIndex = SourceSlotIndex;
	Parms.DestinationSlotCategory = std::move(DestinationSlotCategory);
	Parms.DestinationSlotIndex = DestinationSlotIndex;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.DumpInventory
// (Final, Native, Public, BlueprintCallable)

void UMatchaInventoryComponent::DumpInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "DumpInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaInventoryComponent.GetItemInSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMatchaInventorySlot       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMatchaInventorySlot UMatchaInventoryComponent::GetItemInSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "GetItemInSlot");

	Params::MatchaInventoryComponent_GetItemInSlot Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.HasAnEmptySlotForCategory
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::HasAnEmptySlotForCategory(const struct FGameplayTag& SlotCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "HasAnEmptySlotForCategory");

	Params::MatchaInventoryComponent_HasAnEmptySlotForCategory Parms{};

	Parms.SlotCategory = std::move(SlotCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.HasItemInCategory
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaInventoryItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::HasItemInCategory(const struct FMatchaInventoryItem& Item, const struct FGameplayTag& SlotCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "HasItemInCategory");

	Params::MatchaInventoryComponent_HasItemInCategory Parms{};

	Parms.Item = std::move(Item);
	Parms.SlotCategory = std::move(SlotCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Matcha.MatchaInventoryComponent.MatchaInventoryUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UMatchaInventoryComponent::MatchaInventoryUpdated__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "MatchaInventoryUpdated__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Matcha.MatchaInventoryComponent.ReActivateInventoryItems
// (Final, Native, Public, BlueprintCallable)

void UMatchaInventoryComponent::ReActivateInventoryItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "ReActivateInventoryItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaInventoryComponent.ResetInventory
// (Final, Native, Public, BlueprintCallable)

void UMatchaInventoryComponent::ResetInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "ResetInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaInventoryComponent.TryAddItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaInventoryItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaInventoryComponent::TryAddItem(const struct FMatchaInventoryItem& Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryAddItem");

	Params::MatchaInventoryComponent_TryAddItem Parms{};

	Parms.Item = std::move(Item);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryAddItemChecked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaInventoryItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryAddItemChecked(const struct FMatchaInventoryItem& Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryAddItemChecked");

	Params::MatchaInventoryComponent_TryAddItemChecked Parms{};

	Parms.Item = std::move(Item);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryAddOrReplaceItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaInventoryItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReplaceSlotCategory                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReplaceSlotIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryAddOrReplaceItem(const struct FMatchaInventoryItem& Item, int32 Count, const struct FGameplayTag& ReplaceSlotCategory, int32 ReplaceSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryAddOrReplaceItem");

	Params::MatchaInventoryComponent_TryAddOrReplaceItem Parms{};

	Parms.Item = std::move(Item);
	Parms.Count = Count;
	Parms.ReplaceSlotCategory = std::move(ReplaceSlotCategory);
	Parms.ReplaceSlotIndex = ReplaceSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryConsumeItemInSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryConsumeItemInSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryConsumeItemInSlot");

	Params::MatchaInventoryComponent_TryConsumeItemInSlot Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryDropAllItems
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ItemOwner                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartingSpawnLocation                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaInventoryComponent::TryDropAllItems(const class AActor* ItemOwner, const struct FVector& StartingSpawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryDropAllItems");

	Params::MatchaInventoryComponent_TryDropAllItems Parms{};

	Parms.ItemOwner = ItemOwner;
	Parms.StartingSpawnLocation = std::move(StartingSpawnLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaInventoryComponent.TryDropItem
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceSlotIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryDropItem(const struct FGameplayTag& SlotCategory, int32 SourceSlotIndex, int32 Count, const struct FVector& SpawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryDropItem");

	Params::MatchaInventoryComponent_TryDropItem Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SourceSlotIndex = SourceSlotIndex;
	Parms.Count = Count;
	Parms.SpawnLocation = std::move(SpawnLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryDropRandomItemInCategory
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryDropRandomItemInCategory(const struct FGameplayTag& SlotCategory, int32 Count, const struct FVector& SpawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryDropRandomItemInCategory");

	Params::MatchaInventoryComponent_TryDropRandomItemInCategory Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.Count = Count;
	Parms.SpawnLocation = std::move(SpawnLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryEnergizeSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryEnergizeSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryEnergizeSlot");

	Params::MatchaInventoryComponent_TryEnergizeSlot Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryHoldItemSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryHoldItemSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryHoldItemSlot");

	Params::MatchaInventoryComponent_TryHoldItemSlot Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryMoveItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SourceSlotCategory                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceSlotIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DestinationSlotCategory                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DestinationSlotIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryMoveItem(const struct FGameplayTag& SourceSlotCategory, int32 SourceSlotIndex, int32 Count, const struct FGameplayTag& DestinationSlotCategory, int32 DestinationSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryMoveItem");

	Params::MatchaInventoryComponent_TryMoveItem Parms{};

	Parms.SourceSlotCategory = std::move(SourceSlotCategory);
	Parms.SourceSlotIndex = SourceSlotIndex;
	Parms.Count = Count;
	Parms.DestinationSlotCategory = std::move(DestinationSlotCategory);
	Parms.DestinationSlotIndex = DestinationSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryRemoveItemFromSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryRemoveItemFromSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryRemoveItemFromSlot");

	Params::MatchaInventoryComponent_TryRemoveItemFromSlot Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotIndex = SlotIndex;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryRemoveItemInCategory
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaInventoryItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryRemoveItemInCategory(const struct FMatchaInventoryItem& Item, const struct FGameplayTag& SlotCategory, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryRemoveItemInCategory");

	Params::MatchaInventoryComponent_TryRemoveItemInCategory Parms{};

	Parms.Item = std::move(Item);
	Parms.SlotCategory = std::move(SlotCategory);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryReplaceItemInSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchaInventoryItem             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryReplaceItemInSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex, const struct FMatchaInventoryItem& Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryReplaceItemInSlot");

	Params::MatchaInventoryComponent_TryReplaceItemInSlot Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotIndex = SlotIndex;
	Parms.Item = std::move(Item);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TrySwapItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SourceSlotCategory                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceSlotIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DestinationSlotCategory                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DestinationSlotIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TrySwapItem(const struct FGameplayTag& SourceSlotCategory, int32 SourceSlotIndex, const struct FGameplayTag& DestinationSlotCategory, int32 DestinationSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TrySwapItem");

	Params::MatchaInventoryComponent_TrySwapItem Parms{};

	Parms.SourceSlotCategory = std::move(SourceSlotCategory);
	Parms.SourceSlotIndex = SourceSlotIndex;
	Parms.DestinationSlotCategory = std::move(DestinationSlotCategory);
	Parms.DestinationSlotIndex = DestinationSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.TryThrowItem
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceSlotIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ThrowDirection                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::TryThrowItem(const struct FGameplayTag& SlotCategory, int32 SourceSlotIndex, int32 Count, const struct FVector& SpawnLocation, const struct FVector2D& ThrowDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "TryThrowItem");

	Params::MatchaInventoryComponent_TryThrowItem Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SourceSlotIndex = SourceSlotIndex;
	Parms.Count = Count;
	Parms.SpawnLocation = std::move(SpawnLocation);
	Parms.ThrowDirection = std::move(ThrowDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.UnHoldAllSlots
// (Final, Native, Public, BlueprintCallable)

void UMatchaInventoryComponent::UnHoldAllSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "UnHoldAllSlots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaInventoryComponent.GetHeldItemSlotIndexInCategory
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchaInventoryComponent::GetHeldItemSlotIndexInCategory(const struct FGameplayTag& SlotCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "GetHeldItemSlotIndexInCategory");

	Params::MatchaInventoryComponent_GetHeldItemSlotIndexInCategory Parms{};

	Parms.SlotCategory = std::move(SlotCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryComponent.HasItemInSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     SlotCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaInventoryComponent::HasItemInSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryComponent", "HasItemInSlot");

	Params::MatchaInventoryComponent_HasItemInSlot Parms{};

	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaInventoryItemUIData.OnInteractionRendererUpdated
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           NewInteractionRenderer                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldInteractionRenderer                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaInventoryItemUIData::OnInteractionRendererUpdated(class AActor* NewInteractionRenderer, class AActor* OldInteractionRenderer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryItemUIData", "OnInteractionRendererUpdated");

	Params::MatchaInventoryItemUIData_OnInteractionRendererUpdated Parms{};

	Parms.NewInteractionRenderer = NewInteractionRenderer;
	Parms.OldInteractionRenderer = OldInteractionRenderer;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Matcha.MatchaInventoryUIData.MatchaInventoryCategoriesUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UMatchaInventoryUIData::MatchaInventoryCategoriesUpdated__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryUIData", "MatchaInventoryCategoriesUpdated__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Matcha.MatchaInventoryUIData.OnInventoryComponentUpdated
// (Final, Native, Protected)

void UMatchaInventoryUIData::OnInventoryComponentUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaInventoryUIData", "OnInventoryComponentUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaItemRenderer.ConfigureFromItem
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMatchaItemAsset*                 ItemAsset                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaItemRenderer::ConfigureFromItem(const class UMatchaItemAsset* ItemAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaItemRenderer", "ConfigureFromItem");

	Params::MatchaItemRenderer_ConfigureFromItem Parms{};

	Parms.ItemAsset = ItemAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaItemRenderer.OnUpdateFromEntity
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Entity                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaItemRenderer::OnUpdateFromEntity(class AActor* Entity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaItemRenderer", "OnUpdateFromEntity");

	Params::MatchaItemRenderer_OnUpdateFromEntity Parms{};

	Parms.Entity = Entity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaItemRenderer.SetHighlightState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsHighlighted                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaItemRenderer::SetHighlightState(bool bIsHighlighted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaItemRenderer", "SetHighlightState");

	Params::MatchaItemRenderer_SetHighlightState Parms{};

	Parms.bIsHighlighted = bIsHighlighted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaItemRenderer.UpdateItemCount
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaItemRenderer::UpdateItemCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaItemRenderer", "UpdateItemCount");

	Params::MatchaItemRenderer_UpdateItemCount Parms{};

	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetDamageVolumeEntity.OnEndOverlapWithCharacter
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetDamageVolumeEntity::OnEndOverlapWithCharacter(class AMatchaSnapNetCharacterEntity* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetDamageVolumeEntity", "OnEndOverlapWithCharacter");

	Params::MatchaSnapNetDamageVolumeEntity_OnEndOverlapWithCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetDamageVolumeEntity.OnOverlapCharacter
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetDamageVolumeEntity::OnOverlapCharacter(class AMatchaSnapNetCharacterEntity* Character, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetDamageVolumeEntity", "OnOverlapCharacter");

	Params::MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter Parms{};

	Parms.Character = Character;
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.ComputeNextZone
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FActiveKOZone                    OutNextZone                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void AMatchaSnapNetKOZoneEntity::ComputeNextZone(struct FActiveKOZone* OutNextZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "ComputeNextZone");

	Params::MatchaSnapNetKOZoneEntity_ComputeNextZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNextZone != nullptr)
		*OutNextZone = std::move(Parms.OutNextZone);
}


// Function Matcha.MatchaSnapNetKOZoneEntity.SelectFinalZone
// (Native, Event, Protected, BlueprintEvent)

void AMatchaSnapNetKOZoneEntity::SelectFinalZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "SelectFinalZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.SetTimeScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeScale_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetKOZoneEntity::SetTimeScale(float TimeScale_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "SetTimeScale");

	Params::MatchaSnapNetKOZoneEntity_SetTimeScale Parms{};

	Parms.TimeScale_0 = TimeScale_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.SkipToNextPhase
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetKOZoneEntity::SkipToNextPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "SkipToNextPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.UpdateCollisionToZoneBounds
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FActiveKOZone                    Zone                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaSnapNetKOZoneEntity::UpdateCollisionToZoneBounds(const struct FActiveKOZone& Zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "UpdateCollisionToZoneBounds");

	Params::MatchaSnapNetKOZoneEntity_UpdateCollisionToZoneBounds Parms{};

	Parms.Zone = std::move(Zone);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.GetActiveZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FActiveKOZone              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FActiveKOZone AMatchaSnapNetKOZoneEntity::GetActiveZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "GetActiveZone");

	Params::MatchaSnapNetKOZoneEntity_GetActiveZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.GetCurrentCycleIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetKOZoneEntity::GetCurrentCycleIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "GetCurrentCycleIndex");

	Params::MatchaSnapNetKOZoneEntity_GetCurrentCycleIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.GetCurrentCycleTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetKOZoneEntity::GetCurrentCycleTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "GetCurrentCycleTime");

	Params::MatchaSnapNetKOZoneEntity_GetCurrentCycleTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.GetCurrentSafeZoneExtents
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        OutSafeZoneMin                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutSafeZoneMax                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetKOZoneEntity::GetCurrentSafeZoneExtents(struct FVector2D* OutSafeZoneMin, struct FVector2D* OutSafeZoneMax) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "GetCurrentSafeZoneExtents");

	Params::MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSafeZoneMin != nullptr)
		*OutSafeZoneMin = std::move(Parms.OutSafeZoneMin);

	if (OutSafeZoneMax != nullptr)
		*OutSafeZoneMax = std::move(Parms.OutSafeZoneMax);
}


// Function Matcha.MatchaSnapNetKOZoneEntity.IsFinalZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetKOZoneEntity::IsFinalZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "IsFinalZone");

	Params::MatchaSnapNetKOZoneEntity_IsFinalZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetKOZoneEntity.IsLastStand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetKOZoneEntity::IsLastStand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetKOZoneEntity", "IsLastStand");

	Params::MatchaSnapNetKOZoneEntity_IsLastStand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaKnockoutVolume.K2_BeginOverlap
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMatchaKnockoutVolume::K2_BeginOverlap(class AActor* Target, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaKnockoutVolume", "K2_BeginOverlap");

	Params::MatchaKnockoutVolume_K2_BeginOverlap Parms{};

	Parms.Target = Target;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaKnockoutVolume.K2_EndOverlap
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaKnockoutVolume::K2_EndOverlap(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaKnockoutVolume", "K2_EndOverlap");

	Params::MatchaKnockoutVolume_K2_EndOverlap Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLeaderboardUIData.OnGetGameLeaderboardV1Completed
// (Final, Native, Private, HasOutParams)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RequestID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGetGameLeaderboardV1Response    GameLeaderboardResponse                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FErrorResponseV1                 ErrorResponse                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaLeaderboardUIData::OnGetGameLeaderboardV1Completed(bool Success, const class FString& RequestID, const struct FGetGameLeaderboardV1Response& GameLeaderboardResponse, const struct FErrorResponseV1& ErrorResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLeaderboardUIData", "OnGetGameLeaderboardV1Completed");

	Params::MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed Parms{};

	Parms.Success = Success;
	Parms.RequestID = std::move(RequestID);
	Parms.GameLeaderboardResponse = std::move(GameLeaderboardResponse);
	Parms.ErrorResponse = std::move(ErrorResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLeaderboardUIData.OnSearchGameLeaderboardV1Completed
// (Final, Native, Private, HasOutParams)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RequestID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGetGameLeaderboardV1Response    GameLeaderboardResponse                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FErrorResponseV1                 ErrorResponse                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaLeaderboardUIData::OnSearchGameLeaderboardV1Completed(bool Success, const class FString& RequestID, const struct FGetGameLeaderboardV1Response& GameLeaderboardResponse, const struct FErrorResponseV1& ErrorResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLeaderboardUIData", "OnSearchGameLeaderboardV1Completed");

	Params::MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed Parms{};

	Parms.Success = Success;
	Parms.RequestID = std::move(RequestID);
	Parms.GameLeaderboardResponse = std::move(GameLeaderboardResponse);
	Parms.ErrorResponse = std::move(ErrorResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLeaderboardUIData.Reload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLeaderboardUIData::Reload(int32 Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLeaderboardUIData", "Reload");

	Params::MatchaLeaderboardUIData_Reload Parms{};

	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.GetLocalPlayerNetworkId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatchaLocalPlayerUIData::GetLocalPlayerNetworkId(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaLocalPlayerUIData", "GetLocalPlayerNetworkId");

	Params::MatchaLocalPlayerUIData_GetLocalPlayerNetworkId Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaLocalPlayerUIData.JoinQueue
// (Final, Native, Public, BlueprintCallable)

void UMatchaLocalPlayerUIData::JoinQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "JoinQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.LeaveQueue
// (Final, Native, Public, BlueprintCallable)

void UMatchaLocalPlayerUIData::LeaveQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "LeaveQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.OnIdentityStateChanged
// (Final, Native, Protected)
// Parameters:
// EIdentityState                          PreviousIdentityState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIdentityState                          IdentityState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnIdentityStateChanged(EIdentityState PreviousIdentityState, EIdentityState IdentityState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnIdentityStateChanged");

	Params::MatchaLocalPlayerUIData_OnIdentityStateChanged Parms{};

	Parms.PreviousIdentityState = PreviousIdentityState;
	Parms.IdentityState = IdentityState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.OnLocalPlayerJoin
// (Final, Native, Protected)
// Parameters:
// int32                                   LocalPlayerIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnLocalPlayerJoin(int32 LocalPlayerIndex, int32 PlayerIndex, int32 ErrorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnLocalPlayerJoin");

	Params::MatchaLocalPlayerUIData_OnLocalPlayerJoin Parms{};

	Parms.LocalPlayerIndex = LocalPlayerIndex;
	Parms.PlayerIndex = PlayerIndex;
	Parms.ErrorCode = ErrorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.OnLoginResponseChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FLoginResponseV1                 LoginResponse                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnLoginResponseChanged(const struct FLoginResponseV1& LoginResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnLoginResponseChanged");

	Params::MatchaLocalPlayerUIData_OnLoginResponseChanged Parms{};

	Parms.LoginResponse = std::move(LoginResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.OnMasterVolumeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnMasterVolumeChanged(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnMasterVolumeChanged");

	Params::MatchaLocalPlayerUIData_OnMasterVolumeChanged Parms{};

	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaLocalPlayerUIData.OnMusicVolumeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnMusicVolumeChanged(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnMusicVolumeChanged");

	Params::MatchaLocalPlayerUIData_OnMusicVolumeChanged Parms{};

	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaLocalPlayerUIData.OnPartyChanged
// (Final, Native, Protected)
// Parameters:
// class UMatchaPartyServiceModel*         ServicesSubsystem                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnPartyChanged(class UMatchaPartyServiceModel* ServicesSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnPartyChanged");

	Params::MatchaLocalPlayerUIData_OnPartyChanged Parms{};

	Parms.ServicesSubsystem = ServicesSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.OnQueuesAvailableChanged
// (Final, Native, Protected)
// Parameters:
// class UMatchaPartyServiceModel*         PartyServiceModel                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnQueuesAvailableChanged(class UMatchaPartyServiceModel* PartyServiceModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnQueuesAvailableChanged");

	Params::MatchaLocalPlayerUIData_OnQueuesAvailableChanged Parms{};

	Parms.PartyServiceModel = PartyServiceModel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.OnReceivedInvitesChanged
// (Final, Native, Protected)
// Parameters:
// class UMatchaPartyServiceModel*         ServicesSubsystem                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnReceivedInvitesChanged(class UMatchaPartyServiceModel* ServicesSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnReceivedInvitesChanged");

	Params::MatchaLocalPlayerUIData_OnReceivedInvitesChanged Parms{};

	Parms.ServicesSubsystem = ServicesSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.OnSentInvitesChanged
// (Final, Native, Protected)
// Parameters:
// class UMatchaPartyServiceModel*         ServicesSubsystem                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnSentInvitesChanged(class UMatchaPartyServiceModel* ServicesSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnSentInvitesChanged");

	Params::MatchaLocalPlayerUIData_OnSentInvitesChanged Parms{};

	Parms.ServicesSubsystem = ServicesSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.OnSFXVolumeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::OnSFXVolumeChanged(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "OnSFXVolumeChanged");

	Params::MatchaLocalPlayerUIData_OnSFXVolumeChanged Parms{};

	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaLocalPlayerUIData.SelectQueueAtIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   QueueIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SelectQueueAtIndex(int32 QueueIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SelectQueueAtIndex");

	Params::MatchaLocalPlayerUIData_SelectQueueAtIndex Parms{};

	Parms.QueueIndex = QueueIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SelectQueueWithId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             QueueId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SelectQueueWithId(class FName QueueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SelectQueueWithId");

	Params::MatchaLocalPlayerUIData_SelectQueueWithId Parms{};

	Parms.QueueId = QueueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetAllowHeavyAttackFromMoveStickMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetAllowHeavyAttackFromMoveStickMode(bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetAllowHeavyAttackFromMoveStickMode");

	Params::MatchaLocalPlayerUIData_SetAllowHeavyAttackFromMoveStickMode Parms{};

	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetAttackStickMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAttackStickMoveType                    MoveTypeToCast                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetAttackStickMode(EAttackStickMoveType MoveTypeToCast)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetAttackStickMode");

	Params::MatchaLocalPlayerUIData_SetAttackStickMode Parms{};

	Parms.MoveTypeToCast = MoveTypeToCast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetAutoDashSettingEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetAutoDashSettingEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetAutoDashSettingEnabled");

	Params::MatchaLocalPlayerUIData_SetAutoDashSettingEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetFrameRateCap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFrameRateCap                           NewCap                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetFrameRateCap(EFrameRateCap NewCap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetFrameRateCap");

	Params::MatchaLocalPlayerUIData_SetFrameRateCap Parms{};

	Parms.NewCap = NewCap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetInventoryHeldSlotStackingMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInventoryHeldSlotStackingMode          StackingMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetInventoryHeldSlotStackingMode(EInventoryHeldSlotStackingMode StackingMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetInventoryHeldSlotStackingMode");

	Params::MatchaLocalPlayerUIData_SetInventoryHeldSlotStackingMode Parms{};

	Parms.StackingMode = StackingMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetMasterVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetMasterVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetMasterVolume");

	Params::MatchaLocalPlayerUIData_SetMasterVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetMusicVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetMusicVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetMusicVolume");

	Params::MatchaLocalPlayerUIData_SetMusicVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetSelectedCharacterIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetSelectedCharacterIndex(int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetSelectedCharacterIndex");

	Params::MatchaLocalPlayerUIData_SetSelectedCharacterIndex Parms{};

	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.SetSFXVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::SetSFXVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "SetSFXVolume");

	Params::MatchaLocalPlayerUIData_SetSFXVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.TryDisconnect
// (Final, Native, Public, BlueprintCallable)

void UMatchaLocalPlayerUIData::TryDisconnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "TryDisconnect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.TryJoinRemoteServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ConnectionURL                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLocalPlayerUIData::TryJoinRemoteServer(const class FString& ConnectionURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "TryJoinRemoteServer");

	Params::MatchaLocalPlayerUIData_TryJoinRemoteServer Parms{};

	Parms.ConnectionURL = std::move(ConnectionURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLocalPlayerUIData.TryStartPracticeRoom
// (Final, Native, Public, BlueprintCallable)

void UMatchaLocalPlayerUIData::TryStartPracticeRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLocalPlayerUIData", "TryStartPracticeRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaLootComponent.DropLootFromTable
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          StartingSpawnLocation                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDropItemsIgnoringOwnerCollision                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaLootComponent::DropLootFromTable(const struct FVector& StartingSpawnLocation, const bool bDropItemsIgnoringOwnerCollision) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaLootComponent", "DropLootFromTable");

	Params::MatchaLootComponent_DropLootFromTable Parms{};

	Parms.StartingSpawnLocation = std::move(StartingSpawnLocation);
	Parms.bDropItemsIgnoringOwnerCollision = bDropItemsIgnoringOwnerCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetInteractableRenderer.K2_OnUpdateFromEntity
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetInteractiveEntity*  EntityActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetInteractableRenderer::K2_OnUpdateFromEntity(const class AMatchaSnapNetInteractiveEntity* EntityActor, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetInteractableRenderer", "K2_OnUpdateFromEntity");

	Params::MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity Parms{};

	Parms.EntityActor = EntityActor;
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaMovingPlatformEntity.GetCurrentPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMatchaMovingPlatformPhase              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMatchaMovingPlatformPhase AMatchaMovingPlatformEntity::GetCurrentPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaMovingPlatformEntity", "GetCurrentPhase");

	Params::MatchaMovingPlatformEntity_GetCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaMovingPlatformEntity.GetCurrentPhaseDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaMovingPlatformEntity::GetCurrentPhaseDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaMovingPlatformEntity", "GetCurrentPhaseDuration");

	Params::MatchaMovingPlatformEntity_GetCurrentPhaseDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaMovingPlatformEntity.GetCurrentPhaseNormalizedProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaMovingPlatformEntity::GetCurrentPhaseNormalizedProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaMovingPlatformEntity", "GetCurrentPhaseNormalizedProgress");

	Params::MatchaMovingPlatformEntity_GetCurrentPhaseNormalizedProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPartyServiceModel.AcceptPartyInvite
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SendingPlayerId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaPartyServiceModel::AcceptPartyInvite(const class FName& SendingPlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "AcceptPartyInvite");

	Params::MatchaPartyServiceModel_AcceptPartyInvite Parms{};

	Parms.SendingPlayerId = SendingPlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.CancelPartyInvite
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TargetPlayerId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaPartyServiceModel::CancelPartyInvite(const class FName& TargetPlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "CancelPartyInvite");

	Params::MatchaPartyServiceModel_CancelPartyInvite Parms{};

	Parms.TargetPlayerId = TargetPlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.GetPartyId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMatchaPartyServiceModel::GetPartyId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "GetPartyId");

	Params::MatchaPartyServiceModel_GetPartyId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPartyServiceModel.GetPartyLeaderPlayerId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMatchaPartyServiceModel::GetPartyLeaderPlayerId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "GetPartyLeaderPlayerId");

	Params::MatchaPartyServiceModel_GetPartyLeaderPlayerId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPartyServiceModel.GetPartyMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FPartyMember>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPartyMember> UMatchaPartyServiceModel::GetPartyMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "GetPartyMembers");

	Params::MatchaPartyServiceModel_GetPartyMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPartyServiceModel.GetQueuesAvailable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FQueuesAvailableResponseV1Entry>OutQueuesAvailable                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaPartyServiceModel::GetQueuesAvailable(TArray<struct FQueuesAvailableResponseV1Entry>* OutQueuesAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "GetQueuesAvailable");

	Params::MatchaPartyServiceModel_GetQueuesAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutQueuesAvailable != nullptr)
		*OutQueuesAvailable = std::move(Parms.OutQueuesAvailable);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPartyServiceModel.GetReceivedPartyInvites
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FReceivedPartyInvite>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FReceivedPartyInvite> UMatchaPartyServiceModel::GetReceivedPartyInvites()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "GetReceivedPartyInvites");

	Params::MatchaPartyServiceModel_GetReceivedPartyInvites Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPartyServiceModel.GetSentPartyInvites
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FSentPartyInvite>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSentPartyInvite> UMatchaPartyServiceModel::GetSentPartyInvites()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "GetSentPartyInvites");

	Params::MatchaPartyServiceModel_GetSentPartyInvites Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPartyServiceModel.JoinQueue
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QueueId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaPartyServiceModel::JoinQueue(const class FName& QueueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "JoinQueue");

	Params::MatchaPartyServiceModel_JoinQueue Parms{};

	Parms.QueueId = QueueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.LeaveParty
// (Final, Native, Public, BlueprintCallable)

void UMatchaPartyServiceModel::LeaveParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "LeaveParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.LeaveQueue
// (Final, Native, Public, BlueprintCallable)

void UMatchaPartyServiceModel::LeaveQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "LeaveQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.LoadQueuesAvailableV1
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           OutRequestId                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaPartyServiceModel::LoadQueuesAvailableV1(class FString* OutRequestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "LoadQueuesAvailableV1");

	Params::MatchaPartyServiceModel_LoadQueuesAvailableV1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRequestId != nullptr)
		*OutRequestId = std::move(Parms.OutRequestId);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPartyServiceModel.LoadReceivedPartyInvites
// (Final, Native, Public, BlueprintCallable)

void UMatchaPartyServiceModel::LoadReceivedPartyInvites()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "LoadReceivedPartyInvites");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.LoadSentPartyInvites
// (Final, Native, Public, BlueprintCallable)

void UMatchaPartyServiceModel::LoadSentPartyInvites()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "LoadSentPartyInvites");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.OnWebsocketConnectionStateChanged
// (Final, Native, Protected)
// Parameters:
// class UOdyServicesModelBase*            InServicesSubsystem                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaPartyServiceModel::OnWebsocketConnectionStateChanged(class UOdyServicesModelBase* InServicesSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "OnWebsocketConnectionStateChanged");

	Params::MatchaPartyServiceModel_OnWebsocketConnectionStateChanged Parms{};

	Parms.InServicesSubsystem = InServicesSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.RejectPartyInvite
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SendingPlayerId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaPartyServiceModel::RejectPartyInvite(const class FName& SendingPlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "RejectPartyInvite");

	Params::MatchaPartyServiceModel_RejectPartyInvite Parms{};

	Parms.SendingPlayerId = SendingPlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.SendPartyInvite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TargetPlayerName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaPartyServiceModel::SendPartyInvite(const class FString& TargetPlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "SendPartyInvite");

	Params::MatchaPartyServiceModel_SendPartyInvite Parms{};

	Parms.TargetPlayerName = std::move(TargetPlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPartyServiceModel.GetPlayerParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerParty               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FPlayerParty UMatchaPartyServiceModel::GetPlayerParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPartyServiceModel", "GetPlayerParty");

	Params::MatchaPartyServiceModel_GetPlayerParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaPlayerProfileUIData.OnPlayerProfileUpdated
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FMatchaPlayerProfileV1           PlayerProfile                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaPlayerProfileUIData::OnPlayerProfileUpdated(const struct FMatchaPlayerProfileV1& PlayerProfile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPlayerProfileUIData", "OnPlayerProfileUpdated");

	Params::MatchaPlayerProfileUIData_OnPlayerProfileUpdated Parms{};

	Parms.PlayerProfile = std::move(PlayerProfile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaPlayersServiceModel.FlushPendingProfileLookups
// (Final, Native, Protected)

void UMatchaPlayersServiceModel::FlushPendingProfileLookups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaPlayersServiceModel", "FlushPendingProfileLookups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaRegionServiceModel.OnWebsocketConnectionStateChanged
// (Final, Native, Protected)
// Parameters:
// class UOdyServicesModelBase*            InServicesSubsystem                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaRegionServiceModel::OnWebsocketConnectionStateChanged(class UOdyServicesModelBase* InServicesSubsystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaRegionServiceModel", "OnWebsocketConnectionStateChanged");

	Params::MatchaRegionServiceModel_OnWebsocketConnectionStateChanged Parms{};

	Parms.InServicesSubsystem = InServicesSubsystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetCharacterEntity*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetCharacterEntity* AMatchaSnapNetCharacterEntity::Get(int32 PlayerIndex, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetCharacterEntity", "Get");

	Params::MatchaSnapNetCharacterEntity_Get Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetFromSimulation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USnapNetSimulation*               SnapNetSimulation                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetCharacterEntity*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetCharacterEntity* AMatchaSnapNetCharacterEntity::GetFromSimulation(int32 PlayerIndex, const class USnapNetSimulation* SnapNetSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetCharacterEntity", "GetFromSimulation");

	Params::MatchaSnapNetCharacterEntity_GetFromSimulation Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.SnapNetSimulation = SnapNetSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetUIAssetData
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AMatchaSnapNetCharacterEntity>CharacterEntityClass                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOdyUIAssetData*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOdyUIAssetData* AMatchaSnapNetCharacterEntity::GetUIAssetData(TSubclassOf<class AMatchaSnapNetCharacterEntity> CharacterEntityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetCharacterEntity", "GetUIAssetData");

	Params::MatchaSnapNetCharacterEntity_GetUIAssetData Parms{};

	Parms.CharacterEntityClass = CharacterEntityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.AddEnergy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::AddEnergy(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "AddEnergy");

	Params::MatchaSnapNetCharacterEntity_AddEnergy Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.AddImmuneToCrowdControlFromHitTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            ImmuneToCCTags                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::AddImmuneToCrowdControlFromHitTags(const struct FGameplayTagContainer& ImmuneToCCTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "AddImmuneToCrowdControlFromHitTags");

	Params::MatchaSnapNetCharacterEntity_AddImmuneToCrowdControlFromHitTags Parms{};

	Parms.ImmuneToCCTags = std::move(ImmuneToCCTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.AddImmuneToDamageFromHitTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            CannotBeDamagedByTags                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::AddImmuneToDamageFromHitTags(const struct FGameplayTagContainer& CannotBeDamagedByTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "AddImmuneToDamageFromHitTags");

	Params::MatchaSnapNetCharacterEntity_AddImmuneToDamageFromHitTags Parms{};

	Parms.CannotBeDamagedByTags = std::move(CannotBeDamagedByTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.AddRecentlyScannedCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EntityIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::AddRecentlyScannedCharacter(int32 EntityIndex, float Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "AddRecentlyScannedCharacter");

	Params::MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter Parms{};

	Parms.EntityIndex = EntityIndex;
	Parms.Timestamp = Timestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ApplyBuff
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBuffInfo                        BuffInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EObjectRarity                           ObjectRarity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::ApplyBuff(const struct FBuffInfo& BuffInfo, EObjectRarity ObjectRarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ApplyBuff");

	Params::MatchaSnapNetCharacterEntity_ApplyBuff Parms{};

	Parms.BuffInfo = std::move(BuffInfo);
	Parms.ObjectRarity = ObjectRarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ApplyGlitchMark
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           GlitchMarkTarget                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsMarkFromItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::ApplyGlitchMark(class AActor* GlitchMarkTarget, bool bIsMarkFromItem, float DurationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ApplyGlitchMark");

	Params::MatchaSnapNetCharacterEntity_ApplyGlitchMark Parms{};

	Parms.GlitchMarkTarget = GlitchMarkTarget;
	Parms.bIsMarkFromItem = bIsMarkFromItem;
	Parms.DurationSeconds = DurationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ApplyPeriodicDamageEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     PeriodicDamageEffectTag                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PeriodicDamageInstigator                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PeriodicDamageIntervalSeconds                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::ApplyPeriodicDamageEffect(const struct FGameplayTag& PeriodicDamageEffectTag, const class AActor* PeriodicDamageInstigator, float DamageAmount, float DurationSeconds, float PeriodicDamageIntervalSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ApplyPeriodicDamageEffect");

	Params::MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect Parms{};

	Parms.PeriodicDamageEffectTag = std::move(PeriodicDamageEffectTag);
	Parms.PeriodicDamageInstigator = PeriodicDamageInstigator;
	Parms.DamageAmount = DamageAmount;
	Parms.DurationSeconds = DurationSeconds;
	Parms.PeriodicDamageIntervalSeconds = PeriodicDamageIntervalSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.CancelCameraScanMode
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::CancelCameraScanMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "CancelCameraScanMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.CancelDisguise
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::CancelDisguise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "CancelDisguise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.CanGlitchBeamAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::CanGlitchBeamAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "CanGlitchBeamAttack");

	Params::MatchaSnapNetCharacterEntity_CanGlitchBeamAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ClearCurrentGrab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetThrowDirection                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::ClearCurrentGrab(bool bResetThrowDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ClearCurrentGrab");

	Params::MatchaSnapNetCharacterEntity_ClearCurrentGrab Parms{};

	Parms.bResetThrowDirection = bResetThrowDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ClearHelpless
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::ClearHelpless()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ClearHelpless");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ClearStatesForExternalLaunch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClearCurrentMontage                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::ClearStatesForExternalLaunch(bool bClearCurrentMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ClearStatesForExternalLaunch");

	Params::MatchaSnapNetCharacterEntity_ClearStatesForExternalLaunch Parms{};

	Parms.bClearCurrentMontage = bClearCurrentMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.DisableGravity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::DisableGravity(float DurationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "DisableGravity");

	Params::MatchaSnapNetCharacterEntity_DisableGravity Parms{};

	Parms.DurationSeconds = DurationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.DisableProjectileReflectionWhenShielding
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::DisableProjectileReflectionWhenShielding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "DisableProjectileReflectionWhenShielding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.EnableProjectileReflectionWhenShielding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReflectAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReflectSpeedMultiplier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReflectDamageMultiplier                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::EnableProjectileReflectionWhenShielding(float ReflectAngle, float ReflectSpeedMultiplier, float ReflectDamageMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "EnableProjectileReflectionWhenShielding");

	Params::MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding Parms{};

	Parms.ReflectAngle = ReflectAngle;
	Parms.ReflectSpeedMultiplier = ReflectSpeedMultiplier;
	Parms.ReflectDamageMultiplier = ReflectDamageMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetHeldItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UMatchaItemAsset*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMatchaItemAsset* AMatchaSnapNetCharacterEntity::GetHeldItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetHeldItem");

	Params::MatchaSnapNetCharacterEntity_GetHeldItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.InertialCancel
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::InertialCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "InertialCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsInGlitchBeamWindUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsInGlitchBeamWindUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsInGlitchBeamWindUp");

	Params::MatchaSnapNetCharacterEntity_IsInGlitchBeamWindUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.OnCharacterJump
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EJumpType                               JumpType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::OnCharacterJump(EJumpType JumpType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "OnCharacterJump");

	Params::MatchaSnapNetCharacterEntity_OnCharacterJump Parms{};

	Parms.JumpType = JumpType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.OnCharacterKnockBackApplied
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InInstigator                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::OnCharacterKnockBackApplied(const class AActor* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "OnCharacterKnockBackApplied");

	Params::MatchaSnapNetCharacterEntity_OnCharacterKnockBackApplied Parms{};

	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.OnKnockedOutAnEnemyCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           KnockedEnemyCharacter                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::OnKnockedOutAnEnemyCharacter(class AActor* KnockedEnemyCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "OnKnockedOutAnEnemyCharacter");

	Params::MatchaSnapNetCharacterEntity_OnKnockedOutAnEnemyCharacter Parms{};

	Parms.KnockedEnemyCharacter = KnockedEnemyCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.PerformGlitchBeam
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::PerformGlitchBeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "PerformGlitchBeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.PerformSpecialTeleport
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSpecialTeleportSettings         TeleportSettings                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMatchaSnapNetCharacterEntity::PerformSpecialTeleport(const struct FSpecialTeleportSettings& TeleportSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "PerformSpecialTeleport");

	Params::MatchaSnapNetCharacterEntity_PerformSpecialTeleport Parms{};

	Parms.TeleportSettings = std::move(TeleportSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RemoveBuffsWithTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     BuffTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RemoveBuffsWithTag(const struct FGameplayTag& BuffTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RemoveBuffsWithTag");

	Params::MatchaSnapNetCharacterEntity_RemoveBuffsWithTag Parms{};

	Parms.BuffTag = std::move(BuffTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RemoveImmuneToCrowdControlFromHitTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            ImmuneToCCTags                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RemoveImmuneToCrowdControlFromHitTags(const struct FGameplayTagContainer& ImmuneToCCTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RemoveImmuneToCrowdControlFromHitTags");

	Params::MatchaSnapNetCharacterEntity_RemoveImmuneToCrowdControlFromHitTags Parms{};

	Parms.ImmuneToCCTags = std::move(ImmuneToCCTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RemoveImmuneToDamageFromHitTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            CannotBeDamagedByTags                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RemoveImmuneToDamageFromHitTags(const struct FGameplayTagContainer& CannotBeDamagedByTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RemoveImmuneToDamageFromHitTags");

	Params::MatchaSnapNetCharacterEntity_RemoveImmuneToDamageFromHitTags Parms{};

	Parms.CannotBeDamagedByTags = std::move(CannotBeDamagedByTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RemovePeriodicDamageEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           PeriodicDamageInstigator                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     PeriodicDamageEffectTag                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RemovePeriodicDamageEffect(class AActor* PeriodicDamageInstigator, const struct FGameplayTag& PeriodicDamageEffectTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RemovePeriodicDamageEffect");

	Params::MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect Parms{};

	Parms.PeriodicDamageInstigator = PeriodicDamageInstigator;
	Parms.PeriodicDamageEffectTag = std::move(PeriodicDamageEffectTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RemoveSuperArmor
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::RemoveSuperArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RemoveSuperArmor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RequestCameraScanMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RequestCameraScanMode(float DurationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RequestCameraScanMode");

	Params::MatchaSnapNetCharacterEntity_RequestCameraScanMode Parms{};

	Parms.DurationSeconds = DurationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RequestDisable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RequestDisable(float DurationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RequestDisable");

	Params::MatchaSnapNetCharacterEntity_RequestDisable Parms{};

	Parms.DurationSeconds = DurationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RequestIntangibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RequestIntangibility(float DurationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RequestIntangibility");

	Params::MatchaSnapNetCharacterEntity_RequestIntangibility Parms{};

	Parms.DurationSeconds = DurationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RequestLandingState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RequestLandingState(float DurationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RequestLandingState");

	Params::MatchaSnapNetCharacterEntity_RequestLandingState Parms{};

	Parms.DurationSeconds = DurationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RequestPeriodicCoinGeneration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RequestPeriodicCoinGeneration(int32 Amount, float Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RequestPeriodicCoinGeneration");

	Params::MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration Parms{};

	Parms.Amount = Amount;
	Parms.Interval = Interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.RequestSuperArmor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::RequestSuperArmor(float DurationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "RequestSuperArmor");

	Params::MatchaSnapNetCharacterEntity_RequestSuperArmor Parms{};

	Parms.DurationSeconds = DurationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ResetAirJumps
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::ResetAirJumps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ResetAirJumps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ResetDisguiseElapsedTime
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::ResetDisguiseElapsedTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ResetDisguiseElapsedTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ResetEnhancedAirDodge
// (Final, Native, Protected, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::ResetEnhancedAirDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ResetEnhancedAirDodge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ResetZAirDashGrab
// (Final, Native, Protected, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::ResetZAirDashGrab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ResetZAirDashGrab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetCurrentGameplayPromptID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   IntID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::SetCurrentGameplayPromptID(int32 IntID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetCurrentGameplayPromptID");

	Params::MatchaSnapNetCharacterEntity_SetCurrentGameplayPromptID Parms{};

	Parms.IntID = IntID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetDisguiseEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::SetDisguiseEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetDisguiseEnabled");

	Params::MatchaSnapNetCharacterEntity_SetDisguiseEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetEnhancedAirDodgeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::SetEnhancedAirDodgeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetEnhancedAirDodgeEnabled");

	Params::MatchaSnapNetCharacterEntity_SetEnhancedAirDodgeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetShieldInvincible
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bIsInvincible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::SetShieldInvincible(bool bIsInvincible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetShieldInvincible");

	Params::MatchaSnapNetCharacterEntity_SetShieldInvincible Parms{};

	Parms.bIsInvincible = bIsInvincible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetupSpecialAttackRestrictions
// (Final, Native, Protected, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::SetupSpecialAttackRestrictions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetupSpecialAttackRestrictions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetWallClingEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::SetWallClingEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetWallClingEnabled");

	Params::MatchaSnapNetCharacterEntity_SetWallClingEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetWallRunEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::SetWallRunEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetWallRunEnabled");

	Params::MatchaSnapNetCharacterEntity_SetWallRunEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetZAirDashGrabEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::SetZAirDashGrabEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetZAirDashGrabEnabled");

	Params::MatchaSnapNetCharacterEntity_SetZAirDashGrabEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.SetZAirGrabEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::SetZAirGrabEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "SetZAirGrabEnabled");

	Params::MatchaSnapNetCharacterEntity_SetZAirGrabEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.ToggleAutoTech
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldEnable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterEntity::ToggleAutoTech(bool bShouldEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "ToggleAutoTech");

	Params::MatchaSnapNetCharacterEntity_ToggleAutoTech Parms{};

	Parms.bShouldEnable = bShouldEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.TryPerformDisguise
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::TryPerformDisguise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "TryPerformDisguise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.TryPerformGlitchStepAttack
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetCharacterEntity::TryPerformGlitchStepAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "TryPerformGlitchStepAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetCompanionEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMatchaAttachableCompanionEntity* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaAttachableCompanionEntity* AMatchaSnapNetCharacterEntity::GetCompanionEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetCompanionEntity");

	Params::MatchaSnapNetCharacterEntity_GetCompanionEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetCurrentShieldHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetCurrentShieldHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetCurrentShieldHealth");

	Params::MatchaSnapNetCharacterEntity_GetCurrentShieldHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetCurrentTeam
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetCurrentTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetCurrentTeam");

	Params::MatchaSnapNetCharacterEntity_GetCurrentTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetDisguiseElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetDisguiseElapsedTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetDisguiseElapsedTime");

	Params::MatchaSnapNetCharacterEntity_GetDisguiseElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetDisguiseId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetDisguiseId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetDisguiseId");

	Params::MatchaSnapNetCharacterEntity_GetDisguiseId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetEnergy");

	Params::MatchaSnapNetCharacterEntity_GetEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetEnergyGenerationRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetEnergyGenerationRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetEnergyGenerationRatio");

	Params::MatchaSnapNetCharacterEntity_GetEnergyGenerationRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetGlitchMarkedTargetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bFromItemSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMatchaSnapNetCharacterEntity::GetGlitchMarkedTargetActor(bool bFromItemSource) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetGlitchMarkedTargetActor");

	Params::MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor Parms{};

	Parms.bFromItemSource = bFromItemSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetHitStunRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetHitStunRemainingTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetHitStunRemainingTime");

	Params::MatchaSnapNetCharacterEntity_GetHitStunRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetJuiceStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetJuiceStat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetJuiceStat");

	Params::MatchaSnapNetCharacterEntity_GetJuiceStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetMaxAirJumps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetMaxAirJumps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetMaxAirJumps");

	Params::MatchaSnapNetCharacterEntity_GetMaxAirJumps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetMaxEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetMaxEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetMaxEnergy");

	Params::MatchaSnapNetCharacterEntity_GetMaxEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetMaxShieldHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetMaxShieldHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetMaxShieldHealth");

	Params::MatchaSnapNetCharacterEntity_GetMaxShieldHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetMostRecentlyHitEnemyPlayerWithinTimeWindow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   WindowTimeSeconds                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetMostRecentlyHitEnemyPlayerWithinTimeWindow(float WindowTimeSeconds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetMostRecentlyHitEnemyPlayerWithinTimeWindow");

	Params::MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow Parms{};

	Parms.WindowTimeSeconds = WindowTimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetOwningPlayerEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMatchaSnapNetPlayerEntity*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetPlayerEntity* AMatchaSnapNetCharacterEntity::GetOwningPlayerEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetOwningPlayerEntity");

	Params::MatchaSnapNetCharacterEntity_GetOwningPlayerEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetRemainingAirJumps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetRemainingAirJumps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetRemainingAirJumps");

	Params::MatchaSnapNetCharacterEntity_GetRemainingAirJumps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetRevealedCharacterEntityIndices
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> AMatchaSnapNetCharacterEntity::GetRevealedCharacterEntityIndices() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetRevealedCharacterEntityIndices");

	Params::MatchaSnapNetCharacterEntity_GetRevealedCharacterEntityIndices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetSharedTeamCoinsCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetSharedTeamCoinsCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetSharedTeamCoinsCount");

	Params::MatchaSnapNetCharacterEntity_GetSharedTeamCoinsCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetSharedTeamPowerSparksCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetSharedTeamPowerSparksCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetSharedTeamPowerSparksCount");

	Params::MatchaSnapNetCharacterEntity_GetSharedTeamPowerSparksCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetShieldLastInputTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetShieldLastInputTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetShieldLastInputTime");

	Params::MatchaSnapNetCharacterEntity_GetShieldLastInputTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetShieldState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMatchaShieldState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMatchaShieldState AMatchaSnapNetCharacterEntity::GetShieldState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetShieldState");

	Params::MatchaSnapNetCharacterEntity_GetShieldState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetSlowAmountStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSnapNetCharacterEntity::GetSlowAmountStat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetSlowAmountStat");

	Params::MatchaSnapNetCharacterEntity_GetSlowAmountStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.GetTimeSinceLastDashingStateMilliseconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMatchaSnapNetCharacterEntity::GetTimeSinceLastDashingStateMilliseconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "GetTimeSinceLastDashingStateMilliseconds");

	Params::MatchaSnapNetCharacterEntity_GetTimeSinceLastDashingStateMilliseconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.HasEnoughEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   NeededAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::HasEnoughEnergy(float NeededAmount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "HasEnoughEnergy");

	Params::MatchaSnapNetCharacterEntity_HasEnoughEnergy Parms{};

	Parms.NeededAmount = NeededAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.HasSuperArmor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::HasSuperArmor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "HasSuperArmor");

	Params::MatchaSnapNetCharacterEntity_HasSuperArmor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsDashing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsDashing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsDashing");

	Params::MatchaSnapNetCharacterEntity_IsDashing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsDisguised
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsDisguised() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsDisguised");

	Params::MatchaSnapNetCharacterEntity_IsDisguised Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsDisguiseEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsDisguiseEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsDisguiseEnabled");

	Params::MatchaSnapNetCharacterEntity_IsDisguiseEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsEnhancedAirDodgeEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsEnhancedAirDodgeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsEnhancedAirDodgeEnabled");

	Params::MatchaSnapNetCharacterEntity_IsEnhancedAirDodgeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsHelpless
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsHelpless() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsHelpless");

	Params::MatchaSnapNetCharacterEntity_IsHelpless Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsInHitStun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsInHitStun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsInHitStun");

	Params::MatchaSnapNetCharacterEntity_IsInHitStun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsInPetrifyHitFreeze
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsInPetrifyHitFreeze() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsInPetrifyHitFreeze");

	Params::MatchaSnapNetCharacterEntity_IsInPetrifyHitFreeze Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsInsideZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsInsideZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsInsideZone");

	Params::MatchaSnapNetCharacterEntity_IsInsideZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsInSoulState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsInSoulState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsInSoulState");

	Params::MatchaSnapNetCharacterEntity_IsInSoulState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsIntangible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsIntangible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsIntangible");

	Params::MatchaSnapNetCharacterEntity_IsIntangible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsZAirDashGrabEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsZAirDashGrabEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsZAirDashGrabEnabled");

	Params::MatchaSnapNetCharacterEntity_IsZAirDashGrabEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterEntity.IsZAirGrabEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterEntity::IsZAirGrabEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterEntity", "IsZAirGrabEnabled");

	Params::MatchaSnapNetCharacterEntity_IsZAirGrabEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.AnchorTooltipWidgetToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTooltipAnchorActor                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::AnchorTooltipWidgetToActor(class AActor* InTooltipAnchorActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "AnchorTooltipWidgetToActor");

	Params::MatchaSnapNetCharacterRenderer_AnchorTooltipWidgetToActor Parms{};

	Parms.InTooltipAnchorActor = InTooltipAnchorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.ApplyVisibilityOverrides
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    CharacterEntity                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVisibilityOverride>      VisibilityOverrides                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::ApplyVisibilityOverrides(const class AMatchaSnapNetCharacterEntity* CharacterEntity, const TArray<struct FVisibilityOverride>& VisibilityOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "ApplyVisibilityOverrides");

	Params::MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides Parms{};

	Parms.CharacterEntity = CharacterEntity;
	Parms.VisibilityOverrides = std::move(VisibilityOverrides);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.EnableExternalViewTargetControl
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bNewEnable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterRenderer::EnableExternalViewTargetControl(bool bNewEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "EnableExternalViewTargetControl");

	Params::MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl Parms{};

	Parms.bNewEnable = bNewEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.K2_CalcCamera
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMinimalViewInfo                 OutResult                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::K2_CalcCamera(float DeltaTime, struct FMinimalViewInfo* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "K2_CalcCamera");

	Params::MatchaSnapNetCharacterRenderer_K2_CalcCamera Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnAliveStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EAliveState                             OldAliveState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAliveState                             NewAliveState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnAliveStateChanged(EAliveState OldAliveState, EAliveState NewAliveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnAliveStateChanged");

	Params::MatchaSnapNetCharacterRenderer_OnAliveStateChanged Parms{};

	Parms.OldAliveState = OldAliveState;
	Parms.NewAliveState = NewAliveState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnAliveStateInitialized
// (Event, Protected, BlueprintEvent)
// Parameters:
// EAliveState                             CurrentAliveState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnAliveStateInitialized(EAliveState CurrentAliveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnAliveStateInitialized");

	Params::MatchaSnapNetCharacterRenderer_OnAliveStateInitialized Parms{};

	Parms.CurrentAliveState = CurrentAliveState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnGlitchMarkChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bNewHasGlitchMark                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnGlitchMarkChanged(bool bNewHasGlitchMark)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnGlitchMarkChanged");

	Params::MatchaSnapNetCharacterRenderer_OnGlitchMarkChanged Parms{};

	Parms.bNewHasGlitchMark = bNewHasGlitchMark;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnHasInteractTargetChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bHasInteractTarget                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnHasInteractTargetChanged(bool bHasInteractTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnHasInteractTargetChanged");

	Params::MatchaSnapNetCharacterRenderer_OnHasInteractTargetChanged Parms{};

	Parms.bHasInteractTarget = bHasInteractTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnInstigatedHitInfoChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           NewHitCauser                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewHitReceiver                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewHitFlags                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewHitFreezeSeconds                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnInstigatedHitInfoChanged(const class AActor* NewHitCauser, const class AActor* NewHitReceiver, uint8 NewHitFlags, float NewHitFreezeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnInstigatedHitInfoChanged");

	Params::MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged Parms{};

	Parms.NewHitCauser = NewHitCauser;
	Parms.NewHitReceiver = NewHitReceiver;
	Parms.NewHitFlags = NewHitFlags;
	Parms.NewHitFreezeSeconds = NewHitFreezeSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnInteractionProgressChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsProgressingInteraction                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InteractionTotalTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InteractionCurrentTime                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnInteractionProgressChanged(bool bIsProgressingInteraction, float InteractionTotalTime, float InteractionCurrentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnInteractionProgressChanged");

	Params::MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged Parms{};

	Parms.bIsProgressingInteraction = bIsProgressingInteraction;
	Parms.InteractionTotalTime = InteractionTotalTime;
	Parms.InteractionCurrentTime = InteractionCurrentTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnReceivedHitInfoChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           NewHitCauser                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewHitFlags                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewHitFreezeSeconds                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnReceivedHitInfoChanged(const class AActor* NewHitCauser, uint8 NewHitFlags, float NewHitFreezeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnReceivedHitInfoChanged");

	Params::MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged Parms{};

	Parms.NewHitCauser = NewHitCauser;
	Parms.NewHitFlags = NewHitFlags;
	Parms.NewHitFreezeSeconds = NewHitFreezeSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnTeamAttackTargetChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bCurrentlyTargeted                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTargetedByAlly                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnTeamAttackTargetChanged(bool bCurrentlyTargeted, bool bTargetedByAlly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnTeamAttackTargetChanged");

	Params::MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged Parms{};

	Parms.bCurrentlyTargeted = bCurrentlyTargeted;
	Parms.bTargetedByAlly = bTargetedByAlly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnTeamAttackWarningChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bShouldShowWarning                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnTeamAttackWarningChanged(bool bShouldShowWarning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnTeamAttackWarningChanged");

	Params::MatchaSnapNetCharacterRenderer_OnTeamAttackWarningChanged Parms{};

	Parms.bShouldShowWarning = bShouldShowWarning;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.OnZoneStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bNewInsideZone                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::OnZoneStateChanged(bool bNewInsideZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "OnZoneStateChanged");

	Params::MatchaSnapNetCharacterRenderer_OnZoneStateChanged Parms{};

	Parms.bNewInsideZone = bNewInsideZone;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetCharacterRenderer.UpdatePropertyVisuals
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AMatchaSnapNetCharacterEntity*    CharacterEntity                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleported                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::UpdatePropertyVisuals(const class AMatchaSnapNetCharacterEntity* CharacterEntity, bool bTeleported)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "UpdatePropertyVisuals");

	Params::MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals Parms{};

	Parms.CharacterEntity = CharacterEntity;
	Parms.bTeleported = bTeleported;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.GetAudioEventFromSkinData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             AudioEventId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* AMatchaSnapNetCharacterRenderer::GetAudioEventFromSkinData(class FName AudioEventId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "GetAudioEventFromSkinData");

	Params::MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData Parms{};

	Parms.AudioEventId = AudioEventId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.GetNiagaraSystemFromSkinData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NiagaraSystemId                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* AMatchaSnapNetCharacterRenderer::GetNiagaraSystemFromSkinData(class FName NiagaraSystemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "GetNiagaraSystemFromSkinData");

	Params::MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData Parms{};

	Parms.NiagaraSystemId = NiagaraSystemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.IsGameplayVisibleToSpectatedPlayer
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterRenderer::IsGameplayVisibleToSpectatedPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "IsGameplayVisibleToSpectatedPlayer");

	Params::MatchaSnapNetCharacterRenderer_IsGameplayVisibleToSpectatedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.IsLocallySpectated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterRenderer::IsLocallySpectated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "IsLocallySpectated");

	Params::MatchaSnapNetCharacterRenderer_IsLocallySpectated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.IsTeamMateWithLocallySpectatedCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterRenderer::IsTeamMateWithLocallySpectatedCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "IsTeamMateWithLocallySpectatedCharacter");

	Params::MatchaSnapNetCharacterRenderer_IsTeamMateWithLocallySpectatedCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.IsViewTargetExternallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMatchaSnapNetCharacterRenderer::IsViewTargetExternallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "IsViewTargetExternallyControlled");

	Params::MatchaSnapNetCharacterRenderer_IsViewTargetExternallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetCharacterRenderer.UpdateBPOnlyComponentsGameplayVisibility
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bIsGameplayVisible                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetCharacterRenderer::UpdateBPOnlyComponentsGameplayVisibility(bool bIsGameplayVisible) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetCharacterRenderer", "UpdateBPOnlyComponentsGameplayVisibility");

	Params::MatchaSnapNetCharacterRenderer_UpdateBPOnlyComponentsGameplayVisibility Parms{};

	Parms.bIsGameplayVisible = bIsGameplayVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetGameInstance.SetMasterVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaSnapNetGameInstance::SetMasterVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "SetMasterVolume");

	Params::MatchaSnapNetGameInstance_SetMasterVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetGameInstance.GetAllyRTPC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UAkRtpc*                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAkRtpc* UMatchaSnapNetGameInstance::GetAllyRTPC() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetAllyRTPC");

	Params::MatchaSnapNetGameInstance_GetAllyRTPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetColorForAllies
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor UMatchaSnapNetGameInstance::GetColorForAllies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetColorForAllies");

	Params::MatchaSnapNetGameInstance_GetColorForAllies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetColorForEnemies
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor UMatchaSnapNetGameInstance::GetColorForEnemies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetColorForEnemies");

	Params::MatchaSnapNetGameInstance_GetColorForEnemies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetColorForSelf
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor UMatchaSnapNetGameInstance::GetColorForSelf() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetColorForSelf");

	Params::MatchaSnapNetGameInstance_GetColorForSelf Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetColorForTeamNumber
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TeamNumber                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor UMatchaSnapNetGameInstance::GetColorForTeamNumber(int32 TeamNumber) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetColorForTeamNumber");

	Params::MatchaSnapNetGameInstance_GetColorForTeamNumber Parms{};

	Parms.TeamNumber = TeamNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetEnabledSpawnRegions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<ESpawnRegion>              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<ESpawnRegion> UMatchaSnapNetGameInstance::GetEnabledSpawnRegions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetEnabledSpawnRegions");

	Params::MatchaSnapNetGameInstance_GetEnabledSpawnRegions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetGameplayEventNotificationChannel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag UMatchaSnapNetGameInstance::GetGameplayEventNotificationChannel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetGameplayEventNotificationChannel");

	Params::MatchaSnapNetGameInstance_GetGameplayEventNotificationChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetGenericAudioEventFromId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             AudioEventId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* UMatchaSnapNetGameInstance::GetGenericAudioEventFromId(class FName AudioEventId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetGenericAudioEventFromId");

	Params::MatchaSnapNetGameInstance_GetGenericAudioEventFromId Parms{};

	Parms.AudioEventId = AudioEventId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetGenericNiagaraSystemFromId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NiagaraSystemId                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* UMatchaSnapNetGameInstance::GetGenericNiagaraSystemFromId(class FName NiagaraSystemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetGenericNiagaraSystemFromId");

	Params::MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId Parms{};

	Parms.NiagaraSystemId = NiagaraSystemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetLocallySpectatedRTPC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UAkRtpc*                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAkRtpc* UMatchaSnapNetGameInstance::GetLocallySpectatedRTPC() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetLocallySpectatedRTPC");

	Params::MatchaSnapNetGameInstance_GetLocallySpectatedRTPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetGameInstance.GetSpawnRegionsToDisplayNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<ESpawnRegion, class FText>   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<ESpawnRegion, class FText> UMatchaSnapNetGameInstance::GetSpawnRegionsToDisplayNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetGameInstance", "GetSpawnRegionsToDisplayNames");

	Params::MatchaSnapNetGameInstance_GetSpawnRegionsToDisplayNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPropertyGameplayTagFunctionLibrary.Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatchaSnapNetGameplayTagPropertyMatchaSnapNetGameplayTagProperty                       (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag UMatchaSnapNetPropertyGameplayTagFunctionLibrary::Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag(const struct FMatchaSnapNetGameplayTagProperty& MatchaSnapNetGameplayTagProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetPropertyGameplayTagFunctionLibrary", "Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag");

	Params::MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag Parms{};

	Parms.MatchaSnapNetGameplayTagProperty = std::move(MatchaSnapNetGameplayTagProperty);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPropertyGameplayTagFunctionLibrary.SetValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMatchaSnapNetGameplayTagPropertyMatchaSnapNetGameplayTagProperty                       (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaSnapNetPropertyGameplayTagFunctionLibrary::SetValue(struct FMatchaSnapNetGameplayTagProperty& MatchaSnapNetGameplayTagProperty, const struct FGameplayTag& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetPropertyGameplayTagFunctionLibrary", "SetValue");

	Params::MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue Parms{};

	Parms.MatchaSnapNetGameplayTagProperty = std::move(MatchaSnapNetGameplayTagProperty);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MatchaSnapNetGameplayTagProperty = std::move(Parms.MatchaSnapNetGameplayTagProperty);
}


// Function Matcha.MatchaFinalZone.GetLastStandBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox AMatchaFinalZone::GetLastStandBounds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaFinalZone", "GetLastStandBounds");

	Params::MatchaFinalZone_GetLastStandBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Matcha.MatchaSnapNetPlayerController.JoinedGame__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void AMatchaSnapNetPlayerController::JoinedGame__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "JoinedGame__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Matcha.MatchaSnapNetPlayerController.RequestSelectSpawnRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESpawnRegion                            SelectedSpawnRegion                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerController::RequestSelectSpawnRegion(ESpawnRegion SelectedSpawnRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "RequestSelectSpawnRegion");

	Params::MatchaSnapNetPlayerController_RequestSelectSpawnRegion Parms{};

	Parms.SelectedSpawnRegion = SelectedSpawnRegion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayerController.SetHoveredCharacter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             CharacterClass                                         (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerController::SetHoveredCharacter(const TSoftClassPtr<class UClass>& CharacterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "SetHoveredCharacter");

	Params::MatchaSnapNetPlayerController_SetHoveredCharacter Parms{};

	Parms.CharacterClass = CharacterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Matcha.MatchaSnapNetPlayerController.SpectatedCharacterRendererChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AMatchaSnapNetCharacterRenderer*  CharacterRenderer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerController::SpectatedCharacterRendererChanged__DelegateSignature(class AMatchaSnapNetCharacterRenderer* CharacterRenderer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "SpectatedCharacterRendererChanged__DelegateSignature");

	Params::MatchaSnapNetPlayerController_SpectatedCharacterRendererChanged__DelegateSignature Parms{};

	Parms.CharacterRenderer = CharacterRenderer;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Matcha.MatchaSnapNetPlayerController.SpectatedPlayerIndexChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   PlayerIndexForLocalPlayer                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PreviousSpectatedPlayerIndex                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewSpectatedPlayerIndex                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerController::SpectatedPlayerIndexChanged__DelegateSignature(int32 PlayerIndexForLocalPlayer, int32 PreviousSpectatedPlayerIndex, int32 NewSpectatedPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "SpectatedPlayerIndexChanged__DelegateSignature");

	Params::MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature Parms{};

	Parms.PlayerIndexForLocalPlayer = PlayerIndexForLocalPlayer;
	Parms.PreviousSpectatedPlayerIndex = PreviousSpectatedPlayerIndex;
	Parms.NewSpectatedPlayerIndex = NewSpectatedPlayerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaSnapNetPlayerController.SpectateNextPlayer
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetPlayerController::SpectateNextPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "SpectateNextPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayerController.SpectatePreviousPlayer
// (Final, Native, Public, BlueprintCallable)

void AMatchaSnapNetPlayerController::SpectatePreviousPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "SpectatePreviousPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayerController.DEBUG_SetPlayerName
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FString                           NewName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerController::DEBUG_SetPlayerName(const class FString& NewName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "DEBUG_SetPlayerName");

	Params::MatchaSnapNetPlayerController_DEBUG_SetPlayerName Parms{};

	Parms.NewName = std::move(NewName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayerController.GetCameraMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMatchaCameraMode                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMatchaCameraMode AMatchaSnapNetPlayerController::GetCameraMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "GetCameraMode");

	Params::MatchaSnapNetPlayerController_GetCameraMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerController.GetCurrentFrameInputValues
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerInputValues         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FPlayerInputValues AMatchaSnapNetPlayerController::GetCurrentFrameInputValues() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "GetCurrentFrameInputValues");

	Params::MatchaSnapNetPlayerController_GetCurrentFrameInputValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerController.GetLastFrameInputValues
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerInputValues         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FPlayerInputValues AMatchaSnapNetPlayerController::GetLastFrameInputValues() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "GetLastFrameInputValues");

	Params::MatchaSnapNetPlayerController_GetLastFrameInputValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSnapNetPlayerController.SetPlayerCharacter
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaSnapNetPlayerController::SetPlayerCharacter(int32 CharacterIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSnapNetPlayerController", "SetPlayerCharacter");

	Params::MatchaSnapNetPlayerController_SetPlayerCharacter Parms{};

	Parms.CharacterIndex = CharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaSnapNetPlayInfo.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMatchaSnapNetPlayInfo*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMatchaSnapNetPlayInfo* AMatchaSnapNetPlayInfo::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaSnapNetPlayInfo", "Get");

	Params::MatchaSnapNetPlayInfo_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaSplineTraversalEntity.GetRemainingCooldownTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMatchaSplineTraversalEntity::GetRemainingCooldownTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaSplineTraversalEntity", "GetRemainingCooldownTime");

	Params::MatchaSplineTraversalEntity_GetRemainingCooldownTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaStandaloneServerProvider.OnMatchPhaseChanged
// (Final, Native, Protected)
// Parameters:
// EMatchaMatchPhase                       MatchPhase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchaStandaloneServerProvider::OnMatchPhaseChanged(EMatchaMatchPhase MatchPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaStandaloneServerProvider", "OnMatchPhaseChanged");

	Params::MatchaStandaloneServerProvider_OnMatchPhaseChanged Parms{};

	Parms.MatchPhase = MatchPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaTeamUIData.OnPlayerRevealedIndicesChanged
// (Final, Native, Protected)

void UMatchaTeamUIData::OnPlayerRevealedIndicesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaTeamUIData", "OnPlayerRevealedIndicesChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaTeamUIData.OnTeamMemberCharacterClassChanged
// (Final, Native, Protected)

void UMatchaTeamUIData::OnTeamMemberCharacterClassChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaTeamUIData", "OnTeamMemberCharacterClassChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaTrapRenderer.OnTrapEntityUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AMatchaTrapEntity*                TrapEntity                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleported                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatchaTrapRenderer::OnTrapEntityUpdated(const class AMatchaTrapEntity* TrapEntity, float DeltaSeconds, bool bTeleported)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchaTrapRenderer", "OnTrapEntityUpdated");

	Params::MatchaTrapRenderer_OnTrapEntityUpdated Parms{};

	Parms.TrapEntity = TrapEntity;
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.bTeleported = bTeleported;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Matcha.MatchaUIStatics.FromStringTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             StringTableId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutText                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchaUIStatics::FromStringTable(class FName StringTableId, const class FString& Key, class FText* OutText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaUIStatics", "FromStringTable");

	Params::MatchaUIStatics_FromStringTable Parms{};

	Parms.StringTableId = StringTableId;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutText != nullptr)
		*OutText = std::move(Parms.OutText);

	return Parms.ReturnValue;
}


// Function Matcha.MatchaUIStatics.ShowErrorMessageFromResponse
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FErrorResponseV1                 Error                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchaUIStatics::ShowErrorMessageFromResponse(class UObject* WorldContextObject, const struct FErrorResponseV1& Error)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaUIStatics", "ShowErrorMessageFromResponse");

	Params::MatchaUIStatics_ShowErrorMessageFromResponse Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Error = std::move(Error);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Matcha.MatchaUIStatics.UTCHourToLocalWithSuffix
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   UtcHour                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatchaUIStatics::UTCHourToLocalWithSuffix(int32 UtcHour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaUIStatics", "UTCHourToLocalWithSuffix");

	Params::MatchaUIStatics_UTCHourToLocalWithSuffix Parms{};

	Parms.UtcHour = UtcHour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaUISubsystem.GetUIDataModel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaUIDataModelBase*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaUIDataModelBase* UMatchaUISubsystem::GetUIDataModel(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaUISubsystem", "GetUIDataModel");

	Params::MatchaUISubsystem_GetUIDataModel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Matcha.MatchaUISubsystem.GetUISubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMatchaUISubsystem*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMatchaUISubsystem* UMatchaUISubsystem::GetUISubsystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchaUISubsystem", "GetUISubsystem");

	Params::MatchaUISubsystem_GetUISubsystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

