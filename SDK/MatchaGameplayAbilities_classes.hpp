#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MatchaGameplayAbilities

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_classes.hpp"
#include "MatchaGameplayAbilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class MatchaGameplayAbilities.MatchaGameplayEffect
// 0x02F8 (0x0320 - 0x0028)
class UMatchaGameplayEffect : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EMatchaGameplayEffectDurationType             DurationPolicy;                                    // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchaGameplayEffectModifierMagnitude DurationMagnitude;                                 // 0x0038(0x01E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMatchaScalableFloat                   Period;                                            // 0x0218(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bExecutePeriodicEffectOnApplication;               // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaGameplayEffectPeriodInhibitionRemovedPolicy PeriodicInhibitionPolicy;                          // 0x0241(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_242[0x6];                                      // 0x0242(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchaGameplayModifierInfo>    Modifiers;                                         // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMatchaGameplayEffectExecutionDefinition> Executions;                                        // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UMatchaGameplayEffect>> OverflowEffects;                                   // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bDenyOverflowApplication;                          // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearStackOnOverflow;                             // 0x0279(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UMatchaGameplayEffect>> PrematureExpirationEffectClasses;                  // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UMatchaGameplayEffect>> RoutineExpirationEffectClasses;                    // 0x0290(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EMatchaGameplayEffectStackingType             StackingType;                                      // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackLimitCount;                                   // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaGameplayEffectStackingDurationPolicy   StackDurationRefreshPolicy;                        // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaGameplayEffectStackingPeriodPolicy     StackPeriodResetPolicy;                            // 0x02A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaGameplayEffectStackingExpirationPolicy StackExpirationPolicy;                             // 0x02AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB[0x65];                                     // 0x02AB(0x0065)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMatchaGameplayEffectComponent*> GEComponents;                                      // 0x0310(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffect">();
	}
	static class UMatchaGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEffect>();
	}
};
static_assert(alignof(UMatchaGameplayEffect) == 0x000008, "Wrong alignment on UMatchaGameplayEffect");
static_assert(sizeof(UMatchaGameplayEffect) == 0x000320, "Wrong size on UMatchaGameplayEffect");
static_assert(offsetof(UMatchaGameplayEffect, DurationPolicy) == 0x000030, "Member 'UMatchaGameplayEffect::DurationPolicy' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, DurationMagnitude) == 0x000038, "Member 'UMatchaGameplayEffect::DurationMagnitude' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, Period) == 0x000218, "Member 'UMatchaGameplayEffect::Period' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, bExecutePeriodicEffectOnApplication) == 0x000240, "Member 'UMatchaGameplayEffect::bExecutePeriodicEffectOnApplication' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, PeriodicInhibitionPolicy) == 0x000241, "Member 'UMatchaGameplayEffect::PeriodicInhibitionPolicy' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, Modifiers) == 0x000248, "Member 'UMatchaGameplayEffect::Modifiers' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, Executions) == 0x000258, "Member 'UMatchaGameplayEffect::Executions' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, OverflowEffects) == 0x000268, "Member 'UMatchaGameplayEffect::OverflowEffects' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, bDenyOverflowApplication) == 0x000278, "Member 'UMatchaGameplayEffect::bDenyOverflowApplication' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, bClearStackOnOverflow) == 0x000279, "Member 'UMatchaGameplayEffect::bClearStackOnOverflow' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, PrematureExpirationEffectClasses) == 0x000280, "Member 'UMatchaGameplayEffect::PrematureExpirationEffectClasses' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, RoutineExpirationEffectClasses) == 0x000290, "Member 'UMatchaGameplayEffect::RoutineExpirationEffectClasses' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, StackingType) == 0x0002A0, "Member 'UMatchaGameplayEffect::StackingType' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, StackLimitCount) == 0x0002A4, "Member 'UMatchaGameplayEffect::StackLimitCount' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, StackDurationRefreshPolicy) == 0x0002A8, "Member 'UMatchaGameplayEffect::StackDurationRefreshPolicy' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, StackPeriodResetPolicy) == 0x0002A9, "Member 'UMatchaGameplayEffect::StackPeriodResetPolicy' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, StackExpirationPolicy) == 0x0002AA, "Member 'UMatchaGameplayEffect::StackExpirationPolicy' has a wrong offset!");
static_assert(offsetof(UMatchaGameplayEffect, GEComponents) == 0x000310, "Member 'UMatchaGameplayEffect::GEComponents' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaGameplayEffectComponent
// 0x0000 (0x0028 - 0x0028)
class UMatchaGameplayEffectComponent : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectComponent">();
	}
	static class UMatchaGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaGameplayEffectComponent");
static_assert(sizeof(UMatchaGameplayEffectComponent) == 0x000028, "Wrong size on UMatchaGameplayEffectComponent");

// Class MatchaGameplayAbilities.MatchaAdditionalEffectsGameplayEffectComponent
// 0x0048 (0x0070 - 0x0028)
class UMatchaAdditionalEffectsGameplayEffectComponent final : public UMatchaGameplayEffectComponent
{
public:
	bool                                          bOnApplicationCopyDataFromOriginalSpec;            // 0x0028(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchaConditionalGameplayEffect> OnApplicationGameplayEffects;                      // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UMatchaGameplayEffect>> OnCompleteAlways;                                  // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UMatchaGameplayEffect>> OnCompleteNormal;                                  // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UMatchaGameplayEffect>> OnCompletePrematurely;                             // 0x0060(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAdditionalEffectsGameplayEffectComponent">();
	}
	static class UMatchaAdditionalEffectsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaAdditionalEffectsGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaAdditionalEffectsGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaAdditionalEffectsGameplayEffectComponent");
static_assert(sizeof(UMatchaAdditionalEffectsGameplayEffectComponent) == 0x000070, "Wrong size on UMatchaAdditionalEffectsGameplayEffectComponent");
static_assert(offsetof(UMatchaAdditionalEffectsGameplayEffectComponent, bOnApplicationCopyDataFromOriginalSpec) == 0x000028, "Member 'UMatchaAdditionalEffectsGameplayEffectComponent::bOnApplicationCopyDataFromOriginalSpec' has a wrong offset!");
static_assert(offsetof(UMatchaAdditionalEffectsGameplayEffectComponent, OnApplicationGameplayEffects) == 0x000030, "Member 'UMatchaAdditionalEffectsGameplayEffectComponent::OnApplicationGameplayEffects' has a wrong offset!");
static_assert(offsetof(UMatchaAdditionalEffectsGameplayEffectComponent, OnCompleteAlways) == 0x000040, "Member 'UMatchaAdditionalEffectsGameplayEffectComponent::OnCompleteAlways' has a wrong offset!");
static_assert(offsetof(UMatchaAdditionalEffectsGameplayEffectComponent, OnCompleteNormal) == 0x000050, "Member 'UMatchaAdditionalEffectsGameplayEffectComponent::OnCompleteNormal' has a wrong offset!");
static_assert(offsetof(UMatchaAdditionalEffectsGameplayEffectComponent, OnCompletePrematurely) == 0x000060, "Member 'UMatchaAdditionalEffectsGameplayEffectComponent::OnCompletePrematurely' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaAssetTagsGameplayEffectComponent
// 0x0060 (0x0088 - 0x0028)
class UMatchaAssetTagsGameplayEffectComponent final : public UMatchaGameplayEffectComponent
{
public:
	struct FMatchaInheritedTagContainer           InheritableAssetTags;                              // 0x0028(0x0060)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAssetTagsGameplayEffectComponent">();
	}
	static class UMatchaAssetTagsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaAssetTagsGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaAssetTagsGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaAssetTagsGameplayEffectComponent");
static_assert(sizeof(UMatchaAssetTagsGameplayEffectComponent) == 0x000088, "Wrong size on UMatchaAssetTagsGameplayEffectComponent");
static_assert(offsetof(UMatchaAssetTagsGameplayEffectComponent, InheritableAssetTags) == 0x000028, "Member 'UMatchaAssetTagsGameplayEffectComponent::InheritableAssetTags' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaChanceToApplyGameplayEffectComponent
// 0x0028 (0x0050 - 0x0028)
class UMatchaChanceToApplyGameplayEffectComponent final : public UMatchaGameplayEffectComponent
{
public:
	struct FMatchaScalableFloat                   ChanceToApplyToTarget;                             // 0x0028(0x0028)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaChanceToApplyGameplayEffectComponent">();
	}
	static class UMatchaChanceToApplyGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaChanceToApplyGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaChanceToApplyGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaChanceToApplyGameplayEffectComponent");
static_assert(sizeof(UMatchaChanceToApplyGameplayEffectComponent) == 0x000050, "Wrong size on UMatchaChanceToApplyGameplayEffectComponent");
static_assert(offsetof(UMatchaChanceToApplyGameplayEffectComponent, ChanceToApplyToTarget) == 0x000028, "Member 'UMatchaChanceToApplyGameplayEffectComponent::ChanceToApplyToTarget' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaCustomCanApplyGameplayEffectComponent
// 0x0010 (0x0038 - 0x0028)
class UMatchaCustomCanApplyGameplayEffectComponent final : public UMatchaGameplayEffectComponent
{
public:
	TArray<TSubclassOf<class UMatchaGameplayEffectCustomApplicationRequirement>> ApplicationRequirements;                           // 0x0028(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCustomCanApplyGameplayEffectComponent">();
	}
	static class UMatchaCustomCanApplyGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaCustomCanApplyGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaCustomCanApplyGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaCustomCanApplyGameplayEffectComponent");
static_assert(sizeof(UMatchaCustomCanApplyGameplayEffectComponent) == 0x000038, "Wrong size on UMatchaCustomCanApplyGameplayEffectComponent");
static_assert(offsetof(UMatchaCustomCanApplyGameplayEffectComponent, ApplicationRequirements) == 0x000028, "Member 'UMatchaCustomCanApplyGameplayEffectComponent::ApplicationRequirements' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaGameplayEffectOwner
// 0x0000 (0x0028 - 0x0028)
class IMatchaGameplayEffectOwner final : public IInterface
{
public:
	struct FMatchaActiveGameplayEffectHandle ApplyGameplayEffectClassToSelf(const TSubclassOf<class UMatchaGameplayEffect>& GameplayEffectClass, float Level, const struct FMatchaGameplayEffectContextHandle& EffectContext);
	struct FMatchaActiveGameplayEffectHandle ApplyGameplayEffectSpecHandleToSelf(const struct FMatchaGameplayEffectSpecHandle& GameplayEffectHandle);
	struct FMatchaActiveGameplayEffectHandle ApplyGameplayEffectSpecToSelf(const struct FMatchaGameplayEffectSpec& GameplayEffect);
	struct FMatchaActiveGameplayEffectHandle ApplyGameplayEffectToSelf(const class UMatchaGameplayEffect* GameplayEffect, float Level, const struct FMatchaGameplayEffectContextHandle& EffectContext);
	void RemoveGameplayEffectFromSelf(const struct FMatchaActiveGameplayEffectHandle& Handle, int32 Stacks);
	void RemoveGameplayEffectFromSelfByClass(const TSubclassOf<class UMatchaGameplayEffect>& GameplayEffectClass, int32 Level, int32 Stacks);

	int32 GetAggregatedStackCount(const struct FMatchaGameplayEffectQuery& Query) const;
	struct FMatchaGameplayEffectContextHandle MakeEffectContext() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectOwner">();
	}
	static class IMatchaGameplayEffectOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchaGameplayEffectOwner>();
	}
};
static_assert(alignof(IMatchaGameplayEffectOwner) == 0x000008, "Wrong alignment on IMatchaGameplayEffectOwner");
static_assert(sizeof(IMatchaGameplayEffectOwner) == 0x000028, "Wrong size on IMatchaGameplayEffectOwner");

// Class MatchaGameplayAbilities.MatchaAttributeSetProvider
// 0x0000 (0x0028 - 0x0028)
class IMatchaAttributeSetProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAttributeSetProvider">();
	}
	static class IMatchaAttributeSetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchaAttributeSetProvider>();
	}
};
static_assert(alignof(IMatchaAttributeSetProvider) == 0x000008, "Wrong alignment on IMatchaAttributeSetProvider");
static_assert(sizeof(IMatchaAttributeSetProvider) == 0x000028, "Wrong size on IMatchaAttributeSetProvider");

// Class MatchaGameplayAbilities.MatchaActiveGameplayEffectsContainerProvider
// 0x0000 (0x0028 - 0x0028)
class IMatchaActiveGameplayEffectsContainerProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaActiveGameplayEffectsContainerProvider">();
	}
	static class IMatchaActiveGameplayEffectsContainerProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchaActiveGameplayEffectsContainerProvider>();
	}
};
static_assert(alignof(IMatchaActiveGameplayEffectsContainerProvider) == 0x000008, "Wrong alignment on IMatchaActiveGameplayEffectsContainerProvider");
static_assert(sizeof(IMatchaActiveGameplayEffectsContainerProvider) == 0x000028, "Wrong size on IMatchaActiveGameplayEffectsContainerProvider");

// Class MatchaGameplayAbilities.MatchaGameplayEffectOwnerProvider
// 0x0000 (0x0028 - 0x0028)
class IMatchaGameplayEffectOwnerProvider final : public IInterface
{
public:
	TScriptInterface<class IMatchaGameplayEffectOwner> GetGameplayEffectOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectOwnerProvider">();
	}
	static class IMatchaGameplayEffectOwnerProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchaGameplayEffectOwnerProvider>();
	}
};
static_assert(alignof(IMatchaGameplayEffectOwnerProvider) == 0x000008, "Wrong alignment on IMatchaGameplayEffectOwnerProvider");
static_assert(sizeof(IMatchaGameplayEffectOwnerProvider) == 0x000028, "Wrong size on IMatchaGameplayEffectOwnerProvider");

// Class MatchaGameplayAbilities.MatchaGameplayEffectUIData
// 0x0000 (0x0028 - 0x0028)
class UMatchaGameplayEffectUIData : public UMatchaGameplayEffectComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectUIData">();
	}
	static class UMatchaGameplayEffectUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEffectUIData>();
	}
};
static_assert(alignof(UMatchaGameplayEffectUIData) == 0x000008, "Wrong alignment on UMatchaGameplayEffectUIData");
static_assert(sizeof(UMatchaGameplayEffectUIData) == 0x000028, "Wrong size on UMatchaGameplayEffectUIData");

// Class MatchaGameplayAbilities.MatchaGameplayEffectUIData_TextOnly
// 0x0010 (0x0038 - 0x0028)
class UMatchaGameplayEffectUIData_TextOnly final : public UMatchaGameplayEffectUIData
{
public:
	class FText                                   Description;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectUIData_TextOnly">();
	}
	static class UMatchaGameplayEffectUIData_TextOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEffectUIData_TextOnly>();
	}
};
static_assert(alignof(UMatchaGameplayEffectUIData_TextOnly) == 0x000008, "Wrong alignment on UMatchaGameplayEffectUIData_TextOnly");
static_assert(sizeof(UMatchaGameplayEffectUIData_TextOnly) == 0x000038, "Wrong size on UMatchaGameplayEffectUIData_TextOnly");
static_assert(offsetof(UMatchaGameplayEffectUIData_TextOnly, Description) == 0x000028, "Member 'UMatchaGameplayEffectUIData_TextOnly::Description' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaImmunityGameplayEffectComponent
// 0x0010 (0x0038 - 0x0028)
class UMatchaImmunityGameplayEffectComponent final : public UMatchaGameplayEffectComponent
{
public:
	TArray<struct FMatchaGameplayEffectQuery>     ImmunityQueries;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaImmunityGameplayEffectComponent">();
	}
	static class UMatchaImmunityGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaImmunityGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaImmunityGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaImmunityGameplayEffectComponent");
static_assert(sizeof(UMatchaImmunityGameplayEffectComponent) == 0x000038, "Wrong size on UMatchaImmunityGameplayEffectComponent");
static_assert(offsetof(UMatchaImmunityGameplayEffectComponent, ImmunityQueries) == 0x000028, "Member 'UMatchaImmunityGameplayEffectComponent::ImmunityQueries' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaRemoveOtherGameplayEffectComponent
// 0x0010 (0x0038 - 0x0028)
class UMatchaRemoveOtherGameplayEffectComponent final : public UMatchaGameplayEffectComponent
{
public:
	TArray<struct FMatchaGameplayEffectQuery>     RemoveGameplayEffectQueries;                       // 0x0028(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaRemoveOtherGameplayEffectComponent">();
	}
	static class UMatchaRemoveOtherGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaRemoveOtherGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaRemoveOtherGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaRemoveOtherGameplayEffectComponent");
static_assert(sizeof(UMatchaRemoveOtherGameplayEffectComponent) == 0x000038, "Wrong size on UMatchaRemoveOtherGameplayEffectComponent");
static_assert(offsetof(UMatchaRemoveOtherGameplayEffectComponent, RemoveGameplayEffectQueries) == 0x000028, "Member 'UMatchaRemoveOtherGameplayEffectComponent::RemoveGameplayEffectQueries' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaTargetTagRequirementsGameplayEffectComponent
// 0x0198 (0x01C0 - 0x0028)
class UMatchaTargetTagRequirementsGameplayEffectComponent final : public UMatchaGameplayEffectComponent
{
public:
	struct FMatchaGameplayTagRequirements         ApplicationTagRequirements;                        // 0x0028(0x0088)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMatchaGameplayTagRequirements         OngoingTagRequirements;                            // 0x00B0(0x0088)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMatchaGameplayTagRequirements         RemovalTagRequirements;                            // 0x0138(0x0088)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaTargetTagRequirementsGameplayEffectComponent">();
	}
	static class UMatchaTargetTagRequirementsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaTargetTagRequirementsGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaTargetTagRequirementsGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaTargetTagRequirementsGameplayEffectComponent");
static_assert(sizeof(UMatchaTargetTagRequirementsGameplayEffectComponent) == 0x0001C0, "Wrong size on UMatchaTargetTagRequirementsGameplayEffectComponent");
static_assert(offsetof(UMatchaTargetTagRequirementsGameplayEffectComponent, ApplicationTagRequirements) == 0x000028, "Member 'UMatchaTargetTagRequirementsGameplayEffectComponent::ApplicationTagRequirements' has a wrong offset!");
static_assert(offsetof(UMatchaTargetTagRequirementsGameplayEffectComponent, OngoingTagRequirements) == 0x0000B0, "Member 'UMatchaTargetTagRequirementsGameplayEffectComponent::OngoingTagRequirements' has a wrong offset!");
static_assert(offsetof(UMatchaTargetTagRequirementsGameplayEffectComponent, RemovalTagRequirements) == 0x000138, "Member 'UMatchaTargetTagRequirementsGameplayEffectComponent::RemovalTagRequirements' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaTargetTagsGameplayEffectComponent
// 0x0060 (0x0088 - 0x0028)
class UMatchaTargetTagsGameplayEffectComponent final : public UMatchaGameplayEffectComponent
{
public:
	struct FMatchaInheritedTagContainer           InheritableGrantedTagsContainer;                   // 0x0028(0x0060)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaTargetTagsGameplayEffectComponent">();
	}
	static class UMatchaTargetTagsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaTargetTagsGameplayEffectComponent>();
	}
};
static_assert(alignof(UMatchaTargetTagsGameplayEffectComponent) == 0x000008, "Wrong alignment on UMatchaTargetTagsGameplayEffectComponent");
static_assert(sizeof(UMatchaTargetTagsGameplayEffectComponent) == 0x000088, "Wrong size on UMatchaTargetTagsGameplayEffectComponent");
static_assert(offsetof(UMatchaTargetTagsGameplayEffectComponent, InheritableGrantedTagsContainer) == 0x000028, "Member 'UMatchaTargetTagsGameplayEffectComponent::InheritableGrantedTagsContainer' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaAbilitySystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UMatchaAbilitySystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FMatchaGameplayEffectSpecHandle AddAssetTag(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& NewGameplayTag);
	static struct FMatchaGameplayEffectSpecHandle AddAssetTags(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTagContainer& NewGameplayTags);
	static struct FMatchaGameplayEffectSpecHandle AddGrantedTag(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& NewGameplayTag);
	static struct FMatchaGameplayEffectSpecHandle AddGrantedTags(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTagContainer& NewGameplayTags);
	static struct FMatchaGameplayEffectSpecHandle AssignSetByCallerMagnitude(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, class FName DataName, float Magnitude);
	static struct FMatchaGameplayEffectSpecHandle AssignTagSetByCallerMagnitude(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& DataTag, float Magnitude);
	static struct FMatchaGameplayEffectSpecHandle CloneSpecHandle(class AActor* InNewInstigator, class AActor* InEffectCauser, const struct FMatchaGameplayEffectSpecHandle& GameplayEffectSpecHandle_Clone);
	static void EffectContextAddHitResult(const struct FMatchaGameplayEffectContextHandle& EffectContext, const struct FHitResult& HitResult, bool bReset);
	static class AActor* EffectContextGetEffectCauser(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static struct FHitResult EffectContextGetHitResult(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static class AActor* EffectContextGetInstigatorActor(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static struct FVector EffectContextGetOrigin(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static class AActor* EffectContextGetOriginalInstigatorActor(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static class UObject* EffectContextGetSourceObject(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static bool EffectContextHasHitResult(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static bool EffectContextIsInstigatorLocallyControlled(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static bool EffectContextIsValid(const struct FMatchaGameplayEffectContextHandle& EffectContext);
	static void EffectContextSetOrigin(const struct FMatchaGameplayEffectContextHandle& EffectContext, const struct FVector& Origin);
	static bool EqualEqual_ActiveGameplayEffectHandle(const struct FMatchaActiveGameplayEffectHandle& A, const struct FMatchaActiveGameplayEffectHandle& B);
	static bool EqualEqual_GameplayAttributeGameplayAttribute(const struct FMatchaGameplayAttribute& AttributeA, const struct FMatchaGameplayAttribute& AttributeB);
	static float EvaluateAttributeValueWithTags(class AActor* Actor, const struct FMatchaGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags, bool* bSuccess);
	static float EvaluateAttributeValueWithTagsAndBase(class AActor* Actor, const struct FMatchaGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags, float BaseValue, bool* bSuccess);
	static class FString GetActiveGameplayEffectDebugString(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectExpectedEndTime(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectRemainingDuration(class UObject* WorldContextObject, const struct FMatchaActiveGameplayEffectHandle& ActiveHandle);
	static int32 GetActiveGameplayEffectStackCount(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle);
	static int32 GetActiveGameplayEffectStackLimitCount(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectStartTime(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectTotalDuration(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle);
	static class FString GetDebugStringFromGameplayAttribute(const struct FMatchaGameplayAttribute& Attribute);
	static struct FMatchaGameplayEffectContextHandle GetEffectContext(const struct FMatchaGameplayEffectSpecHandle& SpecHandle);
	static float GetFloatAttribute(const class AActor* Actor, const struct FMatchaGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute);
	static float GetFloatAttributeBase(const class AActor* Actor, const struct FMatchaGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute);
	static const class UMatchaGameplayEffect* GetGameplayEffectFromActiveEffectHandle(const struct FMatchaActiveGameplayEffectHandle& ActiveHandle);
	static const class UMatchaGameplayEffectUIData* GetGameplayEffectUIData(TSubclassOf<class UMatchaGameplayEffect> EffectClass, TSubclassOf<class UMatchaGameplayEffectUIData> DataType);
	static float GetModifiedAttributeMagnitude(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, const struct FMatchaGameplayAttribute& Attribute);
	static bool IsValid(const struct FMatchaGameplayAttribute& Attribute);
	static struct FMatchaGameplayEffectSpecHandle MakeSpecHandle(class UMatchaGameplayEffect* InGameplayEffect, class AActor* InInstigator, class AActor* InEffectCauser, float InLevel);
	static struct FMatchaGameplayEffectSpecHandle MakeSpecHandle_EffectCDO(TSubclassOf<class UMatchaGameplayEffect> InGameplayEffectClass, class AActor* InInstigator, class AActor* InEffectCauser, float InLevel);
	static bool NotEqual_ActiveGameplayEffectHandle(const struct FMatchaActiveGameplayEffectHandle& A, const struct FMatchaActiveGameplayEffectHandle& B);
	static bool NotEqual_GameplayAttributeGameplayAttribute(const struct FMatchaGameplayAttribute& AttributeA, const struct FMatchaGameplayAttribute& AttributeB);
	static struct FMatchaGameplayEffectSpecHandle SetDuration(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, float Duration);
	static struct FMatchaGameplayEffectSpecHandle SetStackCount(const struct FMatchaGameplayEffectSpecHandle& SpecHandle, int32 StackCount);
	static struct FMatchaGameplayEffectSpecHandle SetStackCountToMax(const struct FMatchaGameplayEffectSpecHandle& SpecHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAbilitySystemBlueprintLibrary">();
	}
	static class UMatchaAbilitySystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaAbilitySystemBlueprintLibrary>();
	}
};
static_assert(alignof(UMatchaAbilitySystemBlueprintLibrary) == 0x000008, "Wrong alignment on UMatchaAbilitySystemBlueprintLibrary");
static_assert(sizeof(UMatchaAbilitySystemBlueprintLibrary) == 0x000028, "Wrong size on UMatchaAbilitySystemBlueprintLibrary");

// Class MatchaGameplayAbilities.MatchaAbilitySystemGlobals
// 0x0218 (0x0240 - 0x0028)
class UMatchaAbilitySystemGlobals : public UObject
{
public:
	struct FSoftClassPath                         AbilitySystemGlobalsClassName;                     // 0x0028(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDebugTargetFromHud;                            // 0x0070(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActivateFailIsDeadTag;                             // 0x0074(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailIsDeadName;                            // 0x007C(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailCooldownTag;                           // 0x0084(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailCooldownName;                          // 0x008C(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailCostTag;                               // 0x0094(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailCostName;                              // 0x009C(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailTagsBlockedTag;                        // 0x00A4(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailTagsBlockedName;                       // 0x00AC(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailTagsMissingTag;                        // 0x00B4(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailTagsMissingName;                       // 0x00BC(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailNetworkingTag;                         // 0x00C4(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailNetworkingName;                        // 0x00CC(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimalReplicationTagCountBits;                    // 0x00D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowGameplayModEvaluationChannels;               // 0x00D8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMatchaGameplayModEvaluationChannel           DefaultGameplayModEvaluationChannel;               // 0x00D9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GameplayModEvaluationChannelAliases[0xA];          // 0x00DC(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        GlobalCurveTableName;                              // 0x0130(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            GlobalCurveTable;                                  // 0x0150(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalAttributeMetaDataTableName;                  // 0x0158(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GlobalAttributeMetaDataTable;                      // 0x0178(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalAttributeSetDefaultsTableName;               // 0x0180(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSoftObjectPath>                GlobalAttributeSetDefaultsTableNames;              // 0x01A0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class UCurveTable*>                    GlobalAttributeDefaultsTables;                     // 0x01B0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GameplayTagResponseTableName;                      // 0x01C0(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMatchaGameplayTagReponseTable*         GameplayTagResponseTable;                          // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x1];                                      // 0x01E8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          PredictTargetGameplayEffects;                      // 0x01E9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ReplicateActivationOwnedTags;                      // 0x01EA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EB[0x55];                                     // 0x01EB(0x0055)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAbilitySystemGlobals">();
	}
	static class UMatchaAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaAbilitySystemGlobals>();
	}
};
static_assert(alignof(UMatchaAbilitySystemGlobals) == 0x000008, "Wrong alignment on UMatchaAbilitySystemGlobals");
static_assert(sizeof(UMatchaAbilitySystemGlobals) == 0x000240, "Wrong size on UMatchaAbilitySystemGlobals");
static_assert(offsetof(UMatchaAbilitySystemGlobals, AbilitySystemGlobalsClassName) == 0x000028, "Member 'UMatchaAbilitySystemGlobals::AbilitySystemGlobalsClassName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, bUseDebugTargetFromHud) == 0x000070, "Member 'UMatchaAbilitySystemGlobals::bUseDebugTargetFromHud' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailIsDeadTag) == 0x000074, "Member 'UMatchaAbilitySystemGlobals::ActivateFailIsDeadTag' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailIsDeadName) == 0x00007C, "Member 'UMatchaAbilitySystemGlobals::ActivateFailIsDeadName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailCooldownTag) == 0x000084, "Member 'UMatchaAbilitySystemGlobals::ActivateFailCooldownTag' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailCooldownName) == 0x00008C, "Member 'UMatchaAbilitySystemGlobals::ActivateFailCooldownName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailCostTag) == 0x000094, "Member 'UMatchaAbilitySystemGlobals::ActivateFailCostTag' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailCostName) == 0x00009C, "Member 'UMatchaAbilitySystemGlobals::ActivateFailCostName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailTagsBlockedTag) == 0x0000A4, "Member 'UMatchaAbilitySystemGlobals::ActivateFailTagsBlockedTag' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailTagsBlockedName) == 0x0000AC, "Member 'UMatchaAbilitySystemGlobals::ActivateFailTagsBlockedName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailTagsMissingTag) == 0x0000B4, "Member 'UMatchaAbilitySystemGlobals::ActivateFailTagsMissingTag' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailTagsMissingName) == 0x0000BC, "Member 'UMatchaAbilitySystemGlobals::ActivateFailTagsMissingName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailNetworkingTag) == 0x0000C4, "Member 'UMatchaAbilitySystemGlobals::ActivateFailNetworkingTag' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ActivateFailNetworkingName) == 0x0000CC, "Member 'UMatchaAbilitySystemGlobals::ActivateFailNetworkingName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, MinimalReplicationTagCountBits) == 0x0000D4, "Member 'UMatchaAbilitySystemGlobals::MinimalReplicationTagCountBits' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, bAllowGameplayModEvaluationChannels) == 0x0000D8, "Member 'UMatchaAbilitySystemGlobals::bAllowGameplayModEvaluationChannels' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, DefaultGameplayModEvaluationChannel) == 0x0000D9, "Member 'UMatchaAbilitySystemGlobals::DefaultGameplayModEvaluationChannel' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GameplayModEvaluationChannelAliases) == 0x0000DC, "Member 'UMatchaAbilitySystemGlobals::GameplayModEvaluationChannelAliases' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GlobalCurveTableName) == 0x000130, "Member 'UMatchaAbilitySystemGlobals::GlobalCurveTableName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GlobalCurveTable) == 0x000150, "Member 'UMatchaAbilitySystemGlobals::GlobalCurveTable' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GlobalAttributeMetaDataTableName) == 0x000158, "Member 'UMatchaAbilitySystemGlobals::GlobalAttributeMetaDataTableName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GlobalAttributeMetaDataTable) == 0x000178, "Member 'UMatchaAbilitySystemGlobals::GlobalAttributeMetaDataTable' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GlobalAttributeSetDefaultsTableName) == 0x000180, "Member 'UMatchaAbilitySystemGlobals::GlobalAttributeSetDefaultsTableName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GlobalAttributeSetDefaultsTableNames) == 0x0001A0, "Member 'UMatchaAbilitySystemGlobals::GlobalAttributeSetDefaultsTableNames' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GlobalAttributeDefaultsTables) == 0x0001B0, "Member 'UMatchaAbilitySystemGlobals::GlobalAttributeDefaultsTables' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GameplayTagResponseTableName) == 0x0001C0, "Member 'UMatchaAbilitySystemGlobals::GameplayTagResponseTableName' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, GameplayTagResponseTable) == 0x0001E0, "Member 'UMatchaAbilitySystemGlobals::GameplayTagResponseTable' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, PredictTargetGameplayEffects) == 0x0001E9, "Member 'UMatchaAbilitySystemGlobals::PredictTargetGameplayEffects' has a wrong offset!");
static_assert(offsetof(UMatchaAbilitySystemGlobals, ReplicateActivationOwnedTags) == 0x0001EA, "Member 'UMatchaAbilitySystemGlobals::ReplicateActivationOwnedTags' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaGameplayEffectCalculation
// 0x0010 (0x0038 - 0x0028)
class UMatchaGameplayEffectCalculation : public UObject
{
public:
	TArray<struct FMatchaGameplayEffectAttributeCaptureDefinition> RelevantAttributesToCapture;                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectCalculation">();
	}
	static class UMatchaGameplayEffectCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEffectCalculation>();
	}
};
static_assert(alignof(UMatchaGameplayEffectCalculation) == 0x000008, "Wrong alignment on UMatchaGameplayEffectCalculation");
static_assert(sizeof(UMatchaGameplayEffectCalculation) == 0x000038, "Wrong size on UMatchaGameplayEffectCalculation");
static_assert(offsetof(UMatchaGameplayEffectCalculation, RelevantAttributesToCapture) == 0x000028, "Member 'UMatchaGameplayEffectCalculation::RelevantAttributesToCapture' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaGameplayEffectCustomApplicationRequirement
// 0x0000 (0x0028 - 0x0028)
class UMatchaGameplayEffectCustomApplicationRequirement final : public UObject
{
public:
	bool CanApplyGameplayEffect(const class UMatchaGameplayEffect* GameplayEffect, const struct FMatchaGameplayEffectSpec& Spec, const TScriptInterface<class IMatchaGameplayEffectOwner>& GameplayEffectOwner) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectCustomApplicationRequirement">();
	}
	static class UMatchaGameplayEffectCustomApplicationRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEffectCustomApplicationRequirement>();
	}
};
static_assert(alignof(UMatchaGameplayEffectCustomApplicationRequirement) == 0x000008, "Wrong alignment on UMatchaGameplayEffectCustomApplicationRequirement");
static_assert(sizeof(UMatchaGameplayEffectCustomApplicationRequirement) == 0x000028, "Wrong size on UMatchaGameplayEffectCustomApplicationRequirement");

// Class MatchaGameplayAbilities.MatchaGameplayEffectExecutionCalculation
// 0x0008 (0x0040 - 0x0038)
class UMatchaGameplayEffectExecutionCalculation final : public UMatchaGameplayEffectCalculation
{
public:
	bool                                          bRequiresPassedInTags;                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Execute(const struct FMatchaGameplayEffectCustomExecutionParameters& ExecutionParams, struct FMatchaGameplayEffectCustomExecutionOutput* OutExecutionOutput) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectExecutionCalculation">();
	}
	static class UMatchaGameplayEffectExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEffectExecutionCalculation>();
	}
};
static_assert(alignof(UMatchaGameplayEffectExecutionCalculation) == 0x000008, "Wrong alignment on UMatchaGameplayEffectExecutionCalculation");
static_assert(sizeof(UMatchaGameplayEffectExecutionCalculation) == 0x000040, "Wrong size on UMatchaGameplayEffectExecutionCalculation");
static_assert(offsetof(UMatchaGameplayEffectExecutionCalculation, bRequiresPassedInTags) == 0x000038, "Member 'UMatchaGameplayEffectExecutionCalculation::bRequiresPassedInTags' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaGameplayModMagnitudeCalculation
// 0x0008 (0x0040 - 0x0038)
class UMatchaGameplayModMagnitudeCalculation final : public UMatchaGameplayEffectCalculation
{
public:
	bool                                          bAllowNonNetAuthorityDependencyRegistration;       // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateBaseMagnitude(const struct FMatchaGameplayEffectSpec& Spec) const;
	float GetSetByCallerMagnitudeByName(const struct FMatchaGameplayEffectSpec& EffectSpec, const class FName& MagnitudeName) const;
	float GetSetByCallerMagnitudeByTag(const struct FMatchaGameplayEffectSpec& EffectSpec, const struct FGameplayTag& Tag) const;
	const struct FGameplayTagContainer GetSourceActorTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const;
	struct FGameplayTagContainer GetSourceAggregatedTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const;
	const struct FGameplayTagContainer GetSourceSpecTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const;
	const struct FGameplayTagContainer GetTargetActorTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const;
	struct FGameplayTagContainer GetTargetAggregatedTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const;
	const struct FGameplayTagContainer GetTargetSpecTags(const struct FMatchaGameplayEffectSpec& EffectSpec) const;
	float K2_GetCapturedAttributeMagnitude(const struct FMatchaGameplayEffectSpec& EffectSpec, const struct FMatchaGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayModMagnitudeCalculation">();
	}
	static class UMatchaGameplayModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayModMagnitudeCalculation>();
	}
};
static_assert(alignof(UMatchaGameplayModMagnitudeCalculation) == 0x000008, "Wrong alignment on UMatchaGameplayModMagnitudeCalculation");
static_assert(sizeof(UMatchaGameplayModMagnitudeCalculation) == 0x000040, "Wrong size on UMatchaGameplayModMagnitudeCalculation");
static_assert(offsetof(UMatchaGameplayModMagnitudeCalculation, bAllowNonNetAuthorityDependencyRegistration) == 0x000038, "Member 'UMatchaGameplayModMagnitudeCalculation::bAllowNonNetAuthorityDependencyRegistration' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaGameplayTagReponseTable
// 0x0200 (0x0230 - 0x0030)
class UMatchaGameplayTagReponseTable final : public UDataAsset
{
public:
	TArray<struct FMatchaGameplayTagResponseTableEntry> Entries;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x1F0];                                     // 0x0040(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TagResponseEvent(const struct FGameplayTag& Tag, int32 NewCount, TScriptInterface<class IMatchaGameplayEffectOwner> GameplayEffectOwner, int32 Idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayTagReponseTable">();
	}
	static class UMatchaGameplayTagReponseTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayTagReponseTable>();
	}
};
static_assert(alignof(UMatchaGameplayTagReponseTable) == 0x000008, "Wrong alignment on UMatchaGameplayTagReponseTable");
static_assert(sizeof(UMatchaGameplayTagReponseTable) == 0x000230, "Wrong size on UMatchaGameplayTagReponseTable");
static_assert(offsetof(UMatchaGameplayTagReponseTable, Entries) == 0x000030, "Member 'UMatchaGameplayTagReponseTable::Entries' has a wrong offset!");

// Class MatchaGameplayAbilities.MatchaTickableAttributeSetInterface
// 0x0000 (0x0028 - 0x0028)
class IMatchaTickableAttributeSetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaTickableAttributeSetInterface">();
	}
	static class IMatchaTickableAttributeSetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchaTickableAttributeSetInterface>();
	}
};
static_assert(alignof(IMatchaTickableAttributeSetInterface) == 0x000008, "Wrong alignment on IMatchaTickableAttributeSetInterface");
static_assert(sizeof(IMatchaTickableAttributeSetInterface) == 0x000028, "Wrong size on IMatchaTickableAttributeSetInterface");

}

