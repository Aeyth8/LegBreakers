#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Matcha

#include "Basic.hpp"

#include "Matcha_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "OdyServices_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SnapNet_structs.hpp"
#include "SnapNet_classes.hpp"
#include "OdyUI_structs.hpp"
#include "OdyUI_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "MatchaGameplayAbilities_structs.hpp"
#include "MatchaGameplayAbilities_classes.hpp"
#include "OdyGameZones_classes.hpp"
#include "OdyInput_structs.hpp"


namespace SDK
{

// Class Matcha.LegacyMatchaServicesConfiguration
// 0x0058 (0x0090 - 0x0038)
class ULegacyMatchaServicesConfiguration final : public UDeveloperSettings
{
public:
	int32                                         MaxReconnectAttempts;                              // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WebSocketUrlClient;                                // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WebSocketUrlServer;                                // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WebSocketUrlServices;                              // 0x0060(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VersionOverride;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServicesBaseUrl;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetWebSocketUrlClient();
	class FString GetWebSocketUrlServer();
	class FString GetWebSocketUrlServices();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegacyMatchaServicesConfiguration">();
	}
	static class ULegacyMatchaServicesConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegacyMatchaServicesConfiguration>();
	}
};
static_assert(alignof(ULegacyMatchaServicesConfiguration) == 0x000008, "Wrong alignment on ULegacyMatchaServicesConfiguration");
static_assert(sizeof(ULegacyMatchaServicesConfiguration) == 0x000090, "Wrong size on ULegacyMatchaServicesConfiguration");
static_assert(offsetof(ULegacyMatchaServicesConfiguration, MaxReconnectAttempts) == 0x000038, "Member 'ULegacyMatchaServicesConfiguration::MaxReconnectAttempts' has a wrong offset!");
static_assert(offsetof(ULegacyMatchaServicesConfiguration, WebSocketUrlClient) == 0x000040, "Member 'ULegacyMatchaServicesConfiguration::WebSocketUrlClient' has a wrong offset!");
static_assert(offsetof(ULegacyMatchaServicesConfiguration, WebSocketUrlServer) == 0x000050, "Member 'ULegacyMatchaServicesConfiguration::WebSocketUrlServer' has a wrong offset!");
static_assert(offsetof(ULegacyMatchaServicesConfiguration, WebSocketUrlServices) == 0x000060, "Member 'ULegacyMatchaServicesConfiguration::WebSocketUrlServices' has a wrong offset!");
static_assert(offsetof(ULegacyMatchaServicesConfiguration, VersionOverride) == 0x000070, "Member 'ULegacyMatchaServicesConfiguration::VersionOverride' has a wrong offset!");
static_assert(offsetof(ULegacyMatchaServicesConfiguration, ServicesBaseUrl) == 0x000080, "Member 'ULegacyMatchaServicesConfiguration::ServicesBaseUrl' has a wrong offset!");

// Class Matcha.LegacyMatchaQueueServices
// 0x01A8 (0x0488 - 0x02E0)
class ULegacyMatchaQueueServices final : public UOdyServicesModelBase
{
public:
	uint8                                         Pad_2E0[0x1A8];                                    // 0x02E0(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULegacyMatchaQueueServices* Get(const class UObject* WorldContextObject);
	static const class ULegacyMatchaServicesConfiguration* GetServicesConfiguration();

	void AcceptInvite(const class FString& Target);
	void CancelInvite(const class FString& Target);
	void JoinDropIn();
	void JoinQueue();
	void LeaveQueue();
	void LeaveTeam();
	void RejectInvite(const class FString& Target);
	void SendInvite(const class FString& Target);
	void SendPing();
	void SetConnectedPlayerIds(const TArray<class FName>& PlayerIds);
	void SetIdentification(const class FString& Name_0, const class FString& URL, bool IsMatchServer);
	void SetMatchPhase(EMatchaMatchPhase MatchPhase);
	void SetName(const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegacyMatchaQueueServices">();
	}
	static class ULegacyMatchaQueueServices* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegacyMatchaQueueServices>();
	}
};
static_assert(alignof(ULegacyMatchaQueueServices) == 0x000008, "Wrong alignment on ULegacyMatchaQueueServices");
static_assert(sizeof(ULegacyMatchaQueueServices) == 0x000488, "Wrong size on ULegacyMatchaQueueServices");

// Class Matcha.MatchaAICharacterAnimInstance
// 0x0020 (0x0390 - 0x0370)
class UMatchaAICharacterAnimInstance : public UAnimInstance
{
public:
	float                                         BlendTimeDefault;                                  // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationStrengthThresholdForWalkRun;           // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDirectionsBlendTime;                           // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleWalkRunBlendTime;                              // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFalling;                                          // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizontalSpeed;                                   // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalSpeed;                                     // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationStrength;                              // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationLocalDirection;                        // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceleratingEnoughForWalkRun;                     // 0x038C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPositiveVerticalSpeed;                         // 0x038D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFacingScreenLeft;                               // 0x038E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38F[0x1];                                      // 0x038F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAICharacterAnimInstance">();
	}
	static class UMatchaAICharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaAICharacterAnimInstance>();
	}
};
static_assert(alignof(UMatchaAICharacterAnimInstance) == 0x000010, "Wrong alignment on UMatchaAICharacterAnimInstance");
static_assert(sizeof(UMatchaAICharacterAnimInstance) == 0x000390, "Wrong size on UMatchaAICharacterAnimInstance");
static_assert(offsetof(UMatchaAICharacterAnimInstance, BlendTimeDefault) == 0x000368, "Member 'UMatchaAICharacterAnimInstance::BlendTimeDefault' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, AccelerationStrengthThresholdForWalkRun) == 0x00036C, "Member 'UMatchaAICharacterAnimInstance::AccelerationStrengthThresholdForWalkRun' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, FallDirectionsBlendTime) == 0x000370, "Member 'UMatchaAICharacterAnimInstance::FallDirectionsBlendTime' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, IdleWalkRunBlendTime) == 0x000374, "Member 'UMatchaAICharacterAnimInstance::IdleWalkRunBlendTime' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, bFalling) == 0x000378, "Member 'UMatchaAICharacterAnimInstance::bFalling' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, HorizontalSpeed) == 0x00037C, "Member 'UMatchaAICharacterAnimInstance::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, VerticalSpeed) == 0x000380, "Member 'UMatchaAICharacterAnimInstance::VerticalSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, AccelerationStrength) == 0x000384, "Member 'UMatchaAICharacterAnimInstance::AccelerationStrength' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, AccelerationLocalDirection) == 0x000388, "Member 'UMatchaAICharacterAnimInstance::AccelerationLocalDirection' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, bAcceleratingEnoughForWalkRun) == 0x00038C, "Member 'UMatchaAICharacterAnimInstance::bAcceleratingEnoughForWalkRun' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, bHasPositiveVerticalSpeed) == 0x00038D, "Member 'UMatchaAICharacterAnimInstance::bHasPositiveVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaAICharacterAnimInstance, bIsFacingScreenLeft) == 0x00038E, "Member 'UMatchaAICharacterAnimInstance::bIsFacingScreenLeft' has a wrong offset!");

// Class Matcha.MatchaAICharacterEntity
// 0x0640 (0x0D30 - 0x06F0)
class AMatchaAICharacterEntity : public ASnapNetCharacterEntity
{
public:
	uint8                                         Pad_6F0[0x18];                                     // 0x06F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaLootComponent*                   LootComponent;                                     // 0x0708(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAIAnimationInfo>               Animations;                                        // 0x0718(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  MaxDamage;                                         // 0x0728(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x0768(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReceivingHitFreezeMultiplier;                      // 0x076C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFallSpeed;                                      // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkSpeed;                                         // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CoarseHitExtents;                                  // 0x0778(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableBehaviorTreeOnSpawn;                        // 0x0788(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_789[0x3];                                      // 0x0789(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ChannelToBroadcastDeathEventTo;                    // 0x078C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchaGameplayEvent                   DeathEventToBroadcast;                             // 0x0794(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  AggroDistance;                                     // 0x07A8(0x0038)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowRepeatAbilities;                             // 0x07E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E1[0x3];                                      // 0x07E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitFreezeDeltaTimeMultiplier;                      // 0x07E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalSpeed;                                   // 0x07E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalSpeed;                                     // 0x07EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationStrength;                              // 0x07F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationLocalDirection;                        // 0x07F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPoseDirty;                                        // 0x07F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F9[0x7];                                      // 0x07F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyVector                 Scale;                                             // 0x0800(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FName                                   DefaultHitFXId;                                    // 0x0880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCombinedFXInfo                        DeathFX;                                           // 0x0888(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  Damage;                                            // 0x0910(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FFacingInfo                            FacingInfo;                                        // 0x0950(0x0078)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FHitFreezeStateInfo                    HitFreezeStateInfo;                                // 0x09C8(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FAIPlayingMontageInfo                  AIPlayingMontageInfo;                              // 0x0A30(0x0110)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FAIAppliedRootMotionInfo               CurrentAppliedRootMotionInfo;                      // 0x0B40(0x00E0)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsDead;                                           // 0x0C20(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FMatchaCharacterFlags                  AnimationAppliedFlags;                             // 0x0C38(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUnprocessedHitBoxData>         CurrentFrameOutgoingHits;                          // 0x0C50(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAppliedHitInfo>                RecentlyAppliedHits;                               // 0x0C60(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector                                SpawnLocation;                                     // 0x0C70(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               SpawnRotation;                                     // 0x0C88(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsInvulnerable;                                   // 0x0CA0(0x0018)(Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0CB8(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentTeamNumber;                                 // 0x0CC8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CCC[0x4];                                      // 0x0CCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOdyUIFloatBinding                     DamageBinding;                                     // 0x0CD0(0x0020)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FOdyUITextBinding                      PlayerNameBinding;                                 // 0x0CF0(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D18[0x8];                                      // 0x0D18(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchaProcessedHitInfo>        CurrentFrameIncomingHits;                          // 0x0D20(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class AMatchaAICharacterEntity* Get(int32 PlayerIndex, const class UObject* WorldContextObject);
	static class AMatchaAICharacterEntity* GetFromSimulation(int32 PlayerIndex, const class USnapNetSimulation* SnapNetSimulation);

	bool CharacterTeleport(const struct FVector& DestinationLocation, const struct FRotator& DestinationRotation, bool bIsATest, bool bNoCheck);
	void PlayAnimationAtIndex(const int32 Index_0);
	void ResetDamage();
	void SetInvulnerable(bool bShouldBeInvulnerable);

	int32 GetAggroDistance() const;
	struct FVector GetSpawnLocation() const;
	void ToggleBehaviorTree(const bool bShouldEnable) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAICharacterEntity">();
	}
	static class AMatchaAICharacterEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaAICharacterEntity>();
	}
};
static_assert(alignof(AMatchaAICharacterEntity) == 0x000010, "Wrong alignment on AMatchaAICharacterEntity");
static_assert(sizeof(AMatchaAICharacterEntity) == 0x000D30, "Wrong size on AMatchaAICharacterEntity");
static_assert(offsetof(AMatchaAICharacterEntity, LootComponent) == 0x000708, "Member 'AMatchaAICharacterEntity::LootComponent' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, BehaviorTree) == 0x000710, "Member 'AMatchaAICharacterEntity::BehaviorTree' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, Animations) == 0x000718, "Member 'AMatchaAICharacterEntity::Animations' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, MaxDamage) == 0x000728, "Member 'AMatchaAICharacterEntity::MaxDamage' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, Weight) == 0x000768, "Member 'AMatchaAICharacterEntity::Weight' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, ReceivingHitFreezeMultiplier) == 0x00076C, "Member 'AMatchaAICharacterEntity::ReceivingHitFreezeMultiplier' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, MaxFallSpeed) == 0x000770, "Member 'AMatchaAICharacterEntity::MaxFallSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, WalkSpeed) == 0x000774, "Member 'AMatchaAICharacterEntity::WalkSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, CoarseHitExtents) == 0x000778, "Member 'AMatchaAICharacterEntity::CoarseHitExtents' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, bEnableBehaviorTreeOnSpawn) == 0x000788, "Member 'AMatchaAICharacterEntity::bEnableBehaviorTreeOnSpawn' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, ChannelToBroadcastDeathEventTo) == 0x00078C, "Member 'AMatchaAICharacterEntity::ChannelToBroadcastDeathEventTo' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, DeathEventToBroadcast) == 0x000794, "Member 'AMatchaAICharacterEntity::DeathEventToBroadcast' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, AggroDistance) == 0x0007A8, "Member 'AMatchaAICharacterEntity::AggroDistance' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, bAllowRepeatAbilities) == 0x0007E0, "Member 'AMatchaAICharacterEntity::bAllowRepeatAbilities' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, HitFreezeDeltaTimeMultiplier) == 0x0007E4, "Member 'AMatchaAICharacterEntity::HitFreezeDeltaTimeMultiplier' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, HorizontalSpeed) == 0x0007E8, "Member 'AMatchaAICharacterEntity::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, VerticalSpeed) == 0x0007EC, "Member 'AMatchaAICharacterEntity::VerticalSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, AccelerationStrength) == 0x0007F0, "Member 'AMatchaAICharacterEntity::AccelerationStrength' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, AccelerationLocalDirection) == 0x0007F4, "Member 'AMatchaAICharacterEntity::AccelerationLocalDirection' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, bPoseDirty) == 0x0007F8, "Member 'AMatchaAICharacterEntity::bPoseDirty' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, Scale) == 0x000800, "Member 'AMatchaAICharacterEntity::Scale' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, DefaultHitFXId) == 0x000880, "Member 'AMatchaAICharacterEntity::DefaultHitFXId' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, DeathFX) == 0x000888, "Member 'AMatchaAICharacterEntity::DeathFX' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, Damage) == 0x000910, "Member 'AMatchaAICharacterEntity::Damage' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, FacingInfo) == 0x000950, "Member 'AMatchaAICharacterEntity::FacingInfo' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, HitFreezeStateInfo) == 0x0009C8, "Member 'AMatchaAICharacterEntity::HitFreezeStateInfo' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, AIPlayingMontageInfo) == 0x000A30, "Member 'AMatchaAICharacterEntity::AIPlayingMontageInfo' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, CurrentAppliedRootMotionInfo) == 0x000B40, "Member 'AMatchaAICharacterEntity::CurrentAppliedRootMotionInfo' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, bIsDead) == 0x000C20, "Member 'AMatchaAICharacterEntity::bIsDead' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, AnimationAppliedFlags) == 0x000C38, "Member 'AMatchaAICharacterEntity::AnimationAppliedFlags' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, CurrentFrameOutgoingHits) == 0x000C50, "Member 'AMatchaAICharacterEntity::CurrentFrameOutgoingHits' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, RecentlyAppliedHits) == 0x000C60, "Member 'AMatchaAICharacterEntity::RecentlyAppliedHits' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, SpawnLocation) == 0x000C70, "Member 'AMatchaAICharacterEntity::SpawnLocation' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, SpawnRotation) == 0x000C88, "Member 'AMatchaAICharacterEntity::SpawnRotation' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, bIsInvulnerable) == 0x000CA0, "Member 'AMatchaAICharacterEntity::bIsInvulnerable' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, DisplayName) == 0x000CB8, "Member 'AMatchaAICharacterEntity::DisplayName' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, CurrentTeamNumber) == 0x000CC8, "Member 'AMatchaAICharacterEntity::CurrentTeamNumber' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, DamageBinding) == 0x000CD0, "Member 'AMatchaAICharacterEntity::DamageBinding' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, PlayerNameBinding) == 0x000CF0, "Member 'AMatchaAICharacterEntity::PlayerNameBinding' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterEntity, CurrentFrameIncomingHits) == 0x000D20, "Member 'AMatchaAICharacterEntity::CurrentFrameIncomingHits' has a wrong offset!");

// Class Matcha.MatchaSnapNetEntity
// 0x00E8 (0x0378 - 0x0290)
class AMatchaSnapNetEntity : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USnapNetEntityComponent*                EntityComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMatchaEntityRelevanceMode                    RelevanceMode;                                     // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoDestroysOnDisable;                            // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartAsEnabled;                                   // 0x02A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyInt32                  CreationTime;                                      // 0x02B0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEntityIndex            InstigatorEntityIndex;                             // 0x02E8(0x0068)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bEnabled;                                          // 0x0350(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         LifeTimeMilliSeconds;                              // 0x0368(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0xC];                                      // 0x036C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnabledChanged(bool bOldEnabled, bool bNewEnabled);
	void OnSpawnFinished();
	void SetEnabled(bool bShouldEnable);

	int32 GetCurrentEntityTimeInMilliseconds() const;
	int32 GetMillisecondsSinceCreation() const;
	class AActor* GetOwnerEntity() const;
	int32 GetOwnerEntityIndex() const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetEntity">();
	}
	static class AMatchaSnapNetEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetEntity>();
	}
};
static_assert(alignof(AMatchaSnapNetEntity) == 0x000008, "Wrong alignment on AMatchaSnapNetEntity");
static_assert(sizeof(AMatchaSnapNetEntity) == 0x000378, "Wrong size on AMatchaSnapNetEntity");
static_assert(offsetof(AMatchaSnapNetEntity, EntityComponent) == 0x000298, "Member 'AMatchaSnapNetEntity::EntityComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetEntity, RelevanceMode) == 0x0002A0, "Member 'AMatchaSnapNetEntity::RelevanceMode' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetEntity, Lifetime) == 0x0002A4, "Member 'AMatchaSnapNetEntity::Lifetime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetEntity, bAutoDestroysOnDisable) == 0x0002A8, "Member 'AMatchaSnapNetEntity::bAutoDestroysOnDisable' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetEntity, bStartAsEnabled) == 0x0002A9, "Member 'AMatchaSnapNetEntity::bStartAsEnabled' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetEntity, CreationTime) == 0x0002B0, "Member 'AMatchaSnapNetEntity::CreationTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetEntity, InstigatorEntityIndex) == 0x0002E8, "Member 'AMatchaSnapNetEntity::InstigatorEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetEntity, bEnabled) == 0x000350, "Member 'AMatchaSnapNetEntity::bEnabled' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetEntity, LifeTimeMilliSeconds) == 0x000368, "Member 'AMatchaSnapNetEntity::LifeTimeMilliSeconds' has a wrong offset!");

// Class Matcha.MatchaSnapNetGameEntity
// 0x0370 (0x06E8 - 0x0378)
class AMatchaSnapNetGameEntity : public AMatchaSnapNetEntity
{
public:
	struct FSnapNetPropertyString                 ServerVersion;                                     // 0x0378(0x0030)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  ServerFrameTime;                                   // 0x03A8(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                IsMatchServer;                                     // 0x03E8(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  MatchTeamCount;                                    // 0x0400(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  TotalPlayerCount;                                  // 0x0438(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  AlivePlayerCount;                                  // 0x0470(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x28];                                     // 0x04A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GameplayEventListenChannel;                        // 0x04D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             ActorClassesToCache;                               // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEnum                   CurrentMatchPhase;                                 // 0x04E8(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  MatchPhaseRemainingTime;                           // 0x0530(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  LastWinningTeamNumber;                             // 0x0568(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMatchaTeamNetworkState>        Teams;                                             // 0x05A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FMatchaGameplayEventNotificationData   MatchaGameplayEventNotificationData;               // 0x05B0(0x00C8)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FMatchaKillFeedNetworkState            KillFeedNetworkState;                              // 0x0678(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AActor>, struct FWeakActorArray> CachedActorsByClass;                               // 0x0688(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D8[0x10];                                     // 0x06D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AMatchaSnapNetGameEntity* Get(const class UObject* WorldContextObject);

	void OnAnyActorDestroyed(class AActor* DestroyedActor);
	void OnAnyActorSpawned(class AActor* SpawnedActor);

	EMatchaMatchPhase GetCurrentMatchPhase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetGameEntity">();
	}
	static class AMatchaSnapNetGameEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetGameEntity>();
	}
};
static_assert(alignof(AMatchaSnapNetGameEntity) == 0x000008, "Wrong alignment on AMatchaSnapNetGameEntity");
static_assert(sizeof(AMatchaSnapNetGameEntity) == 0x0006E8, "Wrong size on AMatchaSnapNetGameEntity");
static_assert(offsetof(AMatchaSnapNetGameEntity, ServerVersion) == 0x000378, "Member 'AMatchaSnapNetGameEntity::ServerVersion' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, ServerFrameTime) == 0x0003A8, "Member 'AMatchaSnapNetGameEntity::ServerFrameTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, IsMatchServer) == 0x0003E8, "Member 'AMatchaSnapNetGameEntity::IsMatchServer' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, MatchTeamCount) == 0x000400, "Member 'AMatchaSnapNetGameEntity::MatchTeamCount' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, TotalPlayerCount) == 0x000438, "Member 'AMatchaSnapNetGameEntity::TotalPlayerCount' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, AlivePlayerCount) == 0x000470, "Member 'AMatchaSnapNetGameEntity::AlivePlayerCount' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, GameplayEventListenChannel) == 0x0004D0, "Member 'AMatchaSnapNetGameEntity::GameplayEventListenChannel' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, ActorClassesToCache) == 0x0004D8, "Member 'AMatchaSnapNetGameEntity::ActorClassesToCache' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, CurrentMatchPhase) == 0x0004E8, "Member 'AMatchaSnapNetGameEntity::CurrentMatchPhase' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, MatchPhaseRemainingTime) == 0x000530, "Member 'AMatchaSnapNetGameEntity::MatchPhaseRemainingTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, LastWinningTeamNumber) == 0x000568, "Member 'AMatchaSnapNetGameEntity::LastWinningTeamNumber' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, Teams) == 0x0005A0, "Member 'AMatchaSnapNetGameEntity::Teams' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, MatchaGameplayEventNotificationData) == 0x0005B0, "Member 'AMatchaSnapNetGameEntity::MatchaGameplayEventNotificationData' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, KillFeedNetworkState) == 0x000678, "Member 'AMatchaSnapNetGameEntity::KillFeedNetworkState' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetGameEntity, CachedActorsByClass) == 0x000688, "Member 'AMatchaSnapNetGameEntity::CachedActorsByClass' has a wrong offset!");

// Class Matcha.MatchaAICharacterRenderer
// 0x0080 (0x0398 - 0x0318)
class AMatchaAICharacterRenderer final : public APawn
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOdyUIFloatBinding                     CurrentDamage;                                     // 0x0320(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     MaxDamage;                                         // 0x0340(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	class USnapNetEntityRendererComponent*        EntityRendererComponent;                           // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootSceneComponent;                                // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFalling;                                        // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAlive;                                          // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37A[0x6];                                      // 0x037A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CurrentDisplayName;                                // 0x0380(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentTeamNumber;                                 // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAICharacterRenderer">();
	}
	static class AMatchaAICharacterRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaAICharacterRenderer>();
	}
};
static_assert(alignof(AMatchaAICharacterRenderer) == 0x000008, "Wrong alignment on AMatchaAICharacterRenderer");
static_assert(sizeof(AMatchaAICharacterRenderer) == 0x000398, "Wrong size on AMatchaAICharacterRenderer");
static_assert(offsetof(AMatchaAICharacterRenderer, CurrentDamage) == 0x000320, "Member 'AMatchaAICharacterRenderer::CurrentDamage' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterRenderer, MaxDamage) == 0x000340, "Member 'AMatchaAICharacterRenderer::MaxDamage' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterRenderer, EntityRendererComponent) == 0x000360, "Member 'AMatchaAICharacterRenderer::EntityRendererComponent' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterRenderer, MeshComponent) == 0x000368, "Member 'AMatchaAICharacterRenderer::MeshComponent' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterRenderer, RootSceneComponent) == 0x000370, "Member 'AMatchaAICharacterRenderer::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterRenderer, bIsFalling) == 0x000378, "Member 'AMatchaAICharacterRenderer::bIsFalling' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterRenderer, bIsAlive) == 0x000379, "Member 'AMatchaAICharacterRenderer::bIsAlive' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterRenderer, CurrentDisplayName) == 0x000380, "Member 'AMatchaAICharacterRenderer::CurrentDisplayName' has a wrong offset!");
static_assert(offsetof(AMatchaAICharacterRenderer, CurrentTeamNumber) == 0x000390, "Member 'AMatchaAICharacterRenderer::CurrentTeamNumber' has a wrong offset!");

// Class Matcha.MatchaAIController
// 0x0000 (0x03C0 - 0x03C0)
class AMatchaAIController final : public ASnapNetAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAIController">();
	}
	static class AMatchaAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaAIController>();
	}
};
static_assert(alignof(AMatchaAIController) == 0x000008, "Wrong alignment on AMatchaAIController");
static_assert(sizeof(AMatchaAIController) == 0x0003C0, "Wrong size on AMatchaAIController");

// Class Matcha.MatchaAnalyticsManager
// 0x0068 (0x0090 - 0x0028)
class UMatchaAnalyticsManager final : public UObject
{
public:
	TWeakObjectPtr<class AMatchaSnapNetGameEntity> GameEntity;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, TWeakObjectPtr<class AMatchaSnapNetCharacterEntity>> PlayerCharacters;                                  // 0x0030(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterMontageStarted(class AMatchaCharacterBase* CharacterEntity, float MontageDuration, EMatchaCharacterMontageType MontageType, EMatchaCharacterMontageType PreviousMontageType);
	void OnMatchPhaseChanged(EMatchaMatchPhase MatchPhase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAnalyticsManager">();
	}
	static class UMatchaAnalyticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaAnalyticsManager>();
	}
};
static_assert(alignof(UMatchaAnalyticsManager) == 0x000008, "Wrong alignment on UMatchaAnalyticsManager");
static_assert(sizeof(UMatchaAnalyticsManager) == 0x000090, "Wrong size on UMatchaAnalyticsManager");
static_assert(offsetof(UMatchaAnalyticsManager, GameEntity) == 0x000028, "Member 'UMatchaAnalyticsManager::GameEntity' has a wrong offset!");
static_assert(offsetof(UMatchaAnalyticsManager, PlayerCharacters) == 0x000030, "Member 'UMatchaAnalyticsManager::PlayerCharacters' has a wrong offset!");

// Class Matcha.MatchaAssetSettings
// 0x0080 (0x00B8 - 0x0038)
class UMatchaAssetSettings final : public UDeveloperSettings
{
public:
	TMap<TSoftClassPtr<class UClass>, struct FPathList> DataAssetsToPin;                                   // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  OfflineMap;                                        // 0x0088(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USnapNetServerScript>       OfflineServerScriptClass;                          // 0x00B0(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAssetSettings">();
	}
	static class UMatchaAssetSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaAssetSettings>();
	}
};
static_assert(alignof(UMatchaAssetSettings) == 0x000008, "Wrong alignment on UMatchaAssetSettings");
static_assert(sizeof(UMatchaAssetSettings) == 0x0000B8, "Wrong size on UMatchaAssetSettings");
static_assert(offsetof(UMatchaAssetSettings, DataAssetsToPin) == 0x000038, "Member 'UMatchaAssetSettings::DataAssetsToPin' has a wrong offset!");
static_assert(offsetof(UMatchaAssetSettings, OfflineMap) == 0x000088, "Member 'UMatchaAssetSettings::OfflineMap' has a wrong offset!");
static_assert(offsetof(UMatchaAssetSettings, OfflineServerScriptClass) == 0x0000B0, "Member 'UMatchaAssetSettings::OfflineServerScriptClass' has a wrong offset!");

// Class Matcha.MatchaNotify_PlaySound
// 0x0020 (0x0058 - 0x0038)
class UMatchaNotify_PlaySound final : public UAnimNotify
{
public:
	class FName                                   AudioEventId;                                      // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectEventType                              EffectEventType;                                   // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeMultiplier;                                  // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFollow;                                           // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotify_PlaySound">();
	}
	static class UMatchaNotify_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotify_PlaySound>();
	}
};
static_assert(alignof(UMatchaNotify_PlaySound) == 0x000008, "Wrong alignment on UMatchaNotify_PlaySound");
static_assert(sizeof(UMatchaNotify_PlaySound) == 0x000058, "Wrong size on UMatchaNotify_PlaySound");
static_assert(offsetof(UMatchaNotify_PlaySound, AudioEventId) == 0x000038, "Member 'UMatchaNotify_PlaySound::AudioEventId' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlaySound, EffectEventType) == 0x000040, "Member 'UMatchaNotify_PlaySound::EffectEventType' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlaySound, VolumeMultiplier) == 0x000044, "Member 'UMatchaNotify_PlaySound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlaySound, PitchMultiplier) == 0x000048, "Member 'UMatchaNotify_PlaySound::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlaySound, bFollow) == 0x00004C, "Member 'UMatchaNotify_PlaySound::bFollow' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlaySound, AttachName) == 0x000050, "Member 'UMatchaNotify_PlaySound::AttachName' has a wrong offset!");

// Class Matcha.MatchaAssetManager
// 0x0010 (0x04E0 - 0x04D0)
class UMatchaAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAssetManager">();
	}
	static class UMatchaAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaAssetManager>();
	}
};
static_assert(alignof(UMatchaAssetManager) == 0x000008, "Wrong alignment on UMatchaAssetManager");
static_assert(sizeof(UMatchaAssetManager) == 0x0004E0, "Wrong size on UMatchaAssetManager");

// Class Matcha.MatchaCharacterBase
// 0x0CE0 (0x1350 - 0x0670)
#pragma pack(push, 0x1)
class alignas(0x10) AMatchaCharacterBase : public ACharacter
{
public:
	uint8                                         Pad_668[0x28];                                     // 0x0668(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CoarseHitExtents;                                  // 0x0690(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterSizeScale;                                // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A4[0x4];                                      // 0x06A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DefaultJumpCustomGravityCurve;                     // 0x06A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EJumpType, class UCurveFloat*>           PerJumpTypeCustomGravityCurve;                     // 0x06B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EFallType, float>                        PerFallTypeMaxFallSpeed;                           // 0x0700(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EFallType, float>                        PerFallTypeGravityScale;                           // 0x0750(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TargetedGlitchDashCurve;                           // 0x07A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxOutOfAutoTravelSpeed;                           // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x07AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReceivingHitFreezeMultiplier;                      // 0x07B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyDiminishingReturnsToStuns;                   // 0x07B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B5[0x3];                                      // 0x07B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFacingInfo                            FacingInfo;                                        // 0x07B8(0x0078)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FHitFreezeStateInfo                    HitFreezeStateInfo;                                // 0x0830(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_898[0x8];                                      // 0x0898(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayingMontageInfo                    PlayingMontageInfo;                                // 0x08A0(0x0160)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FAppliedRootMotionInfo                 CurrentAppliedRootMotionInfo;                      // 0x0A00(0x0108)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FAutoTravelRootMotionInfo              CurrentAutoTravelRootMotionInfo;                   // 0x0B08(0x02A8)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FTargetedGlitchDashInfo                CurrentTargetedGlitchDashInfo;                     // 0x0DB0(0x0140)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsInClankFreeze;                                  // 0x0EF0(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEnum                   AliveState;                                        // 0x0F08(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEnum                   CurrentFallType;                                   // 0x0F50(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyVelocity               Acceleration;                                      // 0x0F98(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FJumpNetworkData                       JumpNetworkData;                                   // 0x0FD0(0x0100)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  CurrentMontageId;                                  // 0x10D0(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  RemainingStunTime;                                 // 0x1108(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  LastStunnedTime;                                   // 0x1148(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  RecentlyRequestedStunCount;                        // 0x1180(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsImmuneToStuns;                                  // 0x11B8(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bShouldBeRevealedToAllPlayers;                     // 0x11D0(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	class USnapNetEntityComponent*                EntityComponent;                                   // 0x11E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEnum                   MovementMode;                                      // 0x11F0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyVelocity               Velocity;                                          // 0x1238(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRandomStream                          RandomStream;                                      // 0x1270(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1278[0x58];                                    // 0x1278(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTriggeredOneShotNotifyInfo>    TriggeredOneShotNotifies;                          // 0x12D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMatchaProcessedHitInfo>        CurrentFrameIncomingHits;                          // 0x12E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F0[0x40];                                    // 0x12F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaSnapNetCharacterMovementComponent* MatchaCMC;                                         // 0x1330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMatchaSnapNetCharacterAnimInstance*    MatchaAnimInstance;                                // 0x1338(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1340[0x8];                                     // 0x1340(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHitBox(const struct FMatchaHitBoxData& HitBoxData, class UObject* Source, const struct FVector& Location);
	void CharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	bool CharacterTeleport(const struct FVector& DestinationLocation, const struct FRotator& DestinationRotation, bool bIsATest, bool bNoCheck);
	void ClearTargetedGlitchDash();
	void DestroyTrackedEntity(const struct FGameplayTag& EntityTag);
	const class AActor* GetTrackedEntity(const struct FGameplayTag& EntityTag);
	void InflictDamage(class AActor* DamageInstigator, float Damage);
	void PerformAoEHeal(const struct FActorFilterInfo& ActorFilterInfo, float HealAmount, float Range);
	void PerformAoEStun(const struct FActorFilterInfo& ActorFilterInfo, float StunTimeInSeconds, float Range, const struct FVector2D& OffsetFromCharacter);
	void PerformCharacterLaunchAngleSpeed(ELaunchType LaunchType, ELaunchActionRestrictionType ActionRestrictionType, float LaunchSpeed, float LaunchAngle, float Acceleration_0, float Gravity, float ActionRestrictionDuration, bool bApplyIntangibility);
	void PerformCharacterLaunchVelocity(ELaunchType LaunchType, ELaunchActionRestrictionType ActionRestrictionType, const struct FVector& LaunchVelocity, float Acceleration_0, float Gravity, float ActionRestrictionDuration, bool bApplyIntangibility, bool bClearCurrentMontage);
	void RequestHitFreeze(int32 HitFreezeMilliseconds, bool bShouldShake, bool bShouldPetrify);
	void RequestStun(float DurationSeconds);
	void RequestTargetedGlitchDash(int32 TargetEntityIndex, int32 AirStallTimeMilliseconds, int32 TravelTimeMilliseconds, const struct FVector2D& OffsetVector, ETargetedGlitchDashFacingType FacingType, EMatchaCharacterMontageType MontageToPlayOnRequest, EMatchaCharacterMontageType PostTravelMontage, EMatchaRootMotionType PostTravelRootMotion);
	void RequestTraversalEntityRootMotionForce(const class AMatchaSplineTraversalEntity* TraversalEntity, float TravelSpeed, bool bRequestedDisable, bool bRequestedIntangibility, bool bDisableCapsuleCollision);
	void SetShouldBeRevealedToAllPlayers(bool bShouldBeRevealed);
	void SpawnTrackedEntity(const struct FGameplayTag& EntityTag, const struct FVector& Location, const struct FRotator& Rotation);
	void ToggleStunImmunity(bool bShouldEnable);

	EAliveState GetAliveState() const;
	EAutoTravelRootMotionType GetCurrentAutoTravelType() const;
	EFallType GetCurrentFallType() const;
	EJumpType GetCurrentJumpType() const;
	float GetCurrentlyPlayingMontageTime() const;
	EMatchaCharacterMontageType GetCurrentMontageType() const;
	ETraversalEntityType GetCurrentTraversalEntityType() const;
	int32 GetEntityIndex() const;
	EMovementMode GetMovementMode() const;
	int32 GetOwnerPlayerIndex() const;
	const TArray<struct FVisibilityOverride> GetVisibilityOverrides() const;
	bool IsTargetedGlitchDashing() const;
	bool ShouldBeRevealedToAllPlayers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCharacterBase">();
	}
	static class AMatchaCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaCharacterBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMatchaCharacterBase) == 0x000010, "Wrong alignment on AMatchaCharacterBase");
static_assert(sizeof(AMatchaCharacterBase) == 0x001350, "Wrong size on AMatchaCharacterBase");
static_assert(offsetof(AMatchaCharacterBase, CoarseHitExtents) == 0x000690, "Member 'AMatchaCharacterBase::CoarseHitExtents' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, CharacterSizeScale) == 0x0006A0, "Member 'AMatchaCharacterBase::CharacterSizeScale' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, DefaultJumpCustomGravityCurve) == 0x0006A8, "Member 'AMatchaCharacterBase::DefaultJumpCustomGravityCurve' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, PerJumpTypeCustomGravityCurve) == 0x0006B0, "Member 'AMatchaCharacterBase::PerJumpTypeCustomGravityCurve' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, PerFallTypeMaxFallSpeed) == 0x000700, "Member 'AMatchaCharacterBase::PerFallTypeMaxFallSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, PerFallTypeGravityScale) == 0x000750, "Member 'AMatchaCharacterBase::PerFallTypeGravityScale' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, TargetedGlitchDashCurve) == 0x0007A0, "Member 'AMatchaCharacterBase::TargetedGlitchDashCurve' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, MaxOutOfAutoTravelSpeed) == 0x0007A8, "Member 'AMatchaCharacterBase::MaxOutOfAutoTravelSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, Weight) == 0x0007AC, "Member 'AMatchaCharacterBase::Weight' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, ReceivingHitFreezeMultiplier) == 0x0007B0, "Member 'AMatchaCharacterBase::ReceivingHitFreezeMultiplier' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, bApplyDiminishingReturnsToStuns) == 0x0007B4, "Member 'AMatchaCharacterBase::bApplyDiminishingReturnsToStuns' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, FacingInfo) == 0x0007B8, "Member 'AMatchaCharacterBase::FacingInfo' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, HitFreezeStateInfo) == 0x000830, "Member 'AMatchaCharacterBase::HitFreezeStateInfo' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, PlayingMontageInfo) == 0x0008A0, "Member 'AMatchaCharacterBase::PlayingMontageInfo' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, CurrentAppliedRootMotionInfo) == 0x000A00, "Member 'AMatchaCharacterBase::CurrentAppliedRootMotionInfo' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, CurrentAutoTravelRootMotionInfo) == 0x000B08, "Member 'AMatchaCharacterBase::CurrentAutoTravelRootMotionInfo' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, CurrentTargetedGlitchDashInfo) == 0x000DB0, "Member 'AMatchaCharacterBase::CurrentTargetedGlitchDashInfo' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, bIsInClankFreeze) == 0x000EF0, "Member 'AMatchaCharacterBase::bIsInClankFreeze' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, AliveState) == 0x000F08, "Member 'AMatchaCharacterBase::AliveState' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, CurrentFallType) == 0x000F50, "Member 'AMatchaCharacterBase::CurrentFallType' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, Acceleration) == 0x000F98, "Member 'AMatchaCharacterBase::Acceleration' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, JumpNetworkData) == 0x000FD0, "Member 'AMatchaCharacterBase::JumpNetworkData' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, CurrentMontageId) == 0x0010D0, "Member 'AMatchaCharacterBase::CurrentMontageId' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, RemainingStunTime) == 0x001108, "Member 'AMatchaCharacterBase::RemainingStunTime' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, LastStunnedTime) == 0x001148, "Member 'AMatchaCharacterBase::LastStunnedTime' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, RecentlyRequestedStunCount) == 0x001180, "Member 'AMatchaCharacterBase::RecentlyRequestedStunCount' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, bIsImmuneToStuns) == 0x0011B8, "Member 'AMatchaCharacterBase::bIsImmuneToStuns' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, bShouldBeRevealedToAllPlayers) == 0x0011D0, "Member 'AMatchaCharacterBase::bShouldBeRevealedToAllPlayers' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, EntityComponent) == 0x0011E8, "Member 'AMatchaCharacterBase::EntityComponent' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, MovementMode) == 0x0011F0, "Member 'AMatchaCharacterBase::MovementMode' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, Velocity) == 0x001238, "Member 'AMatchaCharacterBase::Velocity' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, RandomStream) == 0x001270, "Member 'AMatchaCharacterBase::RandomStream' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, TriggeredOneShotNotifies) == 0x0012D0, "Member 'AMatchaCharacterBase::TriggeredOneShotNotifies' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, CurrentFrameIncomingHits) == 0x0012E0, "Member 'AMatchaCharacterBase::CurrentFrameIncomingHits' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, MatchaCMC) == 0x001330, "Member 'AMatchaCharacterBase::MatchaCMC' has a wrong offset!");
static_assert(offsetof(AMatchaCharacterBase, MatchaAnimInstance) == 0x001338, "Member 'AMatchaCharacterBase::MatchaAnimInstance' has a wrong offset!");

// Class Matcha.MatchaAttachableCompanionEntity
// 0x01A0 (0x14F0 - 0x1350)
#pragma pack(push, 0x1)
class alignas(0x10) AMatchaAttachableCompanionEntity : public AMatchaCharacterBase
{
public:
	TMap<EMatchaRootMotionType, struct FRootMotionForceData> RootMotionForceDefinitions;                        // 0x1348(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAttachToOwnerOnInitialize;                        // 0x1398(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSharesAliveStateWithOwner;                        // 0x1399(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139A[0x2];                                     // 0x139A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnDurationMilliseconds;                        // 0x139C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeashDistance;                                     // 0x13A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OwnerAttachRadius;                                 // 0x13A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnTowardsOwner;                               // 0x13A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachToOwnerOnOverlap;                           // 0x13A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldFaceOwnerDirectionWhileAttached;            // 0x13AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13AB[0x5];                                     // 0x13AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyEntityIndex            OwnerEntityIndex;                                  // 0x13B0(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FCompanionAttachInfo                   AttachInfo;                                        // 0x1418(0x00C8)(Transient, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ReturnSpeedCurve;                                  // 0x14E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetOwnerEntityIndex() const;
	bool IsAttachedToOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAttachableCompanionEntity">();
	}
	static class AMatchaAttachableCompanionEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaAttachableCompanionEntity>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMatchaAttachableCompanionEntity) == 0x000010, "Wrong alignment on AMatchaAttachableCompanionEntity");
static_assert(sizeof(AMatchaAttachableCompanionEntity) == 0x0014F0, "Wrong size on AMatchaAttachableCompanionEntity");
static_assert(offsetof(AMatchaAttachableCompanionEntity, RootMotionForceDefinitions) == 0x001348, "Member 'AMatchaAttachableCompanionEntity::RootMotionForceDefinitions' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, bAttachToOwnerOnInitialize) == 0x001398, "Member 'AMatchaAttachableCompanionEntity::bAttachToOwnerOnInitialize' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, bSharesAliveStateWithOwner) == 0x001399, "Member 'AMatchaAttachableCompanionEntity::bSharesAliveStateWithOwner' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, ReturnDurationMilliseconds) == 0x00139C, "Member 'AMatchaAttachableCompanionEntity::ReturnDurationMilliseconds' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, LeashDistance) == 0x0013A0, "Member 'AMatchaAttachableCompanionEntity::LeashDistance' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, OwnerAttachRadius) == 0x0013A4, "Member 'AMatchaAttachableCompanionEntity::OwnerAttachRadius' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, bReturnTowardsOwner) == 0x0013A8, "Member 'AMatchaAttachableCompanionEntity::bReturnTowardsOwner' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, bAttachToOwnerOnOverlap) == 0x0013A9, "Member 'AMatchaAttachableCompanionEntity::bAttachToOwnerOnOverlap' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, bShouldFaceOwnerDirectionWhileAttached) == 0x0013AA, "Member 'AMatchaAttachableCompanionEntity::bShouldFaceOwnerDirectionWhileAttached' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, OwnerEntityIndex) == 0x0013B0, "Member 'AMatchaAttachableCompanionEntity::OwnerEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, AttachInfo) == 0x001418, "Member 'AMatchaAttachableCompanionEntity::AttachInfo' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntity, ReturnSpeedCurve) == 0x0014E0, "Member 'AMatchaAttachableCompanionEntity::ReturnSpeedCurve' has a wrong offset!");

// Class Matcha.MatchaAttachableCompanionEntityVigil
// 0x00B0 (0x15A0 - 0x14F0)
class AMatchaAttachableCompanionEntityVigil : public AMatchaAttachableCompanionEntity
{
public:
	struct FMatchaHitBoxData                      HitBoxData;                                        // 0x14E8(0x00A8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   AttachSocketName;                                  // 0x1590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysChangeFacingOnOwnerAttack;                  // 0x1598(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1599[0x7];                                     // 0x1599(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAttachableCompanionEntityVigil">();
	}
	static class AMatchaAttachableCompanionEntityVigil* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaAttachableCompanionEntityVigil>();
	}
};
static_assert(alignof(AMatchaAttachableCompanionEntityVigil) == 0x000010, "Wrong alignment on AMatchaAttachableCompanionEntityVigil");
static_assert(sizeof(AMatchaAttachableCompanionEntityVigil) == 0x0015A0, "Wrong size on AMatchaAttachableCompanionEntityVigil");
static_assert(offsetof(AMatchaAttachableCompanionEntityVigil, HitBoxData) == 0x0014E8, "Member 'AMatchaAttachableCompanionEntityVigil::HitBoxData' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntityVigil, AttachSocketName) == 0x001590, "Member 'AMatchaAttachableCompanionEntityVigil::AttachSocketName' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionEntityVigil, bAlwaysChangeFacingOnOwnerAttack) == 0x001598, "Member 'AMatchaAttachableCompanionEntityVigil::bAlwaysChangeFacingOnOwnerAttack' has a wrong offset!");

// Class Matcha.MatchaSnapNetPlayerEntity
// 0x03E0 (0x0670 - 0x0290)
class AMatchaSnapNetPlayerEntity : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyInt32                  RespawnTimeMilliseconds;                           // 0x0298(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<struct FPropertyEntityIndexWrapper>    TeamMemberEntityIndexes;                           // 0x02D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AMatchaSnapNetPlayerEntity*>     LocalTeamMembers;                                  // 0x02E0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMatchaInventoryComponent*              InventoryComponent;                                // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyString                 DisplayName;                                       // 0x02F8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  TeamNumber;                                        // 0x0328(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USnapNetEntityComponent*                EntityComponent;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEntityIndex            CharacterEntityIndex;                              // 0x0368(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  CharacterSelectClassIdx;                           // 0x03D0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  HoveredCharacterSelectClassIdx;                    // 0x0408(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  RemainingStocks;                                   // 0x0440(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  SharedTeamCoins;                                   // 0x0478(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  SharedTeamPowerSparks;                             // 0x04B0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEnum                   GlobalCombatStatus;                                // 0x04E8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyEnum                   CurrentSelectedSpawnRegion;                        // 0x0538(0x0048)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  KnockoutCount;                                     // 0x0580(0x0038)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  ReviveCount;                                       // 0x05B8(0x0038)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  DamageDealt;                                       // 0x05F0(0x0040)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  DamageHealed;                                      // 0x0630(0x0040)(Protected, NativeAccessSpecifierProtected)

public:
	static class AMatchaSnapNetPlayerEntity* Get(int32 PlayerIndex, const class UObject* WorldContextObject);
	static TArray<class AMatchaSnapNetPlayerEntity*> GetByTeamIndex(int32 TeamNumber_0, const class UObject* WorldContextObject);
	static class AMatchaSnapNetPlayerEntity* GetFromSimulation(int32 PlayerIndex, const class USnapNetSimulation* SnapNetSimulation);

	void GiveTeamCoins(int32 Amount);
	void GiveTeamPowerSparks(int32 Amount);
	void SetSharedTeamCoins(int32 SharedTeamCoins_0);
	void SetSharedTeamPowerSparks(int32 InSharedTeamPowerSparks);

	class FText GetDisplayName() const;
	class UMatchaInventoryComponent* GetInventoryComponent() const;
	class AMatchaSnapNetCharacterEntity* GetOwnedCharacter() const;
	int32 GetOwnerPlayerIndex() const;
	int32 GetSharedTeamCoins() const;
	int32 GetSharedTeamPowerSparks() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetPlayerEntity">();
	}
	static class AMatchaSnapNetPlayerEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetPlayerEntity>();
	}
};
static_assert(alignof(AMatchaSnapNetPlayerEntity) == 0x000008, "Wrong alignment on AMatchaSnapNetPlayerEntity");
static_assert(sizeof(AMatchaSnapNetPlayerEntity) == 0x000670, "Wrong size on AMatchaSnapNetPlayerEntity");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, RespawnTimeMilliseconds) == 0x000298, "Member 'AMatchaSnapNetPlayerEntity::RespawnTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, TeamMemberEntityIndexes) == 0x0002D0, "Member 'AMatchaSnapNetPlayerEntity::TeamMemberEntityIndexes' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, LocalTeamMembers) == 0x0002E0, "Member 'AMatchaSnapNetPlayerEntity::LocalTeamMembers' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, InventoryComponent) == 0x0002F0, "Member 'AMatchaSnapNetPlayerEntity::InventoryComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, DisplayName) == 0x0002F8, "Member 'AMatchaSnapNetPlayerEntity::DisplayName' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, TeamNumber) == 0x000328, "Member 'AMatchaSnapNetPlayerEntity::TeamNumber' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, EntityComponent) == 0x000360, "Member 'AMatchaSnapNetPlayerEntity::EntityComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, CharacterEntityIndex) == 0x000368, "Member 'AMatchaSnapNetPlayerEntity::CharacterEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, CharacterSelectClassIdx) == 0x0003D0, "Member 'AMatchaSnapNetPlayerEntity::CharacterSelectClassIdx' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, HoveredCharacterSelectClassIdx) == 0x000408, "Member 'AMatchaSnapNetPlayerEntity::HoveredCharacterSelectClassIdx' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, RemainingStocks) == 0x000440, "Member 'AMatchaSnapNetPlayerEntity::RemainingStocks' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, SharedTeamCoins) == 0x000478, "Member 'AMatchaSnapNetPlayerEntity::SharedTeamCoins' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, SharedTeamPowerSparks) == 0x0004B0, "Member 'AMatchaSnapNetPlayerEntity::SharedTeamPowerSparks' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, GlobalCombatStatus) == 0x0004E8, "Member 'AMatchaSnapNetPlayerEntity::GlobalCombatStatus' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, CurrentSelectedSpawnRegion) == 0x000538, "Member 'AMatchaSnapNetPlayerEntity::CurrentSelectedSpawnRegion' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, KnockoutCount) == 0x000580, "Member 'AMatchaSnapNetPlayerEntity::KnockoutCount' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, ReviveCount) == 0x0005B8, "Member 'AMatchaSnapNetPlayerEntity::ReviveCount' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, DamageDealt) == 0x0005F0, "Member 'AMatchaSnapNetPlayerEntity::DamageDealt' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerEntity, DamageHealed) == 0x000630, "Member 'AMatchaSnapNetPlayerEntity::DamageHealed' has a wrong offset!");

// Class Matcha.MatchaSnapNetRenderer
// 0x0010 (0x02A0 - 0x0290)
class AMatchaSnapNetRenderer : public AActor
{
public:
	class USnapNetEntityRendererComponent*        EntityRendererComponent;                           // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OwnerPlayerIndex;                                  // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InstigatorEntityIndex;                             // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AMatchaSnapNetCharacterRenderer* GetInstigatorRenderer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetRenderer">();
	}
	static class AMatchaSnapNetRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetRenderer>();
	}
};
static_assert(alignof(AMatchaSnapNetRenderer) == 0x000008, "Wrong alignment on AMatchaSnapNetRenderer");
static_assert(sizeof(AMatchaSnapNetRenderer) == 0x0002A0, "Wrong size on AMatchaSnapNetRenderer");
static_assert(offsetof(AMatchaSnapNetRenderer, EntityRendererComponent) == 0x000290, "Member 'AMatchaSnapNetRenderer::EntityRendererComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetRenderer, OwnerPlayerIndex) == 0x000298, "Member 'AMatchaSnapNetRenderer::OwnerPlayerIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetRenderer, InstigatorEntityIndex) == 0x00029C, "Member 'AMatchaSnapNetRenderer::InstigatorEntityIndex' has a wrong offset!");

// Class Matcha.MatchaAttachableCompanionRenderer
// 0x0018 (0x02B8 - 0x02A0)
class AMatchaAttachableCompanionRenderer final : public AMatchaSnapNetRenderer
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootSceneComponent;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldHideWhileAttached;                          // 0x02B0(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAliveState                                   AliveState;                                        // 0x02B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECompanionAttachState                         AttachState;                                       // 0x02B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAlive;                                          // 0x02B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaAttachableCompanionRenderer">();
	}
	static class AMatchaAttachableCompanionRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaAttachableCompanionRenderer>();
	}
};
static_assert(alignof(AMatchaAttachableCompanionRenderer) == 0x000008, "Wrong alignment on AMatchaAttachableCompanionRenderer");
static_assert(sizeof(AMatchaAttachableCompanionRenderer) == 0x0002B8, "Wrong size on AMatchaAttachableCompanionRenderer");
static_assert(offsetof(AMatchaAttachableCompanionRenderer, MeshComponent) == 0x0002A0, "Member 'AMatchaAttachableCompanionRenderer::MeshComponent' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionRenderer, RootSceneComponent) == 0x0002A8, "Member 'AMatchaAttachableCompanionRenderer::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionRenderer, bShouldHideWhileAttached) == 0x0002B0, "Member 'AMatchaAttachableCompanionRenderer::bShouldHideWhileAttached' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionRenderer, AliveState) == 0x0002B1, "Member 'AMatchaAttachableCompanionRenderer::AliveState' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionRenderer, AttachState) == 0x0002B2, "Member 'AMatchaAttachableCompanionRenderer::AttachState' has a wrong offset!");
static_assert(offsetof(AMatchaAttachableCompanionRenderer, bIsAlive) == 0x0002B3, "Member 'AMatchaAttachableCompanionRenderer::bIsAlive' has a wrong offset!");

// Class Matcha.MatchaPlayerUIData
// 0x0420 (0x0488 - 0x0068)
class UMatchaPlayerUIData : public UOdyUIData
{
public:
	struct FOdyUIBoolBinding                      bIsSpectatedPlayer;                                // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      bIsAllyToSpectatedPlayer;                          // 0x0088(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       PlayerIndex;                                       // 0x00A8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       CharacterEntityIndex;                              // 0x00C8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      PlayerName;                                        // 0x00E8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   CharacterPortrait;                                 // 0x0110(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   CharacterMinimapPortrait;                          // 0x0170(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   EndOfGamePortrait;                                 // 0x01D0(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       TeamNumber;                                        // 0x0230(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       Stocks;                                            // 0x0250(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       DamagePercent;                                     // 0x0270(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       Knockouts;                                         // 0x0290(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       DamageDealt;                                       // 0x02B0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       DamageHealed;                                      // 0x02D0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       Revives;                                           // 0x02F0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsAlive;                                           // 0x0310(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       CurrentSelectedSpawnRegion;                        // 0x0330(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       SharedTeamCoins;                                   // 0x0350(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       SharedTeamPowerSparks;                             // 0x0370(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentShieldHealth;                               // 0x0390(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentMaxShieldHealth;                            // 0x03B0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     MaxEnergy;                                         // 0x03D0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     Energy;                                            // 0x03F0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaInventoryUIData>     InventoryUIDataClass;                              // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaInventoryUIData*                 InventoryUIData;                                   // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaCharacterUIData>     CharacterUIDataClass;                              // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaCharacterUIData*                 CharacterUIData;                                   // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaCharacterUIData*                 HoveredCharacterSelectUIData;                      // 0x0430(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaInventoryItemUIData> InventoryItemDataClass;                            // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaInventoryItemUIData*             InteractableItem;                                  // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 RevealedCharacterEntityIndices;                    // 0x0448(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRevealedCharacterEntityIndicesChanged;           // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x20];                                     // 0x0468(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPlayerUIData">();
	}
	static class UMatchaPlayerUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaPlayerUIData>();
	}
};
static_assert(alignof(UMatchaPlayerUIData) == 0x000008, "Wrong alignment on UMatchaPlayerUIData");
static_assert(sizeof(UMatchaPlayerUIData) == 0x000488, "Wrong size on UMatchaPlayerUIData");
static_assert(offsetof(UMatchaPlayerUIData, bIsSpectatedPlayer) == 0x000068, "Member 'UMatchaPlayerUIData::bIsSpectatedPlayer' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, bIsAllyToSpectatedPlayer) == 0x000088, "Member 'UMatchaPlayerUIData::bIsAllyToSpectatedPlayer' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, PlayerIndex) == 0x0000A8, "Member 'UMatchaPlayerUIData::PlayerIndex' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, CharacterEntityIndex) == 0x0000C8, "Member 'UMatchaPlayerUIData::CharacterEntityIndex' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, PlayerName) == 0x0000E8, "Member 'UMatchaPlayerUIData::PlayerName' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, CharacterPortrait) == 0x000110, "Member 'UMatchaPlayerUIData::CharacterPortrait' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, CharacterMinimapPortrait) == 0x000170, "Member 'UMatchaPlayerUIData::CharacterMinimapPortrait' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, EndOfGamePortrait) == 0x0001D0, "Member 'UMatchaPlayerUIData::EndOfGamePortrait' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, TeamNumber) == 0x000230, "Member 'UMatchaPlayerUIData::TeamNumber' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, Stocks) == 0x000250, "Member 'UMatchaPlayerUIData::Stocks' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, DamagePercent) == 0x000270, "Member 'UMatchaPlayerUIData::DamagePercent' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, Knockouts) == 0x000290, "Member 'UMatchaPlayerUIData::Knockouts' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, DamageDealt) == 0x0002B0, "Member 'UMatchaPlayerUIData::DamageDealt' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, DamageHealed) == 0x0002D0, "Member 'UMatchaPlayerUIData::DamageHealed' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, Revives) == 0x0002F0, "Member 'UMatchaPlayerUIData::Revives' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, IsAlive) == 0x000310, "Member 'UMatchaPlayerUIData::IsAlive' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, CurrentSelectedSpawnRegion) == 0x000330, "Member 'UMatchaPlayerUIData::CurrentSelectedSpawnRegion' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, SharedTeamCoins) == 0x000350, "Member 'UMatchaPlayerUIData::SharedTeamCoins' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, SharedTeamPowerSparks) == 0x000370, "Member 'UMatchaPlayerUIData::SharedTeamPowerSparks' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, CurrentShieldHealth) == 0x000390, "Member 'UMatchaPlayerUIData::CurrentShieldHealth' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, CurrentMaxShieldHealth) == 0x0003B0, "Member 'UMatchaPlayerUIData::CurrentMaxShieldHealth' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, MaxEnergy) == 0x0003D0, "Member 'UMatchaPlayerUIData::MaxEnergy' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, Energy) == 0x0003F0, "Member 'UMatchaPlayerUIData::Energy' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, InventoryUIDataClass) == 0x000410, "Member 'UMatchaPlayerUIData::InventoryUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, InventoryUIData) == 0x000418, "Member 'UMatchaPlayerUIData::InventoryUIData' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, CharacterUIDataClass) == 0x000420, "Member 'UMatchaPlayerUIData::CharacterUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, CharacterUIData) == 0x000428, "Member 'UMatchaPlayerUIData::CharacterUIData' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, HoveredCharacterSelectUIData) == 0x000430, "Member 'UMatchaPlayerUIData::HoveredCharacterSelectUIData' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, InventoryItemDataClass) == 0x000438, "Member 'UMatchaPlayerUIData::InventoryItemDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, InteractableItem) == 0x000440, "Member 'UMatchaPlayerUIData::InteractableItem' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, RevealedCharacterEntityIndices) == 0x000448, "Member 'UMatchaPlayerUIData::RevealedCharacterEntityIndices' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerUIData, OnRevealedCharacterEntityIndicesChanged) == 0x000458, "Member 'UMatchaPlayerUIData::OnRevealedCharacterEntityIndicesChanged' has a wrong offset!");

// Class Matcha.MatchaServerScript
// 0x02A0 (0x02D0 - 0x0030)
class UMatchaServerScript : public USnapNetServerScript
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMatchaPlayerSlotStatus>               PlayerSlots;                                       // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x108];                                     // 0x0048(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaServerServices*                  ServerServices;                                    // 0x0150(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMatchaStandaloneServerProvider*        StandaloneServerProvider;                          // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMatchaAnalyticsManager*                AnalyticsManager;                                  // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x18];                                     // 0x0168(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillFeedMaxEntries;                                // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockOutCreditMaximumTimeSeconds;                  // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASnapNetAIController>       AIControllerClass;                                 // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0x50];                                     // 0x0190(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMatchaSnapNetGameEntity>   GameEntityClass;                                   // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMatchaSnapNetGameEntity*               GameEntity;                                        // 0x01E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GameFormat;                                        // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoStartTimeSeconds;                              // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnSelectionDurationSeconds;                     // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnSelectionOutroDurationSeconds;                // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchCompletedCelebrationDurationSeconds;          // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchShutdownLingerSeconds;                        // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchPhaseRemainingTime;                           // 0x0214(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialStocks;                                     // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnTime;                                       // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumGameTimeSeconds;                            // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalGameTime;                                     // 0x0224(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMatchaSnapNetPlayerEntity> PlayerEntityClass;                                 // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x50];                                     // 0x0230(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FMatchaServerPlayerData>   ConnectedPlayers;                                  // 0x0280(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ClearItems();
	void InflictDamageActors(float DamageAmount, class AActor* Victim, class AActor* Instigator);
	void OnCharacterKnockedOut(class AMatchaSnapNetCharacterEntity* CharacterThatWasKnockedOut, const struct FMatchaKnockoutData& KnockoutData);
	void OnCharacterKnockedOutOtherCharacter(class AMatchaSnapNetCharacterEntity* CharacterThatKnocked);
	void OnGameInfoRequestCompleted(bool Succeeded, const class FString& RequestID, const struct FMatchaApiV1GamesInfoResponse& GameInfo, const struct FErrorResponseV1& ErrorResponse);
	void RespawnPlayer(class AMatchaSnapNetPlayerEntity* PlayerEntity);
	void SetPlayerName(int32 PlayerIndex, const class FString& Name_0);
	void SpawnBot(const TSubclassOf<class AMatchaSnapNetCharacterEntity>& CharacterEntityClass, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	int32 TrySpectatePlayer(int32 RequestingPlayerIndex, int32 TargetPlayerIndex);
	bool ValidateDTLSToken(const class FString& Token);

	class AMatchaSnapNetPlayerEntity* FindPlayerEntityForPlayerIndex(int32 PlayerIndex) const;
	int32 FindPlayerIndexForPlayerId(class FName PlayerId) const;
	int32 FindTeamNumberForPlayerIndex(int32 PlayerIndex) const;
	TSubclassOf<class AMatchaSnapNetCharacterEntity> GetDefaultCharacterEntityClass() const;
	int32 GetNewPlayerTeamNumber() const;
	TArray<class AMatchaSnapNetPlayerEntity*> GetPlayersOnTeam(int32 TeamNumber) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaServerScript">();
	}
	static class UMatchaServerScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaServerScript>();
	}
};
static_assert(alignof(UMatchaServerScript) == 0x000008, "Wrong alignment on UMatchaServerScript");
static_assert(sizeof(UMatchaServerScript) == 0x0002D0, "Wrong size on UMatchaServerScript");
static_assert(offsetof(UMatchaServerScript, PlayerSlots) == 0x000038, "Member 'UMatchaServerScript::PlayerSlots' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, ServerServices) == 0x000150, "Member 'UMatchaServerScript::ServerServices' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, StandaloneServerProvider) == 0x000158, "Member 'UMatchaServerScript::StandaloneServerProvider' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, AnalyticsManager) == 0x000160, "Member 'UMatchaServerScript::AnalyticsManager' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, KillFeedMaxEntries) == 0x000180, "Member 'UMatchaServerScript::KillFeedMaxEntries' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, KnockOutCreditMaximumTimeSeconds) == 0x000184, "Member 'UMatchaServerScript::KnockOutCreditMaximumTimeSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, AIControllerClass) == 0x000188, "Member 'UMatchaServerScript::AIControllerClass' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, GameEntityClass) == 0x0001E0, "Member 'UMatchaServerScript::GameEntityClass' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, GameEntity) == 0x0001E8, "Member 'UMatchaServerScript::GameEntity' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, GameFormat) == 0x0001F0, "Member 'UMatchaServerScript::GameFormat' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, AutoStartTimeSeconds) == 0x000200, "Member 'UMatchaServerScript::AutoStartTimeSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, SpawnSelectionDurationSeconds) == 0x000204, "Member 'UMatchaServerScript::SpawnSelectionDurationSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, SpawnSelectionOutroDurationSeconds) == 0x000208, "Member 'UMatchaServerScript::SpawnSelectionOutroDurationSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, MatchCompletedCelebrationDurationSeconds) == 0x00020C, "Member 'UMatchaServerScript::MatchCompletedCelebrationDurationSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, MatchShutdownLingerSeconds) == 0x000210, "Member 'UMatchaServerScript::MatchShutdownLingerSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, MatchPhaseRemainingTime) == 0x000214, "Member 'UMatchaServerScript::MatchPhaseRemainingTime' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, InitialStocks) == 0x000218, "Member 'UMatchaServerScript::InitialStocks' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, RespawnTime) == 0x00021C, "Member 'UMatchaServerScript::RespawnTime' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, MaximumGameTimeSeconds) == 0x000220, "Member 'UMatchaServerScript::MaximumGameTimeSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, TotalGameTime) == 0x000224, "Member 'UMatchaServerScript::TotalGameTime' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, PlayerEntityClass) == 0x000228, "Member 'UMatchaServerScript::PlayerEntityClass' has a wrong offset!");
static_assert(offsetof(UMatchaServerScript, ConnectedPlayers) == 0x000280, "Member 'UMatchaServerScript::ConnectedPlayers' has a wrong offset!");

// Class Matcha.MatchaBattleRoyaleServerScript
// 0x0138 (0x0408 - 0x02D0)
class UMatchaBattleRoyaleServerScript final : public UMatchaServerScript
{
public:
	class FName                                   InitialSpawnTag;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MatchSpawnTag;                                     // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMatchaItemAsset*                       SoulItem;                                          // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CoinAmountToRevive;                                // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageToDealUponRevive;                            // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPredictionDistance;                             // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSimulationDistance;                             // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRandomStream                          RandomStream;                                      // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AMatchaSnapNetKOZoneEntity*             CachedKoZoneEntity;                                // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x100];                                    // 0x0308(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AMatchaPlayerStart* FindRandomSpawnPointInRegion(ESpawnRegion SpawnRegion, int32 TeamNumber, bool bShouldFindPointWithTeammates);
	void ProcessSoulOrbRevival(class AMatchaSnapNetCharacterEntity* ReviverCharacter, const struct FVector& ReviveLocation, const struct FRotator& ReviveRotation);
	bool TrySpendCoins(const class AMatchaSnapNetCharacterEntity* SpenderCharacter, int32 CoinsToSpend);
	bool TrySpendCurrency(const class AMatchaSnapNetCharacterEntity* SpenderCharacter, int32 AmountToSpend, EInGameCurrencyType CurrencyType);

	struct FTransform ChooseSpawnFurthestFromPlayers(const TArray<struct FTransform>& SpawnPoints, const class AMatchaSnapNetCharacterEntity* CharacterEntity) const;
	TArray<struct FTransform> FindSpawnPointsWithTag(class FName SpawnTag) const;
	bool HasEnoughCoins(const class AMatchaSnapNetCharacterEntity* Character, int32 CoinAmountToCheck) const;
	bool HasEnoughCurrencyOfType(const class AMatchaSnapNetCharacterEntity* Character, int32 AmountToCheck, EInGameCurrencyType CurrencyType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaBattleRoyaleServerScript">();
	}
	static class UMatchaBattleRoyaleServerScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaBattleRoyaleServerScript>();
	}
};
static_assert(alignof(UMatchaBattleRoyaleServerScript) == 0x000008, "Wrong alignment on UMatchaBattleRoyaleServerScript");
static_assert(sizeof(UMatchaBattleRoyaleServerScript) == 0x000408, "Wrong size on UMatchaBattleRoyaleServerScript");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, InitialSpawnTag) == 0x0002D0, "Member 'UMatchaBattleRoyaleServerScript::InitialSpawnTag' has a wrong offset!");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, MatchSpawnTag) == 0x0002D8, "Member 'UMatchaBattleRoyaleServerScript::MatchSpawnTag' has a wrong offset!");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, SoulItem) == 0x0002E0, "Member 'UMatchaBattleRoyaleServerScript::SoulItem' has a wrong offset!");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, CoinAmountToRevive) == 0x0002E8, "Member 'UMatchaBattleRoyaleServerScript::CoinAmountToRevive' has a wrong offset!");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, DamageToDealUponRevive) == 0x0002EC, "Member 'UMatchaBattleRoyaleServerScript::DamageToDealUponRevive' has a wrong offset!");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, MaxPredictionDistance) == 0x0002F0, "Member 'UMatchaBattleRoyaleServerScript::MaxPredictionDistance' has a wrong offset!");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, MaxSimulationDistance) == 0x0002F4, "Member 'UMatchaBattleRoyaleServerScript::MaxSimulationDistance' has a wrong offset!");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, RandomStream) == 0x0002F8, "Member 'UMatchaBattleRoyaleServerScript::RandomStream' has a wrong offset!");
static_assert(offsetof(UMatchaBattleRoyaleServerScript, CachedKoZoneEntity) == 0x000300, "Member 'UMatchaBattleRoyaleServerScript::CachedKoZoneEntity' has a wrong offset!");

// Class Matcha.MatchaBreakableEntity
// 0x0138 (0x04B0 - 0x0378)
class AMatchaBreakableEntity : public AMatchaSnapNetEntity
{
public:
	uint8                                         Pad_378[0x18];                                     // 0x0378(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultRootComponent;                              // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          HurtBoxCollision;                                  // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CoarseHitExtents;                                  // 0x03A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  MaxDamage;                                         // 0x03B0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  CurrentDamage;                                     // 0x03F0(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   DefaultHitFXId;                                    // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bBroken;                                           // 0x0438(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FRandomStream                          RandomStream;                                      // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ChannelToBroadcastEventTo;                         // 0x0458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchaGameplayEvent                   GameplayEventToBroadcast;                          // 0x0460(0x0014)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUnprocessedHitBoxData>         CurrentFrameOutgoingHits;                          // 0x0478(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAppliedHitInfo>                RecentlyAppliedHits;                               // 0x0488(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentTeamNumber;                                 // 0x0498(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchaProcessedHitInfo>        CurrentFrameIncomingHits;                          // 0x04A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnBroken();

	float GetDamage() const;
	float GetMaxDamage() const;
	bool IsAlive() const;
	bool IsBroken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaBreakableEntity">();
	}
	static class AMatchaBreakableEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaBreakableEntity>();
	}
};
static_assert(alignof(AMatchaBreakableEntity) == 0x000008, "Wrong alignment on AMatchaBreakableEntity");
static_assert(sizeof(AMatchaBreakableEntity) == 0x0004B0, "Wrong size on AMatchaBreakableEntity");
static_assert(offsetof(AMatchaBreakableEntity, DefaultRootComponent) == 0x000390, "Member 'AMatchaBreakableEntity::DefaultRootComponent' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, HurtBoxCollision) == 0x000398, "Member 'AMatchaBreakableEntity::HurtBoxCollision' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, CoarseHitExtents) == 0x0003A0, "Member 'AMatchaBreakableEntity::CoarseHitExtents' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, MaxDamage) == 0x0003B0, "Member 'AMatchaBreakableEntity::MaxDamage' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, CurrentDamage) == 0x0003F0, "Member 'AMatchaBreakableEntity::CurrentDamage' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, DefaultHitFXId) == 0x000430, "Member 'AMatchaBreakableEntity::DefaultHitFXId' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, bBroken) == 0x000438, "Member 'AMatchaBreakableEntity::bBroken' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, RandomStream) == 0x000450, "Member 'AMatchaBreakableEntity::RandomStream' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, ChannelToBroadcastEventTo) == 0x000458, "Member 'AMatchaBreakableEntity::ChannelToBroadcastEventTo' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, GameplayEventToBroadcast) == 0x000460, "Member 'AMatchaBreakableEntity::GameplayEventToBroadcast' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, Weight) == 0x000474, "Member 'AMatchaBreakableEntity::Weight' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, CurrentFrameOutgoingHits) == 0x000478, "Member 'AMatchaBreakableEntity::CurrentFrameOutgoingHits' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, RecentlyAppliedHits) == 0x000488, "Member 'AMatchaBreakableEntity::RecentlyAppliedHits' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, CurrentTeamNumber) == 0x000498, "Member 'AMatchaBreakableEntity::CurrentTeamNumber' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableEntity, CurrentFrameIncomingHits) == 0x0004A0, "Member 'AMatchaBreakableEntity::CurrentFrameIncomingHits' has a wrong offset!");

// Class Matcha.MatchaBreakableRenderer
// 0x0070 (0x0310 - 0x02A0)
class AMatchaBreakableRenderer final : public AMatchaSnapNetRenderer
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOdyUIFloatBinding                     CurrentDamage;                                     // 0x02A8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     MaxDamage;                                         // 0x02C8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CurrentTeamNumber;                                 // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DestroyedMeshComponent;                            // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootSceneComponent;                                // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAlive;                                          // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIsAliveChanged(bool bNewIsAlive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaBreakableRenderer">();
	}
	static class AMatchaBreakableRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaBreakableRenderer>();
	}
};
static_assert(alignof(AMatchaBreakableRenderer) == 0x000008, "Wrong alignment on AMatchaBreakableRenderer");
static_assert(sizeof(AMatchaBreakableRenderer) == 0x000310, "Wrong size on AMatchaBreakableRenderer");
static_assert(offsetof(AMatchaBreakableRenderer, CurrentDamage) == 0x0002A8, "Member 'AMatchaBreakableRenderer::CurrentDamage' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableRenderer, MaxDamage) == 0x0002C8, "Member 'AMatchaBreakableRenderer::MaxDamage' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableRenderer, CurrentTeamNumber) == 0x0002E8, "Member 'AMatchaBreakableRenderer::CurrentTeamNumber' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableRenderer, MeshComponent) == 0x0002F0, "Member 'AMatchaBreakableRenderer::MeshComponent' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableRenderer, DestroyedMeshComponent) == 0x0002F8, "Member 'AMatchaBreakableRenderer::DestroyedMeshComponent' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableRenderer, RootSceneComponent) == 0x000300, "Member 'AMatchaBreakableRenderer::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AMatchaBreakableRenderer, bIsAlive) == 0x000308, "Member 'AMatchaBreakableRenderer::bIsAlive' has a wrong offset!");

// Class Matcha.MatchaBTService_TryChooseNextAbility
// 0x00A8 (0x0118 - 0x0070)
class UMatchaBTService_TryChooseNextAbility final : public UBTService
{
public:
	struct FBlackboardKeySelector                 ChosenAbilityIndex;                                // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 CurrentTargetBlackboardKey;                        // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 ChosenAbilityDuration;                             // 0x00C0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 PreviousChosenAbilityIndex;                        // 0x00E8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         CapsuleRadiusForgivenessPct;                       // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityWaitTimeBuffer;                             // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaBTService_TryChooseNextAbility">();
	}
	static class UMatchaBTService_TryChooseNextAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaBTService_TryChooseNextAbility>();
	}
};
static_assert(alignof(UMatchaBTService_TryChooseNextAbility) == 0x000008, "Wrong alignment on UMatchaBTService_TryChooseNextAbility");
static_assert(sizeof(UMatchaBTService_TryChooseNextAbility) == 0x000118, "Wrong size on UMatchaBTService_TryChooseNextAbility");
static_assert(offsetof(UMatchaBTService_TryChooseNextAbility, ChosenAbilityIndex) == 0x000070, "Member 'UMatchaBTService_TryChooseNextAbility::ChosenAbilityIndex' has a wrong offset!");
static_assert(offsetof(UMatchaBTService_TryChooseNextAbility, CurrentTargetBlackboardKey) == 0x000098, "Member 'UMatchaBTService_TryChooseNextAbility::CurrentTargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UMatchaBTService_TryChooseNextAbility, ChosenAbilityDuration) == 0x0000C0, "Member 'UMatchaBTService_TryChooseNextAbility::ChosenAbilityDuration' has a wrong offset!");
static_assert(offsetof(UMatchaBTService_TryChooseNextAbility, PreviousChosenAbilityIndex) == 0x0000E8, "Member 'UMatchaBTService_TryChooseNextAbility::PreviousChosenAbilityIndex' has a wrong offset!");
static_assert(offsetof(UMatchaBTService_TryChooseNextAbility, CapsuleRadiusForgivenessPct) == 0x000110, "Member 'UMatchaBTService_TryChooseNextAbility::CapsuleRadiusForgivenessPct' has a wrong offset!");
static_assert(offsetof(UMatchaBTService_TryChooseNextAbility, AbilityWaitTimeBuffer) == 0x000114, "Member 'UMatchaBTService_TryChooseNextAbility::AbilityWaitTimeBuffer' has a wrong offset!");

// Class Matcha.MatchaBTService_UpdateTargetedEnemy
// 0x0058 (0x00C8 - 0x0070)
class UMatchaBTService_UpdateTargetedEnemy final : public UBTService
{
public:
	struct FBlackboardKeySelector                 CurrentTargetedEnemyBlackboardKey;                 // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 MaxSearchRangeBlackboardKey;                       // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         NavMeshCheckHeightExtent;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaBTService_UpdateTargetedEnemy">();
	}
	static class UMatchaBTService_UpdateTargetedEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaBTService_UpdateTargetedEnemy>();
	}
};
static_assert(alignof(UMatchaBTService_UpdateTargetedEnemy) == 0x000008, "Wrong alignment on UMatchaBTService_UpdateTargetedEnemy");
static_assert(sizeof(UMatchaBTService_UpdateTargetedEnemy) == 0x0000C8, "Wrong size on UMatchaBTService_UpdateTargetedEnemy");
static_assert(offsetof(UMatchaBTService_UpdateTargetedEnemy, CurrentTargetedEnemyBlackboardKey) == 0x000070, "Member 'UMatchaBTService_UpdateTargetedEnemy::CurrentTargetedEnemyBlackboardKey' has a wrong offset!");
static_assert(offsetof(UMatchaBTService_UpdateTargetedEnemy, MaxSearchRangeBlackboardKey) == 0x000098, "Member 'UMatchaBTService_UpdateTargetedEnemy::MaxSearchRangeBlackboardKey' has a wrong offset!");
static_assert(offsetof(UMatchaBTService_UpdateTargetedEnemy, NavMeshCheckHeightExtent) == 0x0000C0, "Member 'UMatchaBTService_UpdateTargetedEnemy::NavMeshCheckHeightExtent' has a wrong offset!");

// Class Matcha.MatchaBuffSetupData
// 0x0050 (0x0080 - 0x0030)
class UMatchaBuffSetupData final : public UPrimaryDataAsset
{
public:
	TMap<struct FGameplayTag, TSubclassOf<class UMatchaCharacterBuff>> BuffsByTag;                                        // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaBuffSetupData">();
	}
	static class UMatchaBuffSetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaBuffSetupData>();
	}
};
static_assert(alignof(UMatchaBuffSetupData) == 0x000008, "Wrong alignment on UMatchaBuffSetupData");
static_assert(sizeof(UMatchaBuffSetupData) == 0x000080, "Wrong size on UMatchaBuffSetupData");
static_assert(offsetof(UMatchaBuffSetupData, BuffsByTag) == 0x000030, "Member 'UMatchaBuffSetupData::BuffsByTag' has a wrong offset!");

// Class Matcha.MatchaClientServicesConfiguration
// 0x0038 (0x0070 - 0x0038)
class UMatchaClientServicesConfiguration final : public UDeveloperSettings
{
public:
	int32                                         MaxReconnectAttempts;                              // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WebSocketUrl;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServicesBaseUrl;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPollIntervalSeconds;                        // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueuePollIntervalSeconds;                          // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitingForSessionPollIntervalSeconds;              // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGamePollIntervalSeconds;                         // 0x006C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetWebSocketUrl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaClientServicesConfiguration">();
	}
	static class UMatchaClientServicesConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaClientServicesConfiguration>();
	}
};
static_assert(alignof(UMatchaClientServicesConfiguration) == 0x000008, "Wrong alignment on UMatchaClientServicesConfiguration");
static_assert(sizeof(UMatchaClientServicesConfiguration) == 0x000070, "Wrong size on UMatchaClientServicesConfiguration");
static_assert(offsetof(UMatchaClientServicesConfiguration, MaxReconnectAttempts) == 0x000038, "Member 'UMatchaClientServicesConfiguration::MaxReconnectAttempts' has a wrong offset!");
static_assert(offsetof(UMatchaClientServicesConfiguration, WebSocketUrl) == 0x000040, "Member 'UMatchaClientServicesConfiguration::WebSocketUrl' has a wrong offset!");
static_assert(offsetof(UMatchaClientServicesConfiguration, ServicesBaseUrl) == 0x000050, "Member 'UMatchaClientServicesConfiguration::ServicesBaseUrl' has a wrong offset!");
static_assert(offsetof(UMatchaClientServicesConfiguration, DefaultPollIntervalSeconds) == 0x000060, "Member 'UMatchaClientServicesConfiguration::DefaultPollIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaClientServicesConfiguration, QueuePollIntervalSeconds) == 0x000064, "Member 'UMatchaClientServicesConfiguration::QueuePollIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaClientServicesConfiguration, WaitingForSessionPollIntervalSeconds) == 0x000068, "Member 'UMatchaClientServicesConfiguration::WaitingForSessionPollIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaClientServicesConfiguration, InGamePollIntervalSeconds) == 0x00006C, "Member 'UMatchaClientServicesConfiguration::InGamePollIntervalSeconds' has a wrong offset!");

// Class Matcha.MatchaChallengeHandlerBase
// 0x00A0 (0x0330 - 0x0290)
class AMatchaChallengeHandlerBase final : public AActor
{
public:
	TSet<struct FGameplayTag>                     EventChannelsToListenTo;                           // 0x0290(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x50];                                     // 0x02E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameplayEvent(const struct FMatchaGameplayEvent& MatchaGameplayEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaChallengeHandlerBase">();
	}
	static class AMatchaChallengeHandlerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaChallengeHandlerBase>();
	}
};
static_assert(alignof(AMatchaChallengeHandlerBase) == 0x000008, "Wrong alignment on AMatchaChallengeHandlerBase");
static_assert(sizeof(AMatchaChallengeHandlerBase) == 0x000330, "Wrong size on AMatchaChallengeHandlerBase");
static_assert(offsetof(AMatchaChallengeHandlerBase, EventChannelsToListenTo) == 0x000290, "Member 'AMatchaChallengeHandlerBase::EventChannelsToListenTo' has a wrong offset!");

// Class Matcha.MatchaSnapNetCharacterAnimInstance
// 0x04B0 (0x0820 - 0x0370)
class UMatchaSnapNetCharacterAnimInstance : public UAnimInstance
{
public:
	float                                         BlendTimeDefault;                                  // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           GroundJumpMontage;                                 // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AirJumpMontage;                                    // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FinalAirJumpMontage;                               // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WallJumpMontage;                                   // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LedgeJumpGetUpMontage;                             // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LedgeJumpMontage;                                  // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LedgeGrabMontage;                                  // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LedgeGetUpMontage;                                 // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LedgeRollMontage;                                  // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LedgeAttackMontage;                                // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LedgeSpecialAttackMontage;                         // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LandingMontage;                                    // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   SpecialLandingMontages;                            // 0x03D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   CounterMontages;                                   // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DiveBombMontage;                                   // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           JabMontage;                                        // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardTiltMontage;                                // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UpTiltMontage;                                     // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DownTiltMontage;                                   // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardSmashMontage;                               // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UpSmashMontage;                                    // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DownSmashMontage;                                  // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           NeutralAirMontage;                                 // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardAirMontage;                                 // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackAirMontage;                                    // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UpAirMontage;                                      // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DownAirMontage;                                    // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DashStartMontage;                                  // 0x0458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DashAttackMontage;                                 // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           NeutralSpecialMontage;                             // 0x0468(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SideSpecialMontage;                                // 0x0470(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UpSpecialMontage;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DownSpecialMontage;                                // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredNeutralSpecialMontage;                    // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredSideSpecialMontage;                       // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredUpSpecialMontage;                         // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredDownSpecialMontage;                       // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           NeutralSpecialAerialMontage;                       // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SideSpecialAerialMontage;                          // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UpSpecialAerialMontage;                            // 0x04B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DownSpecialAerialMontage;                          // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredNeutralSpecialAerialMontage;              // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredSideSpecialAerialMontage;                 // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredUpSpecialAerialMontage;                   // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredDownSpecialAerialMontage;                 // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LightHurtAirMontage;                               // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LightHurtGroundMontage;                            // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   HurtLaunchPoseMontages;                            // 0x04F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   HurtLaunchFrontMontages;                           // 0x0508(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   HurtLaunchBackMontages;                            // 0x0518(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HurtLaunchToTumbleMontage;                         // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TumbleFrontMontage;                                // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TumbleBackMontage;                                 // 0x0538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WallBounceHurtPoseMontage;                         // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETechType, class UAnimMontage*>          PerTechTypeTechMontages;                           // 0x0548(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           KnockDownMontage;                                  // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EKnockDownGetUpType, class UAnimMontage*> PerGetUpTypeGetUpMontages;                         // 0x05A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShieldUpMontage;                                   // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShieldDropMontage;                                 // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AirDodgeMontage;                                   // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GroundForwardDodgeMontage;                         // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GroundBackwardsDodgeMontage;                       // 0x0610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GroundSpotDodgeMontage;                            // 0x0618(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BounceMontage;                                     // 0x0620(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GrabBounceMontage;                                 // 0x0628(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GrabMontage;                                       // 0x0630(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DashGrabMontage;                                   // 0x0638(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GrabLoopMontage;                                   // 0x0640(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShieldBreakMontage;                                // 0x0648(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DizzyMontage;                                      // 0x0650(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StunMontage;                                       // 0x0658(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractMontage;                                   // 0x0660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractCancelMontage;                             // 0x0668(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DropItemMontage;                                   // 0x0670(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowItemMontage;                                  // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FirePistolItemMontage;                             // 0x0680(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ConsumeFoodItemMontage;                            // 0x0688(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ConsumeDeployItemMontage;                          // 0x0690(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CompleteConsumeFoodItemMontage;                    // 0x0698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CompleteConsumeDeployItemMontage;                  // 0x06A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CancelConsumeItemMontage;                          // 0x06A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TeamAttackMontage;                                 // 0x06B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GlitchStepAttackMontage;                           // 0x06B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EnergyBurstMontage;                                // 0x06C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AirGrabMontage;                                    // 0x06C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DashAirGrabMontage;                                // 0x06D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ZiplineMontage;                                    // 0x06D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GlitchBeamMontage;                                 // 0x06E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TurnAroundMontage;                                 // 0x06E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DashTurnAroundMontage;                             // 0x06F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGrabHeightType, class UAnimMontage*>    PerHeightTypeGrabbedMontages;                      // 0x06F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EThrowDirection, class UAnimMontage*>    PerDirectionThrowMontages;                         // 0x0748(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EThrowType, class UAnimMontage*>         PerThrowTypeBeingThrownMontages;                   // 0x0798(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AccelerationStrengthThresholdForWalkRun;           // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDirectionsBlendTime;                           // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleWalkRunBlendTime;                              // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFalling;                                          // 0x07F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastFalling;                                      // 0x07F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiveBombing;                                      // 0x07F6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDashing;                                          // 0x07F7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouching;                                        // 0x07F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHanging;                                          // 0x07F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInZipline;                                        // 0x07FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInDataStream;                                     // 0x07FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallRunning;                                      // 0x07FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallClinging;                                     // 0x07FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHelpless;                                         // 0x07FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDidJump;                                          // 0x07FF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSpeed;                                   // 0x0800(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalSpeed;                                     // 0x0804(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationStrength;                              // 0x0808(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationLocalDirection;                        // 0x080C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainingAirJumps;                                 // 0x0810(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJumpType                                     LastJumpType;                                      // 0x0814(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFallLoopDirection                            CurrentFallLoopDirection;                          // 0x0815(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallingAndNotHanging;                             // 0x0816(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallingAndNotHelpless;                            // 0x0817(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallingAndHelpless;                               // 0x0818(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallingAndDidJump;                                // 0x0819(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallingAndDidJumpAndWasAerialJump;                // 0x081A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallingAndDidJumpAndWasFinalJump;                 // 0x081B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceleratingEnoughForWalkRun;                     // 0x081C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPositiveVerticalSpeed;                         // 0x081D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPositiveAccelerationLocalDirection;            // 0x081E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81F[0x1];                                      // 0x081F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetCharacterAnimInstance">();
	}
	static class UMatchaSnapNetCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSnapNetCharacterAnimInstance>();
	}
};
static_assert(alignof(UMatchaSnapNetCharacterAnimInstance) == 0x000010, "Wrong alignment on UMatchaSnapNetCharacterAnimInstance");
static_assert(sizeof(UMatchaSnapNetCharacterAnimInstance) == 0x000820, "Wrong size on UMatchaSnapNetCharacterAnimInstance");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, BlendTimeDefault) == 0x000368, "Member 'UMatchaSnapNetCharacterAnimInstance::BlendTimeDefault' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GroundJumpMontage) == 0x000370, "Member 'UMatchaSnapNetCharacterAnimInstance::GroundJumpMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, AirJumpMontage) == 0x000378, "Member 'UMatchaSnapNetCharacterAnimInstance::AirJumpMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, FinalAirJumpMontage) == 0x000380, "Member 'UMatchaSnapNetCharacterAnimInstance::FinalAirJumpMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, WallJumpMontage) == 0x000388, "Member 'UMatchaSnapNetCharacterAnimInstance::WallJumpMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LedgeJumpGetUpMontage) == 0x000390, "Member 'UMatchaSnapNetCharacterAnimInstance::LedgeJumpGetUpMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LedgeJumpMontage) == 0x000398, "Member 'UMatchaSnapNetCharacterAnimInstance::LedgeJumpMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LedgeGrabMontage) == 0x0003A0, "Member 'UMatchaSnapNetCharacterAnimInstance::LedgeGrabMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LedgeGetUpMontage) == 0x0003A8, "Member 'UMatchaSnapNetCharacterAnimInstance::LedgeGetUpMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LedgeRollMontage) == 0x0003B0, "Member 'UMatchaSnapNetCharacterAnimInstance::LedgeRollMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LedgeAttackMontage) == 0x0003B8, "Member 'UMatchaSnapNetCharacterAnimInstance::LedgeAttackMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LedgeSpecialAttackMontage) == 0x0003C0, "Member 'UMatchaSnapNetCharacterAnimInstance::LedgeSpecialAttackMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LandingMontage) == 0x0003C8, "Member 'UMatchaSnapNetCharacterAnimInstance::LandingMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, SpecialLandingMontages) == 0x0003D0, "Member 'UMatchaSnapNetCharacterAnimInstance::SpecialLandingMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, CounterMontages) == 0x0003E0, "Member 'UMatchaSnapNetCharacterAnimInstance::CounterMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DiveBombMontage) == 0x0003F0, "Member 'UMatchaSnapNetCharacterAnimInstance::DiveBombMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, JabMontage) == 0x0003F8, "Member 'UMatchaSnapNetCharacterAnimInstance::JabMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ForwardTiltMontage) == 0x000400, "Member 'UMatchaSnapNetCharacterAnimInstance::ForwardTiltMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, UpTiltMontage) == 0x000408, "Member 'UMatchaSnapNetCharacterAnimInstance::UpTiltMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DownTiltMontage) == 0x000410, "Member 'UMatchaSnapNetCharacterAnimInstance::DownTiltMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ForwardSmashMontage) == 0x000418, "Member 'UMatchaSnapNetCharacterAnimInstance::ForwardSmashMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, UpSmashMontage) == 0x000420, "Member 'UMatchaSnapNetCharacterAnimInstance::UpSmashMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DownSmashMontage) == 0x000428, "Member 'UMatchaSnapNetCharacterAnimInstance::DownSmashMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, NeutralAirMontage) == 0x000430, "Member 'UMatchaSnapNetCharacterAnimInstance::NeutralAirMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ForwardAirMontage) == 0x000438, "Member 'UMatchaSnapNetCharacterAnimInstance::ForwardAirMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, BackAirMontage) == 0x000440, "Member 'UMatchaSnapNetCharacterAnimInstance::BackAirMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, UpAirMontage) == 0x000448, "Member 'UMatchaSnapNetCharacterAnimInstance::UpAirMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DownAirMontage) == 0x000450, "Member 'UMatchaSnapNetCharacterAnimInstance::DownAirMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DashStartMontage) == 0x000458, "Member 'UMatchaSnapNetCharacterAnimInstance::DashStartMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DashAttackMontage) == 0x000460, "Member 'UMatchaSnapNetCharacterAnimInstance::DashAttackMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, NeutralSpecialMontage) == 0x000468, "Member 'UMatchaSnapNetCharacterAnimInstance::NeutralSpecialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, SideSpecialMontage) == 0x000470, "Member 'UMatchaSnapNetCharacterAnimInstance::SideSpecialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, UpSpecialMontage) == 0x000478, "Member 'UMatchaSnapNetCharacterAnimInstance::UpSpecialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DownSpecialMontage) == 0x000480, "Member 'UMatchaSnapNetCharacterAnimInstance::DownSpecialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EmpoweredNeutralSpecialMontage) == 0x000488, "Member 'UMatchaSnapNetCharacterAnimInstance::EmpoweredNeutralSpecialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EmpoweredSideSpecialMontage) == 0x000490, "Member 'UMatchaSnapNetCharacterAnimInstance::EmpoweredSideSpecialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EmpoweredUpSpecialMontage) == 0x000498, "Member 'UMatchaSnapNetCharacterAnimInstance::EmpoweredUpSpecialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EmpoweredDownSpecialMontage) == 0x0004A0, "Member 'UMatchaSnapNetCharacterAnimInstance::EmpoweredDownSpecialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, NeutralSpecialAerialMontage) == 0x0004A8, "Member 'UMatchaSnapNetCharacterAnimInstance::NeutralSpecialAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, SideSpecialAerialMontage) == 0x0004B0, "Member 'UMatchaSnapNetCharacterAnimInstance::SideSpecialAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, UpSpecialAerialMontage) == 0x0004B8, "Member 'UMatchaSnapNetCharacterAnimInstance::UpSpecialAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DownSpecialAerialMontage) == 0x0004C0, "Member 'UMatchaSnapNetCharacterAnimInstance::DownSpecialAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EmpoweredNeutralSpecialAerialMontage) == 0x0004C8, "Member 'UMatchaSnapNetCharacterAnimInstance::EmpoweredNeutralSpecialAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EmpoweredSideSpecialAerialMontage) == 0x0004D0, "Member 'UMatchaSnapNetCharacterAnimInstance::EmpoweredSideSpecialAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EmpoweredUpSpecialAerialMontage) == 0x0004D8, "Member 'UMatchaSnapNetCharacterAnimInstance::EmpoweredUpSpecialAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EmpoweredDownSpecialAerialMontage) == 0x0004E0, "Member 'UMatchaSnapNetCharacterAnimInstance::EmpoweredDownSpecialAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LightHurtAirMontage) == 0x0004E8, "Member 'UMatchaSnapNetCharacterAnimInstance::LightHurtAirMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LightHurtGroundMontage) == 0x0004F0, "Member 'UMatchaSnapNetCharacterAnimInstance::LightHurtGroundMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, HurtLaunchPoseMontages) == 0x0004F8, "Member 'UMatchaSnapNetCharacterAnimInstance::HurtLaunchPoseMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, HurtLaunchFrontMontages) == 0x000508, "Member 'UMatchaSnapNetCharacterAnimInstance::HurtLaunchFrontMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, HurtLaunchBackMontages) == 0x000518, "Member 'UMatchaSnapNetCharacterAnimInstance::HurtLaunchBackMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, HurtLaunchToTumbleMontage) == 0x000528, "Member 'UMatchaSnapNetCharacterAnimInstance::HurtLaunchToTumbleMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, TumbleFrontMontage) == 0x000530, "Member 'UMatchaSnapNetCharacterAnimInstance::TumbleFrontMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, TumbleBackMontage) == 0x000538, "Member 'UMatchaSnapNetCharacterAnimInstance::TumbleBackMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, WallBounceHurtPoseMontage) == 0x000540, "Member 'UMatchaSnapNetCharacterAnimInstance::WallBounceHurtPoseMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, PerTechTypeTechMontages) == 0x000548, "Member 'UMatchaSnapNetCharacterAnimInstance::PerTechTypeTechMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, KnockDownMontage) == 0x000598, "Member 'UMatchaSnapNetCharacterAnimInstance::KnockDownMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, PerGetUpTypeGetUpMontages) == 0x0005A0, "Member 'UMatchaSnapNetCharacterAnimInstance::PerGetUpTypeGetUpMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ShieldUpMontage) == 0x0005F0, "Member 'UMatchaSnapNetCharacterAnimInstance::ShieldUpMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ShieldDropMontage) == 0x0005F8, "Member 'UMatchaSnapNetCharacterAnimInstance::ShieldDropMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, AirDodgeMontage) == 0x000600, "Member 'UMatchaSnapNetCharacterAnimInstance::AirDodgeMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GroundForwardDodgeMontage) == 0x000608, "Member 'UMatchaSnapNetCharacterAnimInstance::GroundForwardDodgeMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GroundBackwardsDodgeMontage) == 0x000610, "Member 'UMatchaSnapNetCharacterAnimInstance::GroundBackwardsDodgeMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GroundSpotDodgeMontage) == 0x000618, "Member 'UMatchaSnapNetCharacterAnimInstance::GroundSpotDodgeMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, BounceMontage) == 0x000620, "Member 'UMatchaSnapNetCharacterAnimInstance::BounceMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GrabBounceMontage) == 0x000628, "Member 'UMatchaSnapNetCharacterAnimInstance::GrabBounceMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GrabMontage) == 0x000630, "Member 'UMatchaSnapNetCharacterAnimInstance::GrabMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DashGrabMontage) == 0x000638, "Member 'UMatchaSnapNetCharacterAnimInstance::DashGrabMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GrabLoopMontage) == 0x000640, "Member 'UMatchaSnapNetCharacterAnimInstance::GrabLoopMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ShieldBreakMontage) == 0x000648, "Member 'UMatchaSnapNetCharacterAnimInstance::ShieldBreakMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DizzyMontage) == 0x000650, "Member 'UMatchaSnapNetCharacterAnimInstance::DizzyMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, StunMontage) == 0x000658, "Member 'UMatchaSnapNetCharacterAnimInstance::StunMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, InteractMontage) == 0x000660, "Member 'UMatchaSnapNetCharacterAnimInstance::InteractMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, InteractCancelMontage) == 0x000668, "Member 'UMatchaSnapNetCharacterAnimInstance::InteractCancelMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DropItemMontage) == 0x000670, "Member 'UMatchaSnapNetCharacterAnimInstance::DropItemMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ThrowItemMontage) == 0x000678, "Member 'UMatchaSnapNetCharacterAnimInstance::ThrowItemMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, FirePistolItemMontage) == 0x000680, "Member 'UMatchaSnapNetCharacterAnimInstance::FirePistolItemMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ConsumeFoodItemMontage) == 0x000688, "Member 'UMatchaSnapNetCharacterAnimInstance::ConsumeFoodItemMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ConsumeDeployItemMontage) == 0x000690, "Member 'UMatchaSnapNetCharacterAnimInstance::ConsumeDeployItemMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, CompleteConsumeFoodItemMontage) == 0x000698, "Member 'UMatchaSnapNetCharacterAnimInstance::CompleteConsumeFoodItemMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, CompleteConsumeDeployItemMontage) == 0x0006A0, "Member 'UMatchaSnapNetCharacterAnimInstance::CompleteConsumeDeployItemMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, CancelConsumeItemMontage) == 0x0006A8, "Member 'UMatchaSnapNetCharacterAnimInstance::CancelConsumeItemMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, TeamAttackMontage) == 0x0006B0, "Member 'UMatchaSnapNetCharacterAnimInstance::TeamAttackMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GlitchStepAttackMontage) == 0x0006B8, "Member 'UMatchaSnapNetCharacterAnimInstance::GlitchStepAttackMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, EnergyBurstMontage) == 0x0006C0, "Member 'UMatchaSnapNetCharacterAnimInstance::EnergyBurstMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, AirGrabMontage) == 0x0006C8, "Member 'UMatchaSnapNetCharacterAnimInstance::AirGrabMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DashAirGrabMontage) == 0x0006D0, "Member 'UMatchaSnapNetCharacterAnimInstance::DashAirGrabMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, ZiplineMontage) == 0x0006D8, "Member 'UMatchaSnapNetCharacterAnimInstance::ZiplineMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, GlitchBeamMontage) == 0x0006E0, "Member 'UMatchaSnapNetCharacterAnimInstance::GlitchBeamMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, TurnAroundMontage) == 0x0006E8, "Member 'UMatchaSnapNetCharacterAnimInstance::TurnAroundMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, DashTurnAroundMontage) == 0x0006F0, "Member 'UMatchaSnapNetCharacterAnimInstance::DashTurnAroundMontage' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, PerHeightTypeGrabbedMontages) == 0x0006F8, "Member 'UMatchaSnapNetCharacterAnimInstance::PerHeightTypeGrabbedMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, PerDirectionThrowMontages) == 0x000748, "Member 'UMatchaSnapNetCharacterAnimInstance::PerDirectionThrowMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, PerThrowTypeBeingThrownMontages) == 0x000798, "Member 'UMatchaSnapNetCharacterAnimInstance::PerThrowTypeBeingThrownMontages' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, AccelerationStrengthThresholdForWalkRun) == 0x0007E8, "Member 'UMatchaSnapNetCharacterAnimInstance::AccelerationStrengthThresholdForWalkRun' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, FallDirectionsBlendTime) == 0x0007EC, "Member 'UMatchaSnapNetCharacterAnimInstance::FallDirectionsBlendTime' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, IdleWalkRunBlendTime) == 0x0007F0, "Member 'UMatchaSnapNetCharacterAnimInstance::IdleWalkRunBlendTime' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bFalling) == 0x0007F4, "Member 'UMatchaSnapNetCharacterAnimInstance::bFalling' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bFastFalling) == 0x0007F5, "Member 'UMatchaSnapNetCharacterAnimInstance::bFastFalling' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bDiveBombing) == 0x0007F6, "Member 'UMatchaSnapNetCharacterAnimInstance::bDiveBombing' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bDashing) == 0x0007F7, "Member 'UMatchaSnapNetCharacterAnimInstance::bDashing' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bCrouching) == 0x0007F8, "Member 'UMatchaSnapNetCharacterAnimInstance::bCrouching' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bHanging) == 0x0007F9, "Member 'UMatchaSnapNetCharacterAnimInstance::bHanging' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bInZipline) == 0x0007FA, "Member 'UMatchaSnapNetCharacterAnimInstance::bInZipline' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bInDataStream) == 0x0007FB, "Member 'UMatchaSnapNetCharacterAnimInstance::bInDataStream' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bWallRunning) == 0x0007FC, "Member 'UMatchaSnapNetCharacterAnimInstance::bWallRunning' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bWallClinging) == 0x0007FD, "Member 'UMatchaSnapNetCharacterAnimInstance::bWallClinging' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bHelpless) == 0x0007FE, "Member 'UMatchaSnapNetCharacterAnimInstance::bHelpless' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bDidJump) == 0x0007FF, "Member 'UMatchaSnapNetCharacterAnimInstance::bDidJump' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, HorizontalSpeed) == 0x000800, "Member 'UMatchaSnapNetCharacterAnimInstance::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, VerticalSpeed) == 0x000804, "Member 'UMatchaSnapNetCharacterAnimInstance::VerticalSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, AccelerationStrength) == 0x000808, "Member 'UMatchaSnapNetCharacterAnimInstance::AccelerationStrength' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, AccelerationLocalDirection) == 0x00080C, "Member 'UMatchaSnapNetCharacterAnimInstance::AccelerationLocalDirection' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, RemainingAirJumps) == 0x000810, "Member 'UMatchaSnapNetCharacterAnimInstance::RemainingAirJumps' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, LastJumpType) == 0x000814, "Member 'UMatchaSnapNetCharacterAnimInstance::LastJumpType' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, CurrentFallLoopDirection) == 0x000815, "Member 'UMatchaSnapNetCharacterAnimInstance::CurrentFallLoopDirection' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bFallingAndNotHanging) == 0x000816, "Member 'UMatchaSnapNetCharacterAnimInstance::bFallingAndNotHanging' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bFallingAndNotHelpless) == 0x000817, "Member 'UMatchaSnapNetCharacterAnimInstance::bFallingAndNotHelpless' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bFallingAndHelpless) == 0x000818, "Member 'UMatchaSnapNetCharacterAnimInstance::bFallingAndHelpless' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bFallingAndDidJump) == 0x000819, "Member 'UMatchaSnapNetCharacterAnimInstance::bFallingAndDidJump' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bFallingAndDidJumpAndWasAerialJump) == 0x00081A, "Member 'UMatchaSnapNetCharacterAnimInstance::bFallingAndDidJumpAndWasAerialJump' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bFallingAndDidJumpAndWasFinalJump) == 0x00081B, "Member 'UMatchaSnapNetCharacterAnimInstance::bFallingAndDidJumpAndWasFinalJump' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bAcceleratingEnoughForWalkRun) == 0x00081C, "Member 'UMatchaSnapNetCharacterAnimInstance::bAcceleratingEnoughForWalkRun' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bHasPositiveVerticalSpeed) == 0x00081D, "Member 'UMatchaSnapNetCharacterAnimInstance::bHasPositiveVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterAnimInstance, bHasPositiveAccelerationLocalDirection) == 0x00081E, "Member 'UMatchaSnapNetCharacterAnimInstance::bHasPositiveAccelerationLocalDirection' has a wrong offset!");

// Class Matcha.MatchaCharacterAnimInstanceAiMi
// 0x0020 (0x0840 - 0x0820)
class UMatchaCharacterAnimInstanceAiMi : public UMatchaSnapNetCharacterAnimInstance
{
public:
	class UAnimMontage*                           NeutralSpeciaDashToMarklMontage;                   // 0x0820(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           NeutralSpecialDashToMarkAerialMontage;             // 0x0828(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredNeutralSpeciaDashToMarklMontage;          // 0x0830(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredNeutralSpecialDashToMarkAerialMontage;    // 0x0838(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCharacterAnimInstanceAiMi">();
	}
	static class UMatchaCharacterAnimInstanceAiMi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaCharacterAnimInstanceAiMi>();
	}
};
static_assert(alignof(UMatchaCharacterAnimInstanceAiMi) == 0x000010, "Wrong alignment on UMatchaCharacterAnimInstanceAiMi");
static_assert(sizeof(UMatchaCharacterAnimInstanceAiMi) == 0x000840, "Wrong size on UMatchaCharacterAnimInstanceAiMi");
static_assert(offsetof(UMatchaCharacterAnimInstanceAiMi, NeutralSpeciaDashToMarklMontage) == 0x000820, "Member 'UMatchaCharacterAnimInstanceAiMi::NeutralSpeciaDashToMarklMontage' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceAiMi, NeutralSpecialDashToMarkAerialMontage) == 0x000828, "Member 'UMatchaCharacterAnimInstanceAiMi::NeutralSpecialDashToMarkAerialMontage' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceAiMi, EmpoweredNeutralSpeciaDashToMarklMontage) == 0x000830, "Member 'UMatchaCharacterAnimInstanceAiMi::EmpoweredNeutralSpeciaDashToMarklMontage' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceAiMi, EmpoweredNeutralSpecialDashToMarkAerialMontage) == 0x000838, "Member 'UMatchaCharacterAnimInstanceAiMi::EmpoweredNeutralSpecialDashToMarkAerialMontage' has a wrong offset!");

// Class Matcha.MatchaCharacterAnimInstanceNao
// 0x0080 (0x08A0 - 0x0820)
class UMatchaCharacterAnimInstanceNao : public UMatchaSnapNetCharacterAnimInstance
{
public:
	class UAnimMontage*                           NeutralSpecialMontageDetached;                     // 0x0820(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SideSpecialMontageDetached;                        // 0x0828(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UpSpecialMontageDetached;                          // 0x0830(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DownSpecialMontageDetached;                        // 0x0838(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredNeutralSpecialMontageDetached;            // 0x0840(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredSideSpecialMontageDetached;               // 0x0848(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredUpSpecialMontageDetached;                 // 0x0850(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredDownSpecialMontageDetached;               // 0x0858(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           NeutralSpecialAerialMontageDetached;               // 0x0860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SideSpecialAerialMontageDetached;                  // 0x0868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UpSpecialAerialMontageDetached;                    // 0x0870(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DownSpecialAerialMontageDetached;                  // 0x0878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredNeutralSpecialAerialMontageDetached;      // 0x0880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredSideSpecialAerialMontageDetached;         // 0x0888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredUpSpecialAerialMontageDetached;           // 0x0890(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmpoweredDownSpecialAerialMontageDetached;         // 0x0898(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCharacterAnimInstanceNao">();
	}
	static class UMatchaCharacterAnimInstanceNao* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaCharacterAnimInstanceNao>();
	}
};
static_assert(alignof(UMatchaCharacterAnimInstanceNao) == 0x000010, "Wrong alignment on UMatchaCharacterAnimInstanceNao");
static_assert(sizeof(UMatchaCharacterAnimInstanceNao) == 0x0008A0, "Wrong size on UMatchaCharacterAnimInstanceNao");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, NeutralSpecialMontageDetached) == 0x000820, "Member 'UMatchaCharacterAnimInstanceNao::NeutralSpecialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, SideSpecialMontageDetached) == 0x000828, "Member 'UMatchaCharacterAnimInstanceNao::SideSpecialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, UpSpecialMontageDetached) == 0x000830, "Member 'UMatchaCharacterAnimInstanceNao::UpSpecialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, DownSpecialMontageDetached) == 0x000838, "Member 'UMatchaCharacterAnimInstanceNao::DownSpecialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, EmpoweredNeutralSpecialMontageDetached) == 0x000840, "Member 'UMatchaCharacterAnimInstanceNao::EmpoweredNeutralSpecialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, EmpoweredSideSpecialMontageDetached) == 0x000848, "Member 'UMatchaCharacterAnimInstanceNao::EmpoweredSideSpecialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, EmpoweredUpSpecialMontageDetached) == 0x000850, "Member 'UMatchaCharacterAnimInstanceNao::EmpoweredUpSpecialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, EmpoweredDownSpecialMontageDetached) == 0x000858, "Member 'UMatchaCharacterAnimInstanceNao::EmpoweredDownSpecialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, NeutralSpecialAerialMontageDetached) == 0x000860, "Member 'UMatchaCharacterAnimInstanceNao::NeutralSpecialAerialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, SideSpecialAerialMontageDetached) == 0x000868, "Member 'UMatchaCharacterAnimInstanceNao::SideSpecialAerialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, UpSpecialAerialMontageDetached) == 0x000870, "Member 'UMatchaCharacterAnimInstanceNao::UpSpecialAerialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, DownSpecialAerialMontageDetached) == 0x000878, "Member 'UMatchaCharacterAnimInstanceNao::DownSpecialAerialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, EmpoweredNeutralSpecialAerialMontageDetached) == 0x000880, "Member 'UMatchaCharacterAnimInstanceNao::EmpoweredNeutralSpecialAerialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, EmpoweredSideSpecialAerialMontageDetached) == 0x000888, "Member 'UMatchaCharacterAnimInstanceNao::EmpoweredSideSpecialAerialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, EmpoweredUpSpecialAerialMontageDetached) == 0x000890, "Member 'UMatchaCharacterAnimInstanceNao::EmpoweredUpSpecialAerialMontageDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceNao, EmpoweredDownSpecialAerialMontageDetached) == 0x000898, "Member 'UMatchaCharacterAnimInstanceNao::EmpoweredDownSpecialAerialMontageDetached' has a wrong offset!");

// Class Matcha.MatchaCharacterAnimInstanceVigil
// 0x0010 (0x0830 - 0x0820)
class UMatchaCharacterAnimInstanceVigil : public UMatchaSnapNetCharacterAnimInstance
{
public:
	bool                                          bIsDetaching;                                      // 0x0820(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDetached;                                       // 0x0821(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReturning;                                      // 0x0822(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttached;                                       // 0x0823(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_824[0xC];                                      // 0x0824(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCharacterAnimInstanceVigil">();
	}
	static class UMatchaCharacterAnimInstanceVigil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaCharacterAnimInstanceVigil>();
	}
};
static_assert(alignof(UMatchaCharacterAnimInstanceVigil) == 0x000010, "Wrong alignment on UMatchaCharacterAnimInstanceVigil");
static_assert(sizeof(UMatchaCharacterAnimInstanceVigil) == 0x000830, "Wrong size on UMatchaCharacterAnimInstanceVigil");
static_assert(offsetof(UMatchaCharacterAnimInstanceVigil, bIsDetaching) == 0x000820, "Member 'UMatchaCharacterAnimInstanceVigil::bIsDetaching' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceVigil, bIsDetached) == 0x000821, "Member 'UMatchaCharacterAnimInstanceVigil::bIsDetached' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceVigil, bIsReturning) == 0x000822, "Member 'UMatchaCharacterAnimInstanceVigil::bIsReturning' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterAnimInstanceVigil, bIsAttached) == 0x000823, "Member 'UMatchaCharacterAnimInstanceVigil::bIsAttached' has a wrong offset!");

// Class Matcha.MatchaCharacterBuff
// 0x0000 (0x0028 - 0x0028)
class UMatchaCharacterBuff : public UObject
{
public:
	float ModifyOutGoingHitBoxDamage(class AMatchaSnapNetCharacterEntity* BuffedCharacter, float BaseHitBoxDamage, EObjectRarity BuffRarity) const;
	void OnBuffApplied(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnBuffRefreshed(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnBuffRemoved(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnCharacterCrouchEnd(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnCharacterCrouchStart(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnCharacterEnteredKOZone(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnCharacterExitedKOZone(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnCharacterJump(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EJumpType JumpType, EObjectRarity BuffRarity) const;
	void OnCharacterLand(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EFallType FallTypeBeforeLand, EMatchaCharacterMontageType MontageBeforeLand, int32 MillisecondsInAirBeforeLand, EObjectRarity BuffRarity) const;
	void OnCharacterMontageEnd(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EMatchaCharacterMontageType MontageType, EObjectRarity BuffRarity) const;
	void OnCharacterMontageStart(class AMatchaSnapNetCharacterEntity* BuffedCharacter, float MontageDuration, EMatchaCharacterMontageType MontageType, EMatchaCharacterMontageType PreviousMontageType, EObjectRarity BuffRarity) const;
	void OnCharacterPeformedTech(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnCharacterShieldStateChanged(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EMatchaShieldState PreviousShieldState, EMatchaShieldState NewShieldState, EObjectRarity BuffRarity) const;
	void OnCharacterStartDash(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnCharacterStartDodge(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnCharacterStartGroundedJump(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnKnockedOutAnEnemyCharacter(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* EnemyCharacter, EObjectRarity BuffRarity) const;
	void OnMontageSpawnedHitBox(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EMatchaCharacterMontageType MontageType, int32 MontageHitBoxCount, EObjectRarity BuffRarity) const;
	void OnOtherBuffApplied(class AMatchaSnapNetCharacterEntity* BuffedCharacter, const class UMatchaCharacterBuff* OtherBuff, EObjectRarity OtherBuffRarity) const;
	void OnOtherBuffRemoved(class AMatchaSnapNetCharacterEntity* BuffedCharacter, const class UMatchaCharacterBuff* OtherBuff, EObjectRarity BuffRarity) const;
	void OnPerfectShield(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnPostApplyIncomingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* HitInstigator, const struct FMatchaHitData& TakenHitData, bool bDidResistWithSuperArmor, bool bWasStunHitInsteadOfKnockBack, float CombinedDamage, float CombinedShieldDamage, EObjectRarity BuffRarity) const;
	void OnPostApplyOutgoingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* TargetHit, class AActor* PreviousTargetHit, const struct FMatchaHitData& HitData, uint8 AppliedHitFlags, EMatchaCharacterMontageType MontageDuringHit, EObjectRarity BuffRarity) const;
	void OnPreApplyIncomingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnPreApplyOutgoingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;
	void OnShieldBlockedAHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* HitInstigator, float PreHitShieldHealth, bool bDidShieldBreak, float DamageShielded, bool bDidPerfectShieldHit, EObjectRarity BuffRarity) const;
	void OnSpawnedOwnedEntity(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* SpawnedEntity, EObjectRarity BuffRarity) const;
	void OnTechCanceledTumbling(class AMatchaSnapNetCharacterEntity* BuffedCharacter, EObjectRarity BuffRarity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCharacterBuff">();
	}
	static class UMatchaCharacterBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaCharacterBuff>();
	}
};
static_assert(alignof(UMatchaCharacterBuff) == 0x000008, "Wrong alignment on UMatchaCharacterBuff");
static_assert(sizeof(UMatchaCharacterBuff) == 0x000028, "Wrong size on UMatchaCharacterBuff");

// Class Matcha.MatchaCharacterLaunchComponent
// 0x0028 (0x00C8 - 0x00A0)
class UMatchaCharacterLaunchComponent final : public UActorComponent
{
public:
	float                                         LaunchSpeed;                                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LaunchAngle;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Gravity;                                           // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Deceleration;                                      // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELaunchType                                   LaunchType;                                        // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELaunchActionRestrictionType                  ActionRestrictionType;                             // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionRestrictionDuration;                         // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyIntangibility;                               // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDrawTotalTime;                                // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugDrawTimeStep;                                 // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PerformLaunch(class AMatchaCharacterBase* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCharacterLaunchComponent">();
	}
	static class UMatchaCharacterLaunchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaCharacterLaunchComponent>();
	}
};
static_assert(alignof(UMatchaCharacterLaunchComponent) == 0x000008, "Wrong alignment on UMatchaCharacterLaunchComponent");
static_assert(sizeof(UMatchaCharacterLaunchComponent) == 0x0000C8, "Wrong size on UMatchaCharacterLaunchComponent");
static_assert(offsetof(UMatchaCharacterLaunchComponent, LaunchSpeed) == 0x0000A0, "Member 'UMatchaCharacterLaunchComponent::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, LaunchAngle) == 0x0000A4, "Member 'UMatchaCharacterLaunchComponent::LaunchAngle' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, Gravity) == 0x0000A8, "Member 'UMatchaCharacterLaunchComponent::Gravity' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, Deceleration) == 0x0000AC, "Member 'UMatchaCharacterLaunchComponent::Deceleration' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, LaunchType) == 0x0000B0, "Member 'UMatchaCharacterLaunchComponent::LaunchType' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, ActionRestrictionType) == 0x0000B1, "Member 'UMatchaCharacterLaunchComponent::ActionRestrictionType' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, ActionRestrictionDuration) == 0x0000B4, "Member 'UMatchaCharacterLaunchComponent::ActionRestrictionDuration' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, bApplyIntangibility) == 0x0000B8, "Member 'UMatchaCharacterLaunchComponent::bApplyIntangibility' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, DebugDrawTotalTime) == 0x0000BC, "Member 'UMatchaCharacterLaunchComponent::DebugDrawTotalTime' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterLaunchComponent, DebugDrawTimeStep) == 0x0000C0, "Member 'UMatchaCharacterLaunchComponent::DebugDrawTimeStep' has a wrong offset!");

// Class Matcha.MatchaCharacterSelectMessage
// 0x0050 (0x0078 - 0x0028)
class UMatchaCharacterSelectMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  CharacterClassIdx;                                 // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                IsHovered;                                         // 0x0060(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCharacterSelectMessage">();
	}
	static class UMatchaCharacterSelectMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaCharacterSelectMessage>();
	}
};
static_assert(alignof(UMatchaCharacterSelectMessage) == 0x000008, "Wrong alignment on UMatchaCharacterSelectMessage");
static_assert(sizeof(UMatchaCharacterSelectMessage) == 0x000078, "Wrong size on UMatchaCharacterSelectMessage");
static_assert(offsetof(UMatchaCharacterSelectMessage, CharacterClassIdx) == 0x000028, "Member 'UMatchaCharacterSelectMessage::CharacterClassIdx' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterSelectMessage, IsHovered) == 0x000060, "Member 'UMatchaCharacterSelectMessage::IsHovered' has a wrong offset!");

// Class Matcha.MatchaSnapNetCustomInput
// 0x03D0 (0x03F8 - 0x0028)
class UMatchaSnapNetCustomInput final : public USnapNetCustomInput
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyFloat                  MoveStickX;                                        // 0x0030(0x0040)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  MoveStickY;                                        // 0x0070(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  AttackStickX;                                      // 0x00B0(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  AttackStickY;                                      // 0x00F0(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  TimeSinceLastMoveStickFlick;                       // 0x0130(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bMoveStickUpFlick;                                 // 0x0170(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bMoveStickDownFlick;                               // 0x0188(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bMoveStickRightFlick;                              // 0x01A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bMoveStickLeftFlick;                               // 0x01B8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bAttackStickUpFlick;                               // 0x01D0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bAttackStickDownFlick;                             // 0x01E8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bAttackStickRightFlick;                            // 0x0200(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bAttackStickLeftFlick;                             // 0x0218(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bJump;                                             // 0x0230(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bShortJump;                                        // 0x0248(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bAttack;                                           // 0x0260(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bSpecialAttack;                                    // 0x0278(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bEnergyModifier;                                   // 0x0290(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bShield;                                           // 0x02A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bGrab;                                             // 0x02C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bInteract;                                         // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bCameraMode;                                       // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bKeyboardHeavyAttack;                              // 0x0308(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bKeyboardHeavyAttackModifier;                      // 0x0320(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bKeyboardTeamAttack;                               // 0x0338(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bKeyboardEnergyBurst;                              // 0x0350(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bDPadLeft;                                         // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bDPadUp;                                           // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bDPadRight;                                        // 0x0398(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bDPadDown;                                         // 0x03B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bAutoDashSettingEnabled;                           // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bUseTiltAttacksOnAttackStick;                      // 0x03E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetCustomInput">();
	}
	static class UMatchaSnapNetCustomInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSnapNetCustomInput>();
	}
};
static_assert(alignof(UMatchaSnapNetCustomInput) == 0x000008, "Wrong alignment on UMatchaSnapNetCustomInput");
static_assert(sizeof(UMatchaSnapNetCustomInput) == 0x0003F8, "Wrong size on UMatchaSnapNetCustomInput");
static_assert(offsetof(UMatchaSnapNetCustomInput, MoveStickX) == 0x000030, "Member 'UMatchaSnapNetCustomInput::MoveStickX' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, MoveStickY) == 0x000070, "Member 'UMatchaSnapNetCustomInput::MoveStickY' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, AttackStickX) == 0x0000B0, "Member 'UMatchaSnapNetCustomInput::AttackStickX' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, AttackStickY) == 0x0000F0, "Member 'UMatchaSnapNetCustomInput::AttackStickY' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, TimeSinceLastMoveStickFlick) == 0x000130, "Member 'UMatchaSnapNetCustomInput::TimeSinceLastMoveStickFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bMoveStickUpFlick) == 0x000170, "Member 'UMatchaSnapNetCustomInput::bMoveStickUpFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bMoveStickDownFlick) == 0x000188, "Member 'UMatchaSnapNetCustomInput::bMoveStickDownFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bMoveStickRightFlick) == 0x0001A0, "Member 'UMatchaSnapNetCustomInput::bMoveStickRightFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bMoveStickLeftFlick) == 0x0001B8, "Member 'UMatchaSnapNetCustomInput::bMoveStickLeftFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bAttackStickUpFlick) == 0x0001D0, "Member 'UMatchaSnapNetCustomInput::bAttackStickUpFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bAttackStickDownFlick) == 0x0001E8, "Member 'UMatchaSnapNetCustomInput::bAttackStickDownFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bAttackStickRightFlick) == 0x000200, "Member 'UMatchaSnapNetCustomInput::bAttackStickRightFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bAttackStickLeftFlick) == 0x000218, "Member 'UMatchaSnapNetCustomInput::bAttackStickLeftFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bJump) == 0x000230, "Member 'UMatchaSnapNetCustomInput::bJump' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bShortJump) == 0x000248, "Member 'UMatchaSnapNetCustomInput::bShortJump' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bAttack) == 0x000260, "Member 'UMatchaSnapNetCustomInput::bAttack' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bSpecialAttack) == 0x000278, "Member 'UMatchaSnapNetCustomInput::bSpecialAttack' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bEnergyModifier) == 0x000290, "Member 'UMatchaSnapNetCustomInput::bEnergyModifier' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bShield) == 0x0002A8, "Member 'UMatchaSnapNetCustomInput::bShield' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bGrab) == 0x0002C0, "Member 'UMatchaSnapNetCustomInput::bGrab' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bInteract) == 0x0002D8, "Member 'UMatchaSnapNetCustomInput::bInteract' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bCameraMode) == 0x0002F0, "Member 'UMatchaSnapNetCustomInput::bCameraMode' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bKeyboardHeavyAttack) == 0x000308, "Member 'UMatchaSnapNetCustomInput::bKeyboardHeavyAttack' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bKeyboardHeavyAttackModifier) == 0x000320, "Member 'UMatchaSnapNetCustomInput::bKeyboardHeavyAttackModifier' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bKeyboardTeamAttack) == 0x000338, "Member 'UMatchaSnapNetCustomInput::bKeyboardTeamAttack' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bKeyboardEnergyBurst) == 0x000350, "Member 'UMatchaSnapNetCustomInput::bKeyboardEnergyBurst' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bDPadLeft) == 0x000368, "Member 'UMatchaSnapNetCustomInput::bDPadLeft' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bDPadUp) == 0x000380, "Member 'UMatchaSnapNetCustomInput::bDPadUp' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bDPadRight) == 0x000398, "Member 'UMatchaSnapNetCustomInput::bDPadRight' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bDPadDown) == 0x0003B0, "Member 'UMatchaSnapNetCustomInput::bDPadDown' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bAutoDashSettingEnabled) == 0x0003C8, "Member 'UMatchaSnapNetCustomInput::bAutoDashSettingEnabled' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCustomInput, bUseTiltAttacksOnAttackStick) == 0x0003E0, "Member 'UMatchaSnapNetCustomInput::bUseTiltAttacksOnAttackStick' has a wrong offset!");

// Class Matcha.MatchaCharacterUIData
// 0x0038 (0x00A0 - 0x0068)
class UMatchaCharacterUIData : public UOdyUIData
{
public:
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0068(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterClassChanged;                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaCharacterUIData">();
	}
	static class UMatchaCharacterUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaCharacterUIData>();
	}
};
static_assert(alignof(UMatchaCharacterUIData) == 0x000008, "Wrong alignment on UMatchaCharacterUIData");
static_assert(sizeof(UMatchaCharacterUIData) == 0x0000A0, "Wrong size on UMatchaCharacterUIData");
static_assert(offsetof(UMatchaCharacterUIData, CharacterClass) == 0x000068, "Member 'UMatchaCharacterUIData::CharacterClass' has a wrong offset!");
static_assert(offsetof(UMatchaCharacterUIData, OnCharacterClassChanged) == 0x000090, "Member 'UMatchaCharacterUIData::OnCharacterClassChanged' has a wrong offset!");

// Class Matcha.MatchaClientServices
// 0x1048 (0x1328 - 0x02E0)
class UMatchaClientServices final : public UOdyServicesModelBase
{
public:
	uint8                                         Pad_2E0[0x1010];                                   // 0x02E0(0x1010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaIdentityServiceModel*            IdentityServiceModel;                              // 0x12F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaLeaderboardServiceModel*         LeaderboardServiceModel;                           // 0x12F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaPartyServiceModel*               PartyServiceModel;                                 // 0x1300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaPlayersServiceModel*             PlayersServiceModel;                               // 0x1308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaRegionServiceModel*              RegionsServiceModel;                               // 0x1310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1318[0x10];                                    // 0x1318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLivenessTimerFired();
	void OnWebsocketConnectionStateChanged(class UOdyServicesModelBase* ModelBase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaClientServices">();
	}
	static class UMatchaClientServices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaClientServices>();
	}
};
static_assert(alignof(UMatchaClientServices) == 0x000008, "Wrong alignment on UMatchaClientServices");
static_assert(sizeof(UMatchaClientServices) == 0x001328, "Wrong size on UMatchaClientServices");
static_assert(offsetof(UMatchaClientServices, IdentityServiceModel) == 0x0012F0, "Member 'UMatchaClientServices::IdentityServiceModel' has a wrong offset!");
static_assert(offsetof(UMatchaClientServices, LeaderboardServiceModel) == 0x0012F8, "Member 'UMatchaClientServices::LeaderboardServiceModel' has a wrong offset!");
static_assert(offsetof(UMatchaClientServices, PartyServiceModel) == 0x001300, "Member 'UMatchaClientServices::PartyServiceModel' has a wrong offset!");
static_assert(offsetof(UMatchaClientServices, PlayersServiceModel) == 0x001308, "Member 'UMatchaClientServices::PlayersServiceModel' has a wrong offset!");
static_assert(offsetof(UMatchaClientServices, RegionsServiceModel) == 0x001310, "Member 'UMatchaClientServices::RegionsServiceModel' has a wrong offset!");

// Class Matcha.MatchaSaveGame
// 0x0038 (0x0060 - 0x0028)
class UMatchaSaveGame final : public USaveGame
{
public:
	class FString                                 PlayerId;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCharacterIndex;                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMasterVolume;                               // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMusicVolume;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSFXVolume;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryHeldSlotStackingMode                HeldSlotStackingMode;                              // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackStickMoveType                          AttackStickMoveType;                               // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSmashAttackFromMoveStickFlick;               // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDashSettingEnabled;                           // 0x005B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFrameRateCap                                 FrameRateCap;                                      // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSaveGame">();
	}
	static class UMatchaSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSaveGame>();
	}
};
static_assert(alignof(UMatchaSaveGame) == 0x000008, "Wrong alignment on UMatchaSaveGame");
static_assert(sizeof(UMatchaSaveGame) == 0x000060, "Wrong size on UMatchaSaveGame");
static_assert(offsetof(UMatchaSaveGame, PlayerId) == 0x000028, "Member 'UMatchaSaveGame::PlayerId' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, PlayerName) == 0x000038, "Member 'UMatchaSaveGame::PlayerName' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, SelectedCharacterIndex) == 0x000048, "Member 'UMatchaSaveGame::SelectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, CurrentMasterVolume) == 0x00004C, "Member 'UMatchaSaveGame::CurrentMasterVolume' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, CurrentMusicVolume) == 0x000050, "Member 'UMatchaSaveGame::CurrentMusicVolume' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, CurrentSFXVolume) == 0x000054, "Member 'UMatchaSaveGame::CurrentSFXVolume' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, HeldSlotStackingMode) == 0x000058, "Member 'UMatchaSaveGame::HeldSlotStackingMode' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, AttackStickMoveType) == 0x000059, "Member 'UMatchaSaveGame::AttackStickMoveType' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, bAllowSmashAttackFromMoveStickFlick) == 0x00005A, "Member 'UMatchaSaveGame::bAllowSmashAttackFromMoveStickFlick' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, bAutoDashSettingEnabled) == 0x00005B, "Member 'UMatchaSaveGame::bAutoDashSettingEnabled' has a wrong offset!");
static_assert(offsetof(UMatchaSaveGame, FrameRateCap) == 0x00005C, "Member 'UMatchaSaveGame::FrameRateCap' has a wrong offset!");

// Class Matcha.MatchaDebugChangeCharacter
// 0x0038 (0x0060 - 0x0028)
class UMatchaDebugChangeCharacter final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  NewCharacterEntityClassIndex;                      // 0x0028(0x0038)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugChangeCharacter">();
	}
	static class UMatchaDebugChangeCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugChangeCharacter>();
	}
};
static_assert(alignof(UMatchaDebugChangeCharacter) == 0x000008, "Wrong alignment on UMatchaDebugChangeCharacter");
static_assert(sizeof(UMatchaDebugChangeCharacter) == 0x000060, "Wrong size on UMatchaDebugChangeCharacter");
static_assert(offsetof(UMatchaDebugChangeCharacter, NewCharacterEntityClassIndex) == 0x000028, "Member 'UMatchaDebugChangeCharacter::NewCharacterEntityClassIndex' has a wrong offset!");

// Class Matcha.MatchaDebugChangeMapMessage
// 0x0038 (0x0060 - 0x0028)
class UMatchaDebugChangeMapMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  MapIndex;                                          // 0x0028(0x0038)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugChangeMapMessage">();
	}
	static class UMatchaDebugChangeMapMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugChangeMapMessage>();
	}
};
static_assert(alignof(UMatchaDebugChangeMapMessage) == 0x000008, "Wrong alignment on UMatchaDebugChangeMapMessage");
static_assert(sizeof(UMatchaDebugChangeMapMessage) == 0x000060, "Wrong size on UMatchaDebugChangeMapMessage");
static_assert(offsetof(UMatchaDebugChangeMapMessage, MapIndex) == 0x000028, "Member 'UMatchaDebugChangeMapMessage::MapIndex' has a wrong offset!");

// Class Matcha.MatchaSnapNetAbilitySystemGlobals
// 0x0000 (0x0240 - 0x0240)
class UMatchaSnapNetAbilitySystemGlobals final : public UMatchaAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetAbilitySystemGlobals">();
	}
	static class UMatchaSnapNetAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSnapNetAbilitySystemGlobals>();
	}
};
static_assert(alignof(UMatchaSnapNetAbilitySystemGlobals) == 0x000008, "Wrong alignment on UMatchaSnapNetAbilitySystemGlobals");
static_assert(sizeof(UMatchaSnapNetAbilitySystemGlobals) == 0x000240, "Wrong size on UMatchaSnapNetAbilitySystemGlobals");

// Class Matcha.MatchaDebugChangeTeam
// 0x0038 (0x0060 - 0x0028)
class UMatchaDebugChangeTeam final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  NewTeam;                                           // 0x0028(0x0038)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugChangeTeam">();
	}
	static class UMatchaDebugChangeTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugChangeTeam>();
	}
};
static_assert(alignof(UMatchaDebugChangeTeam) == 0x000008, "Wrong alignment on UMatchaDebugChangeTeam");
static_assert(sizeof(UMatchaDebugChangeTeam) == 0x000060, "Wrong size on UMatchaDebugChangeTeam");
static_assert(offsetof(UMatchaDebugChangeTeam, NewTeam) == 0x000028, "Member 'UMatchaDebugChangeTeam::NewTeam' has a wrong offset!");

// Class Matcha.MatchaDebugDestroyBot
// 0x0000 (0x0028 - 0x0028)
class UMatchaDebugDestroyBot final : public USnapNetReliableMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugDestroyBot">();
	}
	static class UMatchaDebugDestroyBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugDestroyBot>();
	}
};
static_assert(alignof(UMatchaDebugDestroyBot) == 0x000008, "Wrong alignment on UMatchaDebugDestroyBot");
static_assert(sizeof(UMatchaDebugDestroyBot) == 0x000028, "Wrong size on UMatchaDebugDestroyBot");

// Class Matcha.MatchaDebugEndMatchMessage
// 0x0000 (0x0028 - 0x0028)
class UMatchaDebugEndMatchMessage final : public USnapNetReliableMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugEndMatchMessage">();
	}
	static class UMatchaDebugEndMatchMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugEndMatchMessage>();
	}
};
static_assert(alignof(UMatchaDebugEndMatchMessage) == 0x000008, "Wrong alignment on UMatchaDebugEndMatchMessage");
static_assert(sizeof(UMatchaDebugEndMatchMessage) == 0x000028, "Wrong size on UMatchaDebugEndMatchMessage");

// Class Matcha.MatchaDebugEnergizeSlotMessage
// 0x0038 (0x0060 - 0x0028)
class UMatchaDebugEnergizeSlotMessage final : public USnapNetReliableMessage
{
public:
	struct FMatchaSnapNetGameplayTagProperty      Slot;                                              // 0x0028(0x0038)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugEnergizeSlotMessage">();
	}
	static class UMatchaDebugEnergizeSlotMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugEnergizeSlotMessage>();
	}
};
static_assert(alignof(UMatchaDebugEnergizeSlotMessage) == 0x000008, "Wrong alignment on UMatchaDebugEnergizeSlotMessage");
static_assert(sizeof(UMatchaDebugEnergizeSlotMessage) == 0x000060, "Wrong size on UMatchaDebugEnergizeSlotMessage");
static_assert(offsetof(UMatchaDebugEnergizeSlotMessage, Slot) == 0x000028, "Member 'UMatchaDebugEnergizeSlotMessage::Slot' has a wrong offset!");

// Class Matcha.MatchaDebugGiveCoinsMessage
// 0x0038 (0x0060 - 0x0028)
class UMatchaDebugGiveCoinsMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  CoinAmount;                                        // 0x0028(0x0038)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugGiveCoinsMessage">();
	}
	static class UMatchaDebugGiveCoinsMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugGiveCoinsMessage>();
	}
};
static_assert(alignof(UMatchaDebugGiveCoinsMessage) == 0x000008, "Wrong alignment on UMatchaDebugGiveCoinsMessage");
static_assert(sizeof(UMatchaDebugGiveCoinsMessage) == 0x000060, "Wrong size on UMatchaDebugGiveCoinsMessage");
static_assert(offsetof(UMatchaDebugGiveCoinsMessage, CoinAmount) == 0x000028, "Member 'UMatchaDebugGiveCoinsMessage::CoinAmount' has a wrong offset!");

// Class Matcha.MatchaDebugGiveItemMessage
// 0x0058 (0x0080 - 0x0028)
class UMatchaDebugGiveItemMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyPrimaryAsset           ItemAssetId;                                       // 0x0028(0x0058)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugGiveItemMessage">();
	}
	static class UMatchaDebugGiveItemMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugGiveItemMessage>();
	}
};
static_assert(alignof(UMatchaDebugGiveItemMessage) == 0x000008, "Wrong alignment on UMatchaDebugGiveItemMessage");
static_assert(sizeof(UMatchaDebugGiveItemMessage) == 0x000080, "Wrong size on UMatchaDebugGiveItemMessage");
static_assert(offsetof(UMatchaDebugGiveItemMessage, ItemAssetId) == 0x000028, "Member 'UMatchaDebugGiveItemMessage::ItemAssetId' has a wrong offset!");

// Class Matcha.MatchaDebugGivePowerSparksMessage
// 0x0038 (0x0060 - 0x0028)
class UMatchaDebugGivePowerSparksMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  PowerSparksAmount;                                 // 0x0028(0x0038)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugGivePowerSparksMessage">();
	}
	static class UMatchaDebugGivePowerSparksMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugGivePowerSparksMessage>();
	}
};
static_assert(alignof(UMatchaDebugGivePowerSparksMessage) == 0x000008, "Wrong alignment on UMatchaDebugGivePowerSparksMessage");
static_assert(sizeof(UMatchaDebugGivePowerSparksMessage) == 0x000060, "Wrong size on UMatchaDebugGivePowerSparksMessage");
static_assert(offsetof(UMatchaDebugGivePowerSparksMessage, PowerSparksAmount) == 0x000028, "Member 'UMatchaDebugGivePowerSparksMessage::PowerSparksAmount' has a wrong offset!");

// Class Matcha.MatchaDebugKOZoneTimingMessage
// 0x0058 (0x0080 - 0x0028)
class UMatchaDebugKOZoneTimingMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyFloat                  TimeScale;                                         // 0x0028(0x0040)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bSkipToNextPhase;                                  // 0x0068(0x0018)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugKOZoneTimingMessage">();
	}
	static class UMatchaDebugKOZoneTimingMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugKOZoneTimingMessage>();
	}
};
static_assert(alignof(UMatchaDebugKOZoneTimingMessage) == 0x000008, "Wrong alignment on UMatchaDebugKOZoneTimingMessage");
static_assert(sizeof(UMatchaDebugKOZoneTimingMessage) == 0x000080, "Wrong size on UMatchaDebugKOZoneTimingMessage");
static_assert(offsetof(UMatchaDebugKOZoneTimingMessage, TimeScale) == 0x000028, "Member 'UMatchaDebugKOZoneTimingMessage::TimeScale' has a wrong offset!");
static_assert(offsetof(UMatchaDebugKOZoneTimingMessage, bSkipToNextPhase) == 0x000068, "Member 'UMatchaDebugKOZoneTimingMessage::bSkipToNextPhase' has a wrong offset!");

// Class Matcha.MatchaSnapNetGameMode
// 0x0000 (0x0328 - 0x0328)
class AMatchaSnapNetGameMode : public ASnapNetGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetGameMode">();
	}
	static class AMatchaSnapNetGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetGameMode>();
	}
};
static_assert(alignof(AMatchaSnapNetGameMode) == 0x000008, "Wrong alignment on AMatchaSnapNetGameMode");
static_assert(sizeof(AMatchaSnapNetGameMode) == 0x000328, "Wrong size on AMatchaSnapNetGameMode");

// Class Matcha.MatchaDebugOverrideFinalZone
// 0x0038 (0x0060 - 0x0028)
class UMatchaDebugOverrideFinalZone final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  FinalZoneIndex;                                    // 0x0028(0x0038)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugOverrideFinalZone">();
	}
	static class UMatchaDebugOverrideFinalZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugOverrideFinalZone>();
	}
};
static_assert(alignof(UMatchaDebugOverrideFinalZone) == 0x000008, "Wrong alignment on UMatchaDebugOverrideFinalZone");
static_assert(sizeof(UMatchaDebugOverrideFinalZone) == 0x000060, "Wrong size on UMatchaDebugOverrideFinalZone");
static_assert(offsetof(UMatchaDebugOverrideFinalZone, FinalZoneIndex) == 0x000028, "Member 'UMatchaDebugOverrideFinalZone::FinalZoneIndex' has a wrong offset!");

// Class Matcha.MatchaDebugSetDamage
// 0x0070 (0x0098 - 0x0028)
class UMatchaDebugSetDamage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyFloat                  NewDamage;                                         // 0x0028(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyPlayerIndex            TargetPlayerIndex;                                 // 0x0068(0x0030)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugSetDamage">();
	}
	static class UMatchaDebugSetDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugSetDamage>();
	}
};
static_assert(alignof(UMatchaDebugSetDamage) == 0x000008, "Wrong alignment on UMatchaDebugSetDamage");
static_assert(sizeof(UMatchaDebugSetDamage) == 0x000098, "Wrong size on UMatchaDebugSetDamage");
static_assert(offsetof(UMatchaDebugSetDamage, NewDamage) == 0x000028, "Member 'UMatchaDebugSetDamage::NewDamage' has a wrong offset!");
static_assert(offsetof(UMatchaDebugSetDamage, TargetPlayerIndex) == 0x000068, "Member 'UMatchaDebugSetDamage::TargetPlayerIndex' has a wrong offset!");

// Class Matcha.MatchaDebugSetDisplayNameMessage
// 0x0030 (0x0058 - 0x0028)
class UMatchaDebugSetDisplayNameMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyString                 NewDisplayName;                                    // 0x0028(0x0030)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugSetDisplayNameMessage">();
	}
	static class UMatchaDebugSetDisplayNameMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugSetDisplayNameMessage>();
	}
};
static_assert(alignof(UMatchaDebugSetDisplayNameMessage) == 0x000008, "Wrong alignment on UMatchaDebugSetDisplayNameMessage");
static_assert(sizeof(UMatchaDebugSetDisplayNameMessage) == 0x000058, "Wrong size on UMatchaDebugSetDisplayNameMessage");
static_assert(offsetof(UMatchaDebugSetDisplayNameMessage, NewDisplayName) == 0x000028, "Member 'UMatchaDebugSetDisplayNameMessage::NewDisplayName' has a wrong offset!");

// Class Matcha.MatchaDebugShuffleTeams
// 0x0038 (0x0060 - 0x0028)
class UMatchaDebugShuffleTeams final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  NewTeamSize;                                       // 0x0028(0x0038)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugShuffleTeams">();
	}
	static class UMatchaDebugShuffleTeams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugShuffleTeams>();
	}
};
static_assert(alignof(UMatchaDebugShuffleTeams) == 0x000008, "Wrong alignment on UMatchaDebugShuffleTeams");
static_assert(sizeof(UMatchaDebugShuffleTeams) == 0x000060, "Wrong size on UMatchaDebugShuffleTeams");
static_assert(offsetof(UMatchaDebugShuffleTeams, NewTeamSize) == 0x000028, "Member 'UMatchaDebugShuffleTeams::NewTeamSize' has a wrong offset!");

// Class Matcha.MatchaSplineActor
// 0x0038 (0x02C8 - 0x0290)
class AMatchaSplineActor final : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimingCurve;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartHoldSeconds;                                  // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndHoldSeconds;                                    // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultRootComponent;                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            SplineMesh;                                        // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSplineMeshCustomDepthPass;                        // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SplineMeshCustomDepthStencilValue;                 // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESplineMeshAxis                               SplineMeshAxis;                                    // 0x02C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSplineActor">();
	}
	static class AMatchaSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSplineActor>();
	}
};
static_assert(alignof(AMatchaSplineActor) == 0x000008, "Wrong alignment on AMatchaSplineActor");
static_assert(sizeof(AMatchaSplineActor) == 0x0002C8, "Wrong size on AMatchaSplineActor");
static_assert(offsetof(AMatchaSplineActor, SplineComponent) == 0x000290, "Member 'AMatchaSplineActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSplineActor, TimingCurve) == 0x000298, "Member 'AMatchaSplineActor::TimingCurve' has a wrong offset!");
static_assert(offsetof(AMatchaSplineActor, StartHoldSeconds) == 0x0002A0, "Member 'AMatchaSplineActor::StartHoldSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaSplineActor, EndHoldSeconds) == 0x0002A4, "Member 'AMatchaSplineActor::EndHoldSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaSplineActor, DefaultRootComponent) == 0x0002A8, "Member 'AMatchaSplineActor::DefaultRootComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSplineActor, SplineMesh) == 0x0002B0, "Member 'AMatchaSplineActor::SplineMesh' has a wrong offset!");
static_assert(offsetof(AMatchaSplineActor, bSplineMeshCustomDepthPass) == 0x0002B8, "Member 'AMatchaSplineActor::bSplineMeshCustomDepthPass' has a wrong offset!");
static_assert(offsetof(AMatchaSplineActor, SplineMeshCustomDepthStencilValue) == 0x0002BC, "Member 'AMatchaSplineActor::SplineMeshCustomDepthStencilValue' has a wrong offset!");
static_assert(offsetof(AMatchaSplineActor, SplineMeshAxis) == 0x0002C0, "Member 'AMatchaSplineActor::SplineMeshAxis' has a wrong offset!");

// Class Matcha.MatchaDebugSkipCurrentMatchPhase
// 0x0000 (0x0028 - 0x0028)
class UMatchaDebugSkipCurrentMatchPhase final : public USnapNetReliableMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugSkipCurrentMatchPhase">();
	}
	static class UMatchaDebugSkipCurrentMatchPhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugSkipCurrentMatchPhase>();
	}
};
static_assert(alignof(UMatchaDebugSkipCurrentMatchPhase) == 0x000008, "Wrong alignment on UMatchaDebugSkipCurrentMatchPhase");
static_assert(sizeof(UMatchaDebugSkipCurrentMatchPhase) == 0x000028, "Wrong size on UMatchaDebugSkipCurrentMatchPhase");

// Class Matcha.MatchaDebugSpawnBot
// 0x00B8 (0x00E0 - 0x0028)
class UMatchaDebugSpawnBot final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyPosition               SpawnLocation;                                     // 0x0028(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyRotator                SpawnRotation;                                     // 0x0070(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  CharacterIndex;                                    // 0x00A8(0x0038)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugSpawnBot">();
	}
	static class UMatchaDebugSpawnBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugSpawnBot>();
	}
};
static_assert(alignof(UMatchaDebugSpawnBot) == 0x000008, "Wrong alignment on UMatchaDebugSpawnBot");
static_assert(sizeof(UMatchaDebugSpawnBot) == 0x0000E0, "Wrong size on UMatchaDebugSpawnBot");
static_assert(offsetof(UMatchaDebugSpawnBot, SpawnLocation) == 0x000028, "Member 'UMatchaDebugSpawnBot::SpawnLocation' has a wrong offset!");
static_assert(offsetof(UMatchaDebugSpawnBot, SpawnRotation) == 0x000070, "Member 'UMatchaDebugSpawnBot::SpawnRotation' has a wrong offset!");
static_assert(offsetof(UMatchaDebugSpawnBot, CharacterIndex) == 0x0000A8, "Member 'UMatchaDebugSpawnBot::CharacterIndex' has a wrong offset!");

// Class Matcha.MatchaDebugStartMatchMessage
// 0x0068 (0x0090 - 0x0028)
class UMatchaDebugStartMatchMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyBoolean                bAutoShuffleTeams;                                 // 0x0028(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  TeamSize;                                          // 0x0040(0x0038)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bSkipSpawnSelection;                               // 0x0078(0x0018)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugStartMatchMessage">();
	}
	static class UMatchaDebugStartMatchMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugStartMatchMessage>();
	}
};
static_assert(alignof(UMatchaDebugStartMatchMessage) == 0x000008, "Wrong alignment on UMatchaDebugStartMatchMessage");
static_assert(sizeof(UMatchaDebugStartMatchMessage) == 0x000090, "Wrong size on UMatchaDebugStartMatchMessage");
static_assert(offsetof(UMatchaDebugStartMatchMessage, bAutoShuffleTeams) == 0x000028, "Member 'UMatchaDebugStartMatchMessage::bAutoShuffleTeams' has a wrong offset!");
static_assert(offsetof(UMatchaDebugStartMatchMessage, TeamSize) == 0x000040, "Member 'UMatchaDebugStartMatchMessage::TeamSize' has a wrong offset!");
static_assert(offsetof(UMatchaDebugStartMatchMessage, bSkipSpawnSelection) == 0x000078, "Member 'UMatchaDebugStartMatchMessage::bSkipSpawnSelection' has a wrong offset!");

// Class Matcha.MatchaDebugStartServerProfileMessage
// 0x0048 (0x0070 - 0x0028)
class UMatchaDebugStartServerProfileMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyEnum                   ProfileType;                                       // 0x0028(0x0048)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugStartServerProfileMessage">();
	}
	static class UMatchaDebugStartServerProfileMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugStartServerProfileMessage>();
	}
};
static_assert(alignof(UMatchaDebugStartServerProfileMessage) == 0x000008, "Wrong alignment on UMatchaDebugStartServerProfileMessage");
static_assert(sizeof(UMatchaDebugStartServerProfileMessage) == 0x000070, "Wrong size on UMatchaDebugStartServerProfileMessage");
static_assert(offsetof(UMatchaDebugStartServerProfileMessage, ProfileType) == 0x000028, "Member 'UMatchaDebugStartServerProfileMessage::ProfileType' has a wrong offset!");

// Class Matcha.MatchaSnapNetStatics
// 0x0000 (0x0028 - 0x0028)
class UMatchaSnapNetStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector2D Conv_SnapNetPropertyVector2DToVector2D(const struct FSnapNetPropertyVector2D& SnapNetPropertyVector2D);
	static void DestroyEntity(const class UObject* WorldContextObject, int32 EntityIndex);
	static TSoftClassPtr<class UClass> GetCharacterEntityClassFromIndex(const class UObject* WorldContextObject, int32 ClassIndex);
	static int32 GetCharacterEntityClassIndex(const class UObject* WorldContextObject, const class AMatchaSnapNetCharacterEntity* CharacterEntity);
	static class AMatchaSnapNetCharacterEntity* GetCharacterEntityForFirstLocalPlayer(const class UObject* WorldContextObject);
	static class AMatchaSnapNetCharacterEntity* GetCharacterEntityForLocalPlayer(class ULocalPlayer* LocalPlayer);
	static class AMatchaSnapNetCharacterRenderer* GetCharacterRendererForFirstLocalPlayer(const class UObject* WorldContextObject);
	static class AMatchaSnapNetCharacterRenderer* GetCharacterRendererForLocalPlayer(class ULocalPlayer* LocalPlayer);
	static class UWorld* GetDebugVisualizerWorld(const class UObject* WorldContextObject);
	static class AActor* GetEntityByClass(const class UObject* WorldContextObject, const class UClass* EntityClass);
	static class AActor* GetEntityByIndex(const class UObject* WorldContextObject, int32 EntityIndex);
	static int32 GetEntityIndex(const class AActor* Actor);
	static class AActor* GetEntityRendererByIndex(const class UObject* WorldContextObject, int32 EntityIndex);
	static class USnapNetEntityRendererComponent* GetEntityRendererComponentByIndex(const class UObject* WorldContextObject, int32 EntityIndex);
	static class ULocalPlayer* GetFirstLocalPlayer(const class UObject* WorldContextObject);
	static int32 GetListenPort();
	static int32 GetLocalPlayerIndexForFirstLocalPlayer(const class UObject* WorldContextObject);
	static int32 GetLocalPlayerIndexForLocalPlayer(class ULocalPlayer* LocalPlayer);
	static class AMatchaSnapNetPlayerEntity* GetPlayerEntityForFirstLocalPlayer(const class UObject* WorldContextObject);
	static class AMatchaSnapNetPlayerEntity* GetPlayerEntityForLocalPlayer(class ULocalPlayer* LocalPlayer);
	static int32 GetPlayerIndexForFirstLocalPlayer(const class UObject* WorldContextObject);
	static int32 GetPlayerIndexForLocalPlayer(class ULocalPlayer* LocalPlayer);
	static ESnapNetSimulationFrameType GetSnapNetSimulationFrameType(const class UObject* WorldContextObject);
	static ESnapNetWorldType GetSnapNetWorldType(const class UObject* WorldContextObject);
	static int32 GetSpectatedCharacterEntityIndex(const class UObject* WorldContextObject);
	static int32 GetSpectatedPlayerIndex(const class UObject* WorldContextObject);
	static int32 GetSpectatedTeamNumber(const class UObject* WorldContextObject);
	static bool GetWorldRenderPositionForEntity(const class UObject* WorldContextObject, int32 EntityIndex, struct FVector* OutPosition);
	static bool GetWorldRenderPositionForPlayer(const class UObject* WorldContextObject, int32 PlayerIndex, struct FVector* OutPosition);
	static bool IsEntityIndexPropertyValid(const struct FSnapNetPropertyEntityIndex& EntityIndex);
	static bool IsEntityIndexValid(int32 EntityIndex);
	static bool IsEntityOnSpectatedTeam(int32 EntityIndex, const class UObject* WorldContextObject);
	static class AActor* SpawnEntity(const class UObject* WorldContextObject, const TSubclassOf<class AActor>& EntityTemplate, const struct FVector& Location, const struct FRotator& Rotation, int32 OwnerPlayerIndex);
	static class AActor* SpawnOwnedEntity(const TSubclassOf<class AActor>& EntityTemplate, const class AActor* OwnerActor, const struct FVector& Location, const struct FRotator& Rotation);
	static void SwitchSnapNetWorldType(const class UObject* WorldContextObject, ESnapNetWorldType* WorldType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetStatics">();
	}
	static class UMatchaSnapNetStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSnapNetStatics>();
	}
};
static_assert(alignof(UMatchaSnapNetStatics) == 0x000008, "Wrong alignment on UMatchaSnapNetStatics");
static_assert(sizeof(UMatchaSnapNetStatics) == 0x000028, "Wrong size on UMatchaSnapNetStatics");

// Class Matcha.MatchaDebugStopServerProfileMessage
// 0x0048 (0x0070 - 0x0028)
class UMatchaDebugStopServerProfileMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyEnum                   ProfileType;                                       // 0x0028(0x0048)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugStopServerProfileMessage">();
	}
	static class UMatchaDebugStopServerProfileMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugStopServerProfileMessage>();
	}
};
static_assert(alignof(UMatchaDebugStopServerProfileMessage) == 0x000008, "Wrong alignment on UMatchaDebugStopServerProfileMessage");
static_assert(sizeof(UMatchaDebugStopServerProfileMessage) == 0x000070, "Wrong size on UMatchaDebugStopServerProfileMessage");
static_assert(offsetof(UMatchaDebugStopServerProfileMessage, ProfileType) == 0x000028, "Member 'UMatchaDebugStopServerProfileMessage::ProfileType' has a wrong offset!");

// Class Matcha.MatchaDebugTeleportToRegion
// 0x0048 (0x0070 - 0x0028)
class UMatchaDebugTeleportToRegion final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyEnum                   SpawnRegion;                                       // 0x0028(0x0048)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDebugTeleportToRegion">();
	}
	static class UMatchaDebugTeleportToRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDebugTeleportToRegion>();
	}
};
static_assert(alignof(UMatchaDebugTeleportToRegion) == 0x000008, "Wrong alignment on UMatchaDebugTeleportToRegion");
static_assert(sizeof(UMatchaDebugTeleportToRegion) == 0x000070, "Wrong size on UMatchaDebugTeleportToRegion");
static_assert(offsetof(UMatchaDebugTeleportToRegion, SpawnRegion) == 0x000028, "Member 'UMatchaDebugTeleportToRegion::SpawnRegion' has a wrong offset!");

// Class Matcha.MatchaHitEntity
// 0x00C0 (0x0438 - 0x0378)
class AMatchaHitEntity : public AMatchaSnapNetEntity
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumLifespanSeconds;                            // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitEntityHitData>              HitBoxes;                                          // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanFriendlyFire;                                  // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEffectEventType                              EffectEventType;                                   // 0x0399(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39A[0x2];                                      // 0x039A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  DeathTime;                                         // 0x03A0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  CurrentTeamNumber;                                 // 0x03D8(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUnprocessedHitBoxData>         CurrentFrameOutgoingHits;                          // 0x0410(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              HitBoxesExtents;                                   // 0x0420(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaHitEntity">();
	}
	static class AMatchaHitEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaHitEntity>();
	}
};
static_assert(alignof(AMatchaHitEntity) == 0x000008, "Wrong alignment on AMatchaHitEntity");
static_assert(sizeof(AMatchaHitEntity) == 0x000438, "Wrong size on AMatchaHitEntity");
static_assert(offsetof(AMatchaHitEntity, MaximumLifespanSeconds) == 0x000380, "Member 'AMatchaHitEntity::MaximumLifespanSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaHitEntity, HitBoxes) == 0x000388, "Member 'AMatchaHitEntity::HitBoxes' has a wrong offset!");
static_assert(offsetof(AMatchaHitEntity, bCanFriendlyFire) == 0x000398, "Member 'AMatchaHitEntity::bCanFriendlyFire' has a wrong offset!");
static_assert(offsetof(AMatchaHitEntity, EffectEventType) == 0x000399, "Member 'AMatchaHitEntity::EffectEventType' has a wrong offset!");
static_assert(offsetof(AMatchaHitEntity, Weight) == 0x00039C, "Member 'AMatchaHitEntity::Weight' has a wrong offset!");
static_assert(offsetof(AMatchaHitEntity, DeathTime) == 0x0003A0, "Member 'AMatchaHitEntity::DeathTime' has a wrong offset!");
static_assert(offsetof(AMatchaHitEntity, CurrentTeamNumber) == 0x0003D8, "Member 'AMatchaHitEntity::CurrentTeamNumber' has a wrong offset!");
static_assert(offsetof(AMatchaHitEntity, CurrentFrameOutgoingHits) == 0x000410, "Member 'AMatchaHitEntity::CurrentFrameOutgoingHits' has a wrong offset!");
static_assert(offsetof(AMatchaHitEntity, HitBoxesExtents) == 0x000420, "Member 'AMatchaHitEntity::HitBoxesExtents' has a wrong offset!");

// Class Matcha.MatchaProjectileEntity
// 0x01E0 (0x0618 - 0x0438)
class AMatchaProjectileEntity : public AMatchaHitEntity
{
public:
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CustomSpeedOverTimeCurve;                          // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LaunchSpeed;                                       // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CustomAccelerationCurve;                           // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Acceleration;                                      // 0x0458(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              HorizontalVelocityLimits;                          // 0x0468(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              VerticalVelocityLimits;                            // 0x0478(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotationFollowsVelocity;                          // 0x0488(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FramesUntilActivation;                             // 0x048C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillZ;                                             // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyWhenMovementBlocked;                       // 0x0494(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyOnCharacterHit;                            // 0x0495(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplodesWhenDestroyed;                            // 0x0496(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPauseMovementOnDoorHit;                           // 0x0497(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyVelocity               Velocity;                                          // 0x0498(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FBuffInfo                              BuffToApplyOnHit;                                  // 0x04D0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCombinedFXInfo                        ExplosionFX;                                       // 0x04E0(0x0088)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ExplosionRadius;                                   // 0x0568(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBuffInfo                              BuffToApplyOnExplosion;                            // 0x056C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIgnoreHitActorOnExplosion;                        // 0x057C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActorFilterInfo                       ActorsToFilterForOnExplosion;                      // 0x057D(0x0006)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bLaunched;                                         // 0x0583(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchaProcessedHitInfo>        CurrentFrameIncomingHits;                          // 0x0588(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAppliedHitInfo>                RecentlyAppliedHits;                               // 0x0598(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsBeingReflected;                                 // 0x05A8(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  DamageMultiplierWhenReflected;                     // 0x05C0(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsPendingDestroyFromClankResult;                  // 0x0600(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ManualDetonateProjectile(bool bDisableAfterDetonation);
	void OnProjectileExplosion(class AActor* TargetHit);
	void OnProjectileHit(class AActor* HitActor, const struct FMatchaHitData& HitData);
	void SetVelocity(const struct FVector& Velocity_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaProjectileEntity">();
	}
	static class AMatchaProjectileEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaProjectileEntity>();
	}
};
static_assert(alignof(AMatchaProjectileEntity) == 0x000008, "Wrong alignment on AMatchaProjectileEntity");
static_assert(sizeof(AMatchaProjectileEntity) == 0x000618, "Wrong size on AMatchaProjectileEntity");
static_assert(offsetof(AMatchaProjectileEntity, CustomSpeedOverTimeCurve) == 0x000440, "Member 'AMatchaProjectileEntity::CustomSpeedOverTimeCurve' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, LaunchSpeed) == 0x000448, "Member 'AMatchaProjectileEntity::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, CustomAccelerationCurve) == 0x000450, "Member 'AMatchaProjectileEntity::CustomAccelerationCurve' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, Acceleration) == 0x000458, "Member 'AMatchaProjectileEntity::Acceleration' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, HorizontalVelocityLimits) == 0x000468, "Member 'AMatchaProjectileEntity::HorizontalVelocityLimits' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, VerticalVelocityLimits) == 0x000478, "Member 'AMatchaProjectileEntity::VerticalVelocityLimits' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bRotationFollowsVelocity) == 0x000488, "Member 'AMatchaProjectileEntity::bRotationFollowsVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, FramesUntilActivation) == 0x00048C, "Member 'AMatchaProjectileEntity::FramesUntilActivation' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, KillZ) == 0x000490, "Member 'AMatchaProjectileEntity::KillZ' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bDestroyWhenMovementBlocked) == 0x000494, "Member 'AMatchaProjectileEntity::bDestroyWhenMovementBlocked' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bDestroyOnCharacterHit) == 0x000495, "Member 'AMatchaProjectileEntity::bDestroyOnCharacterHit' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bExplodesWhenDestroyed) == 0x000496, "Member 'AMatchaProjectileEntity::bExplodesWhenDestroyed' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bPauseMovementOnDoorHit) == 0x000497, "Member 'AMatchaProjectileEntity::bPauseMovementOnDoorHit' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, Velocity) == 0x000498, "Member 'AMatchaProjectileEntity::Velocity' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, BuffToApplyOnHit) == 0x0004D0, "Member 'AMatchaProjectileEntity::BuffToApplyOnHit' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, ExplosionFX) == 0x0004E0, "Member 'AMatchaProjectileEntity::ExplosionFX' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, ExplosionRadius) == 0x000568, "Member 'AMatchaProjectileEntity::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, BuffToApplyOnExplosion) == 0x00056C, "Member 'AMatchaProjectileEntity::BuffToApplyOnExplosion' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bIgnoreHitActorOnExplosion) == 0x00057C, "Member 'AMatchaProjectileEntity::bIgnoreHitActorOnExplosion' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, ActorsToFilterForOnExplosion) == 0x00057D, "Member 'AMatchaProjectileEntity::ActorsToFilterForOnExplosion' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bLaunched) == 0x000583, "Member 'AMatchaProjectileEntity::bLaunched' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, CurrentFrameIncomingHits) == 0x000588, "Member 'AMatchaProjectileEntity::CurrentFrameIncomingHits' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, RecentlyAppliedHits) == 0x000598, "Member 'AMatchaProjectileEntity::RecentlyAppliedHits' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bIsBeingReflected) == 0x0005A8, "Member 'AMatchaProjectileEntity::bIsBeingReflected' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, DamageMultiplierWhenReflected) == 0x0005C0, "Member 'AMatchaProjectileEntity::DamageMultiplierWhenReflected' has a wrong offset!");
static_assert(offsetof(AMatchaProjectileEntity, bIsPendingDestroyFromClankResult) == 0x000600, "Member 'AMatchaProjectileEntity::bIsPendingDestroyFromClankResult' has a wrong offset!");

// Class Matcha.MatchaDestroyAttachedFXEvent
// 0x00C8 (0x00F8 - 0x0030)
class UMatchaDestroyAttachedFXEvent final : public USnapNetEvent
{
public:
	struct FSnapNetPropertyEntityIndex            SpawningEntity;                                    // 0x0030(0x0068)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyString                 NiagaraSystemId;                                   // 0x0098(0x0030)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyString                 AudioEventId;                                      // 0x00C8(0x0030)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaDestroyAttachedFXEvent">();
	}
	static class UMatchaDestroyAttachedFXEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaDestroyAttachedFXEvent>();
	}
};
static_assert(alignof(UMatchaDestroyAttachedFXEvent) == 0x000008, "Wrong alignment on UMatchaDestroyAttachedFXEvent");
static_assert(sizeof(UMatchaDestroyAttachedFXEvent) == 0x0000F8, "Wrong size on UMatchaDestroyAttachedFXEvent");
static_assert(offsetof(UMatchaDestroyAttachedFXEvent, SpawningEntity) == 0x000030, "Member 'UMatchaDestroyAttachedFXEvent::SpawningEntity' has a wrong offset!");
static_assert(offsetof(UMatchaDestroyAttachedFXEvent, NiagaraSystemId) == 0x000098, "Member 'UMatchaDestroyAttachedFXEvent::NiagaraSystemId' has a wrong offset!");
static_assert(offsetof(UMatchaDestroyAttachedFXEvent, AudioEventId) == 0x0000C8, "Member 'UMatchaDestroyAttachedFXEvent::AudioEventId' has a wrong offset!");

// Class Matcha.MatchaEntityRelevanceSubsystem
// 0x0148 (0x0188 - 0x0040)
class UMatchaEntityRelevanceSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x148];                                     // 0x0040(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaEntityRelevanceSubsystem">();
	}
	static class UMatchaEntityRelevanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaEntityRelevanceSubsystem>();
	}
};
static_assert(alignof(UMatchaEntityRelevanceSubsystem) == 0x000008, "Wrong alignment on UMatchaEntityRelevanceSubsystem");
static_assert(sizeof(UMatchaEntityRelevanceSubsystem) == 0x000188, "Wrong size on UMatchaEntityRelevanceSubsystem");

// Class Matcha.MatchaTriggerBox
// 0x0010 (0x02A0 - 0x0290)
class AMatchaTriggerBox final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          CollisionComponent;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaTriggerBox">();
	}
	static class AMatchaTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaTriggerBox>();
	}
};
static_assert(alignof(AMatchaTriggerBox) == 0x000008, "Wrong alignment on AMatchaTriggerBox");
static_assert(sizeof(AMatchaTriggerBox) == 0x0002A0, "Wrong size on AMatchaTriggerBox");
static_assert(offsetof(AMatchaTriggerBox, CollisionComponent) == 0x000298, "Member 'AMatchaTriggerBox::CollisionComponent' has a wrong offset!");

// Class Matcha.MatchaEnvironmentHazardsCommon
// 0x0000 (0x0028 - 0x0028)
class UMatchaEnvironmentHazardsCommon final : public UBlueprintFunctionLibrary
{
public:
	static void CharacterHazardOverlap(class AMatchaSnapNetCharacterEntity* Character, const struct FHitResult& HitResult);
	static class FName GetAlwaysKnockoutTag();
	static class FName GetMinimumDamageTag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaEnvironmentHazardsCommon">();
	}
	static class UMatchaEnvironmentHazardsCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaEnvironmentHazardsCommon>();
	}
};
static_assert(alignof(UMatchaEnvironmentHazardsCommon) == 0x000008, "Wrong alignment on UMatchaEnvironmentHazardsCommon");
static_assert(sizeof(UMatchaEnvironmentHazardsCommon) == 0x000028, "Wrong size on UMatchaEnvironmentHazardsCommon");

// Class Matcha.MatchaModalWidget
// 0x0000 (0x0448 - 0x0448)
class UMatchaModalWidget : public UOdyMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaModalWidget">();
	}
	static class UMatchaModalWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaModalWidget>();
	}
};
static_assert(alignof(UMatchaModalWidget) == 0x000008, "Wrong alignment on UMatchaModalWidget");
static_assert(sizeof(UMatchaModalWidget) == 0x000448, "Wrong size on UMatchaModalWidget");

// Class Matcha.MatchaErrorModalWidget
// 0x0048 (0x0490 - 0x0448)
class UMatchaErrorModalWidget final : public UMatchaModalWidget
{
public:
	class FText                                   ErrorTitle;                                        // 0x0448(0x0010)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   ErrorMessage;                                      // 0x0458(0x0010)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0468(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Path;                                              // 0x0470(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TraceId;                                           // 0x0480(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaErrorModalWidget">();
	}
	static class UMatchaErrorModalWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaErrorModalWidget>();
	}
};
static_assert(alignof(UMatchaErrorModalWidget) == 0x000008, "Wrong alignment on UMatchaErrorModalWidget");
static_assert(sizeof(UMatchaErrorModalWidget) == 0x000490, "Wrong size on UMatchaErrorModalWidget");
static_assert(offsetof(UMatchaErrorModalWidget, ErrorTitle) == 0x000448, "Member 'UMatchaErrorModalWidget::ErrorTitle' has a wrong offset!");
static_assert(offsetof(UMatchaErrorModalWidget, ErrorMessage) == 0x000458, "Member 'UMatchaErrorModalWidget::ErrorMessage' has a wrong offset!");
static_assert(offsetof(UMatchaErrorModalWidget, ErrorCode) == 0x000468, "Member 'UMatchaErrorModalWidget::ErrorCode' has a wrong offset!");
static_assert(offsetof(UMatchaErrorModalWidget, Path) == 0x000470, "Member 'UMatchaErrorModalWidget::Path' has a wrong offset!");
static_assert(offsetof(UMatchaErrorModalWidget, TraceId) == 0x000480, "Member 'UMatchaErrorModalWidget::TraceId' has a wrong offset!");

// Class Matcha.MatchaPlayerControllerBase
// 0x0018 (0x0870 - 0x0858)
class AMatchaPlayerControllerBase : public APlayerController
{
public:
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputMappingContext*                   CurrentInputMappingContext;                        // 0x0860(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputMethodChanged(EInputMethod InputMethod);
	void SetImguiEnabled(bool bImguiEnabled);
	void SetSelectedCharacter(const TSoftClassPtr<class UClass>& CharacterClass);
	void TravelTo(const class FString& URL);

	const class UInputMappingContext* GetCurrentInputMappingContext() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPlayerControllerBase">();
	}
	static class AMatchaPlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaPlayerControllerBase>();
	}
};
static_assert(alignof(AMatchaPlayerControllerBase) == 0x000008, "Wrong alignment on AMatchaPlayerControllerBase");
static_assert(sizeof(AMatchaPlayerControllerBase) == 0x000870, "Wrong size on AMatchaPlayerControllerBase");
static_assert(offsetof(AMatchaPlayerControllerBase, CurrentInputMappingContext) == 0x000860, "Member 'AMatchaPlayerControllerBase::CurrentInputMappingContext' has a wrong offset!");

// Class Matcha.MatchaFrontEndPlayerController
// 0x0000 (0x0870 - 0x0870)
class AMatchaFrontEndPlayerController final : public AMatchaPlayerControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaFrontEndPlayerController">();
	}
	static class AMatchaFrontEndPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaFrontEndPlayerController>();
	}
};
static_assert(alignof(AMatchaFrontEndPlayerController) == 0x000008, "Wrong alignment on AMatchaFrontEndPlayerController");
static_assert(sizeof(AMatchaFrontEndPlayerController) == 0x000870, "Wrong size on AMatchaFrontEndPlayerController");

// Class Matcha.MatchaFXEvent
// 0x0480 (0x04B0 - 0x0030)
class UMatchaFXEvent final : public USnapNetEvent
{
public:
	struct FSnapNetPropertyEntityIndex            SpawningEntity;                                    // 0x0030(0x0068)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            AssociatedEntity;                                  // 0x0098(0x0068)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   EffectEventType;                                   // 0x0100(0x0048)(Transient, NativeAccessSpecifierPublic)
	struct FVFXInfo                               NiagaraSystemToSpawn;                              // 0x0148(0x01F8)(Transient, NativeAccessSpecifierPublic)
	struct FSFXInfo                               SoundToPlay;                                       // 0x0340(0x0160)(Transient, NativeAccessSpecifierPublic)
	int32                                         AudioEventPlayingId;                               // 0x04A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      SpawnedNiagaraComponent;                           // 0x04A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaFXEvent">();
	}
	static class UMatchaFXEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaFXEvent>();
	}
};
static_assert(alignof(UMatchaFXEvent) == 0x000008, "Wrong alignment on UMatchaFXEvent");
static_assert(sizeof(UMatchaFXEvent) == 0x0004B0, "Wrong size on UMatchaFXEvent");
static_assert(offsetof(UMatchaFXEvent, SpawningEntity) == 0x000030, "Member 'UMatchaFXEvent::SpawningEntity' has a wrong offset!");
static_assert(offsetof(UMatchaFXEvent, AssociatedEntity) == 0x000098, "Member 'UMatchaFXEvent::AssociatedEntity' has a wrong offset!");
static_assert(offsetof(UMatchaFXEvent, EffectEventType) == 0x000100, "Member 'UMatchaFXEvent::EffectEventType' has a wrong offset!");
static_assert(offsetof(UMatchaFXEvent, NiagaraSystemToSpawn) == 0x000148, "Member 'UMatchaFXEvent::NiagaraSystemToSpawn' has a wrong offset!");
static_assert(offsetof(UMatchaFXEvent, SoundToPlay) == 0x000340, "Member 'UMatchaFXEvent::SoundToPlay' has a wrong offset!");
static_assert(offsetof(UMatchaFXEvent, AudioEventPlayingId) == 0x0004A0, "Member 'UMatchaFXEvent::AudioEventPlayingId' has a wrong offset!");
static_assert(offsetof(UMatchaFXEvent, SpawnedNiagaraComponent) == 0x0004A8, "Member 'UMatchaFXEvent::SpawnedNiagaraComponent' has a wrong offset!");

// Class Matcha.MatchaSingleStageServerScript
// 0x0030 (0x0300 - 0x02D0)
class UMatchaSingleStageServerScript final : public UMatchaServerScript
{
public:
	TArray<class AMatchaPlayerStart*>             CachedSpawnPoints;                                 // 0x02D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   Team1StartTag;                                     // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Team2StartTag;                                     // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpectatorStartTag;                                 // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnIntangibilitySeconds;                       // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSingleStageServerScript">();
	}
	static class UMatchaSingleStageServerScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSingleStageServerScript>();
	}
};
static_assert(alignof(UMatchaSingleStageServerScript) == 0x000008, "Wrong alignment on UMatchaSingleStageServerScript");
static_assert(sizeof(UMatchaSingleStageServerScript) == 0x000300, "Wrong size on UMatchaSingleStageServerScript");
static_assert(offsetof(UMatchaSingleStageServerScript, CachedSpawnPoints) == 0x0002D0, "Member 'UMatchaSingleStageServerScript::CachedSpawnPoints' has a wrong offset!");
static_assert(offsetof(UMatchaSingleStageServerScript, Team1StartTag) == 0x0002E0, "Member 'UMatchaSingleStageServerScript::Team1StartTag' has a wrong offset!");
static_assert(offsetof(UMatchaSingleStageServerScript, Team2StartTag) == 0x0002E8, "Member 'UMatchaSingleStageServerScript::Team2StartTag' has a wrong offset!");
static_assert(offsetof(UMatchaSingleStageServerScript, SpectatorStartTag) == 0x0002F0, "Member 'UMatchaSingleStageServerScript::SpectatorStartTag' has a wrong offset!");
static_assert(offsetof(UMatchaSingleStageServerScript, RespawnIntangibilitySeconds) == 0x0002F8, "Member 'UMatchaSingleStageServerScript::RespawnIntangibilitySeconds' has a wrong offset!");

// Class Matcha.MatchaGameEntityRenderer
// 0x0000 (0x02A0 - 0x02A0)
class AMatchaGameEntityRenderer final : public AMatchaSnapNetRenderer
{
public:
	static class AMatchaGameEntityRenderer* Get(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameEntityRenderer">();
	}
	static class AMatchaGameEntityRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaGameEntityRenderer>();
	}
};
static_assert(alignof(AMatchaGameEntityRenderer) == 0x000008, "Wrong alignment on AMatchaGameEntityRenderer");
static_assert(sizeof(AMatchaGameEntityRenderer) == 0x0002A0, "Wrong size on AMatchaGameEntityRenderer");

// Class Matcha.MatchaGameliftSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UMatchaGameliftSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0xB0];                                      // 0x0030(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameliftSubsystem">();
	}
	static class UMatchaGameliftSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameliftSubsystem>();
	}
};
static_assert(alignof(UMatchaGameliftSubsystem) == 0x000008, "Wrong alignment on UMatchaGameliftSubsystem");
static_assert(sizeof(UMatchaGameliftSubsystem) == 0x0000E0, "Wrong size on UMatchaGameliftSubsystem");

// Class Matcha.MatchaGameplayAction
// 0x0000 (0x0028 - 0x0028)
class UMatchaGameplayAction final : public UObject
{
public:
	void HandleGameplayEvent(const struct FMatchaGameplayEvent& Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayAction">();
	}
	static class UMatchaGameplayAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayAction>();
	}
};
static_assert(alignof(UMatchaGameplayAction) == 0x000008, "Wrong alignment on UMatchaGameplayAction");
static_assert(sizeof(UMatchaGameplayAction) == 0x000028, "Wrong size on UMatchaGameplayAction");

// Class Matcha.MatchaGameplayEffectsComponent
// 0x04A0 (0x0540 - 0x00A0)
class UMatchaGameplayEffectsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x90];                                      // 0x00A0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchaActiveGameplayEffectsContainer  ActiveGameplayEffects;                             // 0x0130(0x02B0)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x160];                                    // 0x03E0(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEffectsComponent">();
	}
	static class UMatchaGameplayEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEffectsComponent>();
	}
};
static_assert(alignof(UMatchaGameplayEffectsComponent) == 0x000008, "Wrong alignment on UMatchaGameplayEffectsComponent");
static_assert(sizeof(UMatchaGameplayEffectsComponent) == 0x000540, "Wrong size on UMatchaGameplayEffectsComponent");
static_assert(offsetof(UMatchaGameplayEffectsComponent, ActiveGameplayEffects) == 0x000130, "Member 'UMatchaGameplayEffectsComponent::ActiveGameplayEffects' has a wrong offset!");

// Class Matcha.MatchaTrapEntity
// 0x0020 (0x0398 - 0x0378)
class AMatchaTrapEntity : public AMatchaSnapNetEntity
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanFriendlyFire;                                  // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x17];                                     // 0x0381(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterOverlapContinued(class AMatchaSnapNetCharacterEntity* OverlappedCharacter, float ElapsedOverlapTime);
	void OnCharacterOverlapEnded(class AMatchaSnapNetCharacterEntity* OverlappedCharacter);
	void OnCharacterOverlapStarted(class AMatchaSnapNetCharacterEntity* OverlappedCharacter);

	TArray<class AMatchaSnapNetCharacterEntity*> GetOverlappingCharacters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaTrapEntity">();
	}
	static class AMatchaTrapEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaTrapEntity>();
	}
};
static_assert(alignof(AMatchaTrapEntity) == 0x000008, "Wrong alignment on AMatchaTrapEntity");
static_assert(sizeof(AMatchaTrapEntity) == 0x000398, "Wrong size on AMatchaTrapEntity");
static_assert(offsetof(AMatchaTrapEntity, bCanFriendlyFire) == 0x000380, "Member 'AMatchaTrapEntity::bCanFriendlyFire' has a wrong offset!");

// Class Matcha.MatchaGameplayEventSubsystem
// 0x00A0 (0x00D0 - 0x0030)
class UMatchaGameplayEventSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastGameplayEvent(const struct FGameplayTag& Channel, const struct FMatchaGameplayEvent& GameplayEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayEventSubsystem">();
	}
	static class UMatchaGameplayEventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayEventSubsystem>();
	}
};
static_assert(alignof(UMatchaGameplayEventSubsystem) == 0x000008, "Wrong alignment on UMatchaGameplayEventSubsystem");
static_assert(sizeof(UMatchaGameplayEventSubsystem) == 0x0000D0, "Wrong size on UMatchaGameplayEventSubsystem");

// Class Matcha.CanBeHit
// 0x0000 (0x0028 - 0x0028)
class ICanBeHit final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanBeHit">();
	}
	static class ICanBeHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanBeHit>();
	}
};
static_assert(alignof(ICanBeHit) == 0x000008, "Wrong alignment on ICanBeHit");
static_assert(sizeof(ICanBeHit) == 0x000028, "Wrong size on ICanBeHit");

// Class Matcha.EnvironmentHazard
// 0x0000 (0x0028 - 0x0028)
class IEnvironmentHazard final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentHazard">();
	}
	static class IEnvironmentHazard* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEnvironmentHazard>();
	}
};
static_assert(alignof(IEnvironmentHazard) == 0x000008, "Wrong alignment on IEnvironmentHazard");
static_assert(sizeof(IEnvironmentHazard) == 0x000028, "Wrong size on IEnvironmentHazard");

// Class Matcha.CanBeKnockedOut
// 0x0000 (0x0028 - 0x0028)
class ICanBeKnockedOut final : public IInterface
{
public:
	void ProcessKnockout(const class AActor* Instigator, const struct FVector& KnockoutNormal, const struct FVector& TraceDirection);

	bool CanBeKnockedOut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanBeKnockedOut">();
	}
	static class ICanBeKnockedOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanBeKnockedOut>();
	}
};
static_assert(alignof(ICanBeKnockedOut) == 0x000008, "Wrong alignment on ICanBeKnockedOut");
static_assert(sizeof(ICanBeKnockedOut) == 0x000028, "Wrong size on ICanBeKnockedOut");

// Class Matcha.CanBeInteractedWith
// 0x0000 (0x0028 - 0x0028)
class ICanBeInteractedWith final : public IInterface
{
public:
	void AfterInteractionCancelledOrCompleted(class AActor* InteractingActor, bool bWasCancelled);
	void AfterInteractionStarted(class AActor* InteractingActor);
	void InteractionCancelled(class AActor* InteractingActor);
	void InteractionCompleted(class AActor* InteractingActor);
	void InteractionProgressed(class AActor* InteractingActor, float InteractionProgressTimeSeconds);

	bool CanStartInteraction(class AActor* InteractingActor) const;
	int32 GetInteractionPriority(class AActor* InteractingActor) const;
	struct FMatchaInteractionRequirements GetInteractionRequirements() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanBeInteractedWith">();
	}
	static class ICanBeInteractedWith* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanBeInteractedWith>();
	}
};
static_assert(alignof(ICanBeInteractedWith) == 0x000008, "Wrong alignment on ICanBeInteractedWith");
static_assert(sizeof(ICanBeInteractedWith) == 0x000028, "Wrong size on ICanBeInteractedWith");

// Class Matcha.InteractionTargetRenderer
// 0x0000 (0x0028 - 0x0028)
class IInteractionTargetRenderer final : public IInterface
{
public:
	void SetTargeted(bool bNewTargeted);

	struct FInteractionProgressData GetInteractionProgressData(const class AActor* InteractingRenderer) const;
	struct FVector GetInteractionPromptLocation(const class AActor* InteractingRenderer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionTargetRenderer">();
	}
	static class IInteractionTargetRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionTargetRenderer>();
	}
};
static_assert(alignof(IInteractionTargetRenderer) == 0x000008, "Wrong alignment on IInteractionTargetRenderer");
static_assert(sizeof(IInteractionTargetRenderer) == 0x000028, "Wrong size on IInteractionTargetRenderer");

// Class Matcha.CameraTarget
// 0x0000 (0x0028 - 0x0028)
class ICameraTarget final : public IInterface
{
public:
	struct FVector GetCameraViewTargetOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraTarget">();
	}
	static class ICameraTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICameraTarget>();
	}
};
static_assert(alignof(ICameraTarget) == 0x000008, "Wrong alignment on ICameraTarget");
static_assert(sizeof(ICameraTarget) == 0x000028, "Wrong size on ICameraTarget");

// Class Matcha.CanAttachFX
// 0x0000 (0x0028 - 0x0028)
class ICanAttachFX final : public IInterface
{
public:
	class USceneComponent* GetFXAttachmentComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanAttachFX">();
	}
	static class ICanAttachFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanAttachFX>();
	}
};
static_assert(alignof(ICanAttachFX) == 0x000008, "Wrong alignment on ICanAttachFX");
static_assert(sizeof(ICanAttachFX) == 0x000028, "Wrong size on ICanAttachFX");

// Class Matcha.MatchaEntityCommon
// 0x0000 (0x0028 - 0x0028)
class IMatchaEntityCommon final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaEntityCommon">();
	}
	static class IMatchaEntityCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchaEntityCommon>();
	}
};
static_assert(alignof(IMatchaEntityCommon) == 0x000008, "Wrong alignment on IMatchaEntityCommon");
static_assert(sizeof(IMatchaEntityCommon) == 0x000028, "Wrong size on IMatchaEntityCommon");

// Class Matcha.CanBeTriggered
// 0x0000 (0x0028 - 0x0028)
class ICanBeTriggered final : public IInterface
{
public:
	void OnTriggered(class AActor* OverlappingActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanBeTriggered">();
	}
	static class ICanBeTriggered* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanBeTriggered>();
	}
};
static_assert(alignof(ICanBeTriggered) == 0x000008, "Wrong alignment on ICanBeTriggered");
static_assert(sizeof(ICanBeTriggered) == 0x000028, "Wrong size on ICanBeTriggered");

// Class Matcha.CanBeReset
// 0x0000 (0x0028 - 0x0028)
class ICanBeReset final : public IInterface
{
public:
	void HandleReset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanBeReset">();
	}
	static class ICanBeReset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanBeReset>();
	}
};
static_assert(alignof(ICanBeReset) == 0x000008, "Wrong alignment on ICanBeReset");
static_assert(sizeof(ICanBeReset) == 0x000028, "Wrong size on ICanBeReset");

// Class Matcha.CanBroadcastGameplayEvents
// 0x0000 (0x0028 - 0x0028)
class ICanBroadcastGameplayEvents final : public IInterface
{
public:
	struct FGameplayTag GetBroadcastChannel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanBroadcastGameplayEvents">();
	}
	static class ICanBroadcastGameplayEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanBroadcastGameplayEvents>();
	}
};
static_assert(alignof(ICanBroadcastGameplayEvents) == 0x000008, "Wrong alignment on ICanBroadcastGameplayEvents");
static_assert(sizeof(ICanBroadcastGameplayEvents) == 0x000028, "Wrong size on ICanBroadcastGameplayEvents");

// Class Matcha.InventoryProvider
// 0x0000 (0x0028 - 0x0028)
class IInventoryProvider final : public IInterface
{
public:
	class UMatchaInventoryComponent* GetInventoryComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryProvider">();
	}
	static class IInventoryProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInventoryProvider>();
	}
};
static_assert(alignof(IInventoryProvider) == 0x000008, "Wrong alignment on IInventoryProvider");
static_assert(sizeof(IInventoryProvider) == 0x000028, "Wrong size on IInventoryProvider");

// Class Matcha.ContextReceiver
// 0x0000 (0x0028 - 0x0028)
class IContextReceiver final : public IInterface
{
public:
	void OnReceiveIntContext(int32 Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextReceiver">();
	}
	static class IContextReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContextReceiver>();
	}
};
static_assert(alignof(IContextReceiver) == 0x000008, "Wrong alignment on IContextReceiver");
static_assert(sizeof(IContextReceiver) == 0x000028, "Wrong size on IContextReceiver");

// Class Matcha.ScheduledObjective
// 0x0000 (0x0028 - 0x0028)
class IScheduledObjective final : public IInterface
{
public:
	void BeginScheduledObjective();

	class FString GetScheduledObjectiveDisplayText() const;
	EScheduledObjectiveType GetScheduledObjectiveType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScheduledObjective">();
	}
	static class IScheduledObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScheduledObjective>();
	}
};
static_assert(alignof(IScheduledObjective) == 0x000008, "Wrong alignment on IScheduledObjective");
static_assert(sizeof(IScheduledObjective) == 0x000028, "Wrong size on IScheduledObjective");

// Class Matcha.CanBeReflected
// 0x0000 (0x0028 - 0x0028)
class ICanBeReflected final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanBeReflected">();
	}
	static class ICanBeReflected* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanBeReflected>();
	}
};
static_assert(alignof(ICanBeReflected) == 0x000008, "Wrong alignment on ICanBeReflected");
static_assert(sizeof(ICanBeReflected) == 0x000028, "Wrong size on ICanBeReflected");

// Class Matcha.MatchaGameplayStatics
// 0x0000 (0x0028 - 0x0028)
class UMatchaGameplayStatics final : public UBlueprintFunctionLibrary
{
public:
	static TSoftClassPtr<class UClass> CharacterIndexToCharacterClass(const class UObject* WorldContextObject, int32 CharacterIdx);
	static int32 ConvertFramesToMilliseconds(int32 Frames);
	static int32 ConvertSecondsToFrames(float Seconds);
	static int32 ConvertSecondsToMilliseconds(float Seconds);
	static void DestroyAttachedFXFromEntity(const class AActor* SpawningEntity, const class FName& NiagaraSystemId, const class FName& AudioEventId);
	static void FilterActorsFromArray(int32 InputTeamNumber, const TArray<class AActor*>& InputActors, TArray<class AActor*>* FilteredActors, ETeamFilter TeamFilter, EAliveState AliveStateFilter, bool bShouldFilterForShieldState, EMatchaShieldState ShieldStateFilter, bool bFilterNotIntangible);
	static void FilterActorsFromArrayWithFilterInfo(int32 InputTeamNumber, const TArray<class AActor*>& InputActors, const struct FActorFilterInfo& ActorFilterInfo, TArray<class AActor*>* OutFilteredActors);
	static bool FindClosestEmptySpaceBetweenLocationsForCharacter(const class UObject* WorldContextObject, struct FVector* OutLocation, const struct FVector& InitialDesiredLocation, const struct FVector& FinalDesiredLocation, const struct FQuat& Rotation, float CapsuleRadius, float CapsuleHalfHeight, const TArray<class AActor*>& ActorsToIgnore, bool bAvoidInstantKOZones, bool bAvoidTwoWayPlatforms, bool bAvoidCharacters, bool bShowDebug, float DebugTime);
	static void FindFilteredActorsInRadius(const class UObject* WorldContextObject, const class AActor* Instigator, const struct FVector& Location, float Radius, int32 InputTeamNumber, const struct FActorFilterInfo& ActorFilterInfo, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* FilteredActors);
	static struct FVector2D Get2DLocation(const class AActor* Actor);
	static const class UAkRtpc* GetAllyRTPC(const class UObject* WorldContextObject);
	static class UAkAudioEvent* GetAudioEventFromId(class FName AudioEventId, EEffectEventType EffectEventType, const class AActor* SpawningRenderer, int32 AssociatedEntityIndex);
	static const TArray<TSoftClassPtr<class UClass>> GetAvailableCharacters(const class UObject* WorldContextObject);
	static class UMatchaClientServices* GetClientServies(const class UObject* WorldContextObject);
	static float GetClosestAngleBetweenNormalizedVectors(const struct FVector& A, const struct FVector& B);
	static const struct FLinearColor GetColorForTeamNumber(const class UObject* WorldContextObject, int32 TeamNumber);
	static int32 GetCurrentTeamForActor(const class AActor* AActor);
	static class FText GetDisplayNameForRegion(const class UObject* WorldContextObject, ESpawnRegion SpawnRegion);
	static void GetEnvironmentHazardOverlapsBox(const class UObject* WorldContextObject, TArray<struct FEnvironmentOverlapResult>* Results, const struct FVector& Position, const struct FQuat& Rotation, const struct FVector& BoxHalfSize, const TArray<class FName>& IgnoreTags, const class AActor* IgnoreActor);
	static void GetEnvironmentHazardOverlapsCapsule(const class UObject* WorldContextObject, TArray<struct FEnvironmentOverlapResult>* Results, const struct FVector& Position, const struct FQuat& Rotation, float CapsuleRadius, float CapsuleHalfHeight, const TArray<class FName>& IgnoreTags, const class AActor* IgnoreActor);
	static void GetEnvironmentHazardOverlapsSphere(const class UObject* WorldContextObject, TArray<struct FEnvironmentOverlapResult>* Results, const struct FVector& Position, const struct FQuat& Rotation, float SphereRadius, const TArray<class FName>& IgnoreTags, const class AActor* IgnoreActor);
	static struct FVector GetKnockBackUnitDirectionForAngle(const float HitAngle, const bool bIsFacingRight);
	static const class UAkRtpc* GetLocallySpectatedRTPC(const class UObject* WorldContextObject);
	static class UMatchaSnapNetGameInstance* GetMatchaSnapNetGameInstance(const class UObject* WorldContextObject);
	static class UNiagaraSystem* GetNiagaraSystemFromId(class FName NiagaraSystemId, EEffectEventType EffectEventType, const class AActor* SpawningRenderer, int32 AssociatedEntityIndex);
	static float GetNormalizedAngleBetweenNormalizedVectors(const struct FVector& A, const struct FVector& B);
	static class FString GetOfflineMapPath();
	static class USceneComponent* GetRendererFXAttachComponent(const class AActor* RendererActor);
	static struct FRotator GetRotationTowards(const class AActor* Actor, const class AActor* OtherActor);
	static int32 GetTickRateIntendedDeltaMilliseconds();
	static float GetTickRateIntendedDeltaTime();
	static void GetUISelectableSpawnRegions(const class UObject* WorldContextObject, TArray<ESpawnRegion>* OutSelectableSpawnRegions, bool bIncludeRandom);
	static float GetVectorSideFromAnotherCCW(const struct FVector& A, const struct FVector& B);
	static bool HasQueuedJump(uint8 QueuedJumpFlags);
	static bool IsActorFacingTowardsOtherActor(const class AActor* Actor, const class AActor* OtherActor);
	static bool IsActorWithin2DExtents(const class AActor* AActor, const struct FBox2D& Extents);
	static bool IsCapsuleOverlappingCapsule(const struct FVector2D& CapsuleAStart, const struct FVector2D& CapsuleAEnd, float CapsuleARadius, const struct FVector2D& CapsuleBStart, const struct FVector2D& CapsuleBEnd, float CapsuleBRadius);
	static bool IsCircleOverlappingCapsule(const struct FVector2D& CircleCenter, float CircleRadius, const struct FVector2D& CapsuleStart, const struct FVector2D& CapsuleEnd, float CapsuleRadius);
	static bool IsCircleOverlappingCircle(const struct FVector2D& CenterA, float RadiusA, const struct FVector2D& CenterB, float RadiusB);
	static bool IsCounterHit(uint8 AppliedHitFlags);
	static bool IsLedgeGrantsIntangibility(uint8 LedgePropertyFlags);
	static bool IsLedgeOnlyAllowsJump(uint8 LedgePropertyFlags);
	static bool IsLethalKnockBackHit(uint8 AppliedHitFlags);
	static bool IsOwnedEntityHit(uint8 AppliedHitFlags);
	static bool IsPerfectShieldHit(uint8 AppliedHitFlags);
	static bool IsQueuedJumpFullGroundJump(uint8 QueuedJumpFlags);
	static bool IsQueuedJumpLedgeJump(uint8 QueuedJumpFlags);
	static bool IsQueuedJumpShortGroundJump(uint8 QueuedJumpFlags);
	static bool IsRectangleOverlappingRectangle(const struct FVector2D& CenterA, const struct FVector2D& ExtentsA, const struct FVector2D& CenterB, const struct FVector2D& ExtentsB);
	static bool IsRectangleOverlappingRectangleByEdges(const float TopA, const float BottomA, const float LeftA, const float RightA, const float TopB, const float BottomB, const float LeftB, const float RightB);
	static bool IsShieldHit(uint8 AppliedHitFlags);
	static struct FVector SmoothVectorLerp(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float Precision, float LerpTime);
	static void SpawnFXFromEntity(const class AActor* SpawningEntity, EEffectEventType EffectEventType, const struct FCombinedFXInfo& EffectInfo, int32 AssociatedEntityIndex);
	static void SpawnRenderActorFromEntity(const class AActor* SpawningEntity, TSoftClassPtr<class UClass> ActorClass, const struct FVector& LocationOffset, bool bSpawnForEveryone);
	static bool TryFindVisibilityOverrideInList(const TArray<struct FVisibilityOverride>& OverridesList, class FName Identifier, EVisibilityOverrideTargetType Type, struct FVisibilityOverride* OutOverride);
	static const class UMatchaItemAsset* TryGetEquippedHackItem(const class AMatchaSnapNetCharacterEntity* CharacterEntity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameplayStatics">();
	}
	static class UMatchaGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameplayStatics>();
	}
};
static_assert(alignof(UMatchaGameplayStatics) == 0x000008, "Wrong alignment on UMatchaGameplayStatics");
static_assert(sizeof(UMatchaGameplayStatics) == 0x000028, "Wrong size on UMatchaGameplayStatics");

// Class Matcha.MatchaGameServiceModel
// 0x0060 (0x0090 - 0x0030)
class UMatchaGameServiceModel final : public UOdyServicesModel
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameServiceModel">();
	}
	static class UMatchaGameServiceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameServiceModel>();
	}
};
static_assert(alignof(UMatchaGameServiceModel) == 0x000008, "Wrong alignment on UMatchaGameServiceModel");
static_assert(sizeof(UMatchaGameServiceModel) == 0x000090, "Wrong size on UMatchaGameServiceModel");

// Class Matcha.MatchaGameSession
// 0x0000 (0x02B8 - 0x02B8)
class AMatchaGameSession final : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameSession">();
	}
	static class AMatchaGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaGameSession>();
	}
};
static_assert(alignof(AMatchaGameSession) == 0x000008, "Wrong alignment on AMatchaGameSession");
static_assert(sizeof(AMatchaGameSession) == 0x0002B8, "Wrong size on AMatchaGameSession");

// Class Matcha.MatchaGameWorldUIData
// 0x0368 (0x03D0 - 0x0068)
class UMatchaGameWorldUIData : public UOdyUIData
{
public:
	struct FOdyUIIntBinding                       MatchPhase;                                        // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       MatchPhaseRemainingTime;                           // 0x0088(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITimespanBinding                  MatchPhaseRemainingTimespan;                       // 0x00A8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      ClientVersion;                                     // 0x00C8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      ServerVersion;                                     // 0x00F0(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaTeamUIData>          TeamUIDataClass;                                   // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaPlayerUIData>        PlayerUIDataClass;                                 // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMatchaTeamUIData*>              Teams;                                             // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMatchaPlayerUIData*>            Players;                                           // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdate;                                          // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAvailableHacksChanged;                           // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<EHackType>                               AvailableHacks;                                    // 0x0168(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       TotalTeamsAtMatchStart;                            // 0x01B8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       PlayersInGame;                                     // 0x01D8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       AlivePlayersInGame;                                // 0x01F8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpectatedPlayerChanged;                          // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       PlayerIndexForLocalPlayer;                         // 0x0228(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsSpectating;                                      // 0x0248(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsLocalPlayerTeamEliminated;                       // 0x0268(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       LastWinningTeamNumber;                             // 0x0288(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaZoneUIData>          ZoneUIDataClass;                                   // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaZoneUIData*                      ZoneUIData;                                        // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaGameplayEventNotificationData   CurrentMatchaGameplayEventNotificationData;        // 0x02B8(0x00C8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaKillFeedUIData>      KillFeedUIDataClass;                               // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaKillFeedUIData*                  KillFeedUIData;                                    // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaPlayerUIData*                    SpectatedPlayer;                                   // 0x0390(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaPlayerUIData*                    SpectatedTeammate1;                                // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaPlayerUIData*                    SpectatedTeammate2;                                // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaTeamUIData*                      SpectatedTeam;                                     // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0x20];                                     // 0x03B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindPlayerController();
	class UMatchaPlayerUIData* FindPlayerUIDataForPlayerIndex(int32 PlayerIndex, bool bAddIfNotFound);
	class UMatchaTeamUIData* FindTeamUIDataForPlayerIndex(int32 PlayerIndex);
	class UMatchaTeamUIData* FindTeamUIDataForTeamNumber(int32 TeamNumber, bool bAddIfNotFound);
	class UMatchaPlayerUIData* GetPlayerUIDataForSpectatedPlayer();
	void OnSpectatedPlayerIndexChanged(int32 InPlayerIndexForLocalPlayer, int32 PreviousPlayerIndex, int32 CurrentPlayerIndex);
	void RegisterActiveHackChest(EHackType HackType);
	void UnregisterActiveHackChest(EHackType HackType);

	int32 GetAlivePlayerCount() const;
	int32 GetTotalPlayerCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGameWorldUIData">();
	}
	static class UMatchaGameWorldUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGameWorldUIData>();
	}
};
static_assert(alignof(UMatchaGameWorldUIData) == 0x000008, "Wrong alignment on UMatchaGameWorldUIData");
static_assert(sizeof(UMatchaGameWorldUIData) == 0x0003D0, "Wrong size on UMatchaGameWorldUIData");
static_assert(offsetof(UMatchaGameWorldUIData, MatchPhase) == 0x000068, "Member 'UMatchaGameWorldUIData::MatchPhase' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, MatchPhaseRemainingTime) == 0x000088, "Member 'UMatchaGameWorldUIData::MatchPhaseRemainingTime' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, MatchPhaseRemainingTimespan) == 0x0000A8, "Member 'UMatchaGameWorldUIData::MatchPhaseRemainingTimespan' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, ClientVersion) == 0x0000C8, "Member 'UMatchaGameWorldUIData::ClientVersion' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, ServerVersion) == 0x0000F0, "Member 'UMatchaGameWorldUIData::ServerVersion' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, TeamUIDataClass) == 0x000118, "Member 'UMatchaGameWorldUIData::TeamUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, PlayerUIDataClass) == 0x000120, "Member 'UMatchaGameWorldUIData::PlayerUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, Teams) == 0x000128, "Member 'UMatchaGameWorldUIData::Teams' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, Players) == 0x000138, "Member 'UMatchaGameWorldUIData::Players' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, OnUpdate) == 0x000148, "Member 'UMatchaGameWorldUIData::OnUpdate' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, OnAvailableHacksChanged) == 0x000158, "Member 'UMatchaGameWorldUIData::OnAvailableHacksChanged' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, AvailableHacks) == 0x000168, "Member 'UMatchaGameWorldUIData::AvailableHacks' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, TotalTeamsAtMatchStart) == 0x0001B8, "Member 'UMatchaGameWorldUIData::TotalTeamsAtMatchStart' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, PlayersInGame) == 0x0001D8, "Member 'UMatchaGameWorldUIData::PlayersInGame' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, AlivePlayersInGame) == 0x0001F8, "Member 'UMatchaGameWorldUIData::AlivePlayersInGame' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, OnSpectatedPlayerChanged) == 0x000218, "Member 'UMatchaGameWorldUIData::OnSpectatedPlayerChanged' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, PlayerIndexForLocalPlayer) == 0x000228, "Member 'UMatchaGameWorldUIData::PlayerIndexForLocalPlayer' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, IsSpectating) == 0x000248, "Member 'UMatchaGameWorldUIData::IsSpectating' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, IsLocalPlayerTeamEliminated) == 0x000268, "Member 'UMatchaGameWorldUIData::IsLocalPlayerTeamEliminated' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, LastWinningTeamNumber) == 0x000288, "Member 'UMatchaGameWorldUIData::LastWinningTeamNumber' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, ZoneUIDataClass) == 0x0002A8, "Member 'UMatchaGameWorldUIData::ZoneUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, ZoneUIData) == 0x0002B0, "Member 'UMatchaGameWorldUIData::ZoneUIData' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, CurrentMatchaGameplayEventNotificationData) == 0x0002B8, "Member 'UMatchaGameWorldUIData::CurrentMatchaGameplayEventNotificationData' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, KillFeedUIDataClass) == 0x000380, "Member 'UMatchaGameWorldUIData::KillFeedUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, KillFeedUIData) == 0x000388, "Member 'UMatchaGameWorldUIData::KillFeedUIData' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, SpectatedPlayer) == 0x000390, "Member 'UMatchaGameWorldUIData::SpectatedPlayer' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, SpectatedTeammate1) == 0x000398, "Member 'UMatchaGameWorldUIData::SpectatedTeammate1' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, SpectatedTeammate2) == 0x0003A0, "Member 'UMatchaGameWorldUIData::SpectatedTeammate2' has a wrong offset!");
static_assert(offsetof(UMatchaGameWorldUIData, SpectatedTeam) == 0x0003A8, "Member 'UMatchaGameWorldUIData::SpectatedTeam' has a wrong offset!");

// Class Matcha.MatchaGenericEffectsSetupData
// 0x00A0 (0x00D0 - 0x0030)
class UMatchaGenericEffectsSetupData final : public UPrimaryDataAsset
{
public:
	TMap<class FName, TSoftObjectPtr<class UNiagaraSystem>> NiagaraTemplates;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UAkAudioEvent*>       AudioEvents;                                       // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaGenericEffectsSetupData">();
	}
	static class UMatchaGenericEffectsSetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaGenericEffectsSetupData>();
	}
};
static_assert(alignof(UMatchaGenericEffectsSetupData) == 0x000008, "Wrong alignment on UMatchaGenericEffectsSetupData");
static_assert(sizeof(UMatchaGenericEffectsSetupData) == 0x0000D0, "Wrong size on UMatchaGenericEffectsSetupData");
static_assert(offsetof(UMatchaGenericEffectsSetupData, NiagaraTemplates) == 0x000030, "Member 'UMatchaGenericEffectsSetupData::NiagaraTemplates' has a wrong offset!");
static_assert(offsetof(UMatchaGenericEffectsSetupData, AudioEvents) == 0x000080, "Member 'UMatchaGenericEffectsSetupData::AudioEvents' has a wrong offset!");

// Class Matcha.MatchaHitProcessingSubsystem
// 0x0010 (0x0050 - 0x0040)
class UMatchaHitProcessingSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaHitProcessingSubsystem">();
	}
	static class UMatchaHitProcessingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaHitProcessingSubsystem>();
	}
};
static_assert(alignof(UMatchaHitProcessingSubsystem) == 0x000008, "Wrong alignment on UMatchaHitProcessingSubsystem");
static_assert(sizeof(UMatchaHitProcessingSubsystem) == 0x000050, "Wrong size on UMatchaHitProcessingSubsystem");

// Class Matcha.MatchaSnapNetInteractiveEntity
// 0x0020 (0x0398 - 0x0378)
class AMatchaSnapNetInteractiveEntity : public AMatchaSnapNetEntity
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultRootComponent;                              // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractablesCollider;                             // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchaInteractionRequirements         InteractionRequirements;                           // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void GetPlayerColliderBounds(struct FVector* OutOrigin, struct FVector* OutBounds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetInteractiveEntity">();
	}
	static class AMatchaSnapNetInteractiveEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetInteractiveEntity>();
	}
};
static_assert(alignof(AMatchaSnapNetInteractiveEntity) == 0x000008, "Wrong alignment on AMatchaSnapNetInteractiveEntity");
static_assert(sizeof(AMatchaSnapNetInteractiveEntity) == 0x000398, "Wrong size on AMatchaSnapNetInteractiveEntity");
static_assert(offsetof(AMatchaSnapNetInteractiveEntity, DefaultRootComponent) == 0x000380, "Member 'AMatchaSnapNetInteractiveEntity::DefaultRootComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetInteractiveEntity, InteractablesCollider) == 0x000388, "Member 'AMatchaSnapNetInteractiveEntity::InteractablesCollider' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetInteractiveEntity, InteractionRequirements) == 0x000390, "Member 'AMatchaSnapNetInteractiveEntity::InteractionRequirements' has a wrong offset!");

// Class Matcha.MatchaHittableInteractiveEntity
// 0x0050 (0x03E8 - 0x0398)
class AMatchaHittableInteractiveEntity : public AMatchaSnapNetInteractiveEntity
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          HurtBoxCollision;                                  // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultHitFXId;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUnprocessedHitBoxData>         CurrentFrameOutgoingHits;                          // 0x03B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMatchaProcessedHitInfo>        CurrentFrameIncomingHits;                          // 0x03C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAppliedHitInfo>                RecentlyAppliedHits;                               // 0x03D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnHitReceived(const class AActor* HitInstigator, const class AActor* HitActor, const struct FMatchaHitData& HitData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaHittableInteractiveEntity">();
	}
	static class AMatchaHittableInteractiveEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaHittableInteractiveEntity>();
	}
};
static_assert(alignof(AMatchaHittableInteractiveEntity) == 0x000008, "Wrong alignment on AMatchaHittableInteractiveEntity");
static_assert(sizeof(AMatchaHittableInteractiveEntity) == 0x0003E8, "Wrong size on AMatchaHittableInteractiveEntity");
static_assert(offsetof(AMatchaHittableInteractiveEntity, HurtBoxCollision) == 0x0003A0, "Member 'AMatchaHittableInteractiveEntity::HurtBoxCollision' has a wrong offset!");
static_assert(offsetof(AMatchaHittableInteractiveEntity, DefaultHitFXId) == 0x0003A8, "Member 'AMatchaHittableInteractiveEntity::DefaultHitFXId' has a wrong offset!");
static_assert(offsetof(AMatchaHittableInteractiveEntity, Weight) == 0x0003B0, "Member 'AMatchaHittableInteractiveEntity::Weight' has a wrong offset!");
static_assert(offsetof(AMatchaHittableInteractiveEntity, CurrentFrameOutgoingHits) == 0x0003B8, "Member 'AMatchaHittableInteractiveEntity::CurrentFrameOutgoingHits' has a wrong offset!");
static_assert(offsetof(AMatchaHittableInteractiveEntity, CurrentFrameIncomingHits) == 0x0003C8, "Member 'AMatchaHittableInteractiveEntity::CurrentFrameIncomingHits' has a wrong offset!");
static_assert(offsetof(AMatchaHittableInteractiveEntity, RecentlyAppliedHits) == 0x0003D8, "Member 'AMatchaHittableInteractiveEntity::RecentlyAppliedHits' has a wrong offset!");

// Class Matcha.MatchaHitVolumeEntity
// 0x0008 (0x0440 - 0x0438)
class AMatchaHitVolumeEntity : public AMatchaHitEntity
{
public:
	bool                                          bAttachToOwner;                                    // 0x0438(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVolumeHitATarget(class AActor* TargetHit, const struct FMatchaHitData& HitData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaHitVolumeEntity">();
	}
	static class AMatchaHitVolumeEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaHitVolumeEntity>();
	}
};
static_assert(alignof(AMatchaHitVolumeEntity) == 0x000008, "Wrong alignment on AMatchaHitVolumeEntity");
static_assert(sizeof(AMatchaHitVolumeEntity) == 0x000440, "Wrong size on AMatchaHitVolumeEntity");
static_assert(offsetof(AMatchaHitVolumeEntity, bAttachToOwner) == 0x000438, "Member 'AMatchaHitVolumeEntity::bAttachToOwner' has a wrong offset!");

// Class Matcha.MatchaHUDBase
// 0x0010 (0x03B8 - 0x03A8)
class AMatchaHUDBase : public AOdyHUD
{
public:
	class UOdyMenuData*                           ErrorMenuData;                                     // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 CachedErrorModalClass;                             // 0x03B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaHUDBase">();
	}
	static class AMatchaHUDBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaHUDBase>();
	}
};
static_assert(alignof(AMatchaHUDBase) == 0x000008, "Wrong alignment on AMatchaHUDBase");
static_assert(sizeof(AMatchaHUDBase) == 0x0003B8, "Wrong size on AMatchaHUDBase");
static_assert(offsetof(AMatchaHUDBase, ErrorMenuData) == 0x0003A8, "Member 'AMatchaHUDBase::ErrorMenuData' has a wrong offset!");
static_assert(offsetof(AMatchaHUDBase, CachedErrorModalClass) == 0x0003B0, "Member 'AMatchaHUDBase::CachedErrorModalClass' has a wrong offset!");

// Class Matcha.MatchaIdentityServiceModel
// 0x00E8 (0x0118 - 0x0030)
class UMatchaIdentityServiceModel final : public UOdyServicesModel
{
public:
	FMulticastInlineDelegateProperty_             IdentityStateChanged;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoginResponseV1Changed;                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RegisterPlayerV1Completed;                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LoginTokenRequestV1Completed;                      // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LoginRequestV1Completed;                           // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x98];                                      // 0x0080(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeleteAccount();
	void HandleFailedLoginResponse(const struct FErrorResponseV1& LoginError);
	void HandleSuccessfulLoginResponse(const struct FLoginResponseV1& LoginResponse);
	void RegisterPlayer(const class FString& Name_0, const class FString& SelfRating);
	void SendLoginSteamV1Request(const class FString& SteamAuthSessionTicket, const class FString& CurrentGameLanguage, const class FString& DisplayName, bool* WasSent);
	void SendLoginTokenV1Request(bool* WasSent, const class FString& Token, class FString* OutRequestId);
	void SetIdentityState(EIdentityState NextState);
	void SetName(const class FString& Name_0);
	void TryLogin(bool* Attempted, const class FString& DisplayName);
	void UpdateAccessTokens(const struct FAccessTokens& Tokens);

	void GetAccessTokens(bool* Success, struct FAccessTokens* Tokens) const;
	void GetCachedLoginResponse(bool* Success, struct FLoginResponseV1* LoginResponse) const;
	EIdentityState GetIdentityState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaIdentityServiceModel">();
	}
	static class UMatchaIdentityServiceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaIdentityServiceModel>();
	}
};
static_assert(alignof(UMatchaIdentityServiceModel) == 0x000008, "Wrong alignment on UMatchaIdentityServiceModel");
static_assert(sizeof(UMatchaIdentityServiceModel) == 0x000118, "Wrong size on UMatchaIdentityServiceModel");
static_assert(offsetof(UMatchaIdentityServiceModel, IdentityStateChanged) == 0x000030, "Member 'UMatchaIdentityServiceModel::IdentityStateChanged' has a wrong offset!");
static_assert(offsetof(UMatchaIdentityServiceModel, OnLoginResponseV1Changed) == 0x000040, "Member 'UMatchaIdentityServiceModel::OnLoginResponseV1Changed' has a wrong offset!");
static_assert(offsetof(UMatchaIdentityServiceModel, RegisterPlayerV1Completed) == 0x000050, "Member 'UMatchaIdentityServiceModel::RegisterPlayerV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaIdentityServiceModel, LoginTokenRequestV1Completed) == 0x000060, "Member 'UMatchaIdentityServiceModel::LoginTokenRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaIdentityServiceModel, LoginRequestV1Completed) == 0x000070, "Member 'UMatchaIdentityServiceModel::LoginRequestV1Completed' has a wrong offset!");

// Class Matcha.MatchaInteractionUtils
// 0x0000 (0x0028 - 0x0028)
class UMatchaInteractionUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool TryCancelInteraction(struct FInProgressInteraction* InProgressInteraction, const class UWorld* World);
	static bool TryProgressInteraction(struct FInProgressInteraction* InProgressInteraction, const class UWorld* World);
	static bool TryStartInteraction(const class USnapNetEntityComponent* InstigatorEntityComponent, int32 TargetEntityIndex, float TargetChannelTime, const class UWorld* World, struct FInProgressInteraction* CurrentInteraction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaInteractionUtils">();
	}
	static class UMatchaInteractionUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaInteractionUtils>();
	}
};
static_assert(alignof(UMatchaInteractionUtils) == 0x000008, "Wrong alignment on UMatchaInteractionUtils");
static_assert(sizeof(UMatchaInteractionUtils) == 0x000028, "Wrong size on UMatchaInteractionUtils");

// Class Matcha.MatchaInventoryStatics
// 0x0000 (0x0028 - 0x0028)
class UMatchaInventoryStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FMatchaInventoryItem FromItemAsset(const class UMatchaItemAsset* ItemAsset);
	static const class UMatchaItemAsset* GetValue_ItemAsset(const struct FMatchaInventoryItem& InventoryItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaInventoryStatics">();
	}
	static class UMatchaInventoryStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaInventoryStatics>();
	}
};
static_assert(alignof(UMatchaInventoryStatics) == 0x000008, "Wrong alignment on UMatchaInventoryStatics");
static_assert(sizeof(UMatchaInventoryStatics) == 0x000028, "Wrong size on UMatchaInventoryStatics");

// Class Matcha.MatchaInventoryCategoryUIData
// 0x0040 (0x00A8 - 0x0068)
class UMatchaInventoryCategoryUIData final : public UOdyUIData
{
public:
	struct FOdyUIGameplayTagBinding               Type;                                              // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UMatchaInventorySlotUIData*>     Slots;                                             // 0x0088(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlotsUpdated;                                    // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaInventoryCategoryUIData">();
	}
	static class UMatchaInventoryCategoryUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaInventoryCategoryUIData>();
	}
};
static_assert(alignof(UMatchaInventoryCategoryUIData) == 0x000008, "Wrong alignment on UMatchaInventoryCategoryUIData");
static_assert(sizeof(UMatchaInventoryCategoryUIData) == 0x0000A8, "Wrong size on UMatchaInventoryCategoryUIData");
static_assert(offsetof(UMatchaInventoryCategoryUIData, Type) == 0x000068, "Member 'UMatchaInventoryCategoryUIData::Type' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryCategoryUIData, Slots) == 0x000088, "Member 'UMatchaInventoryCategoryUIData::Slots' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryCategoryUIData, OnSlotsUpdated) == 0x000098, "Member 'UMatchaInventoryCategoryUIData::OnSlotsUpdated' has a wrong offset!");

// Class Matcha.MatchaInventoryComponent
// 0x0100 (0x01A0 - 0x00A0)
class UMatchaInventoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInventoryUpdated;                                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<struct FActiveItemInfo>                  ActiveItems;                                       // 0x00B8(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchaInventory                       Inventory;                                         // 0x0128(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x58];                                     // 0x0148(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanCombineAnyItemStacksWithInventory(const struct FGameplayTag& SourceSlotCategory, const class UMatchaInventoryComponent* DestinationInventoryComponent, const struct FGameplayTag& DestinationSlotCategory);
	bool CanCombineSlots(const struct FGameplayTag& SourceSlotCategory, int32 SourceSlotIndex, const struct FGameplayTag& DestinationSlotCategory, int32 DestinationSlotIndex, int32 Count);
	void DumpInventory();
	const struct FMatchaInventorySlot GetItemInSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex);
	bool HasAnEmptySlotForCategory(const struct FGameplayTag& SlotCategory);
	bool HasItemInCategory(const struct FMatchaInventoryItem& Item, const struct FGameplayTag& SlotCategory);
	void MatchaInventoryUpdated__DelegateSignature();
	void ReActivateInventoryItems();
	void ResetInventory();
	int32 TryAddItem(const struct FMatchaInventoryItem& Item, int32 Count);
	bool TryAddItemChecked(const struct FMatchaInventoryItem& Item, int32 Count);
	bool TryAddOrReplaceItem(const struct FMatchaInventoryItem& Item, int32 Count, const struct FGameplayTag& ReplaceSlotCategory, int32 ReplaceSlotIndex);
	bool TryConsumeItemInSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex);
	void TryDropAllItems(const class AActor* ItemOwner, const struct FVector& StartingSpawnLocation);
	bool TryDropItem(const struct FGameplayTag& SlotCategory, int32 SourceSlotIndex, int32 Count, const struct FVector& SpawnLocation);
	bool TryDropRandomItemInCategory(const struct FGameplayTag& SlotCategory, int32 Count, const struct FVector& SpawnLocation);
	bool TryEnergizeSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex);
	bool TryHoldItemSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex);
	bool TryMoveItem(const struct FGameplayTag& SourceSlotCategory, int32 SourceSlotIndex, int32 Count, const struct FGameplayTag& DestinationSlotCategory, int32 DestinationSlotIndex);
	bool TryRemoveItemFromSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex, int32 Count);
	bool TryRemoveItemInCategory(const struct FMatchaInventoryItem& Item, const struct FGameplayTag& SlotCategory, int32 Count);
	bool TryReplaceItemInSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex, const struct FMatchaInventoryItem& Item, int32 Count);
	bool TrySwapItem(const struct FGameplayTag& SourceSlotCategory, int32 SourceSlotIndex, const struct FGameplayTag& DestinationSlotCategory, int32 DestinationSlotIndex);
	bool TryThrowItem(const struct FGameplayTag& SlotCategory, int32 SourceSlotIndex, int32 Count, const struct FVector& SpawnLocation, const struct FVector2D& ThrowDirection);
	void UnHoldAllSlots();

	int32 GetHeldItemSlotIndexInCategory(const struct FGameplayTag& SlotCategory) const;
	bool HasItemInSlot(const struct FGameplayTag& SlotCategory, int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaInventoryComponent">();
	}
	static class UMatchaInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaInventoryComponent>();
	}
};
static_assert(alignof(UMatchaInventoryComponent) == 0x000008, "Wrong alignment on UMatchaInventoryComponent");
static_assert(sizeof(UMatchaInventoryComponent) == 0x0001A0, "Wrong size on UMatchaInventoryComponent");
static_assert(offsetof(UMatchaInventoryComponent, OnInventoryUpdated) == 0x0000A8, "Member 'UMatchaInventoryComponent::OnInventoryUpdated' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryComponent, ActiveItems) == 0x0000B8, "Member 'UMatchaInventoryComponent::ActiveItems' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryComponent, Inventory) == 0x000128, "Member 'UMatchaInventoryComponent::Inventory' has a wrong offset!");

// Class Matcha.MatchaInventoryItemUIData
// 0x0278 (0x02E0 - 0x0068)
class UMatchaInventoryItemUIData : public UOdyUIData
{
public:
	struct FGameplayTagContainer                  GearItemTags;                                      // 0x0068(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   InventoryIcon;                                     // 0x0088(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   EnchantIcon;                                       // 0x00E8(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       ItemStackSize;                                     // 0x0148(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       ObjectRarity;                                      // 0x0168(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      ItemName;                                          // 0x0188(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      ItemTooltip;                                       // 0x01B0(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      EnergizedItemTooltip;                              // 0x01D8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      ItemIsGunType;                                     // 0x0200(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      ItemIsThrowableOnly;                               // 0x0220(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      ItemIsConsumeOnHold;                               // 0x0240(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsGearItem;                                        // 0x0260(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsCorrespondingGearSlotEnergized;                  // 0x0280(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsItemValid;                                       // 0x02A0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  InteractionRenderer;                               // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMatchaInventoryUIData>  OwningPlayerInventoryUIData;                       // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemUpdated;                                     // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnInteractionRendererUpdated(class AActor* NewInteractionRenderer, class AActor* OldInteractionRenderer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaInventoryItemUIData">();
	}
	static class UMatchaInventoryItemUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaInventoryItemUIData>();
	}
};
static_assert(alignof(UMatchaInventoryItemUIData) == 0x000008, "Wrong alignment on UMatchaInventoryItemUIData");
static_assert(sizeof(UMatchaInventoryItemUIData) == 0x0002E0, "Wrong size on UMatchaInventoryItemUIData");
static_assert(offsetof(UMatchaInventoryItemUIData, GearItemTags) == 0x000068, "Member 'UMatchaInventoryItemUIData::GearItemTags' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, InventoryIcon) == 0x000088, "Member 'UMatchaInventoryItemUIData::InventoryIcon' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, EnchantIcon) == 0x0000E8, "Member 'UMatchaInventoryItemUIData::EnchantIcon' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, ItemStackSize) == 0x000148, "Member 'UMatchaInventoryItemUIData::ItemStackSize' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, ObjectRarity) == 0x000168, "Member 'UMatchaInventoryItemUIData::ObjectRarity' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, ItemName) == 0x000188, "Member 'UMatchaInventoryItemUIData::ItemName' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, ItemTooltip) == 0x0001B0, "Member 'UMatchaInventoryItemUIData::ItemTooltip' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, EnergizedItemTooltip) == 0x0001D8, "Member 'UMatchaInventoryItemUIData::EnergizedItemTooltip' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, ItemIsGunType) == 0x000200, "Member 'UMatchaInventoryItemUIData::ItemIsGunType' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, ItemIsThrowableOnly) == 0x000220, "Member 'UMatchaInventoryItemUIData::ItemIsThrowableOnly' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, ItemIsConsumeOnHold) == 0x000240, "Member 'UMatchaInventoryItemUIData::ItemIsConsumeOnHold' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, IsGearItem) == 0x000260, "Member 'UMatchaInventoryItemUIData::IsGearItem' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, IsCorrespondingGearSlotEnergized) == 0x000280, "Member 'UMatchaInventoryItemUIData::IsCorrespondingGearSlotEnergized' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, IsItemValid) == 0x0002A0, "Member 'UMatchaInventoryItemUIData::IsItemValid' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, InteractionRenderer) == 0x0002C0, "Member 'UMatchaInventoryItemUIData::InteractionRenderer' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, OwningPlayerInventoryUIData) == 0x0002C8, "Member 'UMatchaInventoryItemUIData::OwningPlayerInventoryUIData' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryItemUIData, OnItemUpdated) == 0x0002D0, "Member 'UMatchaInventoryItemUIData::OnItemUpdated' has a wrong offset!");

// Class Matcha.MatchaInventorySlotUIData
// 0x0258 (0x02C0 - 0x0068)
class UMatchaInventorySlotUIData final : public UOdyUIData
{
public:
	struct FOdyUITextureBinding                   InventoryIcon;                                     // 0x0068(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   EnchantIcon;                                       // 0x00C8(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       ItemCount;                                         // 0x0128(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      Energized;                                         // 0x0148(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsHeld;                                            // 0x0168(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsEmpty;                                           // 0x0188(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       ItemStackSize;                                     // 0x01A8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       ObjectRarity;                                      // 0x01C8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      ItemName;                                          // 0x01E8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      ItemTooltip;                                       // 0x0210(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      EnergizedItemTooltip;                              // 0x0238(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      ItemIsGunType;                                     // 0x0260(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      ItemIsThrowableOnly;                               // 0x0280(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      ItemIsConsumeOnHold;                               // 0x02A0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaInventorySlotUIData">();
	}
	static class UMatchaInventorySlotUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaInventorySlotUIData>();
	}
};
static_assert(alignof(UMatchaInventorySlotUIData) == 0x000008, "Wrong alignment on UMatchaInventorySlotUIData");
static_assert(sizeof(UMatchaInventorySlotUIData) == 0x0002C0, "Wrong size on UMatchaInventorySlotUIData");
static_assert(offsetof(UMatchaInventorySlotUIData, InventoryIcon) == 0x000068, "Member 'UMatchaInventorySlotUIData::InventoryIcon' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, EnchantIcon) == 0x0000C8, "Member 'UMatchaInventorySlotUIData::EnchantIcon' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, ItemCount) == 0x000128, "Member 'UMatchaInventorySlotUIData::ItemCount' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, Energized) == 0x000148, "Member 'UMatchaInventorySlotUIData::Energized' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, IsHeld) == 0x000168, "Member 'UMatchaInventorySlotUIData::IsHeld' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, IsEmpty) == 0x000188, "Member 'UMatchaInventorySlotUIData::IsEmpty' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, ItemStackSize) == 0x0001A8, "Member 'UMatchaInventorySlotUIData::ItemStackSize' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, ObjectRarity) == 0x0001C8, "Member 'UMatchaInventorySlotUIData::ObjectRarity' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, ItemName) == 0x0001E8, "Member 'UMatchaInventorySlotUIData::ItemName' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, ItemTooltip) == 0x000210, "Member 'UMatchaInventorySlotUIData::ItemTooltip' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, EnergizedItemTooltip) == 0x000238, "Member 'UMatchaInventorySlotUIData::EnergizedItemTooltip' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, ItemIsGunType) == 0x000260, "Member 'UMatchaInventorySlotUIData::ItemIsGunType' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, ItemIsThrowableOnly) == 0x000280, "Member 'UMatchaInventorySlotUIData::ItemIsThrowableOnly' has a wrong offset!");
static_assert(offsetof(UMatchaInventorySlotUIData, ItemIsConsumeOnHold) == 0x0002A0, "Member 'UMatchaInventorySlotUIData::ItemIsConsumeOnHold' has a wrong offset!");

// Class Matcha.MatchaInventoryUIData
// 0x0098 (0x0100 - 0x0068)
class UMatchaInventoryUIData final : public UOdyUIData
{
public:
	TSubclassOf<class UMatchaInventoryCategoryUIData> CategoryUIDataClass;                               // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaInventorySlotUIData> SlotUIDataClass;                                   // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInventoryCategoriesUpdated;                      // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UMatchaInventoryCategoryUIData*> Categories;                                        // 0x0088(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      HasHeldItemInQuickBarSlot;                         // 0x00D8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMatchaInventoryComponent> BoundInventoryComponent;                           // 0x00F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void MatchaInventoryCategoriesUpdated__DelegateSignature();
	void OnInventoryComponentUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaInventoryUIData">();
	}
	static class UMatchaInventoryUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaInventoryUIData>();
	}
};
static_assert(alignof(UMatchaInventoryUIData) == 0x000008, "Wrong alignment on UMatchaInventoryUIData");
static_assert(sizeof(UMatchaInventoryUIData) == 0x000100, "Wrong size on UMatchaInventoryUIData");
static_assert(offsetof(UMatchaInventoryUIData, CategoryUIDataClass) == 0x000068, "Member 'UMatchaInventoryUIData::CategoryUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryUIData, SlotUIDataClass) == 0x000070, "Member 'UMatchaInventoryUIData::SlotUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryUIData, OnInventoryCategoriesUpdated) == 0x000078, "Member 'UMatchaInventoryUIData::OnInventoryCategoriesUpdated' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryUIData, Categories) == 0x000088, "Member 'UMatchaInventoryUIData::Categories' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryUIData, HasHeldItemInQuickBarSlot) == 0x0000D8, "Member 'UMatchaInventoryUIData::HasHeldItemInQuickBarSlot' has a wrong offset!");
static_assert(offsetof(UMatchaInventoryUIData, BoundInventoryComponent) == 0x0000F8, "Member 'UMatchaInventoryUIData::BoundInventoryComponent' has a wrong offset!");

// Class Matcha.MatchaItemRenderer
// 0x0000 (0x0290 - 0x0290)
class AMatchaItemRenderer : public AActor
{
public:
	void ConfigureFromItem(const class UMatchaItemAsset* ItemAsset);
	void OnUpdateFromEntity(class AActor* Entity);
	void SetHighlightState(bool bIsHighlighted);
	void UpdateItemCount(int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaItemRenderer">();
	}
	static class AMatchaItemRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaItemRenderer>();
	}
};
static_assert(alignof(AMatchaItemRenderer) == 0x000008, "Wrong alignment on AMatchaItemRenderer");
static_assert(sizeof(AMatchaItemRenderer) == 0x000290, "Wrong size on AMatchaItemRenderer");

// Class Matcha.MatchaItemAsset
// 0x0240 (0x0270 - 0x0030)
class UMatchaItemAsset final : public UPrimaryDataAsset
{
public:
	class FText                                   ItemName;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemTooltip;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   EnergizedItemTooltip;                              // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   AllowedSlotCategories;                             // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         StackLimit;                                        // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UniqueInSlotCategory;                              // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              InventoryIcon;                                     // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InWorldRenderer;                                   // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PickupEntity;                                      // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemUsageType                                UsageType;                                         // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemConsumeAnimationType                     ConsumeAnimationType;                              // 0x00F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPutAwayAfterConsumeOrThrow;                   // 0x00F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoConsumeOnHold;                                // 0x00F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConsumeTimeSeconds;                                // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ProjectileEntity;                                  // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemDeployEntityInfo                  ConsumeToDeployEntityInfo;                         // 0x0120(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBuffInfo                              ConsumeBuffInfo;                                   // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCombinedFXInfo                        ConsumeVfxEvent;                                   // 0x0178(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EItemDefaultNeutralThrowDirection             DefaultThrowDirection;                             // 0x0200(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAllowedThrowOrFireDirectionType          AllowedThrowOrFireDirectionType;                   // 0x0201(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 RarityLevel;                                       // 0x0202(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203[0x5];                                      // 0x0203(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ActiveSlotCategories;                              // 0x0208(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              EnchantIcon;                                       // 0x0228(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBuffInfo                              BuffInfo;                                          // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBuffInfo                              EnergizedBuffInfo;                                 // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaItemAsset">();
	}
	static class UMatchaItemAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaItemAsset>();
	}
};
static_assert(alignof(UMatchaItemAsset) == 0x000008, "Wrong alignment on UMatchaItemAsset");
static_assert(sizeof(UMatchaItemAsset) == 0x000270, "Wrong size on UMatchaItemAsset");
static_assert(offsetof(UMatchaItemAsset, ItemName) == 0x000030, "Member 'UMatchaItemAsset::ItemName' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, ItemTooltip) == 0x000040, "Member 'UMatchaItemAsset::ItemTooltip' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, EnergizedItemTooltip) == 0x000050, "Member 'UMatchaItemAsset::EnergizedItemTooltip' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, AllowedSlotCategories) == 0x000060, "Member 'UMatchaItemAsset::AllowedSlotCategories' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, StackLimit) == 0x000070, "Member 'UMatchaItemAsset::StackLimit' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, UniqueInSlotCategory) == 0x000074, "Member 'UMatchaItemAsset::UniqueInSlotCategory' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, InventoryIcon) == 0x000078, "Member 'UMatchaItemAsset::InventoryIcon' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, InWorldRenderer) == 0x0000A0, "Member 'UMatchaItemAsset::InWorldRenderer' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, PickupEntity) == 0x0000C8, "Member 'UMatchaItemAsset::PickupEntity' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, UsageType) == 0x0000F0, "Member 'UMatchaItemAsset::UsageType' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, ConsumeAnimationType) == 0x0000F1, "Member 'UMatchaItemAsset::ConsumeAnimationType' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, bAutoPutAwayAfterConsumeOrThrow) == 0x0000F2, "Member 'UMatchaItemAsset::bAutoPutAwayAfterConsumeOrThrow' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, bAutoConsumeOnHold) == 0x0000F3, "Member 'UMatchaItemAsset::bAutoConsumeOnHold' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, ConsumeTimeSeconds) == 0x0000F4, "Member 'UMatchaItemAsset::ConsumeTimeSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, ProjectileEntity) == 0x0000F8, "Member 'UMatchaItemAsset::ProjectileEntity' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, ConsumeToDeployEntityInfo) == 0x000120, "Member 'UMatchaItemAsset::ConsumeToDeployEntityInfo' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, ConsumeBuffInfo) == 0x000168, "Member 'UMatchaItemAsset::ConsumeBuffInfo' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, ConsumeVfxEvent) == 0x000178, "Member 'UMatchaItemAsset::ConsumeVfxEvent' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, DefaultThrowDirection) == 0x000200, "Member 'UMatchaItemAsset::DefaultThrowDirection' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, AllowedThrowOrFireDirectionType) == 0x000201, "Member 'UMatchaItemAsset::AllowedThrowOrFireDirectionType' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, RarityLevel) == 0x000202, "Member 'UMatchaItemAsset::RarityLevel' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, ActiveSlotCategories) == 0x000208, "Member 'UMatchaItemAsset::ActiveSlotCategories' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, EnchantIcon) == 0x000228, "Member 'UMatchaItemAsset::EnchantIcon' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, BuffInfo) == 0x000250, "Member 'UMatchaItemAsset::BuffInfo' has a wrong offset!");
static_assert(offsetof(UMatchaItemAsset, EnergizedBuffInfo) == 0x000260, "Member 'UMatchaItemAsset::EnergizedBuffInfo' has a wrong offset!");

// Class Matcha.MatchaKillFeedEntryUIData
// 0x0170 (0x01D8 - 0x0068)
class UMatchaKillFeedEntryUIData final : public UOdyUIData
{
public:
	struct FDateTime                              FirstSeenTime;                                     // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsNew;                                             // 0x0070(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      AgedOut;                                           // 0x0090(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         KillFeedIndex;                                     // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstigatorPlayerIndex;                             // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstigatorCharacterIndex;                          // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetPlayerIndex;                                 // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCharacterIndex;                              // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOdyUITextBinding                      InstigatorName;                                    // 0x00C8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   InstigatorIcon;                                    // 0x00F0(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      TargetName;                                        // 0x0150(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   TargetIcon;                                        // 0x0178(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaKillFeedEntryUIData">();
	}
	static class UMatchaKillFeedEntryUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaKillFeedEntryUIData>();
	}
};
static_assert(alignof(UMatchaKillFeedEntryUIData) == 0x000008, "Wrong alignment on UMatchaKillFeedEntryUIData");
static_assert(sizeof(UMatchaKillFeedEntryUIData) == 0x0001D8, "Wrong size on UMatchaKillFeedEntryUIData");
static_assert(offsetof(UMatchaKillFeedEntryUIData, FirstSeenTime) == 0x000068, "Member 'UMatchaKillFeedEntryUIData::FirstSeenTime' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, IsNew) == 0x000070, "Member 'UMatchaKillFeedEntryUIData::IsNew' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, AgedOut) == 0x000090, "Member 'UMatchaKillFeedEntryUIData::AgedOut' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, KillFeedIndex) == 0x0000B0, "Member 'UMatchaKillFeedEntryUIData::KillFeedIndex' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, InstigatorPlayerIndex) == 0x0000B4, "Member 'UMatchaKillFeedEntryUIData::InstigatorPlayerIndex' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, InstigatorCharacterIndex) == 0x0000B8, "Member 'UMatchaKillFeedEntryUIData::InstigatorCharacterIndex' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, TargetPlayerIndex) == 0x0000BC, "Member 'UMatchaKillFeedEntryUIData::TargetPlayerIndex' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, TargetCharacterIndex) == 0x0000C0, "Member 'UMatchaKillFeedEntryUIData::TargetCharacterIndex' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, InstigatorName) == 0x0000C8, "Member 'UMatchaKillFeedEntryUIData::InstigatorName' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, InstigatorIcon) == 0x0000F0, "Member 'UMatchaKillFeedEntryUIData::InstigatorIcon' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, TargetName) == 0x000150, "Member 'UMatchaKillFeedEntryUIData::TargetName' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedEntryUIData, TargetIcon) == 0x000178, "Member 'UMatchaKillFeedEntryUIData::TargetIcon' has a wrong offset!");

// Class Matcha.MatchaSnapNetDamageVolumeEntity
// 0x0048 (0x03C0 - 0x0378)
class AMatchaSnapNetDamageVolumeEntity : public AMatchaSnapNetEntity
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionTag;                                      // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageStartTime;                                   // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamagePerTick;                                     // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageTickRate;                                    // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKnockOutOnOverlapIfAtDamageThreshold;             // 0x0394(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanKnockOutIfKnockedInto;                         // 0x0395(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCreditDamageAndKOToOwnerEntity;                   // 0x0396(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_397[0x1];                                      // 0x0397(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AMatchaSnapNetCharacterEntity> OwnerCharacter;                                    // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            CollisionComponents;                               // 0x03A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDamageZoneCharacterTracking>   CharacterTracking;                                 // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnEndOverlapWithCharacter(class AMatchaSnapNetCharacterEntity* Character);
	void OnOverlapCharacter(class AMatchaSnapNetCharacterEntity* Character, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetDamageVolumeEntity">();
	}
	static class AMatchaSnapNetDamageVolumeEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetDamageVolumeEntity>();
	}
};
static_assert(alignof(AMatchaSnapNetDamageVolumeEntity) == 0x000008, "Wrong alignment on AMatchaSnapNetDamageVolumeEntity");
static_assert(sizeof(AMatchaSnapNetDamageVolumeEntity) == 0x0003C0, "Wrong size on AMatchaSnapNetDamageVolumeEntity");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, CollisionTag) == 0x000380, "Member 'AMatchaSnapNetDamageVolumeEntity::CollisionTag' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, DamageStartTime) == 0x000388, "Member 'AMatchaSnapNetDamageVolumeEntity::DamageStartTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, DamagePerTick) == 0x00038C, "Member 'AMatchaSnapNetDamageVolumeEntity::DamagePerTick' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, DamageTickRate) == 0x000390, "Member 'AMatchaSnapNetDamageVolumeEntity::DamageTickRate' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, bKnockOutOnOverlapIfAtDamageThreshold) == 0x000394, "Member 'AMatchaSnapNetDamageVolumeEntity::bKnockOutOnOverlapIfAtDamageThreshold' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, bCanKnockOutIfKnockedInto) == 0x000395, "Member 'AMatchaSnapNetDamageVolumeEntity::bCanKnockOutIfKnockedInto' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, bCreditDamageAndKOToOwnerEntity) == 0x000396, "Member 'AMatchaSnapNetDamageVolumeEntity::bCreditDamageAndKOToOwnerEntity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, OwnerCharacter) == 0x000398, "Member 'AMatchaSnapNetDamageVolumeEntity::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, CollisionComponents) == 0x0003A0, "Member 'AMatchaSnapNetDamageVolumeEntity::CollisionComponents' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetDamageVolumeEntity, CharacterTracking) == 0x0003B0, "Member 'AMatchaSnapNetDamageVolumeEntity::CharacterTracking' has a wrong offset!");

// Class Matcha.MatchaSnapNetKOZoneEntity
// 0x05D8 (0x0998 - 0x03C0)
class AMatchaSnapNetKOZoneEntity : public AMatchaSnapNetDamageVolumeEntity
{
public:
	uint8                                         Pad_3C0[0x38];                                     // 0x03C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          RandomStream;                                      // 0x03F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FKOZoneConfiguration                   Configuration;                                     // 0x0400(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  CurrentCycleIndex;                                 // 0x0448(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  CurrentCycleTime;                                  // 0x0480(0x0040)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FActiveKOZone                          CurrentExtents;                                    // 0x04C0(0x0438)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AMatchaFinalZone*>               FinalZoneOptions;                                  // 0x08F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_908[0x8];                                      // 0x0908(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMatchaFinalZone*                       FinalZone;                                         // 0x0910(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          NorthCollision;                                    // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EastCollision;                                     // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SouthCollision;                                    // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          WestCollision;                                     // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  TimeScale;                                         // 0x0938(0x0040)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ChannelToBroadcastEventTo;                         // 0x0978(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_980[0x18];                                     // 0x0980(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ComputeNextZone(struct FActiveKOZone* OutNextZone);
	void SelectFinalZone();
	void SetTimeScale(float TimeScale_0);
	void SkipToNextPhase();
	void UpdateCollisionToZoneBounds(const struct FActiveKOZone& Zone);

	const struct FActiveKOZone GetActiveZone() const;
	int32 GetCurrentCycleIndex() const;
	float GetCurrentCycleTime() const;
	void GetCurrentSafeZoneExtents(struct FVector2D* OutSafeZoneMin, struct FVector2D* OutSafeZoneMax) const;
	bool IsFinalZone() const;
	bool IsLastStand() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetKOZoneEntity">();
	}
	static class AMatchaSnapNetKOZoneEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetKOZoneEntity>();
	}
};
static_assert(alignof(AMatchaSnapNetKOZoneEntity) == 0x000008, "Wrong alignment on AMatchaSnapNetKOZoneEntity");
static_assert(sizeof(AMatchaSnapNetKOZoneEntity) == 0x000998, "Wrong size on AMatchaSnapNetKOZoneEntity");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, RandomStream) == 0x0003F8, "Member 'AMatchaSnapNetKOZoneEntity::RandomStream' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, Configuration) == 0x000400, "Member 'AMatchaSnapNetKOZoneEntity::Configuration' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, CurrentCycleIndex) == 0x000448, "Member 'AMatchaSnapNetKOZoneEntity::CurrentCycleIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, CurrentCycleTime) == 0x000480, "Member 'AMatchaSnapNetKOZoneEntity::CurrentCycleTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, CurrentExtents) == 0x0004C0, "Member 'AMatchaSnapNetKOZoneEntity::CurrentExtents' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, FinalZoneOptions) == 0x0008F8, "Member 'AMatchaSnapNetKOZoneEntity::FinalZoneOptions' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, FinalZone) == 0x000910, "Member 'AMatchaSnapNetKOZoneEntity::FinalZone' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, NorthCollision) == 0x000918, "Member 'AMatchaSnapNetKOZoneEntity::NorthCollision' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, EastCollision) == 0x000920, "Member 'AMatchaSnapNetKOZoneEntity::EastCollision' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, SouthCollision) == 0x000928, "Member 'AMatchaSnapNetKOZoneEntity::SouthCollision' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, WestCollision) == 0x000930, "Member 'AMatchaSnapNetKOZoneEntity::WestCollision' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, TimeScale) == 0x000938, "Member 'AMatchaSnapNetKOZoneEntity::TimeScale' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetKOZoneEntity, ChannelToBroadcastEventTo) == 0x000978, "Member 'AMatchaSnapNetKOZoneEntity::ChannelToBroadcastEventTo' has a wrong offset!");

// Class Matcha.MatchaKillFeedUIData
// 0x0028 (0x0090 - 0x0068)
class UMatchaKillFeedUIData final : public UOdyUIData
{
public:
	TSubclassOf<class UMatchaKillFeedEntryUIData> KillFeedEntryUIDataClass;                          // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMatchaKillFeedEntryUIData*>     KillFeedEntries;                                   // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdate;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaKillFeedUIData">();
	}
	static class UMatchaKillFeedUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaKillFeedUIData>();
	}
};
static_assert(alignof(UMatchaKillFeedUIData) == 0x000008, "Wrong alignment on UMatchaKillFeedUIData");
static_assert(sizeof(UMatchaKillFeedUIData) == 0x000090, "Wrong size on UMatchaKillFeedUIData");
static_assert(offsetof(UMatchaKillFeedUIData, KillFeedEntryUIDataClass) == 0x000068, "Member 'UMatchaKillFeedUIData::KillFeedEntryUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedUIData, KillFeedEntries) == 0x000070, "Member 'UMatchaKillFeedUIData::KillFeedEntries' has a wrong offset!");
static_assert(offsetof(UMatchaKillFeedUIData, OnUpdate) == 0x000080, "Member 'UMatchaKillFeedUIData::OnUpdate' has a wrong offset!");

// Class Matcha.MatchaKnockoutVolume
// 0x0088 (0x0400 - 0x0378)
class AMatchaKnockoutVolume : public AMatchaSnapNetEntity
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EKnockoutProcessingMode                       KnockoutProcessingMode;                            // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageThreshold;                                   // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchaHitData                         HitData;                                           // 0x0388(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void K2_BeginOverlap(class AActor* Target, const struct FHitResult& HitResult);
	void K2_EndOverlap(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaKnockoutVolume">();
	}
	static class AMatchaKnockoutVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaKnockoutVolume>();
	}
};
static_assert(alignof(AMatchaKnockoutVolume) == 0x000008, "Wrong alignment on AMatchaKnockoutVolume");
static_assert(sizeof(AMatchaKnockoutVolume) == 0x000400, "Wrong size on AMatchaKnockoutVolume");
static_assert(offsetof(AMatchaKnockoutVolume, KnockoutProcessingMode) == 0x000380, "Member 'AMatchaKnockoutVolume::KnockoutProcessingMode' has a wrong offset!");
static_assert(offsetof(AMatchaKnockoutVolume, DamageThreshold) == 0x000384, "Member 'AMatchaKnockoutVolume::DamageThreshold' has a wrong offset!");
static_assert(offsetof(AMatchaKnockoutVolume, HitData) == 0x000388, "Member 'AMatchaKnockoutVolume::HitData' has a wrong offset!");

// Class Matcha.MatchaSnapNetCharacterMovementComponent
// 0x0140 (0x10C0 - 0x0F80)
class UMatchaSnapNetCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	struct FVector                                RootMotionVelocity;                                // 0x0F78(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyingCustomRootMotionVelocity;                 // 0x0F90(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F91[0x3];                                      // 0x0F91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentMaxFallSpeed;                               // 0x0F94(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaCharacterFlags                  OwnerCharacterFlags;                               // 0x0F98(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	EMatchaShieldState                            OwnerShieldState;                                  // 0x0FB0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHanging;                                        // 0x0FB1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB2[0x2];                                      // 0x0FB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModifiedDeltaTime;                                 // 0x0FB4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB8[0x100];                                    // 0x0FB8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootMotionVerticalDeltaForFalling;                 // 0x10B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10BC[0x4];                                     // 0x10BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetCharacterMovementComponent">();
	}
	static class UMatchaSnapNetCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSnapNetCharacterMovementComponent>();
	}
};
static_assert(alignof(UMatchaSnapNetCharacterMovementComponent) == 0x000010, "Wrong alignment on UMatchaSnapNetCharacterMovementComponent");
static_assert(sizeof(UMatchaSnapNetCharacterMovementComponent) == 0x0010C0, "Wrong size on UMatchaSnapNetCharacterMovementComponent");
static_assert(offsetof(UMatchaSnapNetCharacterMovementComponent, RootMotionVelocity) == 0x000F78, "Member 'UMatchaSnapNetCharacterMovementComponent::RootMotionVelocity' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterMovementComponent, bApplyingCustomRootMotionVelocity) == 0x000F90, "Member 'UMatchaSnapNetCharacterMovementComponent::bApplyingCustomRootMotionVelocity' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterMovementComponent, CurrentMaxFallSpeed) == 0x000F94, "Member 'UMatchaSnapNetCharacterMovementComponent::CurrentMaxFallSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterMovementComponent, OwnerCharacterFlags) == 0x000F98, "Member 'UMatchaSnapNetCharacterMovementComponent::OwnerCharacterFlags' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterMovementComponent, OwnerShieldState) == 0x000FB0, "Member 'UMatchaSnapNetCharacterMovementComponent::OwnerShieldState' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterMovementComponent, bIsHanging) == 0x000FB1, "Member 'UMatchaSnapNetCharacterMovementComponent::bIsHanging' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterMovementComponent, ModifiedDeltaTime) == 0x000FB4, "Member 'UMatchaSnapNetCharacterMovementComponent::ModifiedDeltaTime' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetCharacterMovementComponent, RootMotionVerticalDeltaForFalling) == 0x0010B8, "Member 'UMatchaSnapNetCharacterMovementComponent::RootMotionVerticalDeltaForFalling' has a wrong offset!");

// Class Matcha.MatchaLeaderboardEntryUIData
// 0x0148 (0x01B0 - 0x0068)
class UMatchaLeaderboardEntryUIData final : public UOdyUIData
{
public:
	struct FOdyUIIntBinding                       Rank;                                              // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUINameBinding                      PlayerId;                                          // 0x0088(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      PlayerName;                                        // 0x00A8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextureBinding                   CharacterPortraitTexture;                          // 0x00D0(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       Points;                                            // 0x0130(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       Knockouts;                                         // 0x0150(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       Wins;                                              // 0x0170(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsLocalPlayer;                                     // 0x0190(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaLeaderboardEntryUIData">();
	}
	static class UMatchaLeaderboardEntryUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaLeaderboardEntryUIData>();
	}
};
static_assert(alignof(UMatchaLeaderboardEntryUIData) == 0x000008, "Wrong alignment on UMatchaLeaderboardEntryUIData");
static_assert(sizeof(UMatchaLeaderboardEntryUIData) == 0x0001B0, "Wrong size on UMatchaLeaderboardEntryUIData");
static_assert(offsetof(UMatchaLeaderboardEntryUIData, Rank) == 0x000068, "Member 'UMatchaLeaderboardEntryUIData::Rank' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardEntryUIData, PlayerId) == 0x000088, "Member 'UMatchaLeaderboardEntryUIData::PlayerId' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardEntryUIData, PlayerName) == 0x0000A8, "Member 'UMatchaLeaderboardEntryUIData::PlayerName' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardEntryUIData, CharacterPortraitTexture) == 0x0000D0, "Member 'UMatchaLeaderboardEntryUIData::CharacterPortraitTexture' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardEntryUIData, Points) == 0x000130, "Member 'UMatchaLeaderboardEntryUIData::Points' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardEntryUIData, Knockouts) == 0x000150, "Member 'UMatchaLeaderboardEntryUIData::Knockouts' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardEntryUIData, Wins) == 0x000170, "Member 'UMatchaLeaderboardEntryUIData::Wins' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardEntryUIData, IsLocalPlayer) == 0x000190, "Member 'UMatchaLeaderboardEntryUIData::IsLocalPlayer' has a wrong offset!");

// Class Matcha.MatchaLeaderboardServiceModel
// 0x0030 (0x0060 - 0x0030)
class UMatchaLeaderboardServiceModel final : public UOdyServicesModel
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaLeaderboardServiceModel">();
	}
	static class UMatchaLeaderboardServiceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaLeaderboardServiceModel>();
	}
};
static_assert(alignof(UMatchaLeaderboardServiceModel) == 0x000008, "Wrong alignment on UMatchaLeaderboardServiceModel");
static_assert(sizeof(UMatchaLeaderboardServiceModel) == 0x000060, "Wrong size on UMatchaLeaderboardServiceModel");

// Class Matcha.MatchaLeaderboardUIData
// 0x0090 (0x00F8 - 0x0068)
class UMatchaLeaderboardUIData final : public UOdyUIData
{
public:
	TSubclassOf<class UMatchaLeaderboardEntryUIData> LeaderboardEntryUIDataClass;                       // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMatchaLeaderboardEntryUIData*>  LeaderboardEntries;                                // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LeaderboardEntriesChanged;                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMatchaLeaderboardEntryUIData*          LocalPlayerEntry;                                  // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsLoading;                                         // 0x0098(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       TotalLeaderboardSize;                              // 0x00B8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGetGameLeaderboardV1Completed(bool Success, const class FString& RequestID, const struct FGetGameLeaderboardV1Response& GameLeaderboardResponse, const struct FErrorResponseV1& ErrorResponse);
	void OnSearchGameLeaderboardV1Completed(bool Success, const class FString& RequestID, const struct FGetGameLeaderboardV1Response& GameLeaderboardResponse, const struct FErrorResponseV1& ErrorResponse);
	void Reload(int32 Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaLeaderboardUIData">();
	}
	static class UMatchaLeaderboardUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaLeaderboardUIData>();
	}
};
static_assert(alignof(UMatchaLeaderboardUIData) == 0x000008, "Wrong alignment on UMatchaLeaderboardUIData");
static_assert(sizeof(UMatchaLeaderboardUIData) == 0x0000F8, "Wrong size on UMatchaLeaderboardUIData");
static_assert(offsetof(UMatchaLeaderboardUIData, LeaderboardEntryUIDataClass) == 0x000068, "Member 'UMatchaLeaderboardUIData::LeaderboardEntryUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardUIData, LeaderboardEntries) == 0x000070, "Member 'UMatchaLeaderboardUIData::LeaderboardEntries' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardUIData, LeaderboardEntriesChanged) == 0x000080, "Member 'UMatchaLeaderboardUIData::LeaderboardEntriesChanged' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardUIData, LocalPlayerEntry) == 0x000090, "Member 'UMatchaLeaderboardUIData::LocalPlayerEntry' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardUIData, IsLoading) == 0x000098, "Member 'UMatchaLeaderboardUIData::IsLoading' has a wrong offset!");
static_assert(offsetof(UMatchaLeaderboardUIData, TotalLeaderboardSize) == 0x0000B8, "Member 'UMatchaLeaderboardUIData::TotalLeaderboardSize' has a wrong offset!");

// Class Matcha.MatchaLocalPlayer
// 0x0000 (0x02B0 - 0x02B0)
class UMatchaLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaLocalPlayer">();
	}
	static class UMatchaLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaLocalPlayer>();
	}
};
static_assert(alignof(UMatchaLocalPlayer) == 0x000008, "Wrong alignment on UMatchaLocalPlayer");
static_assert(sizeof(UMatchaLocalPlayer) == 0x0002B0, "Wrong size on UMatchaLocalPlayer");

// Class Matcha.MatchaLocalPlayerUIData
// 0x0468 (0x04D0 - 0x0068)
class UMatchaLocalPlayerUIData : public UOdyUIData
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatchaQueueUIData>         QueueUIDataClass;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      ShowStandaloneServers;                             // 0x0078(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsLoggedOut;                                       // 0x0098(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsNewAccount;                                      // 0x00B8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      NeedsNameChange;                                   // 0x00D8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUINameBinding                      PlayerId;                                          // 0x00F8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      PlayerName;                                        // 0x0118(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UMatchaPlayerProfileUIData*>     TeamMembers;                                       // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsPartyFull;                                       // 0x0150(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamMembersUpdated;                              // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UMatchaPlayerProfileUIData*>     SentInvites;                                       // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSentInvitesUpdated;                              // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UMatchaPlayerProfileUIData*>     ReceivedInvites;                                   // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReceivedInvitesUpdated;                          // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsAbleToQueue;                                     // 0x01C0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsAdmin;                                           // 0x01E0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      QueueStatus;                                       // 0x0200(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITimespanBinding                  TimeInQueue;                                       // 0x0220(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      PartyMatchStatus;                                  // 0x0240(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UMatchaSaveGame*                        PlayerSettings;                                    // 0x0268(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       SelectedCharacterIndexSetting;                     // 0x0270(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     LatencyMilliseconds;                               // 0x0290(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     PacketLossFraction;                                // 0x02B0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     PacketJitterMilliseconds;                          // 0x02D0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     SnapNetClientConnected;                            // 0x02F0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     RenderWorldFrameTime;                              // 0x0310(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       InputDelayFrames;                                  // 0x0330(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       PredictedFrames;                                   // 0x0350(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      LastConnectedServerURL;                            // 0x0370(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UMatchaQueueUIData*>             AvailableQueues;                                   // 0x0398(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAvailableQueuesChanged;                          // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoginStatusChanged;                              // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FOdyUINameBinding                      SelectedQueueId;                                   // 0x03C8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      ServersOnlineTimeMonToThurs;                       // 0x03E8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      ServersOnlineTimeFriToSun;                         // 0x0410(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x8C];                                     // 0x0438(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USnapNetClient>          WeakSnapNetClient;                                 // 0x04C4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetLocalPlayerNetworkId(const class UObject* WorldContextObject);

	void JoinQueue();
	void LeaveQueue();
	void OnIdentityStateChanged(EIdentityState PreviousIdentityState, EIdentityState IdentityState);
	void OnLocalPlayerJoin(int32 LocalPlayerIndex, int32 PlayerIndex, int32 ErrorCode);
	void OnLoginResponseChanged(const struct FLoginResponseV1& LoginResponse);
	void OnMasterVolumeChanged(float Volume);
	void OnMusicVolumeChanged(float Volume);
	void OnPartyChanged(class UMatchaPartyServiceModel* ServicesSubsystem);
	void OnQueuesAvailableChanged(class UMatchaPartyServiceModel* PartyServiceModel);
	void OnReceivedInvitesChanged(class UMatchaPartyServiceModel* ServicesSubsystem);
	void OnSentInvitesChanged(class UMatchaPartyServiceModel* ServicesSubsystem);
	void OnSFXVolumeChanged(float Volume);
	void SelectQueueAtIndex(int32 QueueIndex);
	void SelectQueueWithId(class FName QueueId);
	void SetAllowHeavyAttackFromMoveStickMode(bool bAllow);
	void SetAttackStickMode(EAttackStickMoveType MoveTypeToCast);
	void SetAutoDashSettingEnabled(bool bEnabled);
	void SetFrameRateCap(EFrameRateCap NewCap);
	void SetInventoryHeldSlotStackingMode(EInventoryHeldSlotStackingMode StackingMode);
	void SetMasterVolume(float Volume);
	void SetMusicVolume(float Volume);
	void SetSelectedCharacterIndex(int32 CharacterIndex);
	void SetSFXVolume(float Volume);
	void TryDisconnect();
	void TryJoinRemoteServer(const class FString& ConnectionURL);
	void TryStartPracticeRoom();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaLocalPlayerUIData">();
	}
	static class UMatchaLocalPlayerUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaLocalPlayerUIData>();
	}
};
static_assert(alignof(UMatchaLocalPlayerUIData) == 0x000008, "Wrong alignment on UMatchaLocalPlayerUIData");
static_assert(sizeof(UMatchaLocalPlayerUIData) == 0x0004D0, "Wrong size on UMatchaLocalPlayerUIData");
static_assert(offsetof(UMatchaLocalPlayerUIData, QueueUIDataClass) == 0x000070, "Member 'UMatchaLocalPlayerUIData::QueueUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, ShowStandaloneServers) == 0x000078, "Member 'UMatchaLocalPlayerUIData::ShowStandaloneServers' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, IsLoggedOut) == 0x000098, "Member 'UMatchaLocalPlayerUIData::IsLoggedOut' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, IsNewAccount) == 0x0000B8, "Member 'UMatchaLocalPlayerUIData::IsNewAccount' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, NeedsNameChange) == 0x0000D8, "Member 'UMatchaLocalPlayerUIData::NeedsNameChange' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, PlayerId) == 0x0000F8, "Member 'UMatchaLocalPlayerUIData::PlayerId' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, PlayerName) == 0x000118, "Member 'UMatchaLocalPlayerUIData::PlayerName' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, TeamMembers) == 0x000140, "Member 'UMatchaLocalPlayerUIData::TeamMembers' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, IsPartyFull) == 0x000150, "Member 'UMatchaLocalPlayerUIData::IsPartyFull' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, OnTeamMembersUpdated) == 0x000170, "Member 'UMatchaLocalPlayerUIData::OnTeamMembersUpdated' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, SentInvites) == 0x000180, "Member 'UMatchaLocalPlayerUIData::SentInvites' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, OnSentInvitesUpdated) == 0x000190, "Member 'UMatchaLocalPlayerUIData::OnSentInvitesUpdated' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, ReceivedInvites) == 0x0001A0, "Member 'UMatchaLocalPlayerUIData::ReceivedInvites' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, OnReceivedInvitesUpdated) == 0x0001B0, "Member 'UMatchaLocalPlayerUIData::OnReceivedInvitesUpdated' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, IsAbleToQueue) == 0x0001C0, "Member 'UMatchaLocalPlayerUIData::IsAbleToQueue' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, IsAdmin) == 0x0001E0, "Member 'UMatchaLocalPlayerUIData::IsAdmin' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, QueueStatus) == 0x000200, "Member 'UMatchaLocalPlayerUIData::QueueStatus' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, TimeInQueue) == 0x000220, "Member 'UMatchaLocalPlayerUIData::TimeInQueue' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, PartyMatchStatus) == 0x000240, "Member 'UMatchaLocalPlayerUIData::PartyMatchStatus' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, PlayerSettings) == 0x000268, "Member 'UMatchaLocalPlayerUIData::PlayerSettings' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, SelectedCharacterIndexSetting) == 0x000270, "Member 'UMatchaLocalPlayerUIData::SelectedCharacterIndexSetting' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, LatencyMilliseconds) == 0x000290, "Member 'UMatchaLocalPlayerUIData::LatencyMilliseconds' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, PacketLossFraction) == 0x0002B0, "Member 'UMatchaLocalPlayerUIData::PacketLossFraction' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, PacketJitterMilliseconds) == 0x0002D0, "Member 'UMatchaLocalPlayerUIData::PacketJitterMilliseconds' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, SnapNetClientConnected) == 0x0002F0, "Member 'UMatchaLocalPlayerUIData::SnapNetClientConnected' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, RenderWorldFrameTime) == 0x000310, "Member 'UMatchaLocalPlayerUIData::RenderWorldFrameTime' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, InputDelayFrames) == 0x000330, "Member 'UMatchaLocalPlayerUIData::InputDelayFrames' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, PredictedFrames) == 0x000350, "Member 'UMatchaLocalPlayerUIData::PredictedFrames' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, LastConnectedServerURL) == 0x000370, "Member 'UMatchaLocalPlayerUIData::LastConnectedServerURL' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, AvailableQueues) == 0x000398, "Member 'UMatchaLocalPlayerUIData::AvailableQueues' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, OnAvailableQueuesChanged) == 0x0003A8, "Member 'UMatchaLocalPlayerUIData::OnAvailableQueuesChanged' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, OnLoginStatusChanged) == 0x0003B8, "Member 'UMatchaLocalPlayerUIData::OnLoginStatusChanged' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, SelectedQueueId) == 0x0003C8, "Member 'UMatchaLocalPlayerUIData::SelectedQueueId' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, ServersOnlineTimeMonToThurs) == 0x0003E8, "Member 'UMatchaLocalPlayerUIData::ServersOnlineTimeMonToThurs' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, ServersOnlineTimeFriToSun) == 0x000410, "Member 'UMatchaLocalPlayerUIData::ServersOnlineTimeFriToSun' has a wrong offset!");
static_assert(offsetof(UMatchaLocalPlayerUIData, WeakSnapNetClient) == 0x0004C4, "Member 'UMatchaLocalPlayerUIData::WeakSnapNetClient' has a wrong offset!");

// Class Matcha.MatchaLootComponent
// 0x0010 (0x00B0 - 0x00A0)
class UMatchaLootComponent final : public UActorComponent
{
public:
	struct FRandomStream                          RandomStream;                                      // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UMatchaLootTableAsset*                  LootTable;                                         // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DropLootFromTable(const struct FVector& StartingSpawnLocation, const bool bDropItemsIgnoringOwnerCollision) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaLootComponent">();
	}
	static class UMatchaLootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaLootComponent>();
	}
};
static_assert(alignof(UMatchaLootComponent) == 0x000008, "Wrong alignment on UMatchaLootComponent");
static_assert(sizeof(UMatchaLootComponent) == 0x0000B0, "Wrong size on UMatchaLootComponent");
static_assert(offsetof(UMatchaLootComponent, RandomStream) == 0x0000A0, "Member 'UMatchaLootComponent::RandomStream' has a wrong offset!");
static_assert(offsetof(UMatchaLootComponent, LootTable) == 0x0000A8, "Member 'UMatchaLootComponent::LootTable' has a wrong offset!");

// Class Matcha.MatchaLootTableAsset
// 0x0010 (0x0040 - 0x0030)
class UMatchaLootTableAsset final : public UPrimaryDataAsset
{
public:
	TArray<struct FCategoryLootTable>             CategoryLootTables;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaLootTableAsset">();
	}
	static class UMatchaLootTableAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaLootTableAsset>();
	}
};
static_assert(alignof(UMatchaLootTableAsset) == 0x000008, "Wrong alignment on UMatchaLootTableAsset");
static_assert(sizeof(UMatchaLootTableAsset) == 0x000040, "Wrong size on UMatchaLootTableAsset");
static_assert(offsetof(UMatchaLootTableAsset, CategoryLootTables) == 0x000030, "Member 'UMatchaLootTableAsset::CategoryLootTables' has a wrong offset!");

// Class Matcha.MatchaMatchUIData
// 0x0000 (0x0068 - 0x0068)
class UMatchaMatchUIData final : public UOdyUIData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaMatchUIData">();
	}
	static class UMatchaMatchUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaMatchUIData>();
	}
};
static_assert(alignof(UMatchaMatchUIData) == 0x000008, "Wrong alignment on UMatchaMatchUIData");
static_assert(sizeof(UMatchaMatchUIData) == 0x000068, "Wrong size on UMatchaMatchUIData");

// Class Matcha.MatchaSnapNetInteractableRenderer
// 0x0018 (0x02A8 - 0x0290)
class AMatchaSnapNetInteractableRenderer : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USnapNetEntityRendererComponent*        EntityRendererComponent;                           // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootSceneComponent;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_OnUpdateFromEntity(const class AMatchaSnapNetInteractiveEntity* EntityActor, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetInteractableRenderer">();
	}
	static class AMatchaSnapNetInteractableRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetInteractableRenderer>();
	}
};
static_assert(alignof(AMatchaSnapNetInteractableRenderer) == 0x000008, "Wrong alignment on AMatchaSnapNetInteractableRenderer");
static_assert(sizeof(AMatchaSnapNetInteractableRenderer) == 0x0002A8, "Wrong size on AMatchaSnapNetInteractableRenderer");
static_assert(offsetof(AMatchaSnapNetInteractableRenderer, EntityRendererComponent) == 0x000298, "Member 'AMatchaSnapNetInteractableRenderer::EntityRendererComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetInteractableRenderer, RootSceneComponent) == 0x0002A0, "Member 'AMatchaSnapNetInteractableRenderer::RootSceneComponent' has a wrong offset!");

// Class Matcha.MatchaMovingPlatformEntity
// 0x0110 (0x0488 - 0x0378)
class AMatchaMovingPlatformEntity : public AMatchaSnapNetEntity
{
public:
	struct FSnapNetPropertyEnum                   LoopMode;                                          // 0x0378(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         ResetIntervalSeconds;                              // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyFloat                  StartDelaySeconds;                                 // 0x03C8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertySoftObjectPath         SplineActorToFollow;                               // 0x0408(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x18];                                     // 0x0470(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EMatchaMovingPlatformPhase GetCurrentPhase() const;
	float GetCurrentPhaseDuration() const;
	float GetCurrentPhaseNormalizedProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaMovingPlatformEntity">();
	}
	static class AMatchaMovingPlatformEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaMovingPlatformEntity>();
	}
};
static_assert(alignof(AMatchaMovingPlatformEntity) == 0x000008, "Wrong alignment on AMatchaMovingPlatformEntity");
static_assert(sizeof(AMatchaMovingPlatformEntity) == 0x000488, "Wrong size on AMatchaMovingPlatformEntity");
static_assert(offsetof(AMatchaMovingPlatformEntity, LoopMode) == 0x000378, "Member 'AMatchaMovingPlatformEntity::LoopMode' has a wrong offset!");
static_assert(offsetof(AMatchaMovingPlatformEntity, ResetIntervalSeconds) == 0x0003C0, "Member 'AMatchaMovingPlatformEntity::ResetIntervalSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaMovingPlatformEntity, StartDelaySeconds) == 0x0003C8, "Member 'AMatchaMovingPlatformEntity::StartDelaySeconds' has a wrong offset!");
static_assert(offsetof(AMatchaMovingPlatformEntity, SplineActorToFollow) == 0x000408, "Member 'AMatchaMovingPlatformEntity::SplineActorToFollow' has a wrong offset!");

// Class Matcha.MatchaNotifyState_AirControlMultiplier
// 0x0008 (0x0038 - 0x0030)
class UMatchaNotifyState_AirControlMultiplier final : public UAnimNotifyState
{
public:
	float                                         AirControlMultiplier;                              // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotifyState_AirControlMultiplier">();
	}
	static class UMatchaNotifyState_AirControlMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotifyState_AirControlMultiplier>();
	}
};
static_assert(alignof(UMatchaNotifyState_AirControlMultiplier) == 0x000008, "Wrong alignment on UMatchaNotifyState_AirControlMultiplier");
static_assert(sizeof(UMatchaNotifyState_AirControlMultiplier) == 0x000038, "Wrong size on UMatchaNotifyState_AirControlMultiplier");
static_assert(offsetof(UMatchaNotifyState_AirControlMultiplier, AirControlMultiplier) == 0x000030, "Member 'UMatchaNotifyState_AirControlMultiplier::AirControlMultiplier' has a wrong offset!");

// Class Matcha.MatchaNotifyState_GravityMultiplier
// 0x0008 (0x0038 - 0x0030)
class UMatchaNotifyState_GravityMultiplier final : public UAnimNotifyState
{
public:
	float                                         GravityMultiplier;                                 // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotifyState_GravityMultiplier">();
	}
	static class UMatchaNotifyState_GravityMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotifyState_GravityMultiplier>();
	}
};
static_assert(alignof(UMatchaNotifyState_GravityMultiplier) == 0x000008, "Wrong alignment on UMatchaNotifyState_GravityMultiplier");
static_assert(sizeof(UMatchaNotifyState_GravityMultiplier) == 0x000038, "Wrong size on UMatchaNotifyState_GravityMultiplier");
static_assert(offsetof(UMatchaNotifyState_GravityMultiplier, GravityMultiplier) == 0x000030, "Member 'UMatchaNotifyState_GravityMultiplier::GravityMultiplier' has a wrong offset!");

// Class Matcha.MatchaNotifyState_HitBox
// 0x00A8 (0x00D8 - 0x0030)
class UMatchaNotifyState_HitBox final : public UAnimNotifyState
{
public:
	struct FMatchaHitBoxData                      HitBoxData;                                        // 0x0030(0x00A8)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotifyState_HitBox">();
	}
	static class UMatchaNotifyState_HitBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotifyState_HitBox>();
	}
};
static_assert(alignof(UMatchaNotifyState_HitBox) == 0x000008, "Wrong alignment on UMatchaNotifyState_HitBox");
static_assert(sizeof(UMatchaNotifyState_HitBox) == 0x0000D8, "Wrong size on UMatchaNotifyState_HitBox");
static_assert(offsetof(UMatchaNotifyState_HitBox, HitBoxData) == 0x000030, "Member 'UMatchaNotifyState_HitBox::HitBoxData' has a wrong offset!");

// Class Matcha.MatchaNotifyState_SetFlags
// 0x0018 (0x0048 - 0x0030)
class UMatchaNotifyState_SetFlags final : public UAnimNotifyState
{
public:
	struct FMatchaCharacterFlags                  CharacterFlags;                                    // 0x0030(0x0018)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotifyState_SetFlags">();
	}
	static class UMatchaNotifyState_SetFlags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotifyState_SetFlags>();
	}
};
static_assert(alignof(UMatchaNotifyState_SetFlags) == 0x000008, "Wrong alignment on UMatchaNotifyState_SetFlags");
static_assert(sizeof(UMatchaNotifyState_SetFlags) == 0x000048, "Wrong size on UMatchaNotifyState_SetFlags");
static_assert(offsetof(UMatchaNotifyState_SetFlags, CharacterFlags) == 0x000030, "Member 'UMatchaNotifyState_SetFlags::CharacterFlags' has a wrong offset!");

// Class Matcha.MatchaNotifyState_VisibilityOverride
// 0x0010 (0x0040 - 0x0030)
class UMatchaNotifyState_VisibilityOverride final : public UAnimNotifyState
{
public:
	TArray<struct FVisibilityOverride>            VisibilityOverrides;                               // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotifyState_VisibilityOverride">();
	}
	static class UMatchaNotifyState_VisibilityOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotifyState_VisibilityOverride>();
	}
};
static_assert(alignof(UMatchaNotifyState_VisibilityOverride) == 0x000008, "Wrong alignment on UMatchaNotifyState_VisibilityOverride");
static_assert(sizeof(UMatchaNotifyState_VisibilityOverride) == 0x000040, "Wrong size on UMatchaNotifyState_VisibilityOverride");
static_assert(offsetof(UMatchaNotifyState_VisibilityOverride, VisibilityOverrides) == 0x000030, "Member 'UMatchaNotifyState_VisibilityOverride::VisibilityOverrides' has a wrong offset!");

// Class Matcha.MatchaNotify_GameplayAction
// 0x0030 (0x0068 - 0x0038)
class UMatchaNotify_GameplayAction final : public UAnimNotify
{
public:
	bool                                          bIsHealAoE;                                        // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealAmount;                                        // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStunAoE;                                        // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunTimeSeconds;                                   // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActorFilterInfo                       AreaOfEffectActorFilterInfo;                       // 0x0048(0x0006)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Range;                                             // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OffsetFromCharacter;                               // 0x0058(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotify_GameplayAction">();
	}
	static class UMatchaNotify_GameplayAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotify_GameplayAction>();
	}
};
static_assert(alignof(UMatchaNotify_GameplayAction) == 0x000008, "Wrong alignment on UMatchaNotify_GameplayAction");
static_assert(sizeof(UMatchaNotify_GameplayAction) == 0x000068, "Wrong size on UMatchaNotify_GameplayAction");
static_assert(offsetof(UMatchaNotify_GameplayAction, bIsHealAoE) == 0x000038, "Member 'UMatchaNotify_GameplayAction::bIsHealAoE' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_GameplayAction, HealAmount) == 0x00003C, "Member 'UMatchaNotify_GameplayAction::HealAmount' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_GameplayAction, bIsStunAoE) == 0x000040, "Member 'UMatchaNotify_GameplayAction::bIsStunAoE' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_GameplayAction, StunTimeSeconds) == 0x000044, "Member 'UMatchaNotify_GameplayAction::StunTimeSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_GameplayAction, AreaOfEffectActorFilterInfo) == 0x000048, "Member 'UMatchaNotify_GameplayAction::AreaOfEffectActorFilterInfo' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_GameplayAction, Range) == 0x000050, "Member 'UMatchaNotify_GameplayAction::Range' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_GameplayAction, OffsetFromCharacter) == 0x000058, "Member 'UMatchaNotify_GameplayAction::OffsetFromCharacter' has a wrong offset!");

// Class Matcha.MatchaNotify_SpawnEntity
// 0x0060 (0x0098 - 0x0038)
class UMatchaNotify_SpawnEntity final : public UAnimNotify
{
public:
	TSoftClassPtr<class UClass>                   EntityClass;                                       // 0x0038(0x0028)(Edit, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnBone;                                         // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetFromBone;                                    // 0x0068(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnAngle;                                        // 0x0078(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EEntitySpawnCondition>                 SpawnConditions;                                   // 0x0080(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaximumAliveQuantity;                              // 0x0090(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotify_SpawnEntity">();
	}
	static class UMatchaNotify_SpawnEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotify_SpawnEntity>();
	}
};
static_assert(alignof(UMatchaNotify_SpawnEntity) == 0x000008, "Wrong alignment on UMatchaNotify_SpawnEntity");
static_assert(sizeof(UMatchaNotify_SpawnEntity) == 0x000098, "Wrong size on UMatchaNotify_SpawnEntity");
static_assert(offsetof(UMatchaNotify_SpawnEntity, EntityClass) == 0x000038, "Member 'UMatchaNotify_SpawnEntity::EntityClass' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_SpawnEntity, SpawnBone) == 0x000060, "Member 'UMatchaNotify_SpawnEntity::SpawnBone' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_SpawnEntity, OffsetFromBone) == 0x000068, "Member 'UMatchaNotify_SpawnEntity::OffsetFromBone' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_SpawnEntity, SpawnAngle) == 0x000078, "Member 'UMatchaNotify_SpawnEntity::SpawnAngle' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_SpawnEntity, SpawnConditions) == 0x000080, "Member 'UMatchaNotify_SpawnEntity::SpawnConditions' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_SpawnEntity, MaximumAliveQuantity) == 0x000090, "Member 'UMatchaNotify_SpawnEntity::MaximumAliveQuantity' has a wrong offset!");

// Class Matcha.MatchaSpawnRenderActorEvent
// 0x0140 (0x0170 - 0x0030)
class UMatchaSpawnRenderActorEvent final : public USnapNetEvent
{
public:
	struct FSnapNetPropertyEntityIndex            SpawningEntity;                                    // 0x0030(0x0068)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector2D               Location;                                          // 0x0098(0x0068)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertySoftObjectPath         ActorSoftClass;                                    // 0x0100(0x0068)(Transient, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedActor;                                      // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSpawnRenderActorEvent">();
	}
	static class UMatchaSpawnRenderActorEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSpawnRenderActorEvent>();
	}
};
static_assert(alignof(UMatchaSpawnRenderActorEvent) == 0x000008, "Wrong alignment on UMatchaSpawnRenderActorEvent");
static_assert(sizeof(UMatchaSpawnRenderActorEvent) == 0x000170, "Wrong size on UMatchaSpawnRenderActorEvent");
static_assert(offsetof(UMatchaSpawnRenderActorEvent, SpawningEntity) == 0x000030, "Member 'UMatchaSpawnRenderActorEvent::SpawningEntity' has a wrong offset!");
static_assert(offsetof(UMatchaSpawnRenderActorEvent, Location) == 0x000098, "Member 'UMatchaSpawnRenderActorEvent::Location' has a wrong offset!");
static_assert(offsetof(UMatchaSpawnRenderActorEvent, ActorSoftClass) == 0x000100, "Member 'UMatchaSpawnRenderActorEvent::ActorSoftClass' has a wrong offset!");
static_assert(offsetof(UMatchaSpawnRenderActorEvent, SpawnedActor) == 0x000168, "Member 'UMatchaSpawnRenderActorEvent::SpawnedActor' has a wrong offset!");

// Class Matcha.MatchaNotify_TargetedGlitchDash
// 0x0038 (0x0070 - 0x0038)
class UMatchaNotify_TargetedGlitchDash final : public UAnimNotify
{
public:
	struct FTargetedGlitchDashSettings            TargetedGlitchDashSettings;                        // 0x0038(0x0038)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotify_TargetedGlitchDash">();
	}
	static class UMatchaNotify_TargetedGlitchDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotify_TargetedGlitchDash>();
	}
};
static_assert(alignof(UMatchaNotify_TargetedGlitchDash) == 0x000008, "Wrong alignment on UMatchaNotify_TargetedGlitchDash");
static_assert(sizeof(UMatchaNotify_TargetedGlitchDash) == 0x000070, "Wrong size on UMatchaNotify_TargetedGlitchDash");
static_assert(offsetof(UMatchaNotify_TargetedGlitchDash, TargetedGlitchDashSettings) == 0x000038, "Member 'UMatchaNotify_TargetedGlitchDash::TargetedGlitchDashSettings' has a wrong offset!");

// Class Matcha.MatchaNotify_TeamAttackTeleport
// 0x0000 (0x0038 - 0x0038)
class UMatchaNotify_TeamAttackTeleport final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotify_TeamAttackTeleport">();
	}
	static class UMatchaNotify_TeamAttackTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotify_TeamAttackTeleport>();
	}
};
static_assert(alignof(UMatchaNotify_TeamAttackTeleport) == 0x000008, "Wrong alignment on UMatchaNotify_TeamAttackTeleport");
static_assert(sizeof(UMatchaNotify_TeamAttackTeleport) == 0x000038, "Wrong size on UMatchaNotify_TeamAttackTeleport");

// Class Matcha.MatchaNotify_Teleport
// 0x0058 (0x0090 - 0x0038)
class UMatchaNotify_Teleport final : public UAnimNotify
{
public:
	struct FSpecialTeleportSettings               TeleportSettings;                                  // 0x0038(0x0058)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotify_Teleport">();
	}
	static class UMatchaNotify_Teleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotify_Teleport>();
	}
};
static_assert(alignof(UMatchaNotify_Teleport) == 0x000008, "Wrong alignment on UMatchaNotify_Teleport");
static_assert(sizeof(UMatchaNotify_Teleport) == 0x000090, "Wrong size on UMatchaNotify_Teleport");
static_assert(offsetof(UMatchaNotify_Teleport, TeleportSettings) == 0x000038, "Member 'UMatchaNotify_Teleport::TeleportSettings' has a wrong offset!");

// Class Matcha.MatchaNotify_ThrowItem
// 0x0000 (0x0038 - 0x0038)
class UMatchaNotify_ThrowItem final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotify_ThrowItem">();
	}
	static class UMatchaNotify_ThrowItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotify_ThrowItem>();
	}
};
static_assert(alignof(UMatchaNotify_ThrowItem) == 0x000008, "Wrong alignment on UMatchaNotify_ThrowItem");
static_assert(sizeof(UMatchaNotify_ThrowItem) == 0x000038, "Wrong size on UMatchaNotify_ThrowItem");

// Class Matcha.MatchaPartyServiceModel
// 0x01B8 (0x01E8 - 0x0030)
class UMatchaPartyServiceModel final : public UOdyServicesModel
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             GetCurrentPartyRequestV1Completed;                 // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetSentInvitesRequestV1Completed;                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetReceivedInvitesRequestV1Completed;              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SendInviteRequestV1Completed;                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CancelInviteRequestV1Completed;                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AcceptInviteRequestV1Completed;                    // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RejectInviteRequestV1Completed;                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LeavePartyRequestV1Completed;                      // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LoadQueuesAvailableV1Completed;                    // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0xC8];                                     // 0x0120(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcceptPartyInvite(const class FName& SendingPlayerId);
	void CancelPartyInvite(const class FName& TargetPlayerId);
	class FName GetPartyId();
	class FName GetPartyLeaderPlayerId();
	TArray<struct FPartyMember> GetPartyMembers();
	bool GetQueuesAvailable(TArray<struct FQueuesAvailableResponseV1Entry>* OutQueuesAvailable);
	TArray<struct FReceivedPartyInvite> GetReceivedPartyInvites();
	TArray<struct FSentPartyInvite> GetSentPartyInvites();
	void JoinQueue(const class FName& QueueId);
	void LeaveParty();
	void LeaveQueue();
	bool LoadQueuesAvailableV1(class FString* OutRequestId);
	void LoadReceivedPartyInvites();
	void LoadSentPartyInvites();
	void OnWebsocketConnectionStateChanged(class UOdyServicesModelBase* InServicesSubsystem);
	void RejectPartyInvite(const class FName& SendingPlayerId);
	void SendPartyInvite(const class FString& TargetPlayerName);

	const struct FPlayerParty GetPlayerParty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPartyServiceModel">();
	}
	static class UMatchaPartyServiceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaPartyServiceModel>();
	}
};
static_assert(alignof(UMatchaPartyServiceModel) == 0x000008, "Wrong alignment on UMatchaPartyServiceModel");
static_assert(sizeof(UMatchaPartyServiceModel) == 0x0001E8, "Wrong size on UMatchaPartyServiceModel");
static_assert(offsetof(UMatchaPartyServiceModel, GetCurrentPartyRequestV1Completed) == 0x000090, "Member 'UMatchaPartyServiceModel::GetCurrentPartyRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaPartyServiceModel, GetSentInvitesRequestV1Completed) == 0x0000A0, "Member 'UMatchaPartyServiceModel::GetSentInvitesRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaPartyServiceModel, GetReceivedInvitesRequestV1Completed) == 0x0000B0, "Member 'UMatchaPartyServiceModel::GetReceivedInvitesRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaPartyServiceModel, SendInviteRequestV1Completed) == 0x0000C0, "Member 'UMatchaPartyServiceModel::SendInviteRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaPartyServiceModel, CancelInviteRequestV1Completed) == 0x0000D0, "Member 'UMatchaPartyServiceModel::CancelInviteRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaPartyServiceModel, AcceptInviteRequestV1Completed) == 0x0000E0, "Member 'UMatchaPartyServiceModel::AcceptInviteRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaPartyServiceModel, RejectInviteRequestV1Completed) == 0x0000F0, "Member 'UMatchaPartyServiceModel::RejectInviteRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaPartyServiceModel, LeavePartyRequestV1Completed) == 0x000100, "Member 'UMatchaPartyServiceModel::LeavePartyRequestV1Completed' has a wrong offset!");
static_assert(offsetof(UMatchaPartyServiceModel, LoadQueuesAvailableV1Completed) == 0x000110, "Member 'UMatchaPartyServiceModel::LoadQueuesAvailableV1Completed' has a wrong offset!");

// Class Matcha.MatchaPeriodicHitVolumeEntity
// 0x0048 (0x0488 - 0x0440)
class AMatchaPeriodicHitVolumeEntity : public AMatchaHitVolumeEntity
{
public:
	float                                         PeriodicHitIntervalSeconds;                        // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyInt32                  LastEnabledTimeMilliseconds;                       // 0x0448(0x0038)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPeriodicHitVolumeEntity">();
	}
	static class AMatchaPeriodicHitVolumeEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaPeriodicHitVolumeEntity>();
	}
};
static_assert(alignof(AMatchaPeriodicHitVolumeEntity) == 0x000008, "Wrong alignment on AMatchaPeriodicHitVolumeEntity");
static_assert(sizeof(AMatchaPeriodicHitVolumeEntity) == 0x000488, "Wrong size on AMatchaPeriodicHitVolumeEntity");
static_assert(offsetof(AMatchaPeriodicHitVolumeEntity, PeriodicHitIntervalSeconds) == 0x000440, "Member 'AMatchaPeriodicHitVolumeEntity::PeriodicHitIntervalSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaPeriodicHitVolumeEntity, LastEnabledTimeMilliseconds) == 0x000448, "Member 'AMatchaPeriodicHitVolumeEntity::LastEnabledTimeMilliseconds' has a wrong offset!");

// Class Matcha.MatchaPlayerCameraManager
// 0x0000 (0x24C0 - 0x24C0)
class AMatchaPlayerCameraManager : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPlayerCameraManager">();
	}
	static class AMatchaPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaPlayerCameraManager>();
	}
};
static_assert(alignof(AMatchaPlayerCameraManager) == 0x000010, "Wrong alignment on AMatchaPlayerCameraManager");
static_assert(sizeof(AMatchaPlayerCameraManager) == 0x0024C0, "Wrong size on AMatchaPlayerCameraManager");

// Class Matcha.MatchaPlayerJoinRequest
// 0x00C8 (0x0130 - 0x0068)
class UMatchaPlayerJoinRequest final : public USnapNetPlayerJoinRequest
{
public:
	struct FSnapNetPropertyString                 PlayerSessionId;                                   // 0x0068(0x0030)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyString                 MatchaPlayerId;                                    // 0x0098(0x0030)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyString                 PlayerName;                                        // 0x00C8(0x0030)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  CharacterEntityClassIndex;                         // 0x00F8(0x0038)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPlayerJoinRequest">();
	}
	static class UMatchaPlayerJoinRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaPlayerJoinRequest>();
	}
};
static_assert(alignof(UMatchaPlayerJoinRequest) == 0x000008, "Wrong alignment on UMatchaPlayerJoinRequest");
static_assert(sizeof(UMatchaPlayerJoinRequest) == 0x000130, "Wrong size on UMatchaPlayerJoinRequest");
static_assert(offsetof(UMatchaPlayerJoinRequest, PlayerSessionId) == 0x000068, "Member 'UMatchaPlayerJoinRequest::PlayerSessionId' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerJoinRequest, MatchaPlayerId) == 0x000098, "Member 'UMatchaPlayerJoinRequest::MatchaPlayerId' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerJoinRequest, PlayerName) == 0x0000C8, "Member 'UMatchaPlayerJoinRequest::PlayerName' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerJoinRequest, CharacterEntityClassIndex) == 0x0000F8, "Member 'UMatchaPlayerJoinRequest::CharacterEntityClassIndex' has a wrong offset!");

// Class Matcha.MatchaPlayerProfileUIData
// 0x0050 (0x00B8 - 0x0068)
class UMatchaPlayerProfileUIData final : public UOdyUIData
{
public:
	struct FOdyUINameBinding                      ID;                                                // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      Name_0;                                            // 0x0088(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerProfileUpdated(const struct FMatchaPlayerProfileV1& PlayerProfile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPlayerProfileUIData">();
	}
	static class UMatchaPlayerProfileUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaPlayerProfileUIData>();
	}
};
static_assert(alignof(UMatchaPlayerProfileUIData) == 0x000008, "Wrong alignment on UMatchaPlayerProfileUIData");
static_assert(sizeof(UMatchaPlayerProfileUIData) == 0x0000B8, "Wrong size on UMatchaPlayerProfileUIData");
static_assert(offsetof(UMatchaPlayerProfileUIData, ID) == 0x000068, "Member 'UMatchaPlayerProfileUIData::ID' has a wrong offset!");
static_assert(offsetof(UMatchaPlayerProfileUIData, Name_0) == 0x000088, "Member 'UMatchaPlayerProfileUIData::Name_0' has a wrong offset!");

// Class Matcha.MatchaPlayersServiceModel
// 0x0070 (0x00A0 - 0x0030)
class UMatchaPlayersServiceModel final : public UOdyServicesModel
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlushPendingProfileLookups();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPlayersServiceModel">();
	}
	static class UMatchaPlayersServiceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaPlayersServiceModel>();
	}
};
static_assert(alignof(UMatchaPlayersServiceModel) == 0x000008, "Wrong alignment on UMatchaPlayersServiceModel");
static_assert(sizeof(UMatchaPlayersServiceModel) == 0x0000A0, "Wrong size on UMatchaPlayersServiceModel");

// Class Matcha.MatchaPlayerStart
// 0x0010 (0x02D0 - 0x02C0)
class AMatchaPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESpawnRegion                                  SpawnRegion;                                       // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTeam;                                       // 0x02CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPlayerStart">();
	}
	static class AMatchaPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaPlayerStart>();
	}
};
static_assert(alignof(AMatchaPlayerStart) == 0x000008, "Wrong alignment on AMatchaPlayerStart");
static_assert(sizeof(AMatchaPlayerStart) == 0x0002D0, "Wrong size on AMatchaPlayerStart");
static_assert(offsetof(AMatchaPlayerStart, SpawnRegion) == 0x0002C8, "Member 'AMatchaPlayerStart::SpawnRegion' has a wrong offset!");
static_assert(offsetof(AMatchaPlayerStart, CurrentTeam) == 0x0002CC, "Member 'AMatchaPlayerStart::CurrentTeam' has a wrong offset!");

// Class Matcha.MatchaPracticeServerScript
// 0x0000 (0x02D0 - 0x02D0)
class UMatchaPracticeServerScript : public UMatchaServerScript
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaPracticeServerScript">();
	}
	static class UMatchaPracticeServerScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaPracticeServerScript>();
	}
};
static_assert(alignof(UMatchaPracticeServerScript) == 0x000008, "Wrong alignment on UMatchaPracticeServerScript");
static_assert(sizeof(UMatchaPracticeServerScript) == 0x0002D0, "Wrong size on UMatchaPracticeServerScript");

// Class Matcha.MatchaProjectileRenderer
// 0x0008 (0x02A8 - 0x02A0)
class AMatchaProjectileRenderer final : public AMatchaSnapNetRenderer
{
public:
	class USceneComponent*                        SceneRootComponent;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaProjectileRenderer">();
	}
	static class AMatchaProjectileRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaProjectileRenderer>();
	}
};
static_assert(alignof(AMatchaProjectileRenderer) == 0x000008, "Wrong alignment on AMatchaProjectileRenderer");
static_assert(sizeof(AMatchaProjectileRenderer) == 0x0002A8, "Wrong size on AMatchaProjectileRenderer");
static_assert(offsetof(AMatchaProjectileRenderer, SceneRootComponent) == 0x0002A0, "Member 'AMatchaProjectileRenderer::SceneRootComponent' has a wrong offset!");

// Class Matcha.MatchaQueueUIData
// 0x0048 (0x00B0 - 0x0068)
class UMatchaQueueUIData final : public UOdyUIData
{
public:
	struct FOdyUINameBinding                      QueueId;                                           // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      QueueName;                                         // 0x0088(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaQueueUIData">();
	}
	static class UMatchaQueueUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaQueueUIData>();
	}
};
static_assert(alignof(UMatchaQueueUIData) == 0x000008, "Wrong alignment on UMatchaQueueUIData");
static_assert(sizeof(UMatchaQueueUIData) == 0x0000B0, "Wrong size on UMatchaQueueUIData");
static_assert(offsetof(UMatchaQueueUIData, QueueId) == 0x000068, "Member 'UMatchaQueueUIData::QueueId' has a wrong offset!");
static_assert(offsetof(UMatchaQueueUIData, QueueName) == 0x000088, "Member 'UMatchaQueueUIData::QueueName' has a wrong offset!");

// Class Matcha.MatchaRegionServiceModel
// 0x0000 (0x0030 - 0x0030)
class UMatchaRegionServiceModel final : public UOdyServicesModel
{
public:
	void OnWebsocketConnectionStateChanged(class UOdyServicesModelBase* InServicesSubsystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaRegionServiceModel">();
	}
	static class UMatchaRegionServiceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaRegionServiceModel>();
	}
};
static_assert(alignof(UMatchaRegionServiceModel) == 0x000008, "Wrong alignment on UMatchaRegionServiceModel");
static_assert(sizeof(UMatchaRegionServiceModel) == 0x000030, "Wrong size on UMatchaRegionServiceModel");

// Class Matcha.MatchaServerServices
// 0x0018 (0x02F8 - 0x02E0)
class UMatchaServerServices final : public UOdyServicesModelBase
{
public:
	class UMatchaGameServiceModel*                GameServiceModel;                                  // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaServerServices">();
	}
	static class UMatchaServerServices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaServerServices>();
	}
};
static_assert(alignof(UMatchaServerServices) == 0x000008, "Wrong alignment on UMatchaServerServices");
static_assert(sizeof(UMatchaServerServices) == 0x0002F8, "Wrong size on UMatchaServerServices");
static_assert(offsetof(UMatchaServerServices, GameServiceModel) == 0x0002E0, "Member 'UMatchaServerServices::GameServiceModel' has a wrong offset!");

// Class Matcha.MatchaServicesDebugConfiguration
// 0x0028 (0x0060 - 0x0038)
class UMatchaServicesDebugConfiguration final : public UDeveloperSettings
{
public:
	class FString                                 VersionOverride;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSteamAuth;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TestUserTokens;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaServicesDebugConfiguration">();
	}
	static class UMatchaServicesDebugConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaServicesDebugConfiguration>();
	}
};
static_assert(alignof(UMatchaServicesDebugConfiguration) == 0x000008, "Wrong alignment on UMatchaServicesDebugConfiguration");
static_assert(sizeof(UMatchaServicesDebugConfiguration) == 0x000060, "Wrong size on UMatchaServicesDebugConfiguration");
static_assert(offsetof(UMatchaServicesDebugConfiguration, VersionOverride) == 0x000038, "Member 'UMatchaServicesDebugConfiguration::VersionOverride' has a wrong offset!");
static_assert(offsetof(UMatchaServicesDebugConfiguration, UseSteamAuth) == 0x000048, "Member 'UMatchaServicesDebugConfiguration::UseSteamAuth' has a wrong offset!");
static_assert(offsetof(UMatchaServicesDebugConfiguration, TestUserTokens) == 0x000050, "Member 'UMatchaServicesDebugConfiguration::TestUserTokens' has a wrong offset!");

// Class Matcha.MatchaSkinData
// 0x01B8 (0x01E8 - 0x0030)
class UMatchaSkinData : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FStaticMeshAttachmentInfo> StaticMeshAttachments;                             // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSkeletalMeshAttachmentInfo> SkeletalMeshAttachments;                           // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftClassPtr<class UClass>> ProjectileClasses;                                 // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UNiagaraSystem>> NiagaraTemplates;                                  // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UAkAudioEvent*>       AudioEvents;                                       // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSkinData">();
	}
	static class UMatchaSkinData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSkinData>();
	}
};
static_assert(alignof(UMatchaSkinData) == 0x000008, "Wrong alignment on UMatchaSkinData");
static_assert(sizeof(UMatchaSkinData) == 0x0001E8, "Wrong size on UMatchaSkinData");
static_assert(offsetof(UMatchaSkinData, Mesh) == 0x000030, "Member 'UMatchaSkinData::Mesh' has a wrong offset!");
static_assert(offsetof(UMatchaSkinData, StaticMeshAttachments) == 0x000058, "Member 'UMatchaSkinData::StaticMeshAttachments' has a wrong offset!");
static_assert(offsetof(UMatchaSkinData, SkeletalMeshAttachments) == 0x0000A8, "Member 'UMatchaSkinData::SkeletalMeshAttachments' has a wrong offset!");
static_assert(offsetof(UMatchaSkinData, ProjectileClasses) == 0x0000F8, "Member 'UMatchaSkinData::ProjectileClasses' has a wrong offset!");
static_assert(offsetof(UMatchaSkinData, NiagaraTemplates) == 0x000148, "Member 'UMatchaSkinData::NiagaraTemplates' has a wrong offset!");
static_assert(offsetof(UMatchaSkinData, AudioEvents) == 0x000198, "Member 'UMatchaSkinData::AudioEvents' has a wrong offset!");

// Class Matcha.MatchaSnapNetCharacterEntity
// 0x2910 (0x3C60 - 0x1350)
class AMatchaSnapNetCharacterEntity : public AMatchaCharacterBase
{
public:
	uint8                                         Pad_1348[0x28];                                    // 0x1348(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyFloat                  RespawnTimer;                                      // 0x1370(0x0040)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  GameplayPromptID;                                  // 0x13B0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  NewGameplayPromptMS;                               // 0x13E8(0x0038)(Transient, NativeAccessSpecifierPublic)
	struct FBuffInfo                              CharacterPassiveBuffInfo;                          // 0x1420(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                PortraitTexture;                                   // 0x1430(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                MinimapPortraitTexture;                            // 0x1458(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                EndOfGamePortraitTexture;                          // 0x1480(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOdyUIAssetData*                        UIAssetData;                                       // 0x14A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ShieldMeshComponent;                               // 0x14B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BallSoulComponent;                                 // 0x14B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          LedgeGrabComponent;                                // 0x14C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        LedgeGrabOffsetComponent;                          // 0x14C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractablesCollider;                             // 0x14D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMatchaGameplayEffectsComponent*        MatchaGameplayEffectsComponent;                    // 0x14D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14E0[0x8];                                     // 0x14E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartingDamage;                                    // 0x14E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefaultMaxAirJumps;                                // 0x14EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchWalkSpeed;                                   // 0x14F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkSpeed;                                         // 0x14F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashSpeed;                                         // 0x14F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialSpeed;                                       // 0x14FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialJumpVerticalVelocity;                        // 0x1500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundedFullJumpVerticalVelocity;                  // 0x1504(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundedShortJumpVerticalVelocity;                 // 0x1508(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialJumpMaxHorizontalVelocity;                   // 0x150C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundedJumpMaxHorizontalVelocity;                 // 0x1510(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LedgeJumpVerticalVelocity;                         // 0x1514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LedgeJumpHorizontalTowardsStageVelocity;           // 0x1518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallJumpVerticalVelocity;                          // 0x151C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallJumpHorizontalVelocity;                        // 0x1520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultLandingLagTime;                             // 0x1524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HelplessLandingLagTime;                            // 0x1528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_152C[0x4];                                     // 0x152C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMatchaCharacterMontageType, float>      PerMontageBaseLandingLagMap;                       // 0x1530(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EMatchaCharacterMontageType, float>      PerMontageAutoCancelEarlyMaxTimeMap;               // 0x1580(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EMatchaCharacterMontageType, float>      PerMontageAutoCancelMinElapsedRatioMap;            // 0x15D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         ZeroHealthShieldScale;                             // 0x1620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanChangeFacingOnAerialJumps;                     // 0x1624(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHelplessConditionType                        HelplessConditionType;                             // 0x1625(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1626[0x2];                                     // 0x1626(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESpecialAttackType, struct FSpecialAttackRestrictionInfo> PerTypeSpecialAttackRestrictions;                  // 0x1628(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         CharacterCollisionMovePerSecond;                   // 0x1678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialShieldScale;                                // 0x167C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  RemainingAirJumps;                                 // 0x1680(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FMatchaCharacterAttributeSet           AttributeSet;                                      // 0x16B8(0x09A8)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<EMatchaRootMotionType, struct FRootMotionForceData> RootMotionForceDefinitions;                        // 0x2060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SoulStateSmoothLerpMaxSpeed;                       // 0x20B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoulStateSmoothLerpPrecision;                      // 0x20B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SoulStateFollowOffset;                             // 0x20B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageThresholdSlowAmount;                         // 0x20C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageThresholdToApplySlow;                        // 0x20CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxBaseAcceleration;                               // 0x20D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAerialAcceleration;                             // 0x20D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowModToJumpForceModRatio;                        // 0x20D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NonGroundJumpForceReductionRatioFloor;             // 0x20DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumAirDodgeInitialSpeed;                       // 0x20E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumDashGrabInitialSpeed;                       // 0x20E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGrabHeightType                               GrabHeightType;                                    // 0x20E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20E9[0x7];                                     // 0x20E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EThrowDirection, EThrowType>             PerDirectionThrowType;                             // 0x20F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TeamAttackEnergyCost;                              // 0x2140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2144[0x4];                                     // 0x2144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTeamAttackSettings                    TeamAttackSettings;                                // 0x2148(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         EmpoweredSpecialEnergyCost;                        // 0x2170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnergyBurstEnergyCost;                             // 0x2174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnergyBurstSuperArmorTimeSeconds;                  // 0x2178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnergyBurstGravityDisableTimeSeconds;              // 0x217C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultHitFXId;                                    // 0x2180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultFastFallFXId;                               // 0x2188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultBounceFXId;                                 // 0x2190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZiplineInteractionRange;                           // 0x2198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219C[0x4];                                     // 0x219C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PickupCoinBagClass;                                // 0x21A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PickUpPowerSparksBagClass;                         // 0x21C8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DroppedLootSpawnSpacing;                           // 0x21F0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxOnDeathItemDropDistance;                        // 0x2208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220C[0x4];                                     // 0x220C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AttachableCompanionClass;                          // 0x2210(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FShieldInfo                            ShieldInfo;                                        // 0x2238(0x00D8)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FQueuedJumpInfo                        QueuedJumpInfo;                                    // 0x2310(0x0078)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FAppliedKnockBackInfo                  CurrentKnockBackInfo;                              // 0x2388(0x0260)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsBot;                                            // 0x25E8(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsCrouching;                                      // 0x2600(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FZAirGrabInfo                          ZAirGrabInfo;                                      // 0x2618(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FEnhancedAirDodgeInfo                  EnhancedAirDodgeInfo;                              // 0x2660(0x0030)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FDisguiseInfo                          DisguiseInfo;                                      // 0x2690(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsDashing;                                        // 0x2720(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bIsHelpless;                                       // 0x2738(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FWallRunStateInfo                      WallRunStateInfo;                                  // 0x2750(0x00C8)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FWallClingStateInfo                    WallClingStateInfo;                                // 0x2818(0x00E8)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEntityIndex            MovingPlatformEntityIndex;                         // 0x2900(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyPosition               MovingPlatformRelativePosition;                    // 0x2968(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  LastDashInputDirection;                            // 0x29B0(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  LastDashStartTimeMilliseconds;                     // 0x29F0(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  LastDashTimeMilliseconds;                          // 0x2A28(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  LastFallTimeMilliseconds;                          // 0x2A60(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  RemainingDisableTime;                              // 0x2A98(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  RemainingDizzyTime;                                // 0x2AD8(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  RemainingLandingLagTime;                           // 0x2B18(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  RemainingSuperArmorTime;                           // 0x2B58(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  RemainingIntangibilityTime;                        // 0x2B98(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  RemainingGravityDisableTime;                       // 0x2BD8(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  RemainingCameraScanModeTime;                       // 0x2C18(0x0040)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  CurrentHeldItemConsumeTime;                        // 0x2C58(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  LedgeWalkOffStartTime;                             // 0x2C90(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FHangingStateInfo                      HangingStateInfo;                                  // 0x2CC8(0x0088)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGrabInstigatorInfo                    GrabInstigatorInfo;                                // 0x2D50(0x00E8)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGrabTargetInfo                        GrabTargetInfo;                                    // 0x2E38(0x0130)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FHurtStateInfo                         HurtStateInfo;                                     // 0x2F68(0x0118)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSoulStateInfo                         SoulStateInfo;                                     // 0x3080(0x00B0)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBufferedInputInfo>             InputBuffer;                                       // 0x3130(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  LastTechAttemptTime;                               // 0x3140(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  LastSpecialAttackTime;                             // 0x3178(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActiveSpecialAttackRestriction> ActiveSpecialAttackRestrictions;                   // 0x31B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  RequestedLandingAnimationId;                       // 0x31C0(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  RequestedCounterAnimationId;                       // 0x31F8(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPropertyEntityIndexWrapper>    PickedUpSouls;                                     // 0x3230(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPeriodicDamageEffectInfo>      ActivePeriodicDamageEffects;                       // 0x3240(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPropertyEntityIndexWrapper>    RevealedCharacterEntityIndices;                    // 0x3250(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         RecentHitRevealTimeSeconds;                        // 0x3260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanRevealTimeSeconds;                             // 0x3264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEntityIndex            CompanionEntityIndex;                              // 0x3268(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FKOZoneInfo                            KOZoneInfo;                                        // 0x32D0(0x0098)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEnum                   ExpectedKnockOutType;                              // 0x3368(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyVector2D               BeforeKnockOutDirection;                           // 0x33B0(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FInstigatedHitInfo                     InstigatedHitInfo;                                 // 0x3418(0x0148)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FReceivedHitInfo                       ReceivedHitInfo;                                   // 0x3560(0x00E0)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInstigatedGlitchMarkInfo>      InstigatedGlitchMarks;                             // 0x3640(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  ReceivedGlitchMarkCount;                           // 0x3650(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bReflectProjectilesWhenShieldingEnabled;           // 0x3688(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyBoolean                bAutoTechEnabled;                                  // 0x36A0(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B8[0x20];                                    // 0x36B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTeamAttackInfo                        TeamAttackInfo;                                    // 0x36D8(0x0138)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bThrowEnabled;                                     // 0x3810(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3811[0x7];                                     // 0x3811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyVector2D               NextThrowDirection;                                // 0x3818(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3880[0x18];                                    // 0x3880(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveBuffInfoNetworked>       NetworkedBuffs;                                    // 0x3898(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActiveBuffInfoLocal>           LocalBuffs;                                        // 0x38A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38B8[0x1C0];                                   // 0x38B8(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            KnockBackTimeMultiplierCurve;                      // 0x3A78(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOverlappedEnvironmentHazard>   OverlappedEnvironmentHazards;                      // 0x3A80(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEntityIndex            BestInteractionTargetEntityIndex;                  // 0x3A90(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FInProgressInteraction                 InProgressInteraction;                             // 0x3AF8(0x0140)(Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 PlatformWeMightLandOn;                             // 0x3C38(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  PlatformWeAreFallingThrough;                       // 0x3C40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         CurrentIgnoredPlatforms;                           // 0x3C48(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C58[0x8];                                     // 0x3C58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AMatchaSnapNetCharacterEntity* Get(int32 PlayerIndex, const class UObject* WorldContextObject);
	static class AMatchaSnapNetCharacterEntity* GetFromSimulation(int32 PlayerIndex, const class USnapNetSimulation* SnapNetSimulation);
	static class UOdyUIAssetData* GetUIAssetData(TSubclassOf<class AMatchaSnapNetCharacterEntity> CharacterEntityClass);

	void AddEnergy(float Amount);
	void AddImmuneToCrowdControlFromHitTags(const struct FGameplayTagContainer& ImmuneToCCTags);
	void AddImmuneToDamageFromHitTags(const struct FGameplayTagContainer& CannotBeDamagedByTags);
	void AddRecentlyScannedCharacter(int32 EntityIndex, float Timestamp);
	void ApplyBuff(const struct FBuffInfo& BuffInfo, EObjectRarity ObjectRarity);
	void ApplyGlitchMark(class AActor* GlitchMarkTarget, bool bIsMarkFromItem, float DurationSeconds);
	void ApplyPeriodicDamageEffect(const struct FGameplayTag& PeriodicDamageEffectTag, const class AActor* PeriodicDamageInstigator, float DamageAmount, float DurationSeconds, float PeriodicDamageIntervalSeconds);
	void CancelCameraScanMode();
	void CancelDisguise();
	bool CanGlitchBeamAttack();
	void ClearCurrentGrab(bool bResetThrowDirection);
	void ClearHelpless();
	void ClearStatesForExternalLaunch(bool bClearCurrentMontage);
	void DisableGravity(float DurationSeconds);
	void DisableProjectileReflectionWhenShielding();
	void EnableProjectileReflectionWhenShielding(float ReflectAngle, float ReflectSpeedMultiplier, float ReflectDamageMultiplier);
	const class UMatchaItemAsset* GetHeldItem();
	void InertialCancel();
	bool IsInGlitchBeamWindUp();
	void OnCharacterJump(EJumpType JumpType);
	void OnCharacterKnockBackApplied(const class AActor* InInstigator);
	void OnKnockedOutAnEnemyCharacter(class AActor* KnockedEnemyCharacter);
	void PerformGlitchBeam();
	class AActor* PerformSpecialTeleport(const struct FSpecialTeleportSettings& TeleportSettings);
	void RemoveBuffsWithTag(const struct FGameplayTag& BuffTag);
	void RemoveImmuneToCrowdControlFromHitTags(const struct FGameplayTagContainer& ImmuneToCCTags);
	void RemoveImmuneToDamageFromHitTags(const struct FGameplayTagContainer& CannotBeDamagedByTags);
	void RemovePeriodicDamageEffect(class AActor* PeriodicDamageInstigator, const struct FGameplayTag& PeriodicDamageEffectTag);
	void RemoveSuperArmor();
	void RequestCameraScanMode(float DurationSeconds);
	void RequestDisable(float DurationSeconds);
	void RequestIntangibility(float DurationSeconds);
	void RequestLandingState(float DurationSeconds);
	void RequestPeriodicCoinGeneration(int32 Amount, float Interval);
	void RequestSuperArmor(float DurationSeconds);
	void ResetAirJumps();
	void ResetDisguiseElapsedTime();
	void ResetEnhancedAirDodge();
	void ResetZAirDashGrab();
	void SetCurrentGameplayPromptID(int32 IntID);
	void SetDisguiseEnabled(bool bEnabled);
	void SetEnhancedAirDodgeEnabled(bool bEnabled);
	void SetShieldInvincible(bool bIsInvincible);
	void SetupSpecialAttackRestrictions();
	void SetWallClingEnabled(bool bEnabled);
	void SetWallRunEnabled(bool bEnabled);
	void SetZAirDashGrabEnabled(bool bEnabled);
	void SetZAirGrabEnabled(bool bEnabled);
	void ToggleAutoTech(bool bShouldEnable);
	void TryPerformDisguise();
	void TryPerformGlitchStepAttack();

	class AMatchaAttachableCompanionEntity* GetCompanionEntity() const;
	float GetCurrentShieldHealth() const;
	int32 GetCurrentTeam() const;
	float GetDisguiseElapsedTime() const;
	int32 GetDisguiseId() const;
	float GetEnergy() const;
	float GetEnergyGenerationRatio() const;
	class AActor* GetGlitchMarkedTargetActor(bool bFromItemSource) const;
	float GetHitStunRemainingTime() const;
	float GetJuiceStat() const;
	int32 GetMaxAirJumps() const;
	float GetMaxEnergy() const;
	float GetMaxShieldHealth() const;
	int32 GetMostRecentlyHitEnemyPlayerWithinTimeWindow(float WindowTimeSeconds) const;
	class AMatchaSnapNetPlayerEntity* GetOwningPlayerEntity() const;
	int32 GetRemainingAirJumps() const;
	TArray<int32> GetRevealedCharacterEntityIndices() const;
	int32 GetSharedTeamCoinsCount() const;
	int32 GetSharedTeamPowerSparksCount() const;
	int32 GetShieldLastInputTime() const;
	EMatchaShieldState GetShieldState() const;
	float GetSlowAmountStat() const;
	int32 GetTimeSinceLastDashingStateMilliseconds() const;
	bool HasEnoughEnergy(float NeededAmount) const;
	bool HasSuperArmor() const;
	bool IsDashing() const;
	bool IsDisguised() const;
	bool IsDisguiseEnabled() const;
	bool IsEnhancedAirDodgeEnabled() const;
	bool IsHelpless() const;
	bool IsInHitStun() const;
	bool IsInPetrifyHitFreeze() const;
	bool IsInsideZone() const;
	bool IsInSoulState() const;
	bool IsIntangible() const;
	bool IsZAirDashGrabEnabled() const;
	bool IsZAirGrabEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetCharacterEntity">();
	}
	static class AMatchaSnapNetCharacterEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetCharacterEntity>();
	}
};
static_assert(alignof(AMatchaSnapNetCharacterEntity) == 0x000010, "Wrong alignment on AMatchaSnapNetCharacterEntity");
static_assert(sizeof(AMatchaSnapNetCharacterEntity) == 0x003C60, "Wrong size on AMatchaSnapNetCharacterEntity");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RespawnTimer) == 0x001370, "Member 'AMatchaSnapNetCharacterEntity::RespawnTimer' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, GameplayPromptID) == 0x0013B0, "Member 'AMatchaSnapNetCharacterEntity::GameplayPromptID' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, NewGameplayPromptMS) == 0x0013E8, "Member 'AMatchaSnapNetCharacterEntity::NewGameplayPromptMS' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, CharacterPassiveBuffInfo) == 0x001420, "Member 'AMatchaSnapNetCharacterEntity::CharacterPassiveBuffInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PortraitTexture) == 0x001430, "Member 'AMatchaSnapNetCharacterEntity::PortraitTexture' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MinimapPortraitTexture) == 0x001458, "Member 'AMatchaSnapNetCharacterEntity::MinimapPortraitTexture' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, EndOfGamePortraitTexture) == 0x001480, "Member 'AMatchaSnapNetCharacterEntity::EndOfGamePortraitTexture' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, UIAssetData) == 0x0014A8, "Member 'AMatchaSnapNetCharacterEntity::UIAssetData' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ShieldMeshComponent) == 0x0014B0, "Member 'AMatchaSnapNetCharacterEntity::ShieldMeshComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, BallSoulComponent) == 0x0014B8, "Member 'AMatchaSnapNetCharacterEntity::BallSoulComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LedgeGrabComponent) == 0x0014C0, "Member 'AMatchaSnapNetCharacterEntity::LedgeGrabComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LedgeGrabOffsetComponent) == 0x0014C8, "Member 'AMatchaSnapNetCharacterEntity::LedgeGrabOffsetComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, InteractablesCollider) == 0x0014D0, "Member 'AMatchaSnapNetCharacterEntity::InteractablesCollider' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MatchaGameplayEffectsComponent) == 0x0014D8, "Member 'AMatchaSnapNetCharacterEntity::MatchaGameplayEffectsComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, StartingDamage) == 0x0014E8, "Member 'AMatchaSnapNetCharacterEntity::StartingDamage' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DefaultMaxAirJumps) == 0x0014EC, "Member 'AMatchaSnapNetCharacterEntity::DefaultMaxAirJumps' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, CrouchWalkSpeed) == 0x0014F0, "Member 'AMatchaSnapNetCharacterEntity::CrouchWalkSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, WalkSpeed) == 0x0014F4, "Member 'AMatchaSnapNetCharacterEntity::WalkSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DashSpeed) == 0x0014F8, "Member 'AMatchaSnapNetCharacterEntity::DashSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, AerialSpeed) == 0x0014FC, "Member 'AMatchaSnapNetCharacterEntity::AerialSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, AerialJumpVerticalVelocity) == 0x001500, "Member 'AMatchaSnapNetCharacterEntity::AerialJumpVerticalVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, GroundedFullJumpVerticalVelocity) == 0x001504, "Member 'AMatchaSnapNetCharacterEntity::GroundedFullJumpVerticalVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, GroundedShortJumpVerticalVelocity) == 0x001508, "Member 'AMatchaSnapNetCharacterEntity::GroundedShortJumpVerticalVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, AerialJumpMaxHorizontalVelocity) == 0x00150C, "Member 'AMatchaSnapNetCharacterEntity::AerialJumpMaxHorizontalVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, GroundedJumpMaxHorizontalVelocity) == 0x001510, "Member 'AMatchaSnapNetCharacterEntity::GroundedJumpMaxHorizontalVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LedgeJumpVerticalVelocity) == 0x001514, "Member 'AMatchaSnapNetCharacterEntity::LedgeJumpVerticalVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LedgeJumpHorizontalTowardsStageVelocity) == 0x001518, "Member 'AMatchaSnapNetCharacterEntity::LedgeJumpHorizontalTowardsStageVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, WallJumpVerticalVelocity) == 0x00151C, "Member 'AMatchaSnapNetCharacterEntity::WallJumpVerticalVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, WallJumpHorizontalVelocity) == 0x001520, "Member 'AMatchaSnapNetCharacterEntity::WallJumpHorizontalVelocity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DefaultLandingLagTime) == 0x001524, "Member 'AMatchaSnapNetCharacterEntity::DefaultLandingLagTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, HelplessLandingLagTime) == 0x001528, "Member 'AMatchaSnapNetCharacterEntity::HelplessLandingLagTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PerMontageBaseLandingLagMap) == 0x001530, "Member 'AMatchaSnapNetCharacterEntity::PerMontageBaseLandingLagMap' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PerMontageAutoCancelEarlyMaxTimeMap) == 0x001580, "Member 'AMatchaSnapNetCharacterEntity::PerMontageAutoCancelEarlyMaxTimeMap' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PerMontageAutoCancelMinElapsedRatioMap) == 0x0015D0, "Member 'AMatchaSnapNetCharacterEntity::PerMontageAutoCancelMinElapsedRatioMap' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ZeroHealthShieldScale) == 0x001620, "Member 'AMatchaSnapNetCharacterEntity::ZeroHealthShieldScale' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, bCanChangeFacingOnAerialJumps) == 0x001624, "Member 'AMatchaSnapNetCharacterEntity::bCanChangeFacingOnAerialJumps' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, HelplessConditionType) == 0x001625, "Member 'AMatchaSnapNetCharacterEntity::HelplessConditionType' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PerTypeSpecialAttackRestrictions) == 0x001628, "Member 'AMatchaSnapNetCharacterEntity::PerTypeSpecialAttackRestrictions' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, CharacterCollisionMovePerSecond) == 0x001678, "Member 'AMatchaSnapNetCharacterEntity::CharacterCollisionMovePerSecond' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, InitialShieldScale) == 0x00167C, "Member 'AMatchaSnapNetCharacterEntity::InitialShieldScale' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RemainingAirJumps) == 0x001680, "Member 'AMatchaSnapNetCharacterEntity::RemainingAirJumps' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, AttributeSet) == 0x0016B8, "Member 'AMatchaSnapNetCharacterEntity::AttributeSet' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RootMotionForceDefinitions) == 0x002060, "Member 'AMatchaSnapNetCharacterEntity::RootMotionForceDefinitions' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, SoulStateSmoothLerpMaxSpeed) == 0x0020B0, "Member 'AMatchaSnapNetCharacterEntity::SoulStateSmoothLerpMaxSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, SoulStateSmoothLerpPrecision) == 0x0020B4, "Member 'AMatchaSnapNetCharacterEntity::SoulStateSmoothLerpPrecision' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, SoulStateFollowOffset) == 0x0020B8, "Member 'AMatchaSnapNetCharacterEntity::SoulStateFollowOffset' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DamageThresholdSlowAmount) == 0x0020C8, "Member 'AMatchaSnapNetCharacterEntity::DamageThresholdSlowAmount' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DamageThresholdToApplySlow) == 0x0020CC, "Member 'AMatchaSnapNetCharacterEntity::DamageThresholdToApplySlow' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MaxBaseAcceleration) == 0x0020D0, "Member 'AMatchaSnapNetCharacterEntity::MaxBaseAcceleration' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MaxAerialAcceleration) == 0x0020D4, "Member 'AMatchaSnapNetCharacterEntity::MaxAerialAcceleration' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, SlowModToJumpForceModRatio) == 0x0020D8, "Member 'AMatchaSnapNetCharacterEntity::SlowModToJumpForceModRatio' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, NonGroundJumpForceReductionRatioFloor) == 0x0020DC, "Member 'AMatchaSnapNetCharacterEntity::NonGroundJumpForceReductionRatioFloor' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MaximumAirDodgeInitialSpeed) == 0x0020E0, "Member 'AMatchaSnapNetCharacterEntity::MaximumAirDodgeInitialSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MaximumDashGrabInitialSpeed) == 0x0020E4, "Member 'AMatchaSnapNetCharacterEntity::MaximumDashGrabInitialSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, GrabHeightType) == 0x0020E8, "Member 'AMatchaSnapNetCharacterEntity::GrabHeightType' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PerDirectionThrowType) == 0x0020F0, "Member 'AMatchaSnapNetCharacterEntity::PerDirectionThrowType' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, TeamAttackEnergyCost) == 0x002140, "Member 'AMatchaSnapNetCharacterEntity::TeamAttackEnergyCost' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, TeamAttackSettings) == 0x002148, "Member 'AMatchaSnapNetCharacterEntity::TeamAttackSettings' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, EmpoweredSpecialEnergyCost) == 0x002170, "Member 'AMatchaSnapNetCharacterEntity::EmpoweredSpecialEnergyCost' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, EnergyBurstEnergyCost) == 0x002174, "Member 'AMatchaSnapNetCharacterEntity::EnergyBurstEnergyCost' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, EnergyBurstSuperArmorTimeSeconds) == 0x002178, "Member 'AMatchaSnapNetCharacterEntity::EnergyBurstSuperArmorTimeSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, EnergyBurstGravityDisableTimeSeconds) == 0x00217C, "Member 'AMatchaSnapNetCharacterEntity::EnergyBurstGravityDisableTimeSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DefaultHitFXId) == 0x002180, "Member 'AMatchaSnapNetCharacterEntity::DefaultHitFXId' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DefaultFastFallFXId) == 0x002188, "Member 'AMatchaSnapNetCharacterEntity::DefaultFastFallFXId' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DefaultBounceFXId) == 0x002190, "Member 'AMatchaSnapNetCharacterEntity::DefaultBounceFXId' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ZiplineInteractionRange) == 0x002198, "Member 'AMatchaSnapNetCharacterEntity::ZiplineInteractionRange' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PickupCoinBagClass) == 0x0021A0, "Member 'AMatchaSnapNetCharacterEntity::PickupCoinBagClass' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PickUpPowerSparksBagClass) == 0x0021C8, "Member 'AMatchaSnapNetCharacterEntity::PickUpPowerSparksBagClass' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DroppedLootSpawnSpacing) == 0x0021F0, "Member 'AMatchaSnapNetCharacterEntity::DroppedLootSpawnSpacing' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MaxOnDeathItemDropDistance) == 0x002208, "Member 'AMatchaSnapNetCharacterEntity::MaxOnDeathItemDropDistance' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, AttachableCompanionClass) == 0x002210, "Member 'AMatchaSnapNetCharacterEntity::AttachableCompanionClass' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ShieldInfo) == 0x002238, "Member 'AMatchaSnapNetCharacterEntity::ShieldInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, QueuedJumpInfo) == 0x002310, "Member 'AMatchaSnapNetCharacterEntity::QueuedJumpInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, CurrentKnockBackInfo) == 0x002388, "Member 'AMatchaSnapNetCharacterEntity::CurrentKnockBackInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, bIsBot) == 0x0025E8, "Member 'AMatchaSnapNetCharacterEntity::bIsBot' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, bIsCrouching) == 0x002600, "Member 'AMatchaSnapNetCharacterEntity::bIsCrouching' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ZAirGrabInfo) == 0x002618, "Member 'AMatchaSnapNetCharacterEntity::ZAirGrabInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, EnhancedAirDodgeInfo) == 0x002660, "Member 'AMatchaSnapNetCharacterEntity::EnhancedAirDodgeInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, DisguiseInfo) == 0x002690, "Member 'AMatchaSnapNetCharacterEntity::DisguiseInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, bIsDashing) == 0x002720, "Member 'AMatchaSnapNetCharacterEntity::bIsDashing' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, bIsHelpless) == 0x002738, "Member 'AMatchaSnapNetCharacterEntity::bIsHelpless' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, WallRunStateInfo) == 0x002750, "Member 'AMatchaSnapNetCharacterEntity::WallRunStateInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, WallClingStateInfo) == 0x002818, "Member 'AMatchaSnapNetCharacterEntity::WallClingStateInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MovingPlatformEntityIndex) == 0x002900, "Member 'AMatchaSnapNetCharacterEntity::MovingPlatformEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, MovingPlatformRelativePosition) == 0x002968, "Member 'AMatchaSnapNetCharacterEntity::MovingPlatformRelativePosition' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LastDashInputDirection) == 0x0029B0, "Member 'AMatchaSnapNetCharacterEntity::LastDashInputDirection' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LastDashStartTimeMilliseconds) == 0x0029F0, "Member 'AMatchaSnapNetCharacterEntity::LastDashStartTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LastDashTimeMilliseconds) == 0x002A28, "Member 'AMatchaSnapNetCharacterEntity::LastDashTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LastFallTimeMilliseconds) == 0x002A60, "Member 'AMatchaSnapNetCharacterEntity::LastFallTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RemainingDisableTime) == 0x002A98, "Member 'AMatchaSnapNetCharacterEntity::RemainingDisableTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RemainingDizzyTime) == 0x002AD8, "Member 'AMatchaSnapNetCharacterEntity::RemainingDizzyTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RemainingLandingLagTime) == 0x002B18, "Member 'AMatchaSnapNetCharacterEntity::RemainingLandingLagTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RemainingSuperArmorTime) == 0x002B58, "Member 'AMatchaSnapNetCharacterEntity::RemainingSuperArmorTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RemainingIntangibilityTime) == 0x002B98, "Member 'AMatchaSnapNetCharacterEntity::RemainingIntangibilityTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RemainingGravityDisableTime) == 0x002BD8, "Member 'AMatchaSnapNetCharacterEntity::RemainingGravityDisableTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RemainingCameraScanModeTime) == 0x002C18, "Member 'AMatchaSnapNetCharacterEntity::RemainingCameraScanModeTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, CurrentHeldItemConsumeTime) == 0x002C58, "Member 'AMatchaSnapNetCharacterEntity::CurrentHeldItemConsumeTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LedgeWalkOffStartTime) == 0x002C90, "Member 'AMatchaSnapNetCharacterEntity::LedgeWalkOffStartTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, HangingStateInfo) == 0x002CC8, "Member 'AMatchaSnapNetCharacterEntity::HangingStateInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, GrabInstigatorInfo) == 0x002D50, "Member 'AMatchaSnapNetCharacterEntity::GrabInstigatorInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, GrabTargetInfo) == 0x002E38, "Member 'AMatchaSnapNetCharacterEntity::GrabTargetInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, HurtStateInfo) == 0x002F68, "Member 'AMatchaSnapNetCharacterEntity::HurtStateInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, SoulStateInfo) == 0x003080, "Member 'AMatchaSnapNetCharacterEntity::SoulStateInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, InputBuffer) == 0x003130, "Member 'AMatchaSnapNetCharacterEntity::InputBuffer' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LastTechAttemptTime) == 0x003140, "Member 'AMatchaSnapNetCharacterEntity::LastTechAttemptTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LastSpecialAttackTime) == 0x003178, "Member 'AMatchaSnapNetCharacterEntity::LastSpecialAttackTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ActiveSpecialAttackRestrictions) == 0x0031B0, "Member 'AMatchaSnapNetCharacterEntity::ActiveSpecialAttackRestrictions' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RequestedLandingAnimationId) == 0x0031C0, "Member 'AMatchaSnapNetCharacterEntity::RequestedLandingAnimationId' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RequestedCounterAnimationId) == 0x0031F8, "Member 'AMatchaSnapNetCharacterEntity::RequestedCounterAnimationId' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PickedUpSouls) == 0x003230, "Member 'AMatchaSnapNetCharacterEntity::PickedUpSouls' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ActivePeriodicDamageEffects) == 0x003240, "Member 'AMatchaSnapNetCharacterEntity::ActivePeriodicDamageEffects' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RevealedCharacterEntityIndices) == 0x003250, "Member 'AMatchaSnapNetCharacterEntity::RevealedCharacterEntityIndices' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, RecentHitRevealTimeSeconds) == 0x003260, "Member 'AMatchaSnapNetCharacterEntity::RecentHitRevealTimeSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ScanRevealTimeSeconds) == 0x003264, "Member 'AMatchaSnapNetCharacterEntity::ScanRevealTimeSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, CompanionEntityIndex) == 0x003268, "Member 'AMatchaSnapNetCharacterEntity::CompanionEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, KOZoneInfo) == 0x0032D0, "Member 'AMatchaSnapNetCharacterEntity::KOZoneInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ExpectedKnockOutType) == 0x003368, "Member 'AMatchaSnapNetCharacterEntity::ExpectedKnockOutType' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, BeforeKnockOutDirection) == 0x0033B0, "Member 'AMatchaSnapNetCharacterEntity::BeforeKnockOutDirection' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, InstigatedHitInfo) == 0x003418, "Member 'AMatchaSnapNetCharacterEntity::InstigatedHitInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ReceivedHitInfo) == 0x003560, "Member 'AMatchaSnapNetCharacterEntity::ReceivedHitInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, InstigatedGlitchMarks) == 0x003640, "Member 'AMatchaSnapNetCharacterEntity::InstigatedGlitchMarks' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, ReceivedGlitchMarkCount) == 0x003650, "Member 'AMatchaSnapNetCharacterEntity::ReceivedGlitchMarkCount' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, bReflectProjectilesWhenShieldingEnabled) == 0x003688, "Member 'AMatchaSnapNetCharacterEntity::bReflectProjectilesWhenShieldingEnabled' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, bAutoTechEnabled) == 0x0036A0, "Member 'AMatchaSnapNetCharacterEntity::bAutoTechEnabled' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, TeamAttackInfo) == 0x0036D8, "Member 'AMatchaSnapNetCharacterEntity::TeamAttackInfo' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, bThrowEnabled) == 0x003810, "Member 'AMatchaSnapNetCharacterEntity::bThrowEnabled' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, NextThrowDirection) == 0x003818, "Member 'AMatchaSnapNetCharacterEntity::NextThrowDirection' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, NetworkedBuffs) == 0x003898, "Member 'AMatchaSnapNetCharacterEntity::NetworkedBuffs' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, LocalBuffs) == 0x0038A8, "Member 'AMatchaSnapNetCharacterEntity::LocalBuffs' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, KnockBackTimeMultiplierCurve) == 0x003A78, "Member 'AMatchaSnapNetCharacterEntity::KnockBackTimeMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, OverlappedEnvironmentHazards) == 0x003A80, "Member 'AMatchaSnapNetCharacterEntity::OverlappedEnvironmentHazards' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, BestInteractionTargetEntityIndex) == 0x003A90, "Member 'AMatchaSnapNetCharacterEntity::BestInteractionTargetEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, InProgressInteraction) == 0x003AF8, "Member 'AMatchaSnapNetCharacterEntity::InProgressInteraction' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PlatformWeMightLandOn) == 0x003C38, "Member 'AMatchaSnapNetCharacterEntity::PlatformWeMightLandOn' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, PlatformWeAreFallingThrough) == 0x003C40, "Member 'AMatchaSnapNetCharacterEntity::PlatformWeAreFallingThrough' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterEntity, CurrentIgnoredPlatforms) == 0x003C48, "Member 'AMatchaSnapNetCharacterEntity::CurrentIgnoredPlatforms' has a wrong offset!");

// Class Matcha.MatchaSnapNetCharacterRenderer
// 0x0570 (0x0888 - 0x0318)
class AMatchaSnapNetCharacterRenderer : public APawn
{
public:
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOdyUIIntBinding                       GameplayPromptID;                                  // 0x0328(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     Damage;                                            // 0x0348(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentConsumeItemFinishTime;                      // 0x0368(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentShieldHealth;                               // 0x0388(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentMaxShieldHealth;                            // 0x03A8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentEnergy;                                     // 0x03C8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentMaxEnergy;                                  // 0x03E8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentJuiceStat;                                  // 0x0408(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     CurrentSlowAmountStat;                             // 0x0428(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     RemainingCameraScanModeTime;                       // 0x0448(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       SharedTeamCoinCount;                               // 0x0468(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                ViewTargetOffsetWalking;                           // 0x0488(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ViewTargetOffsetFalling;                           // 0x04A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ViewTarget;                                        // 0x04B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UStaticMesh>>     AvailablePropMeshes;                               // 0x04D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FVector                                PropExtraOffset;                                   // 0x04E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionProgressHeightOffset;                   // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitShakeFrequency;                                 // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitShakeAmplitude;                                 // 0x0500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHitShakeStrength;                               // 0x0504(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHitShakeStrength;                               // 0x0508(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatchaSkinData>            DefaultSkinData;                                   // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAliveState                                   AliveState;                                        // 0x0518(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlive;                                            // 0x0519(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFalling;                                        // 0x051A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCameraInScanMode;                                 // 0x051B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFallType                                     CurrentFallType;                                   // 0x051C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInKnockBack;                                    // 0x051D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLethalKnockBack;                                // 0x051E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldShowBall;                                   // 0x051F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInHitFreeze;                                    // 0x0520(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_521[0x7];                                      // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CurrentPlayerDisplayName;                          // 0x0528(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         OwningPlayerIndex;                                 // 0x0538(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentTeamNumber;                                 // 0x053C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentDisguiseId;                                 // 0x0540(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTeamAttackEnemyTargetEntityIndex;           // 0x0548(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTeamAttackEnemyInstigatorEntityIndex;       // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompanionEntityIndex;                              // 0x0558(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInsideZone;                                     // 0x055C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55D[0x3];                                      // 0x055D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KOZOneDamagePerTick;                               // 0x0560(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KOZoneDamageTickRate;                              // 0x0564(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsViewTargetExternallyControlled;                 // 0x0568(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterKnockOutType                        ExpectedKnockOutType;                              // 0x0569(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56A[0x6];                                      // 0x056A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BeforeKnockOutDirection;                           // 0x0570(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USnapNetEntityRendererComponent*        EntityRendererComponent;                           // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ShieldComponent;                                   // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HurtBallComponent;                                 // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PropMeshComponent;                                 // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      SoulShieldComponent;                               // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      SoulComponent;                                     // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootSceneComponent;                                // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        InteractionAvailableRoot;                          // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        InteractionProgressRoot;                           // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       TooltipWidgetComponent;                            // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentInteractionEntityIndex;                     // 0x05E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaSkinData*                        CurrentSkinData;                                   // 0x05E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UNiagaraSystem*>      CachedSkinDataNiagaraSystems;                      // 0x05F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UAkAudioEvent*>       CachedSkinDataAudioEvents;                         // 0x0640(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UStaticMeshComponent*> CachedStaticMeshes;                                // 0x0690(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class USkeletalMeshComponent*> CachedSkeletalMeshes;                              // 0x06E0(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, TWeakObjectPtr<class UNiagaraComponent>> AttachedNiagaraComponentsById;                     // 0x0730(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_780[0xCC];                                     // 0x0780(0x00CC)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MovingPlatformEntityIndex;                         // 0x084C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MovingPlatformError;                               // 0x0850(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingPlatformErrorReductionRate;                  // 0x0868(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_86C[0x4];                                      // 0x086C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MovingPlatformLastEntityPosition;                  // 0x0870(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AnchorTooltipWidgetToActor(class AActor* InTooltipAnchorActor);
	void ApplyVisibilityOverrides(const class AMatchaSnapNetCharacterEntity* CharacterEntity, const TArray<struct FVisibilityOverride>& VisibilityOverrides);
	bool EnableExternalViewTargetControl(bool bNewEnable);
	void K2_CalcCamera(float DeltaTime, struct FMinimalViewInfo* OutResult);
	void OnAliveStateChanged(EAliveState OldAliveState, EAliveState NewAliveState);
	void OnAliveStateInitialized(EAliveState CurrentAliveState);
	void OnGlitchMarkChanged(bool bNewHasGlitchMark);
	void OnHasInteractTargetChanged(bool bHasInteractTarget);
	void OnInstigatedHitInfoChanged(const class AActor* NewHitCauser, const class AActor* NewHitReceiver, uint8 NewHitFlags, float NewHitFreezeSeconds);
	void OnInteractionProgressChanged(bool bIsProgressingInteraction, float InteractionTotalTime, float InteractionCurrentTime);
	void OnReceivedHitInfoChanged(const class AActor* NewHitCauser, uint8 NewHitFlags, float NewHitFreezeSeconds);
	void OnTeamAttackTargetChanged(bool bCurrentlyTargeted, bool bTargetedByAlly);
	void OnTeamAttackWarningChanged(bool bShouldShowWarning);
	void OnZoneStateChanged(bool bNewInsideZone);
	void UpdatePropertyVisuals(const class AMatchaSnapNetCharacterEntity* CharacterEntity, bool bTeleported);

	class UAkAudioEvent* GetAudioEventFromSkinData(class FName AudioEventId) const;
	class UNiagaraSystem* GetNiagaraSystemFromSkinData(class FName NiagaraSystemId) const;
	bool IsGameplayVisibleToSpectatedPlayer() const;
	bool IsLocallySpectated() const;
	bool IsTeamMateWithLocallySpectatedCharacter() const;
	bool IsViewTargetExternallyControlled() const;
	void UpdateBPOnlyComponentsGameplayVisibility(bool bIsGameplayVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetCharacterRenderer">();
	}
	static class AMatchaSnapNetCharacterRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetCharacterRenderer>();
	}
};
static_assert(alignof(AMatchaSnapNetCharacterRenderer) == 0x000008, "Wrong alignment on AMatchaSnapNetCharacterRenderer");
static_assert(sizeof(AMatchaSnapNetCharacterRenderer) == 0x000888, "Wrong size on AMatchaSnapNetCharacterRenderer");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, GameplayPromptID) == 0x000328, "Member 'AMatchaSnapNetCharacterRenderer::GameplayPromptID' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, Damage) == 0x000348, "Member 'AMatchaSnapNetCharacterRenderer::Damage' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentConsumeItemFinishTime) == 0x000368, "Member 'AMatchaSnapNetCharacterRenderer::CurrentConsumeItemFinishTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentShieldHealth) == 0x000388, "Member 'AMatchaSnapNetCharacterRenderer::CurrentShieldHealth' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentMaxShieldHealth) == 0x0003A8, "Member 'AMatchaSnapNetCharacterRenderer::CurrentMaxShieldHealth' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentEnergy) == 0x0003C8, "Member 'AMatchaSnapNetCharacterRenderer::CurrentEnergy' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentMaxEnergy) == 0x0003E8, "Member 'AMatchaSnapNetCharacterRenderer::CurrentMaxEnergy' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentJuiceStat) == 0x000408, "Member 'AMatchaSnapNetCharacterRenderer::CurrentJuiceStat' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentSlowAmountStat) == 0x000428, "Member 'AMatchaSnapNetCharacterRenderer::CurrentSlowAmountStat' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, RemainingCameraScanModeTime) == 0x000448, "Member 'AMatchaSnapNetCharacterRenderer::RemainingCameraScanModeTime' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, SharedTeamCoinCount) == 0x000468, "Member 'AMatchaSnapNetCharacterRenderer::SharedTeamCoinCount' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, ViewTargetOffsetWalking) == 0x000488, "Member 'AMatchaSnapNetCharacterRenderer::ViewTargetOffsetWalking' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, ViewTargetOffsetFalling) == 0x0004A0, "Member 'AMatchaSnapNetCharacterRenderer::ViewTargetOffsetFalling' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, ViewTarget) == 0x0004B8, "Member 'AMatchaSnapNetCharacterRenderer::ViewTarget' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, AvailablePropMeshes) == 0x0004D0, "Member 'AMatchaSnapNetCharacterRenderer::AvailablePropMeshes' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, PropExtraOffset) == 0x0004E0, "Member 'AMatchaSnapNetCharacterRenderer::PropExtraOffset' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, InteractionProgressHeightOffset) == 0x0004F8, "Member 'AMatchaSnapNetCharacterRenderer::InteractionProgressHeightOffset' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, HitShakeFrequency) == 0x0004FC, "Member 'AMatchaSnapNetCharacterRenderer::HitShakeFrequency' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, HitShakeAmplitude) == 0x000500, "Member 'AMatchaSnapNetCharacterRenderer::HitShakeAmplitude' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, MinHitShakeStrength) == 0x000504, "Member 'AMatchaSnapNetCharacterRenderer::MinHitShakeStrength' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, MaxHitShakeStrength) == 0x000508, "Member 'AMatchaSnapNetCharacterRenderer::MaxHitShakeStrength' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, DefaultSkinData) == 0x000510, "Member 'AMatchaSnapNetCharacterRenderer::DefaultSkinData' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, AliveState) == 0x000518, "Member 'AMatchaSnapNetCharacterRenderer::AliveState' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bAlive) == 0x000519, "Member 'AMatchaSnapNetCharacterRenderer::bAlive' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bIsFalling) == 0x00051A, "Member 'AMatchaSnapNetCharacterRenderer::bIsFalling' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bCameraInScanMode) == 0x00051B, "Member 'AMatchaSnapNetCharacterRenderer::bCameraInScanMode' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentFallType) == 0x00051C, "Member 'AMatchaSnapNetCharacterRenderer::CurrentFallType' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bIsInKnockBack) == 0x00051D, "Member 'AMatchaSnapNetCharacterRenderer::bIsInKnockBack' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bIsLethalKnockBack) == 0x00051E, "Member 'AMatchaSnapNetCharacterRenderer::bIsLethalKnockBack' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bShouldShowBall) == 0x00051F, "Member 'AMatchaSnapNetCharacterRenderer::bShouldShowBall' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bIsInHitFreeze) == 0x000520, "Member 'AMatchaSnapNetCharacterRenderer::bIsInHitFreeze' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentPlayerDisplayName) == 0x000528, "Member 'AMatchaSnapNetCharacterRenderer::CurrentPlayerDisplayName' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, OwningPlayerIndex) == 0x000538, "Member 'AMatchaSnapNetCharacterRenderer::OwningPlayerIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentTeamNumber) == 0x00053C, "Member 'AMatchaSnapNetCharacterRenderer::CurrentTeamNumber' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentDisguiseId) == 0x000540, "Member 'AMatchaSnapNetCharacterRenderer::CurrentDisguiseId' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentTeamAttackEnemyTargetEntityIndex) == 0x000548, "Member 'AMatchaSnapNetCharacterRenderer::CurrentTeamAttackEnemyTargetEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentTeamAttackEnemyInstigatorEntityIndex) == 0x000550, "Member 'AMatchaSnapNetCharacterRenderer::CurrentTeamAttackEnemyInstigatorEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CompanionEntityIndex) == 0x000558, "Member 'AMatchaSnapNetCharacterRenderer::CompanionEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bIsInsideZone) == 0x00055C, "Member 'AMatchaSnapNetCharacterRenderer::bIsInsideZone' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, KOZOneDamagePerTick) == 0x000560, "Member 'AMatchaSnapNetCharacterRenderer::KOZOneDamagePerTick' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, KOZoneDamageTickRate) == 0x000564, "Member 'AMatchaSnapNetCharacterRenderer::KOZoneDamageTickRate' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, bIsViewTargetExternallyControlled) == 0x000568, "Member 'AMatchaSnapNetCharacterRenderer::bIsViewTargetExternallyControlled' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, ExpectedKnockOutType) == 0x000569, "Member 'AMatchaSnapNetCharacterRenderer::ExpectedKnockOutType' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, BeforeKnockOutDirection) == 0x000570, "Member 'AMatchaSnapNetCharacterRenderer::BeforeKnockOutDirection' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, EntityRendererComponent) == 0x000588, "Member 'AMatchaSnapNetCharacterRenderer::EntityRendererComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, MeshComponent) == 0x000590, "Member 'AMatchaSnapNetCharacterRenderer::MeshComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, ShieldComponent) == 0x000598, "Member 'AMatchaSnapNetCharacterRenderer::ShieldComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, HurtBallComponent) == 0x0005A0, "Member 'AMatchaSnapNetCharacterRenderer::HurtBallComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, PropMeshComponent) == 0x0005A8, "Member 'AMatchaSnapNetCharacterRenderer::PropMeshComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, SoulShieldComponent) == 0x0005B0, "Member 'AMatchaSnapNetCharacterRenderer::SoulShieldComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, SoulComponent) == 0x0005B8, "Member 'AMatchaSnapNetCharacterRenderer::SoulComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, RootSceneComponent) == 0x0005C0, "Member 'AMatchaSnapNetCharacterRenderer::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, InteractionAvailableRoot) == 0x0005C8, "Member 'AMatchaSnapNetCharacterRenderer::InteractionAvailableRoot' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, InteractionProgressRoot) == 0x0005D0, "Member 'AMatchaSnapNetCharacterRenderer::InteractionProgressRoot' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, TooltipWidgetComponent) == 0x0005D8, "Member 'AMatchaSnapNetCharacterRenderer::TooltipWidgetComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentInteractionEntityIndex) == 0x0005E0, "Member 'AMatchaSnapNetCharacterRenderer::CurrentInteractionEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CurrentSkinData) == 0x0005E8, "Member 'AMatchaSnapNetCharacterRenderer::CurrentSkinData' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CachedSkinDataNiagaraSystems) == 0x0005F0, "Member 'AMatchaSnapNetCharacterRenderer::CachedSkinDataNiagaraSystems' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CachedSkinDataAudioEvents) == 0x000640, "Member 'AMatchaSnapNetCharacterRenderer::CachedSkinDataAudioEvents' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CachedStaticMeshes) == 0x000690, "Member 'AMatchaSnapNetCharacterRenderer::CachedStaticMeshes' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, CachedSkeletalMeshes) == 0x0006E0, "Member 'AMatchaSnapNetCharacterRenderer::CachedSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, AttachedNiagaraComponentsById) == 0x000730, "Member 'AMatchaSnapNetCharacterRenderer::AttachedNiagaraComponentsById' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, MovingPlatformEntityIndex) == 0x00084C, "Member 'AMatchaSnapNetCharacterRenderer::MovingPlatformEntityIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, MovingPlatformError) == 0x000850, "Member 'AMatchaSnapNetCharacterRenderer::MovingPlatformError' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, MovingPlatformErrorReductionRate) == 0x000868, "Member 'AMatchaSnapNetCharacterRenderer::MovingPlatformErrorReductionRate' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetCharacterRenderer, MovingPlatformLastEntityPosition) == 0x000870, "Member 'AMatchaSnapNetCharacterRenderer::MovingPlatformLastEntityPosition' has a wrong offset!");

// Class Matcha.MatchaSnapNetGameInstance
// 0x05B0 (0x0770 - 0x01C0)
class UMatchaSnapNetGameInstance : public USnapNetGameInstance
{
public:
	TArray<TSoftObjectPtr<class UTexture>>        AIIcons;                                           // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMatchaSnapNetGameEntity> GameEntity;                                        // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaUISubsystem>         UISubsystemClass;                                  // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EMatchaInputAction, class UInputAction*> InputActions;                                      // 0x01E0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EInputMethod, class UInputMappingContext*> InputMappingContexts;                              // 0x0230(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         KnockOutDamageThreshold;                           // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchaHitData                         KOZoneHitData;                                     // 0x0288(0x0078)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           CharacterEntityClasses;                            // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           AllowedCharacterEntityClasses;                     // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DefaultCharacter;                                  // 0x0320(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLinearColor>                   ColorsByTeamNumber;                                // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultTeamColor;                                  // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultAllyColor;                                  // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultSelfColor;                                  // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultEnemyColor;                                 // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitDifferenceDamagePercent;                        // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitFreezeDamageScale;                              // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PerfectShieldWindowFrames;                         // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PerfectShieldExtraFreezeFrames;                    // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LethalKnockBackExtraFreezeFrames;                  // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InputBufferFrames;                                 // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CoyoteTimeFrames;                                  // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TechInputFrames;                                   // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TechTimeOutFrames;                                 // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NeutralStickDeadZone;                              // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoDashNeutralStickDeadZone;                      // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpecialTeleportNeutralStickDeadZone;               // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StickTapThreshold;                                 // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveStickYValueForCrouch;                          // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmashAttackFromMoveStickFlickTime;                 // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BounceKnockBackSpeedReductionMultiplier;           // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockBackDurationToHitStunMultiplier;              // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinKnockBackToTumble;                              // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AfterShieldBreakDizzyTime;                         // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FramesSinceDashStopToCancelIntoPivot;              // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxGrabTime;                                       // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShieldHealth;                                      // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShieldDamagePercentPerSecond;                      // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShieldRegenPercentPerSecond;                       // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoulHealthAmount;                                  // 0x03F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LedgeReGrabTimeOutFrames;                          // 0x03FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LedgeGrabStartIntangibilityFrames;                 // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LedgeGrabIntangibilityFrames;                      // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlatformTraceDistance;                             // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallTraceDistance;                                 // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LedgeGetUpWallTraceDistance;                       // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumDamageKOHazardDefaultReflectAngleThreshold; // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWallClingTime;                                  // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AfterFastFallDiveBombMinTime;                      // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinDashAfterDashStartWaitTimeFrames;               // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FramesAfterDashStartForDashDance;                  // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpecialReverseFrames;                              // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DashGrabOverrideFrames;                            // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunInputAgainstWallAllowedDegreeDifference;    // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlatformFallthroughDeadZone;                       // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GrabSocketName;                                    // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBuffInfo                              GlobalBuffInfoArmor;                               // 0x0440(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBuffInfo                              GlobalBuffInfoGloves;                              // 0x0450(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBuffInfo                              GlobalBuffInfoBoots;                               // 0x0460(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MinInteractionTimeToDisableMovement;               // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDisguiseTimeForSuperArmor;                      // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveBombActivationMinDistanceFromGround;           // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     DoorClass;                                         // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCloseToDoorDistance;                            // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockBackToLaunchSpeedConversionMultiplier;        // 0x048C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockBackBaseDeceleration;                         // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockBackBaseGravity;                              // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockBackGravityLerpSpeed;                         // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KnockBackBalloonMinHitStunFrames;                  // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            KnockBackTimeMultiplierCurve;                      // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LethalKnockBackPredictionSteps;                    // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WallBounceFreezeFrames;                            // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BonusKnockBackRatioTakenAtKnockoutThreshold;       // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LethalHitInstigatorExtraIntangibilityFrames;       // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDirectionalInfluenceAngle;                      // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              UpwardsNoLaunchSpeedInfluenceRange;                // 0x04C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              DownwardsNoLaunchSpeedInfluenceRange;              // 0x04D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxUpwardsLaunchSpeedInfluence;                    // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDownwardsLaunchSpeedInfluence;                  // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGrabHeightType, float>                  PerGrabHeightTypeAttachLocationOffset;             // 0x04E8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         StunDiminishingReturnWindowSeconds;                // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 StunDiminishingReturnMultipliers;                  // 0x0540(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         InitialHackSpawnCount;                             // 0x0550(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PickupItemExtents;                                 // 0x0558(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              MasterSoundMix;                                    // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundClass*                            MasterSoundClass;                                  // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                LocallySpectatedRTPC;                              // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                AllyRTPC;                                          // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ESpawnRegion>                          EnabledSpawnRegions;                               // 0x0590(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ESpawnRegion, class FText>               SpawnRegionsToDisplayName;                         // 0x05A0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MatchaGameplayEventNotificationChannel;            // 0x05F0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HackInventorySlotCategory;                         // 0x05F8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMatchaBuffSetupData*                   BuffSetupData;                                     // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UMatchaCharacterBuff*> CachedBuffCDOsByTag;                               // 0x0608(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UMatchaTrackableEntitySetupData*        TrackableEntitySetupData;                          // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, TSubclassOf<class AMatchaSnapNetEntity>> CachedTrackableEntityClassesByTag;                 // 0x0660(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UMatchaGenericEffectsSetupData*         GenericEffectsSetupData;                           // 0x06B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UNiagaraSystem*>      CachedGenericNiagaraSystems;                       // 0x06B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UAkAudioEvent*>       CachedGenericAudioEvents;                          // 0x0708(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_758[0x18];                                     // 0x0758(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMasterVolume(float Volume);

	const class UAkRtpc* GetAllyRTPC() const;
	const struct FLinearColor GetColorForAllies() const;
	const struct FLinearColor GetColorForEnemies() const;
	const struct FLinearColor GetColorForSelf() const;
	const struct FLinearColor GetColorForTeamNumber(int32 TeamNumber) const;
	const TArray<ESpawnRegion> GetEnabledSpawnRegions() const;
	const struct FGameplayTag GetGameplayEventNotificationChannel() const;
	class UAkAudioEvent* GetGenericAudioEventFromId(class FName AudioEventId) const;
	class UNiagaraSystem* GetGenericNiagaraSystemFromId(class FName NiagaraSystemId) const;
	const class UAkRtpc* GetLocallySpectatedRTPC() const;
	const TMap<ESpawnRegion, class FText> GetSpawnRegionsToDisplayNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetGameInstance">();
	}
	static class UMatchaSnapNetGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSnapNetGameInstance>();
	}
};
static_assert(alignof(UMatchaSnapNetGameInstance) == 0x000008, "Wrong alignment on UMatchaSnapNetGameInstance");
static_assert(sizeof(UMatchaSnapNetGameInstance) == 0x000770, "Wrong size on UMatchaSnapNetGameInstance");
static_assert(offsetof(UMatchaSnapNetGameInstance, AIIcons) == 0x0001C0, "Member 'UMatchaSnapNetGameInstance::AIIcons' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, GameEntity) == 0x0001D0, "Member 'UMatchaSnapNetGameInstance::GameEntity' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, UISubsystemClass) == 0x0001D8, "Member 'UMatchaSnapNetGameInstance::UISubsystemClass' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, InputActions) == 0x0001E0, "Member 'UMatchaSnapNetGameInstance::InputActions' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, InputMappingContexts) == 0x000230, "Member 'UMatchaSnapNetGameInstance::InputMappingContexts' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KnockOutDamageThreshold) == 0x000280, "Member 'UMatchaSnapNetGameInstance::KnockOutDamageThreshold' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KOZoneHitData) == 0x000288, "Member 'UMatchaSnapNetGameInstance::KOZoneHitData' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, CharacterEntityClasses) == 0x000300, "Member 'UMatchaSnapNetGameInstance::CharacterEntityClasses' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, AllowedCharacterEntityClasses) == 0x000310, "Member 'UMatchaSnapNetGameInstance::AllowedCharacterEntityClasses' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DefaultCharacter) == 0x000320, "Member 'UMatchaSnapNetGameInstance::DefaultCharacter' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, ColorsByTeamNumber) == 0x000348, "Member 'UMatchaSnapNetGameInstance::ColorsByTeamNumber' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DefaultTeamColor) == 0x000358, "Member 'UMatchaSnapNetGameInstance::DefaultTeamColor' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DefaultAllyColor) == 0x000368, "Member 'UMatchaSnapNetGameInstance::DefaultAllyColor' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DefaultSelfColor) == 0x000378, "Member 'UMatchaSnapNetGameInstance::DefaultSelfColor' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DefaultEnemyColor) == 0x000388, "Member 'UMatchaSnapNetGameInstance::DefaultEnemyColor' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, HitDifferenceDamagePercent) == 0x000398, "Member 'UMatchaSnapNetGameInstance::HitDifferenceDamagePercent' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, HitFreezeDamageScale) == 0x00039C, "Member 'UMatchaSnapNetGameInstance::HitFreezeDamageScale' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, PerfectShieldWindowFrames) == 0x0003A0, "Member 'UMatchaSnapNetGameInstance::PerfectShieldWindowFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, PerfectShieldExtraFreezeFrames) == 0x0003A4, "Member 'UMatchaSnapNetGameInstance::PerfectShieldExtraFreezeFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, LethalKnockBackExtraFreezeFrames) == 0x0003A8, "Member 'UMatchaSnapNetGameInstance::LethalKnockBackExtraFreezeFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, InputBufferFrames) == 0x0003AC, "Member 'UMatchaSnapNetGameInstance::InputBufferFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, CoyoteTimeFrames) == 0x0003B0, "Member 'UMatchaSnapNetGameInstance::CoyoteTimeFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, TechInputFrames) == 0x0003B4, "Member 'UMatchaSnapNetGameInstance::TechInputFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, TechTimeOutFrames) == 0x0003B8, "Member 'UMatchaSnapNetGameInstance::TechTimeOutFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, NeutralStickDeadZone) == 0x0003BC, "Member 'UMatchaSnapNetGameInstance::NeutralStickDeadZone' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, AutoDashNeutralStickDeadZone) == 0x0003C0, "Member 'UMatchaSnapNetGameInstance::AutoDashNeutralStickDeadZone' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, SpecialTeleportNeutralStickDeadZone) == 0x0003C4, "Member 'UMatchaSnapNetGameInstance::SpecialTeleportNeutralStickDeadZone' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, StickTapThreshold) == 0x0003C8, "Member 'UMatchaSnapNetGameInstance::StickTapThreshold' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MoveStickYValueForCrouch) == 0x0003CC, "Member 'UMatchaSnapNetGameInstance::MoveStickYValueForCrouch' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, SmashAttackFromMoveStickFlickTime) == 0x0003D0, "Member 'UMatchaSnapNetGameInstance::SmashAttackFromMoveStickFlickTime' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, BounceKnockBackSpeedReductionMultiplier) == 0x0003D4, "Member 'UMatchaSnapNetGameInstance::BounceKnockBackSpeedReductionMultiplier' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KnockBackDurationToHitStunMultiplier) == 0x0003D8, "Member 'UMatchaSnapNetGameInstance::KnockBackDurationToHitStunMultiplier' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MinKnockBackToTumble) == 0x0003DC, "Member 'UMatchaSnapNetGameInstance::MinKnockBackToTumble' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, AfterShieldBreakDizzyTime) == 0x0003E0, "Member 'UMatchaSnapNetGameInstance::AfterShieldBreakDizzyTime' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, FramesSinceDashStopToCancelIntoPivot) == 0x0003E4, "Member 'UMatchaSnapNetGameInstance::FramesSinceDashStopToCancelIntoPivot' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MaxGrabTime) == 0x0003E8, "Member 'UMatchaSnapNetGameInstance::MaxGrabTime' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, ShieldHealth) == 0x0003EC, "Member 'UMatchaSnapNetGameInstance::ShieldHealth' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, ShieldDamagePercentPerSecond) == 0x0003F0, "Member 'UMatchaSnapNetGameInstance::ShieldDamagePercentPerSecond' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, ShieldRegenPercentPerSecond) == 0x0003F4, "Member 'UMatchaSnapNetGameInstance::ShieldRegenPercentPerSecond' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, SoulHealthAmount) == 0x0003F8, "Member 'UMatchaSnapNetGameInstance::SoulHealthAmount' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, LedgeReGrabTimeOutFrames) == 0x0003FC, "Member 'UMatchaSnapNetGameInstance::LedgeReGrabTimeOutFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, LedgeGrabStartIntangibilityFrames) == 0x000400, "Member 'UMatchaSnapNetGameInstance::LedgeGrabStartIntangibilityFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, LedgeGrabIntangibilityFrames) == 0x000404, "Member 'UMatchaSnapNetGameInstance::LedgeGrabIntangibilityFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, PlatformTraceDistance) == 0x000408, "Member 'UMatchaSnapNetGameInstance::PlatformTraceDistance' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, WallTraceDistance) == 0x00040C, "Member 'UMatchaSnapNetGameInstance::WallTraceDistance' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, LedgeGetUpWallTraceDistance) == 0x000410, "Member 'UMatchaSnapNetGameInstance::LedgeGetUpWallTraceDistance' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MinimumDamageKOHazardDefaultReflectAngleThreshold) == 0x000414, "Member 'UMatchaSnapNetGameInstance::MinimumDamageKOHazardDefaultReflectAngleThreshold' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MaxWallClingTime) == 0x000418, "Member 'UMatchaSnapNetGameInstance::MaxWallClingTime' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, AfterFastFallDiveBombMinTime) == 0x00041C, "Member 'UMatchaSnapNetGameInstance::AfterFastFallDiveBombMinTime' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MinDashAfterDashStartWaitTimeFrames) == 0x000420, "Member 'UMatchaSnapNetGameInstance::MinDashAfterDashStartWaitTimeFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, FramesAfterDashStartForDashDance) == 0x000424, "Member 'UMatchaSnapNetGameInstance::FramesAfterDashStartForDashDance' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, SpecialReverseFrames) == 0x000428, "Member 'UMatchaSnapNetGameInstance::SpecialReverseFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DashGrabOverrideFrames) == 0x00042C, "Member 'UMatchaSnapNetGameInstance::DashGrabOverrideFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, WallRunInputAgainstWallAllowedDegreeDifference) == 0x000430, "Member 'UMatchaSnapNetGameInstance::WallRunInputAgainstWallAllowedDegreeDifference' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, PlatformFallthroughDeadZone) == 0x000434, "Member 'UMatchaSnapNetGameInstance::PlatformFallthroughDeadZone' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, GrabSocketName) == 0x000438, "Member 'UMatchaSnapNetGameInstance::GrabSocketName' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, GlobalBuffInfoArmor) == 0x000440, "Member 'UMatchaSnapNetGameInstance::GlobalBuffInfoArmor' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, GlobalBuffInfoGloves) == 0x000450, "Member 'UMatchaSnapNetGameInstance::GlobalBuffInfoGloves' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, GlobalBuffInfoBoots) == 0x000460, "Member 'UMatchaSnapNetGameInstance::GlobalBuffInfoBoots' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MinInteractionTimeToDisableMovement) == 0x000470, "Member 'UMatchaSnapNetGameInstance::MinInteractionTimeToDisableMovement' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MinDisguiseTimeForSuperArmor) == 0x000474, "Member 'UMatchaSnapNetGameInstance::MinDisguiseTimeForSuperArmor' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DiveBombActivationMinDistanceFromGround) == 0x000478, "Member 'UMatchaSnapNetGameInstance::DiveBombActivationMinDistanceFromGround' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DoorClass) == 0x000480, "Member 'UMatchaSnapNetGameInstance::DoorClass' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MaxCloseToDoorDistance) == 0x000488, "Member 'UMatchaSnapNetGameInstance::MaxCloseToDoorDistance' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KnockBackToLaunchSpeedConversionMultiplier) == 0x00048C, "Member 'UMatchaSnapNetGameInstance::KnockBackToLaunchSpeedConversionMultiplier' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KnockBackBaseDeceleration) == 0x000490, "Member 'UMatchaSnapNetGameInstance::KnockBackBaseDeceleration' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KnockBackBaseGravity) == 0x000494, "Member 'UMatchaSnapNetGameInstance::KnockBackBaseGravity' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KnockBackGravityLerpSpeed) == 0x000498, "Member 'UMatchaSnapNetGameInstance::KnockBackGravityLerpSpeed' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KnockBackBalloonMinHitStunFrames) == 0x00049C, "Member 'UMatchaSnapNetGameInstance::KnockBackBalloonMinHitStunFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, KnockBackTimeMultiplierCurve) == 0x0004A0, "Member 'UMatchaSnapNetGameInstance::KnockBackTimeMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, LethalKnockBackPredictionSteps) == 0x0004A8, "Member 'UMatchaSnapNetGameInstance::LethalKnockBackPredictionSteps' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, WallBounceFreezeFrames) == 0x0004AC, "Member 'UMatchaSnapNetGameInstance::WallBounceFreezeFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, BonusKnockBackRatioTakenAtKnockoutThreshold) == 0x0004B0, "Member 'UMatchaSnapNetGameInstance::BonusKnockBackRatioTakenAtKnockoutThreshold' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, LethalHitInstigatorExtraIntangibilityFrames) == 0x0004B4, "Member 'UMatchaSnapNetGameInstance::LethalHitInstigatorExtraIntangibilityFrames' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MaxDirectionalInfluenceAngle) == 0x0004B8, "Member 'UMatchaSnapNetGameInstance::MaxDirectionalInfluenceAngle' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, UpwardsNoLaunchSpeedInfluenceRange) == 0x0004C0, "Member 'UMatchaSnapNetGameInstance::UpwardsNoLaunchSpeedInfluenceRange' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, DownwardsNoLaunchSpeedInfluenceRange) == 0x0004D0, "Member 'UMatchaSnapNetGameInstance::DownwardsNoLaunchSpeedInfluenceRange' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MaxUpwardsLaunchSpeedInfluence) == 0x0004E0, "Member 'UMatchaSnapNetGameInstance::MaxUpwardsLaunchSpeedInfluence' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MaxDownwardsLaunchSpeedInfluence) == 0x0004E4, "Member 'UMatchaSnapNetGameInstance::MaxDownwardsLaunchSpeedInfluence' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, PerGrabHeightTypeAttachLocationOffset) == 0x0004E8, "Member 'UMatchaSnapNetGameInstance::PerGrabHeightTypeAttachLocationOffset' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, StunDiminishingReturnWindowSeconds) == 0x000538, "Member 'UMatchaSnapNetGameInstance::StunDiminishingReturnWindowSeconds' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, StunDiminishingReturnMultipliers) == 0x000540, "Member 'UMatchaSnapNetGameInstance::StunDiminishingReturnMultipliers' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, InitialHackSpawnCount) == 0x000550, "Member 'UMatchaSnapNetGameInstance::InitialHackSpawnCount' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, PickupItemExtents) == 0x000558, "Member 'UMatchaSnapNetGameInstance::PickupItemExtents' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MasterSoundMix) == 0x000570, "Member 'UMatchaSnapNetGameInstance::MasterSoundMix' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MasterSoundClass) == 0x000578, "Member 'UMatchaSnapNetGameInstance::MasterSoundClass' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, LocallySpectatedRTPC) == 0x000580, "Member 'UMatchaSnapNetGameInstance::LocallySpectatedRTPC' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, AllyRTPC) == 0x000588, "Member 'UMatchaSnapNetGameInstance::AllyRTPC' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, EnabledSpawnRegions) == 0x000590, "Member 'UMatchaSnapNetGameInstance::EnabledSpawnRegions' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, SpawnRegionsToDisplayName) == 0x0005A0, "Member 'UMatchaSnapNetGameInstance::SpawnRegionsToDisplayName' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, MatchaGameplayEventNotificationChannel) == 0x0005F0, "Member 'UMatchaSnapNetGameInstance::MatchaGameplayEventNotificationChannel' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, HackInventorySlotCategory) == 0x0005F8, "Member 'UMatchaSnapNetGameInstance::HackInventorySlotCategory' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, BuffSetupData) == 0x000600, "Member 'UMatchaSnapNetGameInstance::BuffSetupData' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, CachedBuffCDOsByTag) == 0x000608, "Member 'UMatchaSnapNetGameInstance::CachedBuffCDOsByTag' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, TrackableEntitySetupData) == 0x000658, "Member 'UMatchaSnapNetGameInstance::TrackableEntitySetupData' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, CachedTrackableEntityClassesByTag) == 0x000660, "Member 'UMatchaSnapNetGameInstance::CachedTrackableEntityClassesByTag' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, GenericEffectsSetupData) == 0x0006B0, "Member 'UMatchaSnapNetGameInstance::GenericEffectsSetupData' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, CachedGenericNiagaraSystems) == 0x0006B8, "Member 'UMatchaSnapNetGameInstance::CachedGenericNiagaraSystems' has a wrong offset!");
static_assert(offsetof(UMatchaSnapNetGameInstance, CachedGenericAudioEvents) == 0x000708, "Member 'UMatchaSnapNetGameInstance::CachedGenericAudioEvents' has a wrong offset!");

// Class Matcha.MatchaSnapNetPropertyGameplayTagFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMatchaSnapNetPropertyGameplayTagFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static const struct FGameplayTag Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag(const struct FMatchaSnapNetGameplayTagProperty& MatchaSnapNetGameplayTagProperty);
	static void SetValue(struct FMatchaSnapNetGameplayTagProperty& MatchaSnapNetGameplayTagProperty, const struct FGameplayTag& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetPropertyGameplayTagFunctionLibrary">();
	}
	static class UMatchaSnapNetPropertyGameplayTagFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSnapNetPropertyGameplayTagFunctionLibrary>();
	}
};
static_assert(alignof(UMatchaSnapNetPropertyGameplayTagFunctionLibrary) == 0x000008, "Wrong alignment on UMatchaSnapNetPropertyGameplayTagFunctionLibrary");
static_assert(sizeof(UMatchaSnapNetPropertyGameplayTagFunctionLibrary) == 0x000028, "Wrong size on UMatchaSnapNetPropertyGameplayTagFunctionLibrary");

// Class Matcha.MatchaFinalZone
// 0x0010 (0x02B0 - 0x02A0)
class AMatchaFinalZone final : public AOdyGameZonePOI
{
public:
	float                                         ShrinkTime;                                        // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningTime;                                       // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          LastStandBounds;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FBox GetLastStandBounds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaFinalZone">();
	}
	static class AMatchaFinalZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaFinalZone>();
	}
};
static_assert(alignof(AMatchaFinalZone) == 0x000008, "Wrong alignment on AMatchaFinalZone");
static_assert(sizeof(AMatchaFinalZone) == 0x0002B0, "Wrong size on AMatchaFinalZone");
static_assert(offsetof(AMatchaFinalZone, ShrinkTime) == 0x0002A0, "Member 'AMatchaFinalZone::ShrinkTime' has a wrong offset!");
static_assert(offsetof(AMatchaFinalZone, WarningTime) == 0x0002A4, "Member 'AMatchaFinalZone::WarningTime' has a wrong offset!");
static_assert(offsetof(AMatchaFinalZone, LastStandBounds) == 0x0002A8, "Member 'AMatchaFinalZone::LastStandBounds' has a wrong offset!");

// Class Matcha.MatchaSnapNetPlayerController
// 0x1230 (0x1AA0 - 0x0870)
class AMatchaSnapNetPlayerController : public AMatchaPlayerControllerBase
{
public:
	FMulticastInlineDelegateProperty_             OnSpectatedPlayerIndexChanged;                     // 0x0870(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpectatedCharacterRendererChanged;               // 0x0880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             JoinedGame;                                        // 0x0890(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractInputUpdated;                            // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B0[0x8];                                      // 0x08B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchaFlickConfiguration              FlickConfiguration;                                // 0x08B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C4[0x1C];                                     // 0x08C4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlickDetectionValueThreshold;                      // 0x08E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlickChangeValueThresholdPerFrame;                 // 0x08E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlickSpeedChangeThreshold;                         // 0x08E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlickMoveStickDetectionMaximumStartingActuation;   // 0x08EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F0[0x78];                                     // 0x08F0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentSpectatedPlayerIndex;                       // 0x0968(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentPlayerIndexForLocalPlayer;                  // 0x096C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_970[0x4];                                      // 0x0970(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USnapNetClient>          SnapNetClient;                                     // 0x0974(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AMatchaSnapNetCharacterEntity> SpectatedCharacterEntity;                          // 0x097C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AMatchaSnapNetCharacterRenderer> SpectatedCharacterRenderer;                        // 0x0984(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98C[0x1114];                                   // 0x098C(0x1114)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JoinedGame__DelegateSignature();
	void RequestSelectSpawnRegion(ESpawnRegion SelectedSpawnRegion);
	void SetHoveredCharacter(const TSoftClassPtr<class UClass>& CharacterClass);
	void SpectatedCharacterRendererChanged__DelegateSignature(class AMatchaSnapNetCharacterRenderer* CharacterRenderer);
	void SpectatedPlayerIndexChanged__DelegateSignature(int32 PlayerIndexForLocalPlayer, int32 PreviousSpectatedPlayerIndex, int32 NewSpectatedPlayerIndex);
	void SpectateNextPlayer();
	void SpectatePreviousPlayer();

	void DEBUG_SetPlayerName(const class FString& NewName) const;
	EMatchaCameraMode GetCameraMode() const;
	const struct FPlayerInputValues GetCurrentFrameInputValues() const;
	const struct FPlayerInputValues GetLastFrameInputValues() const;
	void SetPlayerCharacter(int32 CharacterIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetPlayerController">();
	}
	static class AMatchaSnapNetPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetPlayerController>();
	}
};
static_assert(alignof(AMatchaSnapNetPlayerController) == 0x000008, "Wrong alignment on AMatchaSnapNetPlayerController");
static_assert(sizeof(AMatchaSnapNetPlayerController) == 0x001AA0, "Wrong size on AMatchaSnapNetPlayerController");
static_assert(offsetof(AMatchaSnapNetPlayerController, OnSpectatedPlayerIndexChanged) == 0x000870, "Member 'AMatchaSnapNetPlayerController::OnSpectatedPlayerIndexChanged' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, OnSpectatedCharacterRendererChanged) == 0x000880, "Member 'AMatchaSnapNetPlayerController::OnSpectatedCharacterRendererChanged' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, JoinedGame) == 0x000890, "Member 'AMatchaSnapNetPlayerController::JoinedGame' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, OnInteractInputUpdated) == 0x0008A0, "Member 'AMatchaSnapNetPlayerController::OnInteractInputUpdated' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, FlickConfiguration) == 0x0008B8, "Member 'AMatchaSnapNetPlayerController::FlickConfiguration' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, FlickDetectionValueThreshold) == 0x0008E0, "Member 'AMatchaSnapNetPlayerController::FlickDetectionValueThreshold' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, FlickChangeValueThresholdPerFrame) == 0x0008E4, "Member 'AMatchaSnapNetPlayerController::FlickChangeValueThresholdPerFrame' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, FlickSpeedChangeThreshold) == 0x0008E8, "Member 'AMatchaSnapNetPlayerController::FlickSpeedChangeThreshold' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, FlickMoveStickDetectionMaximumStartingActuation) == 0x0008EC, "Member 'AMatchaSnapNetPlayerController::FlickMoveStickDetectionMaximumStartingActuation' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, CurrentSpectatedPlayerIndex) == 0x000968, "Member 'AMatchaSnapNetPlayerController::CurrentSpectatedPlayerIndex' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, CurrentPlayerIndexForLocalPlayer) == 0x00096C, "Member 'AMatchaSnapNetPlayerController::CurrentPlayerIndexForLocalPlayer' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, SnapNetClient) == 0x000974, "Member 'AMatchaSnapNetPlayerController::SnapNetClient' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, SpectatedCharacterEntity) == 0x00097C, "Member 'AMatchaSnapNetPlayerController::SpectatedCharacterEntity' has a wrong offset!");
static_assert(offsetof(AMatchaSnapNetPlayerController, SpectatedCharacterRenderer) == 0x000984, "Member 'AMatchaSnapNetPlayerController::SpectatedCharacterRenderer' has a wrong offset!");

// Class Matcha.MatchaSnapNetPlayInfo
// 0x0008 (0x02C8 - 0x02C0)
class AMatchaSnapNetPlayInfo final : public ASnapNetPlayInfo
{
public:
	bool                                          bIsDropInMap;                                      // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AMatchaSnapNetPlayInfo* Get(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSnapNetPlayInfo">();
	}
	static class AMatchaSnapNetPlayInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSnapNetPlayInfo>();
	}
};
static_assert(alignof(AMatchaSnapNetPlayInfo) == 0x000008, "Wrong alignment on AMatchaSnapNetPlayInfo");
static_assert(sizeof(AMatchaSnapNetPlayInfo) == 0x0002C8, "Wrong size on AMatchaSnapNetPlayInfo");
static_assert(offsetof(AMatchaSnapNetPlayInfo, bIsDropInMap) == 0x0002C0, "Member 'AMatchaSnapNetPlayInfo::bIsDropInMap' has a wrong offset!");

// Class Matcha.MatchaSpawnInSelectionMessage
// 0x0048 (0x0070 - 0x0028)
class UMatchaSpawnInSelectionMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyEnum                   SelectedSpawnRegion;                               // 0x0028(0x0048)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSpawnInSelectionMessage">();
	}
	static class UMatchaSpawnInSelectionMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSpawnInSelectionMessage>();
	}
};
static_assert(alignof(UMatchaSpawnInSelectionMessage) == 0x000008, "Wrong alignment on UMatchaSpawnInSelectionMessage");
static_assert(sizeof(UMatchaSpawnInSelectionMessage) == 0x000070, "Wrong size on UMatchaSpawnInSelectionMessage");
static_assert(offsetof(UMatchaSpawnInSelectionMessage, SelectedSpawnRegion) == 0x000028, "Member 'UMatchaSpawnInSelectionMessage::SelectedSpawnRegion' has a wrong offset!");

// Class Matcha.MatchaSpectatePlayerMessage
// 0x0038 (0x0060 - 0x0028)
class UMatchaSpectatePlayerMessage final : public USnapNetReliableMessage
{
public:
	struct FSnapNetPropertyInt32                  TargetPlayerIndex;                                 // 0x0028(0x0038)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSpectatePlayerMessage">();
	}
	static class UMatchaSpectatePlayerMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaSpectatePlayerMessage>();
	}
};
static_assert(alignof(UMatchaSpectatePlayerMessage) == 0x000008, "Wrong alignment on UMatchaSpectatePlayerMessage");
static_assert(sizeof(UMatchaSpectatePlayerMessage) == 0x000060, "Wrong size on UMatchaSpectatePlayerMessage");
static_assert(offsetof(UMatchaSpectatePlayerMessage, TargetPlayerIndex) == 0x000028, "Member 'UMatchaSpectatePlayerMessage::TargetPlayerIndex' has a wrong offset!");

// Class Matcha.MatchaSplineTraversalEntity
// 0x0180 (0x04F8 - 0x0378)
class AMatchaSplineTraversalEntity : public AMatchaSnapNetEntity
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultRootComponent;                              // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        StartLocationRoot;                                 // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        EndLocationRoot;                                   // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          StartInteractionCollider;                          // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EndInteractionCollider;                            // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchaInteractionRequirements         InteractionRequirements;                           // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CooldownSeconds;                                   // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraversalEntityType                          TraversalEntityType;                               // 0x03B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanHopAnywhere;                                   // 0x03B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowsConcurrentInteractions;                     // 0x03B6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B7[0x1];                                      // 0x03B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertySoftObjectPath         SplineActorToFollow;                               // 0x03B8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyEnum                   DirectionType;                                     // 0x0420(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  TravelSpeed;                                       // 0x0468(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractionData>               CurrentInteractions;                               // 0x04B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyInt32                  EnableTimeMilliseconds;                            // 0x04C0(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	float GetRemainingCooldownTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSplineTraversalEntity">();
	}
	static class AMatchaSplineTraversalEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSplineTraversalEntity>();
	}
};
static_assert(alignof(AMatchaSplineTraversalEntity) == 0x000008, "Wrong alignment on AMatchaSplineTraversalEntity");
static_assert(sizeof(AMatchaSplineTraversalEntity) == 0x0004F8, "Wrong size on AMatchaSplineTraversalEntity");
static_assert(offsetof(AMatchaSplineTraversalEntity, DefaultRootComponent) == 0x000380, "Member 'AMatchaSplineTraversalEntity::DefaultRootComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, StartLocationRoot) == 0x000388, "Member 'AMatchaSplineTraversalEntity::StartLocationRoot' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, EndLocationRoot) == 0x000390, "Member 'AMatchaSplineTraversalEntity::EndLocationRoot' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, StartInteractionCollider) == 0x000398, "Member 'AMatchaSplineTraversalEntity::StartInteractionCollider' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, EndInteractionCollider) == 0x0003A0, "Member 'AMatchaSplineTraversalEntity::EndInteractionCollider' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, InteractionRequirements) == 0x0003A8, "Member 'AMatchaSplineTraversalEntity::InteractionRequirements' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, CooldownSeconds) == 0x0003B0, "Member 'AMatchaSplineTraversalEntity::CooldownSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, TraversalEntityType) == 0x0003B4, "Member 'AMatchaSplineTraversalEntity::TraversalEntityType' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, bCanHopAnywhere) == 0x0003B5, "Member 'AMatchaSplineTraversalEntity::bCanHopAnywhere' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, bAllowsConcurrentInteractions) == 0x0003B6, "Member 'AMatchaSplineTraversalEntity::bAllowsConcurrentInteractions' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, SplineActorToFollow) == 0x0003B8, "Member 'AMatchaSplineTraversalEntity::SplineActorToFollow' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, DirectionType) == 0x000420, "Member 'AMatchaSplineTraversalEntity::DirectionType' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, TravelSpeed) == 0x000468, "Member 'AMatchaSplineTraversalEntity::TravelSpeed' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, CurrentInteractions) == 0x0004B0, "Member 'AMatchaSplineTraversalEntity::CurrentInteractions' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalEntity, EnableTimeMilliseconds) == 0x0004C0, "Member 'AMatchaSplineTraversalEntity::EnableTimeMilliseconds' has a wrong offset!");

// Class Matcha.MatchaSplineTraversalRenderer
// 0x0038 (0x02D8 - 0x02A0)
class AMatchaSplineTraversalRenderer final : public AMatchaSnapNetRenderer
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultRootComponent;                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        StartLocationRoot;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        EndLocationRoot;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnabled;                                        // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemainingCooldownSeconds;                          // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanHopAnywhere;                                   // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnyDirection;                                     // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0xE];                                      // 0x02CA(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaSplineTraversalRenderer">();
	}
	static class AMatchaSplineTraversalRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaSplineTraversalRenderer>();
	}
};
static_assert(alignof(AMatchaSplineTraversalRenderer) == 0x000008, "Wrong alignment on AMatchaSplineTraversalRenderer");
static_assert(sizeof(AMatchaSplineTraversalRenderer) == 0x0002D8, "Wrong size on AMatchaSplineTraversalRenderer");
static_assert(offsetof(AMatchaSplineTraversalRenderer, DefaultRootComponent) == 0x0002A8, "Member 'AMatchaSplineTraversalRenderer::DefaultRootComponent' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalRenderer, StartLocationRoot) == 0x0002B0, "Member 'AMatchaSplineTraversalRenderer::StartLocationRoot' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalRenderer, EndLocationRoot) == 0x0002B8, "Member 'AMatchaSplineTraversalRenderer::EndLocationRoot' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalRenderer, bIsEnabled) == 0x0002C0, "Member 'AMatchaSplineTraversalRenderer::bIsEnabled' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalRenderer, RemainingCooldownSeconds) == 0x0002C4, "Member 'AMatchaSplineTraversalRenderer::RemainingCooldownSeconds' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalRenderer, bCanHopAnywhere) == 0x0002C8, "Member 'AMatchaSplineTraversalRenderer::bCanHopAnywhere' has a wrong offset!");
static_assert(offsetof(AMatchaSplineTraversalRenderer, bAnyDirection) == 0x0002C9, "Member 'AMatchaSplineTraversalRenderer::bAnyDirection' has a wrong offset!");

// Class Matcha.MatchaStandaloneServerProvider
// 0x0088 (0x00B0 - 0x0028)
class UMatchaStandaloneServerProvider final : public UObject
{
public:
	class ULegacyMatchaQueueServices*             QueueServices;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HumanReadableName;                                 // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ConnectURL;                                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x60];                                      // 0x0050(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchPhaseChanged(EMatchaMatchPhase MatchPhase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaStandaloneServerProvider">();
	}
	static class UMatchaStandaloneServerProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaStandaloneServerProvider>();
	}
};
static_assert(alignof(UMatchaStandaloneServerProvider) == 0x000008, "Wrong alignment on UMatchaStandaloneServerProvider");
static_assert(sizeof(UMatchaStandaloneServerProvider) == 0x0000B0, "Wrong size on UMatchaStandaloneServerProvider");
static_assert(offsetof(UMatchaStandaloneServerProvider, QueueServices) == 0x000028, "Member 'UMatchaStandaloneServerProvider::QueueServices' has a wrong offset!");
static_assert(offsetof(UMatchaStandaloneServerProvider, HumanReadableName) == 0x000030, "Member 'UMatchaStandaloneServerProvider::HumanReadableName' has a wrong offset!");
static_assert(offsetof(UMatchaStandaloneServerProvider, ConnectURL) == 0x000040, "Member 'UMatchaStandaloneServerProvider::ConnectURL' has a wrong offset!");

// Class Matcha.MatchaTeamUIData
// 0x0148 (0x01B0 - 0x0068)
class UMatchaTeamUIData final : public UOdyUIData
{
public:
	struct FOdyUIIntBinding                       TeamNumber;                                        // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITextBinding                      TeamNameText;                                      // 0x0088(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       NumPlayersOnTeam;                                  // 0x00B0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       NumAlivePlayersOnTeam;                             // 0x00D0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUITimespanBinding                  SurvivalTime;                                      // 0x00F0(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      TeamHasDuplicateCharacter;                         // 0x0110(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdate;                                          // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UMatchaPlayerUIData*>            Players;                                           // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RelevantEnemyPlayerIndices;                        // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRelevantEnemyPlayerIndicesChanged;               // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FOdyUIIntBinding                       FinishPlace;                                       // 0x0180(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 LastPlayerIndices;                                 // 0x01A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnPlayerRevealedIndicesChanged();
	void OnTeamMemberCharacterClassChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaTeamUIData">();
	}
	static class UMatchaTeamUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaTeamUIData>();
	}
};
static_assert(alignof(UMatchaTeamUIData) == 0x000008, "Wrong alignment on UMatchaTeamUIData");
static_assert(sizeof(UMatchaTeamUIData) == 0x0001B0, "Wrong size on UMatchaTeamUIData");
static_assert(offsetof(UMatchaTeamUIData, TeamNumber) == 0x000068, "Member 'UMatchaTeamUIData::TeamNumber' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, TeamNameText) == 0x000088, "Member 'UMatchaTeamUIData::TeamNameText' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, NumPlayersOnTeam) == 0x0000B0, "Member 'UMatchaTeamUIData::NumPlayersOnTeam' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, NumAlivePlayersOnTeam) == 0x0000D0, "Member 'UMatchaTeamUIData::NumAlivePlayersOnTeam' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, SurvivalTime) == 0x0000F0, "Member 'UMatchaTeamUIData::SurvivalTime' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, TeamHasDuplicateCharacter) == 0x000110, "Member 'UMatchaTeamUIData::TeamHasDuplicateCharacter' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, OnUpdate) == 0x000130, "Member 'UMatchaTeamUIData::OnUpdate' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, Players) == 0x000140, "Member 'UMatchaTeamUIData::Players' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, RelevantEnemyPlayerIndices) == 0x000160, "Member 'UMatchaTeamUIData::RelevantEnemyPlayerIndices' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, OnRelevantEnemyPlayerIndicesChanged) == 0x000170, "Member 'UMatchaTeamUIData::OnRelevantEnemyPlayerIndicesChanged' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, FinishPlace) == 0x000180, "Member 'UMatchaTeamUIData::FinishPlace' has a wrong offset!");
static_assert(offsetof(UMatchaTeamUIData, LastPlayerIndices) == 0x0001A0, "Member 'UMatchaTeamUIData::LastPlayerIndices' has a wrong offset!");

// Class Matcha.MatchaTrackableEntitySetupData
// 0x0050 (0x0080 - 0x0030)
class UMatchaTrackableEntitySetupData final : public UPrimaryDataAsset
{
public:
	TMap<struct FGameplayTag, TSubclassOf<class AMatchaSnapNetEntity>> EntitiesByTag;                                     // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaTrackableEntitySetupData">();
	}
	static class UMatchaTrackableEntitySetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaTrackableEntitySetupData>();
	}
};
static_assert(alignof(UMatchaTrackableEntitySetupData) == 0x000008, "Wrong alignment on UMatchaTrackableEntitySetupData");
static_assert(sizeof(UMatchaTrackableEntitySetupData) == 0x000080, "Wrong size on UMatchaTrackableEntitySetupData");
static_assert(offsetof(UMatchaTrackableEntitySetupData, EntitiesByTag) == 0x000030, "Member 'UMatchaTrackableEntitySetupData::EntitiesByTag' has a wrong offset!");

// Class Matcha.MatchaTrapRenderer
// 0x0000 (0x02A0 - 0x02A0)
class AMatchaTrapRenderer final : public AMatchaSnapNetRenderer
{
public:
	void OnTrapEntityUpdated(const class AMatchaTrapEntity* TrapEntity, float DeltaSeconds, bool bTeleported);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaTrapRenderer">();
	}
	static class AMatchaTrapRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchaTrapRenderer>();
	}
};
static_assert(alignof(AMatchaTrapRenderer) == 0x000008, "Wrong alignment on AMatchaTrapRenderer");
static_assert(sizeof(AMatchaTrapRenderer) == 0x0002A0, "Wrong size on AMatchaTrapRenderer");

// Class Matcha.MatchaUIDataModelBase
// 0x0088 (0x00C8 - 0x0040)
class UMatchaUIDataModelBase : public UOdyUIDataModelBase
{
public:
	TSubclassOf<class UMatchaGameWorldUIData>     GameWorldUIDataClass;                              // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaLocalPlayerUIData>   LocalPlayerUIDataClass;                            // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaLeaderboardUIData>   LeaderboardUIDataClass;                            // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaPlayerProfileUIData> PlayerProfileUIDataClass;                          // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaGameWorldUIData*                 GameWorld;                                         // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaLocalPlayerUIData*               LocalPlayer;                                       // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaLeaderboardUIData*               Leaderboard;                                       // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UMatchaPlayerProfileUIData*> PlayerProfiles;                                    // 0x0078(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaUIDataModelBase">();
	}
	static class UMatchaUIDataModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaUIDataModelBase>();
	}
};
static_assert(alignof(UMatchaUIDataModelBase) == 0x000008, "Wrong alignment on UMatchaUIDataModelBase");
static_assert(sizeof(UMatchaUIDataModelBase) == 0x0000C8, "Wrong size on UMatchaUIDataModelBase");
static_assert(offsetof(UMatchaUIDataModelBase, GameWorldUIDataClass) == 0x000040, "Member 'UMatchaUIDataModelBase::GameWorldUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaUIDataModelBase, LocalPlayerUIDataClass) == 0x000048, "Member 'UMatchaUIDataModelBase::LocalPlayerUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaUIDataModelBase, LeaderboardUIDataClass) == 0x000050, "Member 'UMatchaUIDataModelBase::LeaderboardUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaUIDataModelBase, PlayerProfileUIDataClass) == 0x000058, "Member 'UMatchaUIDataModelBase::PlayerProfileUIDataClass' has a wrong offset!");
static_assert(offsetof(UMatchaUIDataModelBase, GameWorld) == 0x000060, "Member 'UMatchaUIDataModelBase::GameWorld' has a wrong offset!");
static_assert(offsetof(UMatchaUIDataModelBase, LocalPlayer) == 0x000068, "Member 'UMatchaUIDataModelBase::LocalPlayer' has a wrong offset!");
static_assert(offsetof(UMatchaUIDataModelBase, Leaderboard) == 0x000070, "Member 'UMatchaUIDataModelBase::Leaderboard' has a wrong offset!");
static_assert(offsetof(UMatchaUIDataModelBase, PlayerProfiles) == 0x000078, "Member 'UMatchaUIDataModelBase::PlayerProfiles' has a wrong offset!");

// Class Matcha.MatchaUIStatics
// 0x0000 (0x0028 - 0x0028)
class UMatchaUIStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool FromStringTable(class FName StringTableId, const class FString& Key, class FText* OutText);
	static void ShowErrorMessageFromResponse(class UObject* WorldContextObject, const struct FErrorResponseV1& Error);
	static class FString UTCHourToLocalWithSuffix(int32 UtcHour);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaUIStatics">();
	}
	static class UMatchaUIStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaUIStatics>();
	}
};
static_assert(alignof(UMatchaUIStatics) == 0x000008, "Wrong alignment on UMatchaUIStatics");
static_assert(sizeof(UMatchaUIStatics) == 0x000028, "Wrong size on UMatchaUIStatics");

// Class Matcha.MatchaUISubsystem
// 0x0068 (0x0238 - 0x01D0)
class UMatchaUISubsystem : public UOdyUISubsystemBase
{
public:
	TMap<EOdyInputDeviceType, struct FGameplayTag> InputDeviceToTag;                                  // 0x01D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatchaUIDataModelBase>     UIDataModelClass;                                  // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaUIDataModelBase*                 UIDataModel;                                       // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaClientServices*                  ClientServices;                                    // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UMatchaUIDataModelBase* GetUIDataModel(const class UObject* WorldContextObject);
	static class UMatchaUISubsystem* GetUISubsystem(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaUISubsystem">();
	}
	static class UMatchaUISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaUISubsystem>();
	}
};
static_assert(alignof(UMatchaUISubsystem) == 0x000008, "Wrong alignment on UMatchaUISubsystem");
static_assert(sizeof(UMatchaUISubsystem) == 0x000238, "Wrong size on UMatchaUISubsystem");
static_assert(offsetof(UMatchaUISubsystem, InputDeviceToTag) == 0x0001D0, "Member 'UMatchaUISubsystem::InputDeviceToTag' has a wrong offset!");
static_assert(offsetof(UMatchaUISubsystem, UIDataModelClass) == 0x000220, "Member 'UMatchaUISubsystem::UIDataModelClass' has a wrong offset!");
static_assert(offsetof(UMatchaUISubsystem, UIDataModel) == 0x000228, "Member 'UMatchaUISubsystem::UIDataModel' has a wrong offset!");
static_assert(offsetof(UMatchaUISubsystem, ClientServices) == 0x000230, "Member 'UMatchaUISubsystem::ClientServices' has a wrong offset!");

// Class Matcha.MatchaZoneUIData
// 0x00B0 (0x0118 - 0x0068)
class UMatchaZoneUIData final : public UOdyUIData
{
public:
	struct FOdyUIIntBinding                       CycleIndex;                                        // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsShrinking;                                       // 0x0088(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     SecondsUntilNextShrink;                            // 0x00A8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIFloatBinding                     SecondsUntilShrinkComplete;                        // 0x00C8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOdyUIBoolBinding                      IsLastStand;                                       // 0x00E8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaZoneUIData">();
	}
	static class UMatchaZoneUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaZoneUIData>();
	}
};
static_assert(alignof(UMatchaZoneUIData) == 0x000008, "Wrong alignment on UMatchaZoneUIData");
static_assert(sizeof(UMatchaZoneUIData) == 0x000118, "Wrong size on UMatchaZoneUIData");
static_assert(offsetof(UMatchaZoneUIData, CycleIndex) == 0x000068, "Member 'UMatchaZoneUIData::CycleIndex' has a wrong offset!");
static_assert(offsetof(UMatchaZoneUIData, IsShrinking) == 0x000088, "Member 'UMatchaZoneUIData::IsShrinking' has a wrong offset!");
static_assert(offsetof(UMatchaZoneUIData, SecondsUntilNextShrink) == 0x0000A8, "Member 'UMatchaZoneUIData::SecondsUntilNextShrink' has a wrong offset!");
static_assert(offsetof(UMatchaZoneUIData, SecondsUntilShrinkComplete) == 0x0000C8, "Member 'UMatchaZoneUIData::SecondsUntilShrinkComplete' has a wrong offset!");
static_assert(offsetof(UMatchaZoneUIData, IsLastStand) == 0x0000E8, "Member 'UMatchaZoneUIData::IsLastStand' has a wrong offset!");

// Class Matcha.MatchaNotify_PlayNiagaraEffect
// 0x0088 (0x00C0 - 0x0038)
class alignas(0x10) UMatchaNotify_PlayNiagaraEffect final : public UAnimNotify
{
public:
	class FName                                   NiagaraSystemId;                                   // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectEventType                              EffectEventType;                                   // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0048(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0060(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0078(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0091(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0094(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x24];                                      // 0x009C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchaNotify_PlayNiagaraEffect">();
	}
	static class UMatchaNotify_PlayNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchaNotify_PlayNiagaraEffect>();
	}
};
static_assert(alignof(UMatchaNotify_PlayNiagaraEffect) == 0x000010, "Wrong alignment on UMatchaNotify_PlayNiagaraEffect");
static_assert(sizeof(UMatchaNotify_PlayNiagaraEffect) == 0x0000C0, "Wrong size on UMatchaNotify_PlayNiagaraEffect");
static_assert(offsetof(UMatchaNotify_PlayNiagaraEffect, NiagaraSystemId) == 0x000038, "Member 'UMatchaNotify_PlayNiagaraEffect::NiagaraSystemId' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlayNiagaraEffect, EffectEventType) == 0x000040, "Member 'UMatchaNotify_PlayNiagaraEffect::EffectEventType' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlayNiagaraEffect, LocationOffset) == 0x000048, "Member 'UMatchaNotify_PlayNiagaraEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlayNiagaraEffect, RotationOffset) == 0x000060, "Member 'UMatchaNotify_PlayNiagaraEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlayNiagaraEffect, Scale) == 0x000078, "Member 'UMatchaNotify_PlayNiagaraEffect::Scale' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlayNiagaraEffect, bAbsoluteScale) == 0x000090, "Member 'UMatchaNotify_PlayNiagaraEffect::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlayNiagaraEffect, bAttached) == 0x000091, "Member 'UMatchaNotify_PlayNiagaraEffect::bAttached' has a wrong offset!");
static_assert(offsetof(UMatchaNotify_PlayNiagaraEffect, SocketName) == 0x000094, "Member 'UMatchaNotify_PlayNiagaraEffect::SocketName' has a wrong offset!");

}

