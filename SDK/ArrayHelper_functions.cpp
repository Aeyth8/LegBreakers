#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ArrayHelper

#include "Basic.hpp"

#include "ArrayHelper_classes.hpp"
#include "ArrayHelper_parameters.hpp"


namespace SDK
{

// Function ArrayHelper.ArrayHelperBPLibrary.ArrayAddRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           InArrayA                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InItem                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ArrayAddRef(TArray<int32>& InArrayA, const int32& InItem, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ArrayAddRef");

	Params::ArrayHelperBPLibrary_ArrayAddRef Parms{};

	Parms.InArrayA = std::move(InArrayA);
	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InArrayA = std::move(Parms.InArrayA);

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ArrayDivideRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           InArrayA                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InItem                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ArrayDivideRef(TArray<int32>& InArrayA, const int32& InItem, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ArrayDivideRef");

	Params::ArrayHelperBPLibrary_ArrayDivideRef Parms{};

	Parms.InArrayA = std::move(InArrayA);
	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InArrayA = std::move(Parms.InArrayA);

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ArrayMultiplyRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           InArrayA                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InItem                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ArrayMultiplyRef(TArray<int32>& InArrayA, const int32& InItem, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ArrayMultiplyRef");

	Params::ArrayHelperBPLibrary_ArrayMultiplyRef Parms{};

	Parms.InArrayA = std::move(InArrayA);
	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InArrayA = std::move(Parms.InArrayA);

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ArraySubtractRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           InArrayA                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InItem                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ArraySubtractRef(TArray<int32>& InArrayA, const int32& InItem, bool* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ArraySubtractRef");

	Params::ArrayHelperBPLibrary_ArraySubtractRef Parms{};

	Parms.InArrayA = std::move(InArrayA);
	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InArrayA = std::move(Parms.InArrayA);

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;
}


// Function ArrayHelper.ArrayHelperBPLibrary.AverageByte
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArrayHelperBPLibrary::AverageByte(const TArray<uint8>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "AverageByte");

	Params::ArrayHelperBPLibrary_AverageByte Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.AverageFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArrayHelperBPLibrary::AverageFloat(const TArray<float>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "AverageFloat");

	Params::ArrayHelperBPLibrary_AverageFloat Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.AverageInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArrayHelperBPLibrary::AverageInteger(const TArray<int32>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "AverageInteger");

	Params::ArrayHelperBPLibrary_AverageInteger Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.AverageInteger64
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArrayHelperBPLibrary::AverageInteger64(const TArray<int64>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "AverageInteger64");

	Params::ArrayHelperBPLibrary_AverageInteger64 Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.BreakTransformArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTransform>               InTransforms                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutLocations                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRotator>                 OutRotators                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutScales                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::BreakTransformArray(const TArray<struct FTransform>& InTransforms, TArray<struct FVector>* OutLocations, TArray<struct FRotator>* OutRotators, TArray<struct FVector>* OutScales)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "BreakTransformArray");

	Params::ArrayHelperBPLibrary_BreakTransformArray Parms{};

	Parms.InTransforms = std::move(InTransforms);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocations != nullptr)
		*OutLocations = std::move(Parms.OutLocations);

	if (OutRotators != nullptr)
		*OutRotators = std::move(Parms.OutRotators);

	if (OutScales != nullptr)
		*OutScales = std::move(Parms.OutScales);
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampByte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// uint8                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UArrayHelperBPLibrary::ClampByte(const TArray<uint8>& Array, uint8 Min, uint8 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampByte");

	Params::ArrayHelperBPLibrary_ClampByte Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampByteRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// uint8                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClampByteRef(TArray<uint8>& Array, uint8 Min, uint8 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampByteRef");

	Params::ArrayHelperBPLibrary_ClampByteRef Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UArrayHelperBPLibrary::ClampFloat(const TArray<float>& Array, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampFloat");

	Params::ArrayHelperBPLibrary_ClampFloat Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampFloatRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClampFloatRef(TArray<float>& Array, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampFloatRef");

	Params::ArrayHelperBPLibrary_ClampFloatRef Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampInteger
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UArrayHelperBPLibrary::ClampInteger(const TArray<int32>& Array, int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampInteger");

	Params::ArrayHelperBPLibrary_ClampInteger Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampInteger64
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int64                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int64>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int64> UArrayHelperBPLibrary::ClampInteger64(const TArray<int64>& Array, int64 Min, int64 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampInteger64");

	Params::ArrayHelperBPLibrary_ClampInteger64 Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampInteger64Ref
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClampInteger64Ref(TArray<int64>& Array, int64 Min, int64 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampInteger64Ref");

	Params::ArrayHelperBPLibrary_ClampInteger64Ref Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampIntegerRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClampIntegerRef(TArray<int32>& Array, int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampIntegerRef");

	Params::ArrayHelperBPLibrary_ClampIntegerRef Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampVector2DSize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   InMinSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector2D> UArrayHelperBPLibrary::ClampVector2DSize(const TArray<struct FVector2D>& InArray, float InMinSize, float InMaxSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampVector2DSize");

	Params::ArrayHelperBPLibrary_ClampVector2DSize Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InMinSize = InMinSize;
	Parms.InMaxSize = InMaxSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampVector2DSizeRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InMinSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClampVector2DSizeRef(TArray<struct FVector2D>& InArray, float InMinSize, float InMaxSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampVector2DSizeRef");

	Params::ArrayHelperBPLibrary_ClampVector2DSizeRef Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InMinSize = InMinSize;
	Parms.InMaxSize = InMaxSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InArray = std::move(Parms.InArray);
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampVectorSize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   MinSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnly2D                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UArrayHelperBPLibrary::ClampVectorSize(const TArray<struct FVector>& Array, float MinSize, float MaxSize, bool bOnly2D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampVectorSize");

	Params::ArrayHelperBPLibrary_ClampVectorSize Parms{};

	Parms.Array = std::move(Array);
	Parms.MinSize = MinSize;
	Parms.MaxSize = MaxSize;
	Parms.bOnly2D = bOnly2D;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClampVectorSizeRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MinSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnly2D                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClampVectorSizeRef(TArray<struct FVector>& Array, float MinSize, float MaxSize, bool bOnly2D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClampVectorSizeRef");

	Params::ArrayHelperBPLibrary_ClampVectorSizeRef Parms{};

	Parms.Array = std::move(Array);
	Parms.MinSize = MinSize;
	Parms.MaxSize = MaxSize;
	Parms.bOnly2D = bOnly2D;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClosestActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Closest                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClosestActor(const TArray<class AActor*>& Array, const class AActor*& Origin, class AActor** Closest, float* Distance, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClosestActor");

	Params::ArrayHelperBPLibrary_ClosestActor Parms{};

	Parms.Array = std::move(Array);
	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Closest != nullptr)
		*Closest = Parms.Closest;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClosestLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Closest                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClosestLocation(const TArray<struct FVector>& Array, const struct FVector& Origin, struct FVector* Closest, float* Distance, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClosestLocation");

	Params::ArrayHelperBPLibrary_ClosestLocation Parms{};

	Parms.Array = std::move(Array);
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Closest != nullptr)
		*Closest = std::move(Parms.Closest);

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ClosestTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FTransform>               InArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          InOrigin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutClosest                                             (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDistance                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ClosestTransform(const TArray<struct FTransform>& InArray, const struct FVector& InOrigin, struct FTransform* OutClosest, float* OutDistance, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ClosestTransform");

	Params::ArrayHelperBPLibrary_ClosestTransform Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InOrigin = std::move(InOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutClosest != nullptr)
		*OutClosest = std::move(Parms.OutClosest);

	if (OutDistance != nullptr)
		*OutDistance = Parms.OutDistance;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ExtractArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           ArrayA                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           ArrayB                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ExtractArray(const TArray<int32>& ArrayA, TArray<int32>* ArrayB, int32 StartIndex, int32 EndIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ExtractArray");

	Params::ArrayHelperBPLibrary_ExtractArray Parms{};

	Parms.ArrayA = std::move(ArrayA);
	Parms.StartIndex = StartIndex;
	Parms.EndIndex = EndIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ArrayB != nullptr)
		*ArrayB = std::move(Parms.ArrayB);
}


// Function ArrayHelper.ArrayHelperBPLibrary.FarthestActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Farthest                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::FarthestActor(const TArray<class AActor*>& Array, const class AActor*& Origin, class AActor** Farthest, float* Distance, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "FarthestActor");

	Params::ArrayHelperBPLibrary_FarthestActor Parms{};

	Parms.Array = std::move(Array);
	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Farthest != nullptr)
		*Farthest = Parms.Farthest;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function ArrayHelper.ArrayHelperBPLibrary.FarthestLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Farthest                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::FarthestLocation(const TArray<struct FVector>& Array, const struct FVector& Origin, struct FVector* Farthest, float* Distance, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "FarthestLocation");

	Params::ArrayHelperBPLibrary_FarthestLocation Parms{};

	Parms.Array = std::move(Array);
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Farthest != nullptr)
		*Farthest = std::move(Parms.Farthest);

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function ArrayHelper.ArrayHelperBPLibrary.FarthestTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FTransform>               InArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          InOrigin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutFarthest                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDistance                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::FarthestTransform(const TArray<struct FTransform>& InArray, const struct FVector& InOrigin, struct FTransform* OutFarthest, float* OutDistance, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "FarthestTransform");

	Params::ArrayHelperBPLibrary_FarthestTransform Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InOrigin = std::move(InOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFarthest != nullptr)
		*OutFarthest = std::move(Parms.OutFarthest);

	if (OutDistance != nullptr)
		*OutDistance = Parms.OutDistance;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;
}


// Function ArrayHelper.ArrayHelperBPLibrary.FilterMatch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Pattern                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFound                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UArrayHelperBPLibrary::FilterMatch(const TArray<class FString>& Array, const class FString& Pattern, bool* bFound, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "FilterMatch");

	Params::ArrayHelperBPLibrary_FilterMatch Parms{};

	Parms.Array = std::move(Array);
	Parms.Pattern = std::move(Pattern);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFound != nullptr)
		*bFound = Parms.bFound;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.FilterMatches
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Pattern                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFound                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           Indexes                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UArrayHelperBPLibrary::FilterMatches(const TArray<class FString>& Array, const class FString& Pattern, bool* bFound, TArray<int32>* Indexes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "FilterMatches");

	Params::ArrayHelperBPLibrary_FilterMatches Parms{};

	Parms.Array = std::move(Array);
	Parms.Pattern = std::move(Pattern);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFound != nullptr)
		*bFound = Parms.bFound;

	if (Indexes != nullptr)
		*Indexes = std::move(Parms.Indexes);

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MakeTransformArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  InLocations                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FRotator>                 InRotators                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  InScales                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               OutTransforms                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UArrayHelperBPLibrary::MakeTransformArray(const TArray<struct FVector>& InLocations, const TArray<struct FRotator>& InRotators, const TArray<struct FVector>& InScales, TArray<struct FTransform>* OutTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MakeTransformArray");

	Params::ArrayHelperBPLibrary_MakeTransformArray Parms{};

	Parms.InLocations = std::move(InLocations);
	Parms.InRotators = std::move(InRotators);
	Parms.InScales = std::move(InScales);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransforms != nullptr)
		*OutTransforms = std::move(Parms.OutTransforms);

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MaximumByteIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArrayHelperBPLibrary::MaximumByteIndex(const TArray<uint8>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MaximumByteIndex");

	Params::ArrayHelperBPLibrary_MaximumByteIndex Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MaximumFloatIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArrayHelperBPLibrary::MaximumFloatIndex(const TArray<float>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MaximumFloatIndex");

	Params::ArrayHelperBPLibrary_MaximumFloatIndex Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MaximumInteger64Index
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArrayHelperBPLibrary::MaximumInteger64Index(const TArray<int64>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MaximumInteger64Index");

	Params::ArrayHelperBPLibrary_MaximumInteger64Index Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MaximumIntegerIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArrayHelperBPLibrary::MaximumIntegerIndex(const TArray<int32>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MaximumIntegerIndex");

	Params::ArrayHelperBPLibrary_MaximumIntegerIndex Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MinimumByteIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArrayHelperBPLibrary::MinimumByteIndex(const TArray<uint8>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MinimumByteIndex");

	Params::ArrayHelperBPLibrary_MinimumByteIndex Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MinimumFloatIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArrayHelperBPLibrary::MinimumFloatIndex(const TArray<float>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MinimumFloatIndex");

	Params::ArrayHelperBPLibrary_MinimumFloatIndex Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MinimumInteger64Index
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArrayHelperBPLibrary::MinimumInteger64Index(const TArray<int64>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MinimumInteger64Index");

	Params::ArrayHelperBPLibrary_MinimumInteger64Index Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MinimumIntegerIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArrayHelperBPLibrary::MinimumIntegerIndex(const TArray<int32>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MinimumIntegerIndex");

	Params::ArrayHelperBPLibrary_MinimumIntegerIndex Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MinMaxByteNormalization
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// uint8                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UArrayHelperBPLibrary::MinMaxByteNormalization(const TArray<uint8>& Array, uint8 Min, uint8 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MinMaxByteNormalization");

	Params::ArrayHelperBPLibrary_MinMaxByteNormalization Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MinMaxFloatNormalization
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UArrayHelperBPLibrary::MinMaxFloatNormalization(const TArray<float>& Array, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MinMaxFloatNormalization");

	Params::ArrayHelperBPLibrary_MinMaxFloatNormalization Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MinMaxInteger64Normalization
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int64>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int64> UArrayHelperBPLibrary::MinMaxInteger64Normalization(const TArray<int64>& Array, int64 Min, int64 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MinMaxInteger64Normalization");

	Params::ArrayHelperBPLibrary_MinMaxInteger64Normalization Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.MinMaxIntegerNormalization
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UArrayHelperBPLibrary::MinMaxIntegerNormalization(const TArray<int32>& Array, int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "MinMaxIntegerNormalization");

	Params::ArrayHelperBPLibrary_MinMaxIntegerNormalization Parms{};

	Parms.Array = std::move(Array);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UArrayHelperBPLibrary::PredicateFilterActor(const TArray<class AActor*>& Array, const TDelegate<void(class AActor* Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterActor");

	Params::ArrayHelperBPLibrary_PredicateFilterActor Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterByte
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(uint8& Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UArrayHelperBPLibrary::PredicateFilterByte(const TArray<uint8>& Array, const TDelegate<void(uint8& Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterByte");

	Params::ArrayHelperBPLibrary_PredicateFilterByte Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(float& Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UArrayHelperBPLibrary::PredicateFilterFloat(const TArray<float>& Array, const TDelegate<void(float& Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterFloat");

	Params::ArrayHelperBPLibrary_PredicateFilterFloat Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(int32& Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UArrayHelperBPLibrary::PredicateFilterInteger(const TArray<int32>& Array, const TDelegate<void(int32& Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterInteger");

	Params::ArrayHelperBPLibrary_PredicateFilterInteger Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterInteger64
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(int64& Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int64>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int64> UArrayHelperBPLibrary::PredicateFilterInteger64(const TArray<int64>& Array, const TDelegate<void(int64& Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterInteger64");

	Params::ArrayHelperBPLibrary_PredicateFilterInteger64 Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(class FName& Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UArrayHelperBPLibrary::PredicateFilterName(const TArray<class FName>& Array, const TDelegate<void(class FName& Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterName");

	Params::ArrayHelperBPLibrary_PredicateFilterName Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UArrayHelperBPLibrary::PredicateFilterObject(const TArray<class UObject*>& Array, const TDelegate<void(class UObject* Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterObject");

	Params::ArrayHelperBPLibrary_PredicateFilterObject Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UArrayHelperBPLibrary::PredicateFilterString(const TArray<class FString>& Array, const TDelegate<void(const class FString& Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterString");

	Params::ArrayHelperBPLibrary_PredicateFilterString Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterVector
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(struct FVector& Value, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UArrayHelperBPLibrary::PredicateFilterVector(const TArray<struct FVector>& Array, const TDelegate<void(struct FVector& Value, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterVector");

	Params::ArrayHelperBPLibrary_PredicateFilterVector Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterVector2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(struct FVector2D& Value, bool* Result)>InPredicateFunction                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInInvertResult                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector2D> UArrayHelperBPLibrary::PredicateFilterVector2D(const TArray<struct FVector2D>& InArray, const TDelegate<void(struct FVector2D& Value, bool* Result)>& InPredicateFunction, bool bInInvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateFilterVector2D");

	Params::ArrayHelperBPLibrary_PredicateFilterVector2D Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InPredicateFunction = InPredicateFunction;
	Parms.bInInvertResult = bInInvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* A, class AActor* B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UArrayHelperBPLibrary::PredicateSortActor(const TArray<class AActor*>& Array, const TDelegate<void(class AActor* A, class AActor* B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortActor");

	Params::ArrayHelperBPLibrary_PredicateSortActor Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortActorRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* A, class AActor* B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortActorRef(TArray<class AActor*>& Array, const TDelegate<void(class AActor* A, class AActor* B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortActorRef");

	Params::ArrayHelperBPLibrary_PredicateSortActorRef Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortByte
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(uint8& A, uint8& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UArrayHelperBPLibrary::PredicateSortByte(const TArray<uint8>& Array, const TDelegate<void(uint8& A, uint8& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortByte");

	Params::ArrayHelperBPLibrary_PredicateSortByte Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortByteRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(uint8& A, uint8& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortByteRef(TArray<uint8>& Array, const TDelegate<void(uint8& A, uint8& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortByteRef");

	Params::ArrayHelperBPLibrary_PredicateSortByteRef Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(float& A, float& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UArrayHelperBPLibrary::PredicateSortFloat(const TArray<float>& Array, const TDelegate<void(float& A, float& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortFloat");

	Params::ArrayHelperBPLibrary_PredicateSortFloat Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortFloatRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(float& A, float& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortFloatRef(TArray<float>& Array, const TDelegate<void(float& A, float& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortFloatRef");

	Params::ArrayHelperBPLibrary_PredicateSortFloatRef Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(int32& A, int32& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UArrayHelperBPLibrary::PredicateSortInteger(const TArray<int32>& Array, const TDelegate<void(int32& A, int32& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortInteger");

	Params::ArrayHelperBPLibrary_PredicateSortInteger Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortInteger64
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(int64& A, int64& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int64>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int64> UArrayHelperBPLibrary::PredicateSortInteger64(const TArray<int64>& Array, const TDelegate<void(int64& A, int64& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortInteger64");

	Params::ArrayHelperBPLibrary_PredicateSortInteger64 Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortInteger64Ref
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(int64& A, int64& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortInteger64Ref(TArray<int64>& Array, const TDelegate<void(int64& A, int64& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortInteger64Ref");

	Params::ArrayHelperBPLibrary_PredicateSortInteger64Ref Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortIntegerRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(int32& A, int32& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortIntegerRef(TArray<int32>& Array, const TDelegate<void(int32& A, int32& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortIntegerRef");

	Params::ArrayHelperBPLibrary_PredicateSortIntegerRef Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(class FName& A, class FName& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UArrayHelperBPLibrary::PredicateSortName(const TArray<class FName>& Array, const TDelegate<void(class FName& A, class FName& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortName");

	Params::ArrayHelperBPLibrary_PredicateSortName Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortNameRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(class FName& A, class FName& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortNameRef(TArray<class FName>& Array, const TDelegate<void(class FName& A, class FName& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortNameRef");

	Params::ArrayHelperBPLibrary_PredicateSortNameRef Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* A, class UObject* B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UArrayHelperBPLibrary::PredicateSortObject(const TArray<class UObject*>& Array, const TDelegate<void(class UObject* A, class UObject* B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortObject");

	Params::ArrayHelperBPLibrary_PredicateSortObject Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortObjectRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* A, class UObject* B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortObjectRef(TArray<class UObject*>& Array, const TDelegate<void(class UObject* A, class UObject* B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortObjectRef");

	Params::ArrayHelperBPLibrary_PredicateSortObjectRef Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& A, const class FString& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UArrayHelperBPLibrary::PredicateSortString(const TArray<class FString>& Array, const TDelegate<void(const class FString& A, const class FString& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortString");

	Params::ArrayHelperBPLibrary_PredicateSortString Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortStringRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& A, const class FString& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortStringRef(TArray<class FString>& Array, const TDelegate<void(const class FString& A, const class FString& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortStringRef");

	Params::ArrayHelperBPLibrary_PredicateSortStringRef Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortVector
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(struct FVector& A, struct FVector& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UArrayHelperBPLibrary::PredicateSortVector(const TArray<struct FVector>& Array, const TDelegate<void(struct FVector& A, struct FVector& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortVector");

	Params::ArrayHelperBPLibrary_PredicateSortVector Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortVector2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(struct FVector2D& A, struct FVector2D& B, bool* Result)>InPredicateFunction                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInInvertResult                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector2D> UArrayHelperBPLibrary::PredicateSortVector2D(const TArray<struct FVector2D>& InArray, const TDelegate<void(struct FVector2D& A, struct FVector2D& B, bool* Result)>& InPredicateFunction, bool bInInvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortVector2D");

	Params::ArrayHelperBPLibrary_PredicateSortVector2D Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InPredicateFunction = InPredicateFunction;
	Parms.bInInvertResult = bInInvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortVector2DRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(struct FVector2D& A, struct FVector2D& B, bool* Result)>InPredicateFunction                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInInvertResult                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortVector2DRef(TArray<struct FVector2D>& InArray, const TDelegate<void(struct FVector2D& A, struct FVector2D& B, bool* Result)>& InPredicateFunction, bool bInInvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortVector2DRef");

	Params::ArrayHelperBPLibrary_PredicateSortVector2DRef Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InPredicateFunction = InPredicateFunction;
	Parms.bInInvertResult = bInInvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InArray = std::move(Parms.InArray);
}


// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortVectorRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(struct FVector& A, struct FVector& B, bool* Result)>PredicateFunction                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvertResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::PredicateSortVectorRef(TArray<struct FVector>& Array, const TDelegate<void(struct FVector& A, struct FVector& B, bool* Result)>& PredicateFunction, bool InvertResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "PredicateSortVectorRef");

	Params::ArrayHelperBPLibrary_PredicateSortVectorRef Parms{};

	Parms.Array = std::move(Array);
	Parms.PredicateFunction = PredicateFunction;
	Parms.InvertResult = InvertResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.RandomBoolean
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<bool> UArrayHelperBPLibrary::RandomBoolean(int32 Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "RandomBoolean");

	Params::ArrayHelperBPLibrary_RandomBoolean Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.RandomByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UArrayHelperBPLibrary::RandomByte(int32 Size, uint8 MinValue, uint8 MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "RandomByte");

	Params::ArrayHelperBPLibrary_RandomByte Parms{};

	Parms.Size = Size;
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.RandomFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UArrayHelperBPLibrary::RandomFloat(int32 Size, float MinValue, float MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "RandomFloat");

	Params::ArrayHelperBPLibrary_RandomFloat Parms{};

	Parms.Size = Size;
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.RandomInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UArrayHelperBPLibrary::RandomInteger(int32 Size, int32 MinValue, int32 MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "RandomInteger");

	Params::ArrayHelperBPLibrary_RandomInteger Parms{};

	Parms.Size = Size;
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.RandomInteger64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int64>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int64> UArrayHelperBPLibrary::RandomInteger64(int32 Size, int64 MinValue, int64 MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "RandomInteger64");

	Params::ArrayHelperBPLibrary_RandomInteger64 Parms{};

	Parms.Size = Size;
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.RandomItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           ArrayA                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           Weights                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Item                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::RandomItem(const TArray<int32>& ArrayA, const TArray<int32>& Weights, int32* Item, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "RandomItem");

	Params::ArrayHelperBPLibrary_RandomItem Parms{};

	Parms.ArrayA = std::move(ArrayA);
	Parms.Weights = std::move(Weights);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Item != nullptr)
		*Item = Parms.Item;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function ArrayHelper.ArrayHelperBPLibrary.RandomVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UArrayHelperBPLibrary::RandomVector(int32 Size, const struct FVector& MinValue, const struct FVector& MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "RandomVector");

	Params::ArrayHelperBPLibrary_RandomVector Parms{};

	Parms.Size = Size;
	Parms.MinValue = std::move(MinValue);
	Parms.MaxValue = std::move(MaxValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.RandomVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InMinValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InMaxValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector2D> UArrayHelperBPLibrary::RandomVector2D(int32 InSize, const struct FVector2D& InMinValue, const struct FVector2D& InMaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "RandomVector2D");

	Params::ArrayHelperBPLibrary_RandomVector2D Parms{};

	Parms.InSize = InSize;
	Parms.InMinValue = std::move(InMinValue);
	Parms.InMaxValue = std::move(InMaxValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ReverseArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           ArrayA                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           ArrayB                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ReverseArray(const TArray<int32>& ArrayA, TArray<int32>* ArrayB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ReverseArray");

	Params::ArrayHelperBPLibrary_ReverseArray Parms{};

	Parms.ArrayA = std::move(ArrayA);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ArrayB != nullptr)
		*ArrayB = std::move(Parms.ArrayB);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UArrayHelperBPLibrary::SortActor(const TArray<class AActor*>& Array, const class AActor*& Actor, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortActor");

	Params::ArrayHelperBPLibrary_SortActor Parms{};

	Parms.Array = std::move(Array);
	Parms.Actor = Actor;
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortActorRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortActorRef(TArray<class AActor*>& Array, const class AActor*& Actor, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortActorRef");

	Params::ArrayHelperBPLibrary_SortActorRef Parms{};

	Parms.Array = std::move(Array);
	Parms.Actor = Actor;
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortByte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UArrayHelperBPLibrary::SortByte(const TArray<uint8>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortByte");

	Params::ArrayHelperBPLibrary_SortByte Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortByteRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortByteRef(TArray<uint8>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortByteRef");

	Params::ArrayHelperBPLibrary_SortByteRef Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UArrayHelperBPLibrary::SortFloat(const TArray<float>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortFloat");

	Params::ArrayHelperBPLibrary_SortFloat Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortFloatRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortFloatRef(TArray<float>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortFloatRef");

	Params::ArrayHelperBPLibrary_SortFloatRef Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortInteger
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UArrayHelperBPLibrary::SortInteger(const TArray<int32>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortInteger");

	Params::ArrayHelperBPLibrary_SortInteger Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortInteger64
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int64>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int64> UArrayHelperBPLibrary::SortInteger64(const TArray<int64>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortInteger64");

	Params::ArrayHelperBPLibrary_SortInteger64 Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortInteger64Ref
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortInteger64Ref(TArray<int64>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortInteger64Ref");

	Params::ArrayHelperBPLibrary_SortInteger64Ref Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortIntegerRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortIntegerRef(TArray<int32>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortIntegerRef");

	Params::ArrayHelperBPLibrary_SortIntegerRef Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UArrayHelperBPLibrary::SortName(const TArray<class FName>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortName");

	Params::ArrayHelperBPLibrary_SortName Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortNameRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortNameRef(TArray<class FName>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortNameRef");

	Params::ArrayHelperBPLibrary_SortNameRef Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UArrayHelperBPLibrary::SortString(const TArray<class FString>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortString");

	Params::ArrayHelperBPLibrary_SortString Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortStringRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortStringRef(TArray<class FString>& Array, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortStringRef");

	Params::ArrayHelperBPLibrary_SortStringRef Parms{};

	Parms.Array = std::move(Array);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UArrayHelperBPLibrary::SortVector(const TArray<struct FVector>& Array, const struct FVector& Origin, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortVector");

	Params::ArrayHelperBPLibrary_SortVector Parms{};

	Parms.Array = std::move(Array);
	Parms.Origin = std::move(Origin);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector2D                        InOrigin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsAscending                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector2D> UArrayHelperBPLibrary::SortVector2D(const TArray<struct FVector2D>& InArray, const struct FVector2D& InOrigin, bool bInIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortVector2D");

	Params::ArrayHelperBPLibrary_SortVector2D Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InOrigin = std::move(InOrigin);
	Parms.bInIsAscending = bInIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortVector2DRef
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        InOrigin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsAscending                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortVector2DRef(TArray<struct FVector2D>& InArray, const struct FVector2D& InOrigin, bool bInIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortVector2DRef");

	Params::ArrayHelperBPLibrary_SortVector2DRef Parms{};

	Parms.InArray = std::move(InArray);
	Parms.InOrigin = std::move(InOrigin);
	Parms.bInIsAscending = bInIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InArray = std::move(Parms.InArray);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortVectorRef
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsAscending                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortVectorRef(TArray<struct FVector>& Array, const struct FVector& Origin, bool bIsAscending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortVectorRef");

	Params::ArrayHelperBPLibrary_SortVectorRef Parms{};

	Parms.Array = std::move(Array);
	Parms.Origin = std::move(Origin);
	Parms.bIsAscending = bIsAscending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortVertices
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bInCounterClockWise                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector2D> UArrayHelperBPLibrary::SortVertices(const TArray<struct FVector2D>& InArray, bool bInCounterClockWise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortVertices");

	Params::ArrayHelperBPLibrary_SortVertices Parms{};

	Parms.InArray = std::move(InArray);
	Parms.bInCounterClockWise = bInCounterClockWise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.SortVerticesRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                InArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInCounterClockWise                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::SortVerticesRef(TArray<struct FVector2D>& InArray, bool bInCounterClockWise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SortVerticesRef");

	Params::ArrayHelperBPLibrary_SortVerticesRef Parms{};

	Parms.InArray = std::move(InArray);
	Parms.bInCounterClockWise = bInCounterClockWise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InArray = std::move(Parms.InArray);
}


// Function ArrayHelper.ArrayHelperBPLibrary.SplitString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Separator                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchCase                             SearchCase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RemoveEmptyString                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UArrayHelperBPLibrary::SplitString(const class FString& String, const class FString& Separator, ESearchCase SearchCase, bool RemoveEmptyString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "SplitString");

	Params::ArrayHelperBPLibrary_SplitString Parms{};

	Parms.String = std::move(String);
	Parms.Separator = std::move(Separator);
	Parms.SearchCase = SearchCase;
	Parms.RemoveEmptyString = RemoveEmptyString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ArrayHelper.ArrayHelperBPLibrary.ToSet
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           ArrayA                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                             ArrayB                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UArrayHelperBPLibrary::ToSet(const TArray<int32>& ArrayA, TSet<int32>* ArrayB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArrayHelperBPLibrary", "ToSet");

	Params::ArrayHelperBPLibrary_ToSet Parms{};

	Parms.ArrayA = std::move(ArrayA);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ArrayB != nullptr)
		*ArrayB = std::move(Parms.ArrayB);
}

}

