#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OdyMinimap

#include "Basic.hpp"

#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "OdyUI_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "OdyMinimap_structs.hpp"


namespace SDK
{

// Class OdyMinimap.OdyCompassHorizontalWidget
// 0x0068 (0x0348 - 0x02E0)
class UOdyCompassHorizontalWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           IndicatorPanel;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SizeBox;                                           // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompassFieldOfView;                                // 0x02F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x54];                                     // 0x02F4(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIndicator(class UObject* IndicatedObject);
	void DestroyIndicator(class UObject* IndicatedObject);
	void OnActorDestroyed(class AActor* InActor);
	void OnActorSpawned(class AActor* InActor);

	float ConvertWorldPositionToCompassPosition(const struct FVector& WorldPosition) const;
	struct FVector GetCompassWorldPosition() const;
	float GetHeadingYawInDegrees() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyCompassHorizontalWidget">();
	}
	static class UOdyCompassHorizontalWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyCompassHorizontalWidget>();
	}
};
static_assert(alignof(UOdyCompassHorizontalWidget) == 0x000008, "Wrong alignment on UOdyCompassHorizontalWidget");
static_assert(sizeof(UOdyCompassHorizontalWidget) == 0x000348, "Wrong size on UOdyCompassHorizontalWidget");
static_assert(offsetof(UOdyCompassHorizontalWidget, IndicatorPanel) == 0x0002E0, "Member 'UOdyCompassHorizontalWidget::IndicatorPanel' has a wrong offset!");
static_assert(offsetof(UOdyCompassHorizontalWidget, SizeBox) == 0x0002E8, "Member 'UOdyCompassHorizontalWidget::SizeBox' has a wrong offset!");
static_assert(offsetof(UOdyCompassHorizontalWidget, CompassFieldOfView) == 0x0002F0, "Member 'UOdyCompassHorizontalWidget::CompassFieldOfView' has a wrong offset!");

// Class OdyMinimap.OdyCompassIndicatorWidget
// 0x0020 (0x0300 - 0x02E0)
class UOdyCompassIndicatorWidget final : public UUserWidget
{
public:
	TWeakObjectPtr<class UObject>                 IndicatedObject;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IndicatorName;                                     // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Alignment;                                         // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	ESlateVisibility GetIndicatorVisibility();
	struct FVector GetIndicatorWorldPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyCompassIndicatorWidget">();
	}
	static class UOdyCompassIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyCompassIndicatorWidget>();
	}
};
static_assert(alignof(UOdyCompassIndicatorWidget) == 0x000008, "Wrong alignment on UOdyCompassIndicatorWidget");
static_assert(sizeof(UOdyCompassIndicatorWidget) == 0x000300, "Wrong size on UOdyCompassIndicatorWidget");
static_assert(offsetof(UOdyCompassIndicatorWidget, IndicatedObject) == 0x0002E0, "Member 'UOdyCompassIndicatorWidget::IndicatedObject' has a wrong offset!");
static_assert(offsetof(UOdyCompassIndicatorWidget, IndicatorName) == 0x0002E8, "Member 'UOdyCompassIndicatorWidget::IndicatorName' has a wrong offset!");
static_assert(offsetof(UOdyCompassIndicatorWidget, Alignment) == 0x0002F0, "Member 'UOdyCompassIndicatorWidget::Alignment' has a wrong offset!");

// Class OdyMinimap.OdyMinimapActor
// 0x0060 (0x02F0 - 0x0290)
class AOdyMinimapActor : public AActor
{
public:
	struct FDirectoryPath                         OutputFolder;                                      // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOdyMinimapWorldOrientation                   WorldOrientation;                                  // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Brightness;                                        // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 MapSlices;                                         // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               CaptureComponent;                                  // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          CaptureBox;                                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        MapOriginComponent;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             OutputTexture;                                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     OutputTextureSlices;                               // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	bool CaptureMinimap(bool bCheckout);
	class UTexture2D* GetOutputTextureSlice(float WorldHeight);
	void SetupCameraInfo(int32 SliceIndex);
	void SortMapSlices();

	struct FVector2D ConvertWorldExtentToMinimapExtent(const struct FVector& WorldExtent) const;
	struct FVector2D ConvertWorldPositionToMinimapPosition(const struct FVector& WorldPosition) const;
	void EditorOnlySaveOutputTexture() const;
	class UTexture2D* GetOutputTexture() const;
	struct FVector2D GetWorldToMinimapRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyMinimapActor">();
	}
	static class AOdyMinimapActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOdyMinimapActor>();
	}
};
static_assert(alignof(AOdyMinimapActor) == 0x000008, "Wrong alignment on AOdyMinimapActor");
static_assert(sizeof(AOdyMinimapActor) == 0x0002F0, "Wrong size on AOdyMinimapActor");
static_assert(offsetof(AOdyMinimapActor, OutputFolder) == 0x000290, "Member 'AOdyMinimapActor::OutputFolder' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, WorldOrientation) == 0x0002A0, "Member 'AOdyMinimapActor::WorldOrientation' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, Brightness) == 0x0002A4, "Member 'AOdyMinimapActor::Brightness' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, Width) == 0x0002A8, "Member 'AOdyMinimapActor::Width' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, Height) == 0x0002AC, "Member 'AOdyMinimapActor::Height' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, MapSlices) == 0x0002B0, "Member 'AOdyMinimapActor::MapSlices' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, CaptureComponent) == 0x0002C0, "Member 'AOdyMinimapActor::CaptureComponent' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, CaptureBox) == 0x0002C8, "Member 'AOdyMinimapActor::CaptureBox' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, MapOriginComponent) == 0x0002D0, "Member 'AOdyMinimapActor::MapOriginComponent' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, OutputTexture) == 0x0002D8, "Member 'AOdyMinimapActor::OutputTexture' has a wrong offset!");
static_assert(offsetof(AOdyMinimapActor, OutputTextureSlices) == 0x0002E0, "Member 'AOdyMinimapActor::OutputTextureSlices' has a wrong offset!");

// Class OdyMinimap.OdyMinimapIndicated
// 0x0000 (0x0028 - 0x0028)
class IOdyMinimapIndicated final : public IInterface
{
public:
	TSubclassOf<class UOdyCompassIndicatorWidget> GetCompassIndicatorWidgetClass();
	TSubclassOf<class UOdyMinimapIndicatorWidget> GetIndicatorWidgetClass();

	struct FVector GetIndicatorWorldExtent() const;
	struct FVector GetIndicatorWorldPosition() const;
	void SetupIndicatorInstance(class UOdyMinimapIndicatorWidget* IndicatorInstance) const;
	bool ShouldCompassIndicatorBeVisible(class APlayerController* InPlayerController) const;
	bool ShouldIndicatorBeVisible(class APlayerController* InPlayerController) const;
	void TickIndicator(class UOdyMinimapIndicatorWidget* WidgetInstance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyMinimapIndicated">();
	}
	static class IOdyMinimapIndicated* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOdyMinimapIndicated>();
	}
};
static_assert(alignof(IOdyMinimapIndicated) == 0x000008, "Wrong alignment on IOdyMinimapIndicated");
static_assert(sizeof(IOdyMinimapIndicated) == 0x000028, "Wrong size on IOdyMinimapIndicated");

// Class OdyMinimap.OdyMinimapIndicatorWidget
// 0x0030 (0x03C8 - 0x0398)
class UOdyMinimapIndicatorWidget : public UOdyWidget
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IndicatorName;                                     // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Alignment;                                         // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIndicatorUpdateGroup                         UpdateGroup;                                       // 0x03BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BD[0x3];                                      // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UOdyMinimapWidget*                      OwningMinimap;                                     // 0x03C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetIndicatorCompassVisibility();
	ESlateVisibility GetIndicatorVisibility();
	struct FVector GetIndicatorWorldExtent();
	struct FVector GetIndicatorWorldPosition();
	class UOdyMinimapWidget* GetOwningMinimap();
	void SetOwningMinimap(class UOdyMinimapWidget* InOwningMinimap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyMinimapIndicatorWidget">();
	}
	static class UOdyMinimapIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyMinimapIndicatorWidget>();
	}
};
static_assert(alignof(UOdyMinimapIndicatorWidget) == 0x000008, "Wrong alignment on UOdyMinimapIndicatorWidget");
static_assert(sizeof(UOdyMinimapIndicatorWidget) == 0x0003C8, "Wrong size on UOdyMinimapIndicatorWidget");
static_assert(offsetof(UOdyMinimapIndicatorWidget, IndicatorName) == 0x0003A0, "Member 'UOdyMinimapIndicatorWidget::IndicatorName' has a wrong offset!");
static_assert(offsetof(UOdyMinimapIndicatorWidget, Alignment) == 0x0003A8, "Member 'UOdyMinimapIndicatorWidget::Alignment' has a wrong offset!");
static_assert(offsetof(UOdyMinimapIndicatorWidget, ZOrder) == 0x0003B8, "Member 'UOdyMinimapIndicatorWidget::ZOrder' has a wrong offset!");
static_assert(offsetof(UOdyMinimapIndicatorWidget, UpdateGroup) == 0x0003BC, "Member 'UOdyMinimapIndicatorWidget::UpdateGroup' has a wrong offset!");
static_assert(offsetof(UOdyMinimapIndicatorWidget, OwningMinimap) == 0x0003C0, "Member 'UOdyMinimapIndicatorWidget::OwningMinimap' has a wrong offset!");

// Class OdyMinimap.OdyMinimapSubsystem
// 0x0008 (0x0038 - 0x0030)
class UOdyMinimapSubsystem final : public UWorldSubsystem
{
public:
	class AOdyMinimapActor*                       MinimapActor;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FVector2D ConvertWorldExtentToMinimapExtent(const struct FVector& WorldExtent) const;
	struct FVector2D ConvertWorldPositionToMinimapPosition(const struct FVector& WorldPosition) const;
	class AOdyMinimapActor* GetMinimapActor() const;
	float GetMinimapBrightness() const;
	class UTexture2D* GetMinimapTexture() const;
	class UTexture2D* GetMinimapTextureForLocation(const struct FVector& WorldLocation) const;
	struct FVector2D GetWorldToMinimapRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyMinimapSubsystem">();
	}
	static class UOdyMinimapSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyMinimapSubsystem>();
	}
};
static_assert(alignof(UOdyMinimapSubsystem) == 0x000008, "Wrong alignment on UOdyMinimapSubsystem");
static_assert(sizeof(UOdyMinimapSubsystem) == 0x000038, "Wrong size on UOdyMinimapSubsystem");
static_assert(offsetof(UOdyMinimapSubsystem, MinimapActor) == 0x000030, "Member 'UOdyMinimapSubsystem::MinimapActor' has a wrong offset!");

// Class OdyMinimap.OdyMinimapWidget
// 0x00C8 (0x03A8 - 0x02E0)
class UOdyMinimapWidget : public UUserWidget
{
public:
	class USizeBox*                               SizeBox;                                           // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           IndicatorPanel;                                    // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UOdyMinimapIndicatorWidget*> OnTickGroupIndicators;                             // 0x02F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UOdyMinimapIndicatorWidget*> OnStartupGroupIndicators;                          // 0x0340(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         ZoomLevel;                                         // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ZoomCenter;                                        // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddIndicator(class UObject* IndicatedObject);
	void DestroyIndicator(class UObject* IndicatedObject);
	void OnActorDestroyed(class AActor* InActor);
	void OnActorSpawned(class AActor* InActor);
	void SetZoomCenter(const struct FVector2D& Value);
	void SetZoomLevel(const float Value);
	void SetZoomLevelFromWoldMeters(float DesiredMeters);

	struct FVector2D GetZoomCenter() const;
	float GetZoomLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyMinimapWidget">();
	}
	static class UOdyMinimapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyMinimapWidget>();
	}
};
static_assert(alignof(UOdyMinimapWidget) == 0x000008, "Wrong alignment on UOdyMinimapWidget");
static_assert(sizeof(UOdyMinimapWidget) == 0x0003A8, "Wrong size on UOdyMinimapWidget");
static_assert(offsetof(UOdyMinimapWidget, SizeBox) == 0x0002E0, "Member 'UOdyMinimapWidget::SizeBox' has a wrong offset!");
static_assert(offsetof(UOdyMinimapWidget, IndicatorPanel) == 0x0002E8, "Member 'UOdyMinimapWidget::IndicatorPanel' has a wrong offset!");
static_assert(offsetof(UOdyMinimapWidget, OnTickGroupIndicators) == 0x0002F0, "Member 'UOdyMinimapWidget::OnTickGroupIndicators' has a wrong offset!");
static_assert(offsetof(UOdyMinimapWidget, OnStartupGroupIndicators) == 0x000340, "Member 'UOdyMinimapWidget::OnStartupGroupIndicators' has a wrong offset!");
static_assert(offsetof(UOdyMinimapWidget, ZoomLevel) == 0x000390, "Member 'UOdyMinimapWidget::ZoomLevel' has a wrong offset!");
static_assert(offsetof(UOdyMinimapWidget, ZoomCenter) == 0x000398, "Member 'UOdyMinimapWidget::ZoomCenter' has a wrong offset!");

}

