#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ArrayHelper

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function ArrayHelper.ArrayHelperBPLibrary.ArrayAddRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_ArrayAddRef final
{
public:
	TArray<int32>                                 InArrayA;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InItem;                                            // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutResult;                                         // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_ArrayAddRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ArrayAddRef");
static_assert(sizeof(ArrayHelperBPLibrary_ArrayAddRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_ArrayAddRef");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayAddRef, InArrayA) == 0x000000, "Member 'ArrayHelperBPLibrary_ArrayAddRef::InArrayA' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayAddRef, InItem) == 0x000010, "Member 'ArrayHelperBPLibrary_ArrayAddRef::InItem' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayAddRef, OutResult) == 0x000014, "Member 'ArrayHelperBPLibrary_ArrayAddRef::OutResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ArrayDivideRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_ArrayDivideRef final
{
public:
	TArray<int32>                                 InArrayA;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InItem;                                            // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutResult;                                         // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_ArrayDivideRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ArrayDivideRef");
static_assert(sizeof(ArrayHelperBPLibrary_ArrayDivideRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_ArrayDivideRef");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayDivideRef, InArrayA) == 0x000000, "Member 'ArrayHelperBPLibrary_ArrayDivideRef::InArrayA' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayDivideRef, InItem) == 0x000010, "Member 'ArrayHelperBPLibrary_ArrayDivideRef::InItem' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayDivideRef, OutResult) == 0x000014, "Member 'ArrayHelperBPLibrary_ArrayDivideRef::OutResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ArrayMultiplyRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_ArrayMultiplyRef final
{
public:
	TArray<int32>                                 InArrayA;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InItem;                                            // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutResult;                                         // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_ArrayMultiplyRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ArrayMultiplyRef");
static_assert(sizeof(ArrayHelperBPLibrary_ArrayMultiplyRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_ArrayMultiplyRef");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayMultiplyRef, InArrayA) == 0x000000, "Member 'ArrayHelperBPLibrary_ArrayMultiplyRef::InArrayA' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayMultiplyRef, InItem) == 0x000010, "Member 'ArrayHelperBPLibrary_ArrayMultiplyRef::InItem' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ArrayMultiplyRef, OutResult) == 0x000014, "Member 'ArrayHelperBPLibrary_ArrayMultiplyRef::OutResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ArraySubtractRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_ArraySubtractRef final
{
public:
	TArray<int32>                                 InArrayA;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InItem;                                            // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutResult;                                         // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_ArraySubtractRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ArraySubtractRef");
static_assert(sizeof(ArrayHelperBPLibrary_ArraySubtractRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_ArraySubtractRef");
static_assert(offsetof(ArrayHelperBPLibrary_ArraySubtractRef, InArrayA) == 0x000000, "Member 'ArrayHelperBPLibrary_ArraySubtractRef::InArrayA' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ArraySubtractRef, InItem) == 0x000010, "Member 'ArrayHelperBPLibrary_ArraySubtractRef::InItem' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ArraySubtractRef, OutResult) == 0x000014, "Member 'ArrayHelperBPLibrary_ArraySubtractRef::OutResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.AverageByte
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_AverageByte final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_AverageByte) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_AverageByte");
static_assert(sizeof(ArrayHelperBPLibrary_AverageByte) == 0x000018, "Wrong size on ArrayHelperBPLibrary_AverageByte");
static_assert(offsetof(ArrayHelperBPLibrary_AverageByte, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_AverageByte::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_AverageByte, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_AverageByte::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.AverageFloat
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_AverageFloat final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_AverageFloat) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_AverageFloat");
static_assert(sizeof(ArrayHelperBPLibrary_AverageFloat) == 0x000018, "Wrong size on ArrayHelperBPLibrary_AverageFloat");
static_assert(offsetof(ArrayHelperBPLibrary_AverageFloat, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_AverageFloat::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_AverageFloat, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_AverageFloat::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.AverageInteger
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_AverageInteger final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_AverageInteger) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_AverageInteger");
static_assert(sizeof(ArrayHelperBPLibrary_AverageInteger) == 0x000018, "Wrong size on ArrayHelperBPLibrary_AverageInteger");
static_assert(offsetof(ArrayHelperBPLibrary_AverageInteger, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_AverageInteger::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_AverageInteger, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_AverageInteger::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.AverageInteger64
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_AverageInteger64 final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_AverageInteger64) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_AverageInteger64");
static_assert(sizeof(ArrayHelperBPLibrary_AverageInteger64) == 0x000018, "Wrong size on ArrayHelperBPLibrary_AverageInteger64");
static_assert(offsetof(ArrayHelperBPLibrary_AverageInteger64, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_AverageInteger64::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_AverageInteger64, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_AverageInteger64::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.BreakTransformArray
// 0x0040 (0x0040 - 0x0000)
struct ArrayHelperBPLibrary_BreakTransformArray final
{
public:
	TArray<struct FTransform>                     InTransforms;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        OutLocations;                                      // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       OutRotators;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        OutScales;                                         // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_BreakTransformArray) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_BreakTransformArray");
static_assert(sizeof(ArrayHelperBPLibrary_BreakTransformArray) == 0x000040, "Wrong size on ArrayHelperBPLibrary_BreakTransformArray");
static_assert(offsetof(ArrayHelperBPLibrary_BreakTransformArray, InTransforms) == 0x000000, "Member 'ArrayHelperBPLibrary_BreakTransformArray::InTransforms' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_BreakTransformArray, OutLocations) == 0x000010, "Member 'ArrayHelperBPLibrary_BreakTransformArray::OutLocations' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_BreakTransformArray, OutRotators) == 0x000020, "Member 'ArrayHelperBPLibrary_BreakTransformArray::OutRotators' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_BreakTransformArray, OutScales) == 0x000030, "Member 'ArrayHelperBPLibrary_BreakTransformArray::OutScales' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampByte
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_ClampByte final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Min;                                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Max;                                               // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampByte) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampByte");
static_assert(sizeof(ArrayHelperBPLibrary_ClampByte) == 0x000028, "Wrong size on ArrayHelperBPLibrary_ClampByte");
static_assert(offsetof(ArrayHelperBPLibrary_ClampByte, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampByte::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampByte, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampByte::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampByte, Max) == 0x000011, "Member 'ArrayHelperBPLibrary_ClampByte::Max' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampByte, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_ClampByte::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampByteRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_ClampByteRef final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Min;                                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Max;                                               // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_ClampByteRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampByteRef");
static_assert(sizeof(ArrayHelperBPLibrary_ClampByteRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_ClampByteRef");
static_assert(offsetof(ArrayHelperBPLibrary_ClampByteRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampByteRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampByteRef, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampByteRef::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampByteRef, Max) == 0x000011, "Member 'ArrayHelperBPLibrary_ClampByteRef::Max' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampFloat
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_ClampFloat final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampFloat) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampFloat");
static_assert(sizeof(ArrayHelperBPLibrary_ClampFloat) == 0x000028, "Wrong size on ArrayHelperBPLibrary_ClampFloat");
static_assert(offsetof(ArrayHelperBPLibrary_ClampFloat, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampFloat::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampFloat, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampFloat::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampFloat, Max) == 0x000014, "Member 'ArrayHelperBPLibrary_ClampFloat::Max' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampFloat, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_ClampFloat::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampFloatRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_ClampFloatRef final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampFloatRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampFloatRef");
static_assert(sizeof(ArrayHelperBPLibrary_ClampFloatRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_ClampFloatRef");
static_assert(offsetof(ArrayHelperBPLibrary_ClampFloatRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampFloatRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampFloatRef, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampFloatRef::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampFloatRef, Max) == 0x000014, "Member 'ArrayHelperBPLibrary_ClampFloatRef::Max' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampInteger
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_ClampInteger final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampInteger) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampInteger");
static_assert(sizeof(ArrayHelperBPLibrary_ClampInteger) == 0x000028, "Wrong size on ArrayHelperBPLibrary_ClampInteger");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampInteger::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampInteger::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger, Max) == 0x000014, "Member 'ArrayHelperBPLibrary_ClampInteger::Max' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_ClampInteger::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampInteger64
// 0x0030 (0x0030 - 0x0000)
struct ArrayHelperBPLibrary_ClampInteger64 final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         Min;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Max;                                               // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampInteger64) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampInteger64");
static_assert(sizeof(ArrayHelperBPLibrary_ClampInteger64) == 0x000030, "Wrong size on ArrayHelperBPLibrary_ClampInteger64");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger64, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampInteger64::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger64, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampInteger64::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger64, Max) == 0x000018, "Member 'ArrayHelperBPLibrary_ClampInteger64::Max' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger64, ReturnValue) == 0x000020, "Member 'ArrayHelperBPLibrary_ClampInteger64::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampInteger64Ref
// 0x0020 (0x0020 - 0x0000)
struct ArrayHelperBPLibrary_ClampInteger64Ref final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int64                                         Min;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Max;                                               // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampInteger64Ref) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampInteger64Ref");
static_assert(sizeof(ArrayHelperBPLibrary_ClampInteger64Ref) == 0x000020, "Wrong size on ArrayHelperBPLibrary_ClampInteger64Ref");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger64Ref, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampInteger64Ref::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger64Ref, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampInteger64Ref::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampInteger64Ref, Max) == 0x000018, "Member 'ArrayHelperBPLibrary_ClampInteger64Ref::Max' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampIntegerRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_ClampIntegerRef final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampIntegerRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampIntegerRef");
static_assert(sizeof(ArrayHelperBPLibrary_ClampIntegerRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_ClampIntegerRef");
static_assert(offsetof(ArrayHelperBPLibrary_ClampIntegerRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampIntegerRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampIntegerRef, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampIntegerRef::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampIntegerRef, Max) == 0x000014, "Member 'ArrayHelperBPLibrary_ClampIntegerRef::Max' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampVector2DSize
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_ClampVector2DSize final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InMinSize;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMaxSize;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampVector2DSize) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampVector2DSize");
static_assert(sizeof(ArrayHelperBPLibrary_ClampVector2DSize) == 0x000028, "Wrong size on ArrayHelperBPLibrary_ClampVector2DSize");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVector2DSize, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampVector2DSize::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVector2DSize, InMinSize) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampVector2DSize::InMinSize' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVector2DSize, InMaxSize) == 0x000014, "Member 'ArrayHelperBPLibrary_ClampVector2DSize::InMaxSize' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVector2DSize, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_ClampVector2DSize::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampVector2DSizeRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_ClampVector2DSizeRef final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         InMinSize;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMaxSize;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampVector2DSizeRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampVector2DSizeRef");
static_assert(sizeof(ArrayHelperBPLibrary_ClampVector2DSizeRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_ClampVector2DSizeRef");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVector2DSizeRef, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampVector2DSizeRef::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVector2DSizeRef, InMinSize) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampVector2DSizeRef::InMinSize' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVector2DSizeRef, InMaxSize) == 0x000014, "Member 'ArrayHelperBPLibrary_ClampVector2DSizeRef::InMaxSize' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampVectorSize
// 0x0030 (0x0030 - 0x0000)
struct ArrayHelperBPLibrary_ClampVectorSize final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinSize;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSize;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnly2D;                                           // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClampVectorSize) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampVectorSize");
static_assert(sizeof(ArrayHelperBPLibrary_ClampVectorSize) == 0x000030, "Wrong size on ArrayHelperBPLibrary_ClampVectorSize");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSize, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampVectorSize::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSize, MinSize) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampVectorSize::MinSize' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSize, MaxSize) == 0x000014, "Member 'ArrayHelperBPLibrary_ClampVectorSize::MaxSize' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSize, bOnly2D) == 0x000018, "Member 'ArrayHelperBPLibrary_ClampVectorSize::bOnly2D' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSize, ReturnValue) == 0x000020, "Member 'ArrayHelperBPLibrary_ClampVectorSize::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClampVectorSizeRef
// 0x0020 (0x0020 - 0x0000)
struct ArrayHelperBPLibrary_ClampVectorSizeRef final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         MinSize;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSize;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnly2D;                                           // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_ClampVectorSizeRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClampVectorSizeRef");
static_assert(sizeof(ArrayHelperBPLibrary_ClampVectorSizeRef) == 0x000020, "Wrong size on ArrayHelperBPLibrary_ClampVectorSizeRef");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSizeRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClampVectorSizeRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSizeRef, MinSize) == 0x000010, "Member 'ArrayHelperBPLibrary_ClampVectorSizeRef::MinSize' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSizeRef, MaxSize) == 0x000014, "Member 'ArrayHelperBPLibrary_ClampVectorSizeRef::MaxSize' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClampVectorSizeRef, bOnly2D) == 0x000018, "Member 'ArrayHelperBPLibrary_ClampVectorSizeRef::bOnly2D' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClosestActor
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_ClosestActor final
{
public:
	TArray<class AActor*>                         Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	const class AActor*                           Origin;                                            // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Closest;                                           // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClosestActor) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClosestActor");
static_assert(sizeof(ArrayHelperBPLibrary_ClosestActor) == 0x000028, "Wrong size on ArrayHelperBPLibrary_ClosestActor");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestActor, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClosestActor::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestActor, Origin) == 0x000010, "Member 'ArrayHelperBPLibrary_ClosestActor::Origin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestActor, Closest) == 0x000018, "Member 'ArrayHelperBPLibrary_ClosestActor::Closest' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestActor, Distance) == 0x000020, "Member 'ArrayHelperBPLibrary_ClosestActor::Distance' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestActor, Index_0) == 0x000024, "Member 'ArrayHelperBPLibrary_ClosestActor::Index_0' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClosestLocation
// 0x0048 (0x0048 - 0x0000)
struct ArrayHelperBPLibrary_ClosestLocation final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Closest;                                           // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0044(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ClosestLocation) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ClosestLocation");
static_assert(sizeof(ArrayHelperBPLibrary_ClosestLocation) == 0x000048, "Wrong size on ArrayHelperBPLibrary_ClosestLocation");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestLocation, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_ClosestLocation::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestLocation, Origin) == 0x000010, "Member 'ArrayHelperBPLibrary_ClosestLocation::Origin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestLocation, Closest) == 0x000028, "Member 'ArrayHelperBPLibrary_ClosestLocation::Closest' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestLocation, Distance) == 0x000040, "Member 'ArrayHelperBPLibrary_ClosestLocation::Distance' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestLocation, Index_0) == 0x000044, "Member 'ArrayHelperBPLibrary_ClosestLocation::Index_0' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ClosestTransform
// 0x00A0 (0x00A0 - 0x0000)
struct ArrayHelperBPLibrary_ClosestTransform final
{
public:
	TArray<struct FTransform>                     InArray;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                InOrigin;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutClosest;                                        // 0x0030(0x0060)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutDistance;                                       // 0x0090(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutIndex;                                          // 0x0094(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_ClosestTransform) == 0x000010, "Wrong alignment on ArrayHelperBPLibrary_ClosestTransform");
static_assert(sizeof(ArrayHelperBPLibrary_ClosestTransform) == 0x0000A0, "Wrong size on ArrayHelperBPLibrary_ClosestTransform");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestTransform, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_ClosestTransform::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestTransform, InOrigin) == 0x000010, "Member 'ArrayHelperBPLibrary_ClosestTransform::InOrigin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestTransform, OutClosest) == 0x000030, "Member 'ArrayHelperBPLibrary_ClosestTransform::OutClosest' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestTransform, OutDistance) == 0x000090, "Member 'ArrayHelperBPLibrary_ClosestTransform::OutDistance' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ClosestTransform, OutIndex) == 0x000094, "Member 'ArrayHelperBPLibrary_ClosestTransform::OutIndex' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ExtractArray
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_ExtractArray final
{
public:
	TArray<int32>                                 ArrayA;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 ArrayB;                                            // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StartIndex;                                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndIndex;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ExtractArray) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ExtractArray");
static_assert(sizeof(ArrayHelperBPLibrary_ExtractArray) == 0x000028, "Wrong size on ArrayHelperBPLibrary_ExtractArray");
static_assert(offsetof(ArrayHelperBPLibrary_ExtractArray, ArrayA) == 0x000000, "Member 'ArrayHelperBPLibrary_ExtractArray::ArrayA' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ExtractArray, ArrayB) == 0x000010, "Member 'ArrayHelperBPLibrary_ExtractArray::ArrayB' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ExtractArray, StartIndex) == 0x000020, "Member 'ArrayHelperBPLibrary_ExtractArray::StartIndex' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ExtractArray, EndIndex) == 0x000024, "Member 'ArrayHelperBPLibrary_ExtractArray::EndIndex' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.FarthestActor
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_FarthestActor final
{
public:
	TArray<class AActor*>                         Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	const class AActor*                           Origin;                                            // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Farthest;                                          // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_FarthestActor) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_FarthestActor");
static_assert(sizeof(ArrayHelperBPLibrary_FarthestActor) == 0x000028, "Wrong size on ArrayHelperBPLibrary_FarthestActor");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestActor, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_FarthestActor::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestActor, Origin) == 0x000010, "Member 'ArrayHelperBPLibrary_FarthestActor::Origin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestActor, Farthest) == 0x000018, "Member 'ArrayHelperBPLibrary_FarthestActor::Farthest' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestActor, Distance) == 0x000020, "Member 'ArrayHelperBPLibrary_FarthestActor::Distance' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestActor, Index_0) == 0x000024, "Member 'ArrayHelperBPLibrary_FarthestActor::Index_0' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.FarthestLocation
// 0x0048 (0x0048 - 0x0000)
struct ArrayHelperBPLibrary_FarthestLocation final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Farthest;                                          // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0044(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_FarthestLocation) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_FarthestLocation");
static_assert(sizeof(ArrayHelperBPLibrary_FarthestLocation) == 0x000048, "Wrong size on ArrayHelperBPLibrary_FarthestLocation");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestLocation, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_FarthestLocation::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestLocation, Origin) == 0x000010, "Member 'ArrayHelperBPLibrary_FarthestLocation::Origin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestLocation, Farthest) == 0x000028, "Member 'ArrayHelperBPLibrary_FarthestLocation::Farthest' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestLocation, Distance) == 0x000040, "Member 'ArrayHelperBPLibrary_FarthestLocation::Distance' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestLocation, Index_0) == 0x000044, "Member 'ArrayHelperBPLibrary_FarthestLocation::Index_0' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.FarthestTransform
// 0x00A0 (0x00A0 - 0x0000)
struct ArrayHelperBPLibrary_FarthestTransform final
{
public:
	TArray<struct FTransform>                     InArray;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                InOrigin;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutFarthest;                                       // 0x0030(0x0060)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutDistance;                                       // 0x0090(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutIndex;                                          // 0x0094(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_FarthestTransform) == 0x000010, "Wrong alignment on ArrayHelperBPLibrary_FarthestTransform");
static_assert(sizeof(ArrayHelperBPLibrary_FarthestTransform) == 0x0000A0, "Wrong size on ArrayHelperBPLibrary_FarthestTransform");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestTransform, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_FarthestTransform::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestTransform, InOrigin) == 0x000010, "Member 'ArrayHelperBPLibrary_FarthestTransform::InOrigin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestTransform, OutFarthest) == 0x000030, "Member 'ArrayHelperBPLibrary_FarthestTransform::OutFarthest' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestTransform, OutDistance) == 0x000090, "Member 'ArrayHelperBPLibrary_FarthestTransform::OutDistance' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FarthestTransform, OutIndex) == 0x000094, "Member 'ArrayHelperBPLibrary_FarthestTransform::OutIndex' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.FilterMatch
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_FilterMatch final
{
public:
	TArray<class FString>                         Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Pattern;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFound;                                            // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_0;                                           // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_FilterMatch) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_FilterMatch");
static_assert(sizeof(ArrayHelperBPLibrary_FilterMatch) == 0x000038, "Wrong size on ArrayHelperBPLibrary_FilterMatch");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatch, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_FilterMatch::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatch, Pattern) == 0x000010, "Member 'ArrayHelperBPLibrary_FilterMatch::Pattern' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatch, bFound) == 0x000020, "Member 'ArrayHelperBPLibrary_FilterMatch::bFound' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatch, Index_0) == 0x000024, "Member 'ArrayHelperBPLibrary_FilterMatch::Index_0' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatch, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_FilterMatch::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.FilterMatches
// 0x0048 (0x0048 - 0x0000)
struct ArrayHelperBPLibrary_FilterMatches final
{
public:
	TArray<class FString>                         Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Pattern;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFound;                                            // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Indexes;                                           // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_FilterMatches) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_FilterMatches");
static_assert(sizeof(ArrayHelperBPLibrary_FilterMatches) == 0x000048, "Wrong size on ArrayHelperBPLibrary_FilterMatches");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatches, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_FilterMatches::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatches, Pattern) == 0x000010, "Member 'ArrayHelperBPLibrary_FilterMatches::Pattern' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatches, bFound) == 0x000020, "Member 'ArrayHelperBPLibrary_FilterMatches::bFound' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatches, Indexes) == 0x000028, "Member 'ArrayHelperBPLibrary_FilterMatches::Indexes' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_FilterMatches, ReturnValue) == 0x000038, "Member 'ArrayHelperBPLibrary_FilterMatches::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MakeTransformArray
// 0x0048 (0x0048 - 0x0000)
struct ArrayHelperBPLibrary_MakeTransformArray final
{
public:
	TArray<struct FVector>                        InLocations;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       InRotators;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        InScales;                                          // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     OutTransforms;                                     // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MakeTransformArray) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MakeTransformArray");
static_assert(sizeof(ArrayHelperBPLibrary_MakeTransformArray) == 0x000048, "Wrong size on ArrayHelperBPLibrary_MakeTransformArray");
static_assert(offsetof(ArrayHelperBPLibrary_MakeTransformArray, InLocations) == 0x000000, "Member 'ArrayHelperBPLibrary_MakeTransformArray::InLocations' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MakeTransformArray, InRotators) == 0x000010, "Member 'ArrayHelperBPLibrary_MakeTransformArray::InRotators' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MakeTransformArray, InScales) == 0x000020, "Member 'ArrayHelperBPLibrary_MakeTransformArray::InScales' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MakeTransformArray, OutTransforms) == 0x000030, "Member 'ArrayHelperBPLibrary_MakeTransformArray::OutTransforms' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MakeTransformArray, ReturnValue) == 0x000040, "Member 'ArrayHelperBPLibrary_MakeTransformArray::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MaximumByteIndex
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_MaximumByteIndex final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MaximumByteIndex) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MaximumByteIndex");
static_assert(sizeof(ArrayHelperBPLibrary_MaximumByteIndex) == 0x000018, "Wrong size on ArrayHelperBPLibrary_MaximumByteIndex");
static_assert(offsetof(ArrayHelperBPLibrary_MaximumByteIndex, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MaximumByteIndex::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MaximumByteIndex, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_MaximumByteIndex::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MaximumFloatIndex
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_MaximumFloatIndex final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MaximumFloatIndex) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MaximumFloatIndex");
static_assert(sizeof(ArrayHelperBPLibrary_MaximumFloatIndex) == 0x000018, "Wrong size on ArrayHelperBPLibrary_MaximumFloatIndex");
static_assert(offsetof(ArrayHelperBPLibrary_MaximumFloatIndex, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MaximumFloatIndex::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MaximumFloatIndex, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_MaximumFloatIndex::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MaximumInteger64Index
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_MaximumInteger64Index final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MaximumInteger64Index) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MaximumInteger64Index");
static_assert(sizeof(ArrayHelperBPLibrary_MaximumInteger64Index) == 0x000018, "Wrong size on ArrayHelperBPLibrary_MaximumInteger64Index");
static_assert(offsetof(ArrayHelperBPLibrary_MaximumInteger64Index, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MaximumInteger64Index::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MaximumInteger64Index, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_MaximumInteger64Index::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MaximumIntegerIndex
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_MaximumIntegerIndex final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MaximumIntegerIndex) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MaximumIntegerIndex");
static_assert(sizeof(ArrayHelperBPLibrary_MaximumIntegerIndex) == 0x000018, "Wrong size on ArrayHelperBPLibrary_MaximumIntegerIndex");
static_assert(offsetof(ArrayHelperBPLibrary_MaximumIntegerIndex, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MaximumIntegerIndex::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MaximumIntegerIndex, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_MaximumIntegerIndex::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MinimumByteIndex
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_MinimumByteIndex final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MinimumByteIndex) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MinimumByteIndex");
static_assert(sizeof(ArrayHelperBPLibrary_MinimumByteIndex) == 0x000018, "Wrong size on ArrayHelperBPLibrary_MinimumByteIndex");
static_assert(offsetof(ArrayHelperBPLibrary_MinimumByteIndex, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MinimumByteIndex::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinimumByteIndex, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_MinimumByteIndex::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MinimumFloatIndex
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_MinimumFloatIndex final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MinimumFloatIndex) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MinimumFloatIndex");
static_assert(sizeof(ArrayHelperBPLibrary_MinimumFloatIndex) == 0x000018, "Wrong size on ArrayHelperBPLibrary_MinimumFloatIndex");
static_assert(offsetof(ArrayHelperBPLibrary_MinimumFloatIndex, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MinimumFloatIndex::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinimumFloatIndex, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_MinimumFloatIndex::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MinimumInteger64Index
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_MinimumInteger64Index final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MinimumInteger64Index) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MinimumInteger64Index");
static_assert(sizeof(ArrayHelperBPLibrary_MinimumInteger64Index) == 0x000018, "Wrong size on ArrayHelperBPLibrary_MinimumInteger64Index");
static_assert(offsetof(ArrayHelperBPLibrary_MinimumInteger64Index, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MinimumInteger64Index::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinimumInteger64Index, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_MinimumInteger64Index::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MinimumIntegerIndex
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_MinimumIntegerIndex final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_MinimumIntegerIndex) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MinimumIntegerIndex");
static_assert(sizeof(ArrayHelperBPLibrary_MinimumIntegerIndex) == 0x000018, "Wrong size on ArrayHelperBPLibrary_MinimumIntegerIndex");
static_assert(offsetof(ArrayHelperBPLibrary_MinimumIntegerIndex, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MinimumIntegerIndex::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinimumIntegerIndex, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_MinimumIntegerIndex::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MinMaxByteNormalization
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_MinMaxByteNormalization final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Min;                                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Max;                                               // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_MinMaxByteNormalization) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MinMaxByteNormalization");
static_assert(sizeof(ArrayHelperBPLibrary_MinMaxByteNormalization) == 0x000028, "Wrong size on ArrayHelperBPLibrary_MinMaxByteNormalization");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxByteNormalization, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MinMaxByteNormalization::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxByteNormalization, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_MinMaxByteNormalization::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxByteNormalization, Max) == 0x000011, "Member 'ArrayHelperBPLibrary_MinMaxByteNormalization::Max' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxByteNormalization, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_MinMaxByteNormalization::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MinMaxFloatNormalization
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_MinMaxFloatNormalization final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_MinMaxFloatNormalization) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MinMaxFloatNormalization");
static_assert(sizeof(ArrayHelperBPLibrary_MinMaxFloatNormalization) == 0x000028, "Wrong size on ArrayHelperBPLibrary_MinMaxFloatNormalization");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxFloatNormalization, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MinMaxFloatNormalization::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxFloatNormalization, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_MinMaxFloatNormalization::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxFloatNormalization, Max) == 0x000014, "Member 'ArrayHelperBPLibrary_MinMaxFloatNormalization::Max' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxFloatNormalization, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_MinMaxFloatNormalization::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MinMaxInteger64Normalization
// 0x0030 (0x0030 - 0x0000)
struct ArrayHelperBPLibrary_MinMaxInteger64Normalization final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int64                                         Min;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Max;                                               // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_MinMaxInteger64Normalization) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MinMaxInteger64Normalization");
static_assert(sizeof(ArrayHelperBPLibrary_MinMaxInteger64Normalization) == 0x000030, "Wrong size on ArrayHelperBPLibrary_MinMaxInteger64Normalization");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxInteger64Normalization, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MinMaxInteger64Normalization::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxInteger64Normalization, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_MinMaxInteger64Normalization::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxInteger64Normalization, Max) == 0x000018, "Member 'ArrayHelperBPLibrary_MinMaxInteger64Normalization::Max' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxInteger64Normalization, ReturnValue) == 0x000020, "Member 'ArrayHelperBPLibrary_MinMaxInteger64Normalization::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.MinMaxIntegerNormalization
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_MinMaxIntegerNormalization final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_MinMaxIntegerNormalization) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_MinMaxIntegerNormalization");
static_assert(sizeof(ArrayHelperBPLibrary_MinMaxIntegerNormalization) == 0x000028, "Wrong size on ArrayHelperBPLibrary_MinMaxIntegerNormalization");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxIntegerNormalization, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_MinMaxIntegerNormalization::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxIntegerNormalization, Min) == 0x000010, "Member 'ArrayHelperBPLibrary_MinMaxIntegerNormalization::Min' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxIntegerNormalization, Max) == 0x000014, "Member 'ArrayHelperBPLibrary_MinMaxIntegerNormalization::Max' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_MinMaxIntegerNormalization, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_MinMaxIntegerNormalization::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterActor
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterActor final
{
public:
	TArray<class AActor*>                         Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(class AActor* Value, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterActor) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterActor");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterActor) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterActor");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterActor, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterActor::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterActor, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterActor::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterActor, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterActor::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterActor, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterActor::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterByte
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterByte final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(uint8& Value, bool* Result)>   PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterByte) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterByte");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterByte) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterByte");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterByte, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterByte::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterByte, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterByte::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterByte, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterByte::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterByte, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterByte::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterFloat
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterFloat final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(float& Value, bool* Result)>   PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterFloat) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterFloat");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterFloat) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterFloat");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterFloat, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterFloat::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterFloat, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterFloat::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterFloat, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterFloat::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterFloat, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterFloat::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterInteger
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterInteger final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(int32& Value, bool* Result)>   PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterInteger) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterInteger");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterInteger) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterInteger");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterInteger, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterInteger::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterInteger, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterInteger::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterInteger, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterInteger::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterInteger, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterInteger::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterInteger64
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterInteger64 final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(int64& Value, bool* Result)>   PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterInteger64) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterInteger64");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterInteger64) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterInteger64");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterInteger64, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterInteger64::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterInteger64, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterInteger64::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterInteger64, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterInteger64::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterInteger64, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterInteger64::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterName
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterName final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(class FName& Value, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterName) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterName");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterName) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterName");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterName, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterName::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterName, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterName::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterName, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterName::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterName, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterName::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterObject
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterObject final
{
public:
	TArray<class UObject*>                        Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* Value, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterObject) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterObject");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterObject) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterObject");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterObject, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterObject::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterObject, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterObject::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterObject, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterObject::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterObject, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterObject::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterString
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterString final
{
public:
	TArray<class FString>                         Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Value, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterString) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterString");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterString) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterString");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterString, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterString::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterString, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterString::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterString, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterString::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterString, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterString::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterVector
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterVector final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(struct FVector& Value, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterVector) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterVector");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterVector) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterVector");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterVector, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterVector::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterVector, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterVector::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterVector, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterVector::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterVector, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterVector::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateFilterVector2D
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateFilterVector2D final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(struct FVector2D& Value, bool* Result)> InPredicateFunction;                               // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInInvertResult;                                   // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateFilterVector2D) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateFilterVector2D");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateFilterVector2D) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateFilterVector2D");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterVector2D, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateFilterVector2D::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterVector2D, InPredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateFilterVector2D::InPredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterVector2D, bInInvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateFilterVector2D::bInInvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateFilterVector2D, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateFilterVector2D::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortActor
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortActor final
{
public:
	TArray<class AActor*>                         Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(class AActor* A, class AActor* B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortActor) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortActor");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortActor) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortActor");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortActor, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortActor::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortActor, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortActor::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortActor, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortActor::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortActor, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortActor::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortActorRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortActorRef final
{
public:
	TArray<class AActor*>                         Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(class AActor* A, class AActor* B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortActorRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortActorRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortActorRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortActorRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortActorRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortActorRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortActorRef, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortActorRef::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortActorRef, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortActorRef::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortByte
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortByte final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(uint8& A, uint8& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortByte) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortByte");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortByte) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortByte");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortByte, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortByte::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortByte, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortByte::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortByte, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortByte::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortByte, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortByte::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortByteRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortByteRef final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(uint8& A, uint8& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortByteRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortByteRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortByteRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortByteRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortByteRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortByteRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortByteRef, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortByteRef::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortByteRef, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortByteRef::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortFloat
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortFloat final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(float& A, float& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortFloat) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortFloat");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortFloat) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortFloat");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortFloat, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortFloat::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortFloat, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortFloat::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortFloat, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortFloat::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortFloat, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortFloat::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortFloatRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortFloatRef final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(float& A, float& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortFloatRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortFloatRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortFloatRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortFloatRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortFloatRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortFloatRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortFloatRef, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortFloatRef::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortFloatRef, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortFloatRef::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortInteger
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortInteger final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32& A, int32& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortInteger) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortInteger");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortInteger) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortInteger");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortInteger::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortInteger::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortInteger::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortInteger::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortInteger64
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortInteger64 final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(int64& A, int64& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortInteger64) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortInteger64");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortInteger64) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortInteger64");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger64, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortInteger64::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger64, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortInteger64::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger64, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortInteger64::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger64, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortInteger64::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortInteger64Ref
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortInteger64Ref final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(int64& A, int64& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortInteger64Ref) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortInteger64Ref");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortInteger64Ref) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortInteger64Ref");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger64Ref, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortInteger64Ref::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger64Ref, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortInteger64Ref::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortInteger64Ref, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortInteger64Ref::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortIntegerRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortIntegerRef final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(int32& A, int32& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortIntegerRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortIntegerRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortIntegerRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortIntegerRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortIntegerRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortIntegerRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortIntegerRef, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortIntegerRef::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortIntegerRef, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortIntegerRef::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortName
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortName final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(class FName& A, class FName& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortName) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortName");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortName) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortName");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortName, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortName::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortName, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortName::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortName, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortName::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortName, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortName::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortNameRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortNameRef final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(class FName& A, class FName& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortNameRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortNameRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortNameRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortNameRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortNameRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortNameRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortNameRef, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortNameRef::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortNameRef, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortNameRef::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortObject
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortObject final
{
public:
	TArray<class UObject*>                        Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* A, class UObject* B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortObject) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortObject");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortObject) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortObject");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortObject, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortObject::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortObject, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortObject::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortObject, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortObject::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortObject, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortObject::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortObjectRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortObjectRef final
{
public:
	TArray<class UObject*>                        Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* A, class UObject* B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortObjectRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortObjectRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortObjectRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortObjectRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortObjectRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortObjectRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortObjectRef, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortObjectRef::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortObjectRef, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortObjectRef::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortString
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortString final
{
public:
	TArray<class FString>                         Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& A, const class FString& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortString) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortString");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortString) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortString");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortString, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortString::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortString, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortString::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortString, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortString::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortString, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortString::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortStringRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortStringRef final
{
public:
	TArray<class FString>                         Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& A, const class FString& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortStringRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortStringRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortStringRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortStringRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortStringRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortStringRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortStringRef, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortStringRef::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortStringRef, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortStringRef::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortVector
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortVector final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(struct FVector& A, struct FVector& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortVector) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortVector");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortVector) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortVector");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortVector::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortVector::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortVector::InvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortVector::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortVector2D
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortVector2D final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(struct FVector2D& A, struct FVector2D& B, bool* Result)> InPredicateFunction;                               // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInInvertResult;                                   // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortVector2D) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortVector2D");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortVector2D) == 0x000038, "Wrong size on ArrayHelperBPLibrary_PredicateSortVector2D");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector2D, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortVector2D::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector2D, InPredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortVector2D::InPredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector2D, bInInvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortVector2D::bInInvertResult' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector2D, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_PredicateSortVector2D::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortVector2DRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortVector2DRef final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(struct FVector2D& A, struct FVector2D& B, bool* Result)> InPredicateFunction;                               // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInInvertResult;                                   // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortVector2DRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortVector2DRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortVector2DRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortVector2DRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector2DRef, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortVector2DRef::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector2DRef, InPredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortVector2DRef::InPredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVector2DRef, bInInvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortVector2DRef::bInInvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.PredicateSortVectorRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_PredicateSortVectorRef final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(struct FVector& A, struct FVector& B, bool* Result)> PredicateFunction;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertResult;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_PredicateSortVectorRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_PredicateSortVectorRef");
static_assert(sizeof(ArrayHelperBPLibrary_PredicateSortVectorRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_PredicateSortVectorRef");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVectorRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_PredicateSortVectorRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVectorRef, PredicateFunction) == 0x000010, "Member 'ArrayHelperBPLibrary_PredicateSortVectorRef::PredicateFunction' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_PredicateSortVectorRef, InvertResult) == 0x000020, "Member 'ArrayHelperBPLibrary_PredicateSortVectorRef::InvertResult' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.RandomBoolean
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_RandomBoolean final
{
public:
	int32                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_RandomBoolean) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_RandomBoolean");
static_assert(sizeof(ArrayHelperBPLibrary_RandomBoolean) == 0x000018, "Wrong size on ArrayHelperBPLibrary_RandomBoolean");
static_assert(offsetof(ArrayHelperBPLibrary_RandomBoolean, Size) == 0x000000, "Member 'ArrayHelperBPLibrary_RandomBoolean::Size' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomBoolean, ReturnValue) == 0x000008, "Member 'ArrayHelperBPLibrary_RandomBoolean::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.RandomByte
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_RandomByte final
{
public:
	int32                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinValue;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxValue;                                          // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_RandomByte) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_RandomByte");
static_assert(sizeof(ArrayHelperBPLibrary_RandomByte) == 0x000018, "Wrong size on ArrayHelperBPLibrary_RandomByte");
static_assert(offsetof(ArrayHelperBPLibrary_RandomByte, Size) == 0x000000, "Member 'ArrayHelperBPLibrary_RandomByte::Size' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomByte, MinValue) == 0x000004, "Member 'ArrayHelperBPLibrary_RandomByte::MinValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomByte, MaxValue) == 0x000005, "Member 'ArrayHelperBPLibrary_RandomByte::MaxValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomByte, ReturnValue) == 0x000008, "Member 'ArrayHelperBPLibrary_RandomByte::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.RandomFloat
// 0x0020 (0x0020 - 0x0000)
struct ArrayHelperBPLibrary_RandomFloat final
{
public:
	int32                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_RandomFloat) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_RandomFloat");
static_assert(sizeof(ArrayHelperBPLibrary_RandomFloat) == 0x000020, "Wrong size on ArrayHelperBPLibrary_RandomFloat");
static_assert(offsetof(ArrayHelperBPLibrary_RandomFloat, Size) == 0x000000, "Member 'ArrayHelperBPLibrary_RandomFloat::Size' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomFloat, MinValue) == 0x000004, "Member 'ArrayHelperBPLibrary_RandomFloat::MinValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomFloat, MaxValue) == 0x000008, "Member 'ArrayHelperBPLibrary_RandomFloat::MaxValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomFloat, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_RandomFloat::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.RandomInteger
// 0x0020 (0x0020 - 0x0000)
struct ArrayHelperBPLibrary_RandomInteger final
{
public:
	int32                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValue;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_RandomInteger) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_RandomInteger");
static_assert(sizeof(ArrayHelperBPLibrary_RandomInteger) == 0x000020, "Wrong size on ArrayHelperBPLibrary_RandomInteger");
static_assert(offsetof(ArrayHelperBPLibrary_RandomInteger, Size) == 0x000000, "Member 'ArrayHelperBPLibrary_RandomInteger::Size' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomInteger, MinValue) == 0x000004, "Member 'ArrayHelperBPLibrary_RandomInteger::MinValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomInteger, MaxValue) == 0x000008, "Member 'ArrayHelperBPLibrary_RandomInteger::MaxValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomInteger, ReturnValue) == 0x000010, "Member 'ArrayHelperBPLibrary_RandomInteger::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.RandomInteger64
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_RandomInteger64 final
{
public:
	int32                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MinValue;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MaxValue;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_RandomInteger64) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_RandomInteger64");
static_assert(sizeof(ArrayHelperBPLibrary_RandomInteger64) == 0x000028, "Wrong size on ArrayHelperBPLibrary_RandomInteger64");
static_assert(offsetof(ArrayHelperBPLibrary_RandomInteger64, Size) == 0x000000, "Member 'ArrayHelperBPLibrary_RandomInteger64::Size' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomInteger64, MinValue) == 0x000008, "Member 'ArrayHelperBPLibrary_RandomInteger64::MinValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomInteger64, MaxValue) == 0x000010, "Member 'ArrayHelperBPLibrary_RandomInteger64::MaxValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomInteger64, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_RandomInteger64::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.RandomItem
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_RandomItem final
{
public:
	TArray<int32>                                 ArrayA;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 Weights;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Item;                                              // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_RandomItem) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_RandomItem");
static_assert(sizeof(ArrayHelperBPLibrary_RandomItem) == 0x000028, "Wrong size on ArrayHelperBPLibrary_RandomItem");
static_assert(offsetof(ArrayHelperBPLibrary_RandomItem, ArrayA) == 0x000000, "Member 'ArrayHelperBPLibrary_RandomItem::ArrayA' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomItem, Weights) == 0x000010, "Member 'ArrayHelperBPLibrary_RandomItem::Weights' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomItem, Item) == 0x000020, "Member 'ArrayHelperBPLibrary_RandomItem::Item' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomItem, Index_0) == 0x000024, "Member 'ArrayHelperBPLibrary_RandomItem::Index_0' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.RandomVector
// 0x0048 (0x0048 - 0x0000)
struct ArrayHelperBPLibrary_RandomVector final
{
public:
	int32                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinValue;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxValue;                                          // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_RandomVector) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_RandomVector");
static_assert(sizeof(ArrayHelperBPLibrary_RandomVector) == 0x000048, "Wrong size on ArrayHelperBPLibrary_RandomVector");
static_assert(offsetof(ArrayHelperBPLibrary_RandomVector, Size) == 0x000000, "Member 'ArrayHelperBPLibrary_RandomVector::Size' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomVector, MinValue) == 0x000008, "Member 'ArrayHelperBPLibrary_RandomVector::MinValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomVector, MaxValue) == 0x000020, "Member 'ArrayHelperBPLibrary_RandomVector::MaxValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomVector, ReturnValue) == 0x000038, "Member 'ArrayHelperBPLibrary_RandomVector::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.RandomVector2D
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_RandomVector2D final
{
public:
	int32                                         InSize;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              InMinValue;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InMaxValue;                                        // 0x0018(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_RandomVector2D) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_RandomVector2D");
static_assert(sizeof(ArrayHelperBPLibrary_RandomVector2D) == 0x000038, "Wrong size on ArrayHelperBPLibrary_RandomVector2D");
static_assert(offsetof(ArrayHelperBPLibrary_RandomVector2D, InSize) == 0x000000, "Member 'ArrayHelperBPLibrary_RandomVector2D::InSize' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomVector2D, InMinValue) == 0x000008, "Member 'ArrayHelperBPLibrary_RandomVector2D::InMinValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomVector2D, InMaxValue) == 0x000018, "Member 'ArrayHelperBPLibrary_RandomVector2D::InMaxValue' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_RandomVector2D, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_RandomVector2D::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ReverseArray
// 0x0020 (0x0020 - 0x0000)
struct ArrayHelperBPLibrary_ReverseArray final
{
public:
	TArray<int32>                                 ArrayA;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 ArrayB;                                            // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ReverseArray) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ReverseArray");
static_assert(sizeof(ArrayHelperBPLibrary_ReverseArray) == 0x000020, "Wrong size on ArrayHelperBPLibrary_ReverseArray");
static_assert(offsetof(ArrayHelperBPLibrary_ReverseArray, ArrayA) == 0x000000, "Member 'ArrayHelperBPLibrary_ReverseArray::ArrayA' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ReverseArray, ArrayB) == 0x000010, "Member 'ArrayHelperBPLibrary_ReverseArray::ArrayB' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortActor
// 0x0030 (0x0030 - 0x0000)
struct ArrayHelperBPLibrary_SortActor final
{
public:
	TArray<class AActor*>                         Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	const class AActor*                           Actor;                                             // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortActor) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortActor");
static_assert(sizeof(ArrayHelperBPLibrary_SortActor) == 0x000030, "Wrong size on ArrayHelperBPLibrary_SortActor");
static_assert(offsetof(ArrayHelperBPLibrary_SortActor, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortActor::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortActor, Actor) == 0x000010, "Member 'ArrayHelperBPLibrary_SortActor::Actor' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortActor, bIsAscending) == 0x000018, "Member 'ArrayHelperBPLibrary_SortActor::bIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortActor, ReturnValue) == 0x000020, "Member 'ArrayHelperBPLibrary_SortActor::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortActorRef
// 0x0020 (0x0020 - 0x0000)
struct ArrayHelperBPLibrary_SortActorRef final
{
public:
	TArray<class AActor*>                         Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	const class AActor*                           Actor;                                             // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortActorRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortActorRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortActorRef) == 0x000020, "Wrong size on ArrayHelperBPLibrary_SortActorRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortActorRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortActorRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortActorRef, Actor) == 0x000010, "Member 'ArrayHelperBPLibrary_SortActorRef::Actor' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortActorRef, bIsAscending) == 0x000018, "Member 'ArrayHelperBPLibrary_SortActorRef::bIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortByte
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_SortByte final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortByte) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortByte");
static_assert(sizeof(ArrayHelperBPLibrary_SortByte) == 0x000028, "Wrong size on ArrayHelperBPLibrary_SortByte");
static_assert(offsetof(ArrayHelperBPLibrary_SortByte, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortByte::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortByte, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortByte::bIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortByte, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_SortByte::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortByteRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_SortByteRef final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortByteRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortByteRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortByteRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_SortByteRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortByteRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortByteRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortByteRef, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortByteRef::bIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortFloat
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_SortFloat final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortFloat) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortFloat");
static_assert(sizeof(ArrayHelperBPLibrary_SortFloat) == 0x000028, "Wrong size on ArrayHelperBPLibrary_SortFloat");
static_assert(offsetof(ArrayHelperBPLibrary_SortFloat, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortFloat::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortFloat, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortFloat::bIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortFloat, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_SortFloat::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortFloatRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_SortFloatRef final
{
public:
	TArray<float>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortFloatRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortFloatRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortFloatRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_SortFloatRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortFloatRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortFloatRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortFloatRef, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortFloatRef::bIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortInteger
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_SortInteger final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortInteger) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortInteger");
static_assert(sizeof(ArrayHelperBPLibrary_SortInteger) == 0x000028, "Wrong size on ArrayHelperBPLibrary_SortInteger");
static_assert(offsetof(ArrayHelperBPLibrary_SortInteger, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortInteger::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortInteger, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortInteger::bIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortInteger, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_SortInteger::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortInteger64
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_SortInteger64 final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortInteger64) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortInteger64");
static_assert(sizeof(ArrayHelperBPLibrary_SortInteger64) == 0x000028, "Wrong size on ArrayHelperBPLibrary_SortInteger64");
static_assert(offsetof(ArrayHelperBPLibrary_SortInteger64, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortInteger64::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortInteger64, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortInteger64::bIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortInteger64, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_SortInteger64::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortInteger64Ref
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_SortInteger64Ref final
{
public:
	TArray<int64>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortInteger64Ref) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortInteger64Ref");
static_assert(sizeof(ArrayHelperBPLibrary_SortInteger64Ref) == 0x000018, "Wrong size on ArrayHelperBPLibrary_SortInteger64Ref");
static_assert(offsetof(ArrayHelperBPLibrary_SortInteger64Ref, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortInteger64Ref::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortInteger64Ref, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortInteger64Ref::bIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortIntegerRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_SortIntegerRef final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortIntegerRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortIntegerRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortIntegerRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_SortIntegerRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortIntegerRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortIntegerRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortIntegerRef, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortIntegerRef::bIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortName
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_SortName final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortName) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortName");
static_assert(sizeof(ArrayHelperBPLibrary_SortName) == 0x000028, "Wrong size on ArrayHelperBPLibrary_SortName");
static_assert(offsetof(ArrayHelperBPLibrary_SortName, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortName::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortName, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortName::bIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortName, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_SortName::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortNameRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_SortNameRef final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortNameRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortNameRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortNameRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_SortNameRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortNameRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortNameRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortNameRef, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortNameRef::bIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortString
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_SortString final
{
public:
	TArray<class FString>                         Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortString) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortString");
static_assert(sizeof(ArrayHelperBPLibrary_SortString) == 0x000028, "Wrong size on ArrayHelperBPLibrary_SortString");
static_assert(offsetof(ArrayHelperBPLibrary_SortString, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortString::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortString, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortString::bIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortString, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_SortString::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortStringRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_SortStringRef final
{
public:
	TArray<class FString>                         Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortStringRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortStringRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortStringRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_SortStringRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortStringRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortStringRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortStringRef, bIsAscending) == 0x000010, "Member 'ArrayHelperBPLibrary_SortStringRef::bIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortVector
// 0x0040 (0x0040 - 0x0000)
struct ArrayHelperBPLibrary_SortVector final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortVector) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortVector");
static_assert(sizeof(ArrayHelperBPLibrary_SortVector) == 0x000040, "Wrong size on ArrayHelperBPLibrary_SortVector");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortVector::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector, Origin) == 0x000010, "Member 'ArrayHelperBPLibrary_SortVector::Origin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector, bIsAscending) == 0x000028, "Member 'ArrayHelperBPLibrary_SortVector::bIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector, ReturnValue) == 0x000030, "Member 'ArrayHelperBPLibrary_SortVector::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortVector2D
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_SortVector2D final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              InOrigin;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIsAscending;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortVector2D) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortVector2D");
static_assert(sizeof(ArrayHelperBPLibrary_SortVector2D) == 0x000038, "Wrong size on ArrayHelperBPLibrary_SortVector2D");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector2D, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_SortVector2D::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector2D, InOrigin) == 0x000010, "Member 'ArrayHelperBPLibrary_SortVector2D::InOrigin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector2D, bInIsAscending) == 0x000020, "Member 'ArrayHelperBPLibrary_SortVector2D::bInIsAscending' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector2D, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_SortVector2D::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortVector2DRef
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_SortVector2DRef final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              InOrigin;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIsAscending;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortVector2DRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortVector2DRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortVector2DRef) == 0x000028, "Wrong size on ArrayHelperBPLibrary_SortVector2DRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector2DRef, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_SortVector2DRef::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector2DRef, InOrigin) == 0x000010, "Member 'ArrayHelperBPLibrary_SortVector2DRef::InOrigin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVector2DRef, bInIsAscending) == 0x000020, "Member 'ArrayHelperBPLibrary_SortVector2DRef::bInIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortVectorRef
// 0x0030 (0x0030 - 0x0000)
struct ArrayHelperBPLibrary_SortVectorRef final
{
public:
	TArray<struct FVector>                        Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAscending;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortVectorRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortVectorRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortVectorRef) == 0x000030, "Wrong size on ArrayHelperBPLibrary_SortVectorRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortVectorRef, Array) == 0x000000, "Member 'ArrayHelperBPLibrary_SortVectorRef::Array' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVectorRef, Origin) == 0x000010, "Member 'ArrayHelperBPLibrary_SortVectorRef::Origin' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVectorRef, bIsAscending) == 0x000028, "Member 'ArrayHelperBPLibrary_SortVectorRef::bIsAscending' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortVertices
// 0x0028 (0x0028 - 0x0000)
struct ArrayHelperBPLibrary_SortVertices final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInCounterClockWise;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SortVertices) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortVertices");
static_assert(sizeof(ArrayHelperBPLibrary_SortVertices) == 0x000028, "Wrong size on ArrayHelperBPLibrary_SortVertices");
static_assert(offsetof(ArrayHelperBPLibrary_SortVertices, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_SortVertices::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVertices, bInCounterClockWise) == 0x000010, "Member 'ArrayHelperBPLibrary_SortVertices::bInCounterClockWise' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVertices, ReturnValue) == 0x000018, "Member 'ArrayHelperBPLibrary_SortVertices::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SortVerticesRef
// 0x0018 (0x0018 - 0x0000)
struct ArrayHelperBPLibrary_SortVerticesRef final
{
public:
	TArray<struct FVector2D>                      InArray;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInCounterClockWise;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArrayHelperBPLibrary_SortVerticesRef) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SortVerticesRef");
static_assert(sizeof(ArrayHelperBPLibrary_SortVerticesRef) == 0x000018, "Wrong size on ArrayHelperBPLibrary_SortVerticesRef");
static_assert(offsetof(ArrayHelperBPLibrary_SortVerticesRef, InArray) == 0x000000, "Member 'ArrayHelperBPLibrary_SortVerticesRef::InArray' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SortVerticesRef, bInCounterClockWise) == 0x000010, "Member 'ArrayHelperBPLibrary_SortVerticesRef::bInCounterClockWise' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.SplitString
// 0x0038 (0x0038 - 0x0000)
struct ArrayHelperBPLibrary_SplitString final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Separator;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveEmptyString;                                 // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_SplitString) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_SplitString");
static_assert(sizeof(ArrayHelperBPLibrary_SplitString) == 0x000038, "Wrong size on ArrayHelperBPLibrary_SplitString");
static_assert(offsetof(ArrayHelperBPLibrary_SplitString, String) == 0x000000, "Member 'ArrayHelperBPLibrary_SplitString::String' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SplitString, Separator) == 0x000010, "Member 'ArrayHelperBPLibrary_SplitString::Separator' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SplitString, SearchCase) == 0x000020, "Member 'ArrayHelperBPLibrary_SplitString::SearchCase' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SplitString, RemoveEmptyString) == 0x000021, "Member 'ArrayHelperBPLibrary_SplitString::RemoveEmptyString' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_SplitString, ReturnValue) == 0x000028, "Member 'ArrayHelperBPLibrary_SplitString::ReturnValue' has a wrong offset!");

// Function ArrayHelper.ArrayHelperBPLibrary.ToSet
// 0x0060 (0x0060 - 0x0000)
struct ArrayHelperBPLibrary_ToSet final
{
public:
	TArray<int32>                                 ArrayA;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSet<int32>                                   ArrayB;                                            // 0x0010(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrayHelperBPLibrary_ToSet) == 0x000008, "Wrong alignment on ArrayHelperBPLibrary_ToSet");
static_assert(sizeof(ArrayHelperBPLibrary_ToSet) == 0x000060, "Wrong size on ArrayHelperBPLibrary_ToSet");
static_assert(offsetof(ArrayHelperBPLibrary_ToSet, ArrayA) == 0x000000, "Member 'ArrayHelperBPLibrary_ToSet::ArrayA' has a wrong offset!");
static_assert(offsetof(ArrayHelperBPLibrary_ToSet, ArrayB) == 0x000010, "Member 'ArrayHelperBPLibrary_ToSet::ArrayB' has a wrong offset!");

}

