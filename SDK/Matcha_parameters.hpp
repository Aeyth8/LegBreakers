#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Matcha

#include "Basic.hpp"

#include "Matcha_structs.hpp"
#include "OdyUI_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "OdyServices_structs.hpp"
#include "SnapNet_structs.hpp"


namespace SDK::Params
{

// Function Matcha.LegacyMatchaServicesConfiguration.GetWebSocketUrlClient
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaServicesConfiguration_GetWebSocketUrlClient final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaServicesConfiguration_GetWebSocketUrlClient) == 0x000008, "Wrong alignment on LegacyMatchaServicesConfiguration_GetWebSocketUrlClient");
static_assert(sizeof(LegacyMatchaServicesConfiguration_GetWebSocketUrlClient) == 0x000010, "Wrong size on LegacyMatchaServicesConfiguration_GetWebSocketUrlClient");
static_assert(offsetof(LegacyMatchaServicesConfiguration_GetWebSocketUrlClient, ReturnValue) == 0x000000, "Member 'LegacyMatchaServicesConfiguration_GetWebSocketUrlClient::ReturnValue' has a wrong offset!");

// Function Matcha.LegacyMatchaServicesConfiguration.GetWebSocketUrlServer
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaServicesConfiguration_GetWebSocketUrlServer final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaServicesConfiguration_GetWebSocketUrlServer) == 0x000008, "Wrong alignment on LegacyMatchaServicesConfiguration_GetWebSocketUrlServer");
static_assert(sizeof(LegacyMatchaServicesConfiguration_GetWebSocketUrlServer) == 0x000010, "Wrong size on LegacyMatchaServicesConfiguration_GetWebSocketUrlServer");
static_assert(offsetof(LegacyMatchaServicesConfiguration_GetWebSocketUrlServer, ReturnValue) == 0x000000, "Member 'LegacyMatchaServicesConfiguration_GetWebSocketUrlServer::ReturnValue' has a wrong offset!");

// Function Matcha.LegacyMatchaServicesConfiguration.GetWebSocketUrlServices
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaServicesConfiguration_GetWebSocketUrlServices final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaServicesConfiguration_GetWebSocketUrlServices) == 0x000008, "Wrong alignment on LegacyMatchaServicesConfiguration_GetWebSocketUrlServices");
static_assert(sizeof(LegacyMatchaServicesConfiguration_GetWebSocketUrlServices) == 0x000010, "Wrong size on LegacyMatchaServicesConfiguration_GetWebSocketUrlServices");
static_assert(offsetof(LegacyMatchaServicesConfiguration_GetWebSocketUrlServices, ReturnValue) == 0x000000, "Member 'LegacyMatchaServicesConfiguration_GetWebSocketUrlServices::ReturnValue' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.Get
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaQueueServices_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULegacyMatchaQueueServices*             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_Get) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_Get");
static_assert(sizeof(LegacyMatchaQueueServices_Get) == 0x000010, "Wrong size on LegacyMatchaQueueServices_Get");
static_assert(offsetof(LegacyMatchaQueueServices_Get, WorldContextObject) == 0x000000, "Member 'LegacyMatchaQueueServices_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LegacyMatchaQueueServices_Get, ReturnValue) == 0x000008, "Member 'LegacyMatchaQueueServices_Get::ReturnValue' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.GetServicesConfiguration
// 0x0008 (0x0008 - 0x0000)
struct LegacyMatchaQueueServices_GetServicesConfiguration final
{
public:
	const class ULegacyMatchaServicesConfiguration* ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_GetServicesConfiguration) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_GetServicesConfiguration");
static_assert(sizeof(LegacyMatchaQueueServices_GetServicesConfiguration) == 0x000008, "Wrong size on LegacyMatchaQueueServices_GetServicesConfiguration");
static_assert(offsetof(LegacyMatchaQueueServices_GetServicesConfiguration, ReturnValue) == 0x000000, "Member 'LegacyMatchaQueueServices_GetServicesConfiguration::ReturnValue' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.AcceptInvite
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaQueueServices_AcceptInvite final
{
public:
	class FString                                 Target;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_AcceptInvite) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_AcceptInvite");
static_assert(sizeof(LegacyMatchaQueueServices_AcceptInvite) == 0x000010, "Wrong size on LegacyMatchaQueueServices_AcceptInvite");
static_assert(offsetof(LegacyMatchaQueueServices_AcceptInvite, Target) == 0x000000, "Member 'LegacyMatchaQueueServices_AcceptInvite::Target' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.CancelInvite
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaQueueServices_CancelInvite final
{
public:
	class FString                                 Target;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_CancelInvite) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_CancelInvite");
static_assert(sizeof(LegacyMatchaQueueServices_CancelInvite) == 0x000010, "Wrong size on LegacyMatchaQueueServices_CancelInvite");
static_assert(offsetof(LegacyMatchaQueueServices_CancelInvite, Target) == 0x000000, "Member 'LegacyMatchaQueueServices_CancelInvite::Target' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.RejectInvite
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaQueueServices_RejectInvite final
{
public:
	class FString                                 Target;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_RejectInvite) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_RejectInvite");
static_assert(sizeof(LegacyMatchaQueueServices_RejectInvite) == 0x000010, "Wrong size on LegacyMatchaQueueServices_RejectInvite");
static_assert(offsetof(LegacyMatchaQueueServices_RejectInvite, Target) == 0x000000, "Member 'LegacyMatchaQueueServices_RejectInvite::Target' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.SendInvite
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaQueueServices_SendInvite final
{
public:
	class FString                                 Target;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_SendInvite) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_SendInvite");
static_assert(sizeof(LegacyMatchaQueueServices_SendInvite) == 0x000010, "Wrong size on LegacyMatchaQueueServices_SendInvite");
static_assert(offsetof(LegacyMatchaQueueServices_SendInvite, Target) == 0x000000, "Member 'LegacyMatchaQueueServices_SendInvite::Target' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.SetConnectedPlayerIds
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaQueueServices_SetConnectedPlayerIds final
{
public:
	TArray<class FName>                           PlayerIds;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_SetConnectedPlayerIds) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_SetConnectedPlayerIds");
static_assert(sizeof(LegacyMatchaQueueServices_SetConnectedPlayerIds) == 0x000010, "Wrong size on LegacyMatchaQueueServices_SetConnectedPlayerIds");
static_assert(offsetof(LegacyMatchaQueueServices_SetConnectedPlayerIds, PlayerIds) == 0x000000, "Member 'LegacyMatchaQueueServices_SetConnectedPlayerIds::PlayerIds' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.SetIdentification
// 0x0028 (0x0028 - 0x0000)
struct LegacyMatchaQueueServices_SetIdentification final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMatchServer;                                     // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LegacyMatchaQueueServices_SetIdentification) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_SetIdentification");
static_assert(sizeof(LegacyMatchaQueueServices_SetIdentification) == 0x000028, "Wrong size on LegacyMatchaQueueServices_SetIdentification");
static_assert(offsetof(LegacyMatchaQueueServices_SetIdentification, Name_0) == 0x000000, "Member 'LegacyMatchaQueueServices_SetIdentification::Name_0' has a wrong offset!");
static_assert(offsetof(LegacyMatchaQueueServices_SetIdentification, URL) == 0x000010, "Member 'LegacyMatchaQueueServices_SetIdentification::URL' has a wrong offset!");
static_assert(offsetof(LegacyMatchaQueueServices_SetIdentification, IsMatchServer) == 0x000020, "Member 'LegacyMatchaQueueServices_SetIdentification::IsMatchServer' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.SetMatchPhase
// 0x0001 (0x0001 - 0x0000)
struct LegacyMatchaQueueServices_SetMatchPhase final
{
public:
	EMatchaMatchPhase                             MatchPhase;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_SetMatchPhase) == 0x000001, "Wrong alignment on LegacyMatchaQueueServices_SetMatchPhase");
static_assert(sizeof(LegacyMatchaQueueServices_SetMatchPhase) == 0x000001, "Wrong size on LegacyMatchaQueueServices_SetMatchPhase");
static_assert(offsetof(LegacyMatchaQueueServices_SetMatchPhase, MatchPhase) == 0x000000, "Member 'LegacyMatchaQueueServices_SetMatchPhase::MatchPhase' has a wrong offset!");

// Function Matcha.LegacyMatchaQueueServices.SetName
// 0x0010 (0x0010 - 0x0000)
struct LegacyMatchaQueueServices_SetName final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegacyMatchaQueueServices_SetName) == 0x000008, "Wrong alignment on LegacyMatchaQueueServices_SetName");
static_assert(sizeof(LegacyMatchaQueueServices_SetName) == 0x000010, "Wrong size on LegacyMatchaQueueServices_SetName");
static_assert(offsetof(LegacyMatchaQueueServices_SetName, Name_0) == 0x000000, "Member 'LegacyMatchaQueueServices_SetName::Name_0' has a wrong offset!");

// Function Matcha.MatchaAICharacterEntity.Get
// 0x0018 (0x0018 - 0x0000)
struct MatchaAICharacterEntity_Get final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          WorldContextObject;                                // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaAICharacterEntity*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAICharacterEntity_Get) == 0x000008, "Wrong alignment on MatchaAICharacterEntity_Get");
static_assert(sizeof(MatchaAICharacterEntity_Get) == 0x000018, "Wrong size on MatchaAICharacterEntity_Get");
static_assert(offsetof(MatchaAICharacterEntity_Get, PlayerIndex) == 0x000000, "Member 'MatchaAICharacterEntity_Get::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaAICharacterEntity_Get, WorldContextObject) == 0x000008, "Member 'MatchaAICharacterEntity_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaAICharacterEntity_Get, ReturnValue) == 0x000010, "Member 'MatchaAICharacterEntity_Get::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaAICharacterEntity.GetFromSimulation
// 0x0018 (0x0018 - 0x0000)
struct MatchaAICharacterEntity_GetFromSimulation final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class USnapNetSimulation*               SnapNetSimulation;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaAICharacterEntity*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAICharacterEntity_GetFromSimulation) == 0x000008, "Wrong alignment on MatchaAICharacterEntity_GetFromSimulation");
static_assert(sizeof(MatchaAICharacterEntity_GetFromSimulation) == 0x000018, "Wrong size on MatchaAICharacterEntity_GetFromSimulation");
static_assert(offsetof(MatchaAICharacterEntity_GetFromSimulation, PlayerIndex) == 0x000000, "Member 'MatchaAICharacterEntity_GetFromSimulation::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaAICharacterEntity_GetFromSimulation, SnapNetSimulation) == 0x000008, "Member 'MatchaAICharacterEntity_GetFromSimulation::SnapNetSimulation' has a wrong offset!");
static_assert(offsetof(MatchaAICharacterEntity_GetFromSimulation, ReturnValue) == 0x000010, "Member 'MatchaAICharacterEntity_GetFromSimulation::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaAICharacterEntity.CharacterTeleport
// 0x0038 (0x0038 - 0x0000)
struct MatchaAICharacterEntity_CharacterTeleport final
{
public:
	struct FVector                                DestinationLocation;                               // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DestinationRotation;                               // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsATest;                                          // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCheck;                                          // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0032(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaAICharacterEntity_CharacterTeleport) == 0x000008, "Wrong alignment on MatchaAICharacterEntity_CharacterTeleport");
static_assert(sizeof(MatchaAICharacterEntity_CharacterTeleport) == 0x000038, "Wrong size on MatchaAICharacterEntity_CharacterTeleport");
static_assert(offsetof(MatchaAICharacterEntity_CharacterTeleport, DestinationLocation) == 0x000000, "Member 'MatchaAICharacterEntity_CharacterTeleport::DestinationLocation' has a wrong offset!");
static_assert(offsetof(MatchaAICharacterEntity_CharacterTeleport, DestinationRotation) == 0x000018, "Member 'MatchaAICharacterEntity_CharacterTeleport::DestinationRotation' has a wrong offset!");
static_assert(offsetof(MatchaAICharacterEntity_CharacterTeleport, bIsATest) == 0x000030, "Member 'MatchaAICharacterEntity_CharacterTeleport::bIsATest' has a wrong offset!");
static_assert(offsetof(MatchaAICharacterEntity_CharacterTeleport, bNoCheck) == 0x000031, "Member 'MatchaAICharacterEntity_CharacterTeleport::bNoCheck' has a wrong offset!");
static_assert(offsetof(MatchaAICharacterEntity_CharacterTeleport, ReturnValue) == 0x000032, "Member 'MatchaAICharacterEntity_CharacterTeleport::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaAICharacterEntity.PlayAnimationAtIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaAICharacterEntity_PlayAnimationAtIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAICharacterEntity_PlayAnimationAtIndex) == 0x000004, "Wrong alignment on MatchaAICharacterEntity_PlayAnimationAtIndex");
static_assert(sizeof(MatchaAICharacterEntity_PlayAnimationAtIndex) == 0x000004, "Wrong size on MatchaAICharacterEntity_PlayAnimationAtIndex");
static_assert(offsetof(MatchaAICharacterEntity_PlayAnimationAtIndex, Index_0) == 0x000000, "Member 'MatchaAICharacterEntity_PlayAnimationAtIndex::Index_0' has a wrong offset!");

// Function Matcha.MatchaAICharacterEntity.SetInvulnerable
// 0x0001 (0x0001 - 0x0000)
struct MatchaAICharacterEntity_SetInvulnerable final
{
public:
	bool                                          bShouldBeInvulnerable;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAICharacterEntity_SetInvulnerable) == 0x000001, "Wrong alignment on MatchaAICharacterEntity_SetInvulnerable");
static_assert(sizeof(MatchaAICharacterEntity_SetInvulnerable) == 0x000001, "Wrong size on MatchaAICharacterEntity_SetInvulnerable");
static_assert(offsetof(MatchaAICharacterEntity_SetInvulnerable, bShouldBeInvulnerable) == 0x000000, "Member 'MatchaAICharacterEntity_SetInvulnerable::bShouldBeInvulnerable' has a wrong offset!");

// Function Matcha.MatchaAICharacterEntity.GetAggroDistance
// 0x0004 (0x0004 - 0x0000)
struct MatchaAICharacterEntity_GetAggroDistance final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAICharacterEntity_GetAggroDistance) == 0x000004, "Wrong alignment on MatchaAICharacterEntity_GetAggroDistance");
static_assert(sizeof(MatchaAICharacterEntity_GetAggroDistance) == 0x000004, "Wrong size on MatchaAICharacterEntity_GetAggroDistance");
static_assert(offsetof(MatchaAICharacterEntity_GetAggroDistance, ReturnValue) == 0x000000, "Member 'MatchaAICharacterEntity_GetAggroDistance::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaAICharacterEntity.GetSpawnLocation
// 0x0018 (0x0018 - 0x0000)
struct MatchaAICharacterEntity_GetSpawnLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAICharacterEntity_GetSpawnLocation) == 0x000008, "Wrong alignment on MatchaAICharacterEntity_GetSpawnLocation");
static_assert(sizeof(MatchaAICharacterEntity_GetSpawnLocation) == 0x000018, "Wrong size on MatchaAICharacterEntity_GetSpawnLocation");
static_assert(offsetof(MatchaAICharacterEntity_GetSpawnLocation, ReturnValue) == 0x000000, "Member 'MatchaAICharacterEntity_GetSpawnLocation::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaAICharacterEntity.ToggleBehaviorTree
// 0x0001 (0x0001 - 0x0000)
struct MatchaAICharacterEntity_ToggleBehaviorTree final
{
public:
	bool                                          bShouldEnable;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAICharacterEntity_ToggleBehaviorTree) == 0x000001, "Wrong alignment on MatchaAICharacterEntity_ToggleBehaviorTree");
static_assert(sizeof(MatchaAICharacterEntity_ToggleBehaviorTree) == 0x000001, "Wrong size on MatchaAICharacterEntity_ToggleBehaviorTree");
static_assert(offsetof(MatchaAICharacterEntity_ToggleBehaviorTree, bShouldEnable) == 0x000000, "Member 'MatchaAICharacterEntity_ToggleBehaviorTree::bShouldEnable' has a wrong offset!");

// Function Matcha.MatchaSnapNetEntity.OnEnabledChanged
// 0x0002 (0x0002 - 0x0000)
struct MatchaSnapNetEntity_OnEnabledChanged final
{
public:
	bool                                          bOldEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewEnabled;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetEntity_OnEnabledChanged) == 0x000001, "Wrong alignment on MatchaSnapNetEntity_OnEnabledChanged");
static_assert(sizeof(MatchaSnapNetEntity_OnEnabledChanged) == 0x000002, "Wrong size on MatchaSnapNetEntity_OnEnabledChanged");
static_assert(offsetof(MatchaSnapNetEntity_OnEnabledChanged, bOldEnabled) == 0x000000, "Member 'MatchaSnapNetEntity_OnEnabledChanged::bOldEnabled' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetEntity_OnEnabledChanged, bNewEnabled) == 0x000001, "Member 'MatchaSnapNetEntity_OnEnabledChanged::bNewEnabled' has a wrong offset!");

// Function Matcha.MatchaSnapNetEntity.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetEntity_SetEnabled final
{
public:
	bool                                          bShouldEnable;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetEntity_SetEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetEntity_SetEnabled");
static_assert(sizeof(MatchaSnapNetEntity_SetEnabled) == 0x000001, "Wrong size on MatchaSnapNetEntity_SetEnabled");
static_assert(offsetof(MatchaSnapNetEntity_SetEnabled, bShouldEnable) == 0x000000, "Member 'MatchaSnapNetEntity_SetEnabled::bShouldEnable' has a wrong offset!");

// Function Matcha.MatchaSnapNetEntity.GetCurrentEntityTimeInMilliseconds
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetEntity_GetCurrentEntityTimeInMilliseconds final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetEntity_GetCurrentEntityTimeInMilliseconds) == 0x000004, "Wrong alignment on MatchaSnapNetEntity_GetCurrentEntityTimeInMilliseconds");
static_assert(sizeof(MatchaSnapNetEntity_GetCurrentEntityTimeInMilliseconds) == 0x000004, "Wrong size on MatchaSnapNetEntity_GetCurrentEntityTimeInMilliseconds");
static_assert(offsetof(MatchaSnapNetEntity_GetCurrentEntityTimeInMilliseconds, ReturnValue) == 0x000000, "Member 'MatchaSnapNetEntity_GetCurrentEntityTimeInMilliseconds::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetEntity.GetMillisecondsSinceCreation
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetEntity_GetMillisecondsSinceCreation final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetEntity_GetMillisecondsSinceCreation) == 0x000004, "Wrong alignment on MatchaSnapNetEntity_GetMillisecondsSinceCreation");
static_assert(sizeof(MatchaSnapNetEntity_GetMillisecondsSinceCreation) == 0x000004, "Wrong size on MatchaSnapNetEntity_GetMillisecondsSinceCreation");
static_assert(offsetof(MatchaSnapNetEntity_GetMillisecondsSinceCreation, ReturnValue) == 0x000000, "Member 'MatchaSnapNetEntity_GetMillisecondsSinceCreation::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetEntity.GetOwnerEntity
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetEntity_GetOwnerEntity final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetEntity_GetOwnerEntity) == 0x000008, "Wrong alignment on MatchaSnapNetEntity_GetOwnerEntity");
static_assert(sizeof(MatchaSnapNetEntity_GetOwnerEntity) == 0x000008, "Wrong size on MatchaSnapNetEntity_GetOwnerEntity");
static_assert(offsetof(MatchaSnapNetEntity_GetOwnerEntity, ReturnValue) == 0x000000, "Member 'MatchaSnapNetEntity_GetOwnerEntity::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetEntity.GetOwnerEntityIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetEntity_GetOwnerEntityIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetEntity_GetOwnerEntityIndex) == 0x000004, "Wrong alignment on MatchaSnapNetEntity_GetOwnerEntityIndex");
static_assert(sizeof(MatchaSnapNetEntity_GetOwnerEntityIndex) == 0x000004, "Wrong size on MatchaSnapNetEntity_GetOwnerEntityIndex");
static_assert(offsetof(MatchaSnapNetEntity_GetOwnerEntityIndex, ReturnValue) == 0x000000, "Member 'MatchaSnapNetEntity_GetOwnerEntityIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetEntity.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetEntity_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetEntity_IsEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetEntity_IsEnabled");
static_assert(sizeof(MatchaSnapNetEntity_IsEnabled) == 0x000001, "Wrong size on MatchaSnapNetEntity_IsEnabled");
static_assert(offsetof(MatchaSnapNetEntity_IsEnabled, ReturnValue) == 0x000000, "Member 'MatchaSnapNetEntity_IsEnabled::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameEntity.Get
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetGameEntity_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetGameEntity*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameEntity_Get) == 0x000008, "Wrong alignment on MatchaSnapNetGameEntity_Get");
static_assert(sizeof(MatchaSnapNetGameEntity_Get) == 0x000010, "Wrong size on MatchaSnapNetGameEntity_Get");
static_assert(offsetof(MatchaSnapNetGameEntity_Get, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetGameEntity_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetGameEntity_Get, ReturnValue) == 0x000008, "Member 'MatchaSnapNetGameEntity_Get::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameEntity.OnAnyActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetGameEntity_OnAnyActorDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameEntity_OnAnyActorDestroyed) == 0x000008, "Wrong alignment on MatchaSnapNetGameEntity_OnAnyActorDestroyed");
static_assert(sizeof(MatchaSnapNetGameEntity_OnAnyActorDestroyed) == 0x000008, "Wrong size on MatchaSnapNetGameEntity_OnAnyActorDestroyed");
static_assert(offsetof(MatchaSnapNetGameEntity_OnAnyActorDestroyed, DestroyedActor) == 0x000000, "Member 'MatchaSnapNetGameEntity_OnAnyActorDestroyed::DestroyedActor' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameEntity.OnAnyActorSpawned
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetGameEntity_OnAnyActorSpawned final
{
public:
	class AActor*                                 SpawnedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameEntity_OnAnyActorSpawned) == 0x000008, "Wrong alignment on MatchaSnapNetGameEntity_OnAnyActorSpawned");
static_assert(sizeof(MatchaSnapNetGameEntity_OnAnyActorSpawned) == 0x000008, "Wrong size on MatchaSnapNetGameEntity_OnAnyActorSpawned");
static_assert(offsetof(MatchaSnapNetGameEntity_OnAnyActorSpawned, SpawnedActor) == 0x000000, "Member 'MatchaSnapNetGameEntity_OnAnyActorSpawned::SpawnedActor' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameEntity.GetCurrentMatchPhase
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetGameEntity_GetCurrentMatchPhase final
{
public:
	EMatchaMatchPhase                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameEntity_GetCurrentMatchPhase) == 0x000001, "Wrong alignment on MatchaSnapNetGameEntity_GetCurrentMatchPhase");
static_assert(sizeof(MatchaSnapNetGameEntity_GetCurrentMatchPhase) == 0x000001, "Wrong size on MatchaSnapNetGameEntity_GetCurrentMatchPhase");
static_assert(offsetof(MatchaSnapNetGameEntity_GetCurrentMatchPhase, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameEntity_GetCurrentMatchPhase::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaAnalyticsManager.OnCharacterMontageStarted
// 0x0010 (0x0010 - 0x0000)
struct MatchaAnalyticsManager_OnCharacterMontageStarted final
{
public:
	class AMatchaCharacterBase*                   CharacterEntity;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageDuration;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageType;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   PreviousMontageType;                               // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaAnalyticsManager_OnCharacterMontageStarted) == 0x000008, "Wrong alignment on MatchaAnalyticsManager_OnCharacterMontageStarted");
static_assert(sizeof(MatchaAnalyticsManager_OnCharacterMontageStarted) == 0x000010, "Wrong size on MatchaAnalyticsManager_OnCharacterMontageStarted");
static_assert(offsetof(MatchaAnalyticsManager_OnCharacterMontageStarted, CharacterEntity) == 0x000000, "Member 'MatchaAnalyticsManager_OnCharacterMontageStarted::CharacterEntity' has a wrong offset!");
static_assert(offsetof(MatchaAnalyticsManager_OnCharacterMontageStarted, MontageDuration) == 0x000008, "Member 'MatchaAnalyticsManager_OnCharacterMontageStarted::MontageDuration' has a wrong offset!");
static_assert(offsetof(MatchaAnalyticsManager_OnCharacterMontageStarted, MontageType) == 0x00000C, "Member 'MatchaAnalyticsManager_OnCharacterMontageStarted::MontageType' has a wrong offset!");
static_assert(offsetof(MatchaAnalyticsManager_OnCharacterMontageStarted, PreviousMontageType) == 0x00000D, "Member 'MatchaAnalyticsManager_OnCharacterMontageStarted::PreviousMontageType' has a wrong offset!");

// Function Matcha.MatchaAnalyticsManager.OnMatchPhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct MatchaAnalyticsManager_OnMatchPhaseChanged final
{
public:
	EMatchaMatchPhase                             MatchPhase;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAnalyticsManager_OnMatchPhaseChanged) == 0x000001, "Wrong alignment on MatchaAnalyticsManager_OnMatchPhaseChanged");
static_assert(sizeof(MatchaAnalyticsManager_OnMatchPhaseChanged) == 0x000001, "Wrong size on MatchaAnalyticsManager_OnMatchPhaseChanged");
static_assert(offsetof(MatchaAnalyticsManager_OnMatchPhaseChanged, MatchPhase) == 0x000000, "Member 'MatchaAnalyticsManager_OnMatchPhaseChanged::MatchPhase' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.AddHitBox
// 0x00C8 (0x00C8 - 0x0000)
struct MatchaCharacterBase_AddHitBox final
{
public:
	struct FMatchaHitBoxData                      HitBoxData;                                        // 0x0000(0x00A8)(Parm, NativeAccessSpecifierPublic)
	class UObject*                                Source;                                            // 0x00A8(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x00B0(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_AddHitBox) == 0x000008, "Wrong alignment on MatchaCharacterBase_AddHitBox");
static_assert(sizeof(MatchaCharacterBase_AddHitBox) == 0x0000C8, "Wrong size on MatchaCharacterBase_AddHitBox");
static_assert(offsetof(MatchaCharacterBase_AddHitBox, HitBoxData) == 0x000000, "Member 'MatchaCharacterBase_AddHitBox::HitBoxData' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_AddHitBox, Source) == 0x0000A8, "Member 'MatchaCharacterBase_AddHitBox::Source' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_AddHitBox, Location) == 0x0000B0, "Member 'MatchaCharacterBase_AddHitBox::Location' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.CharacterMovementUpdated
// 0x0038 (0x0038 - 0x0000)
struct MatchaCharacterBase_CharacterMovementUpdated final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OldLocation;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldVelocity;                                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_CharacterMovementUpdated) == 0x000008, "Wrong alignment on MatchaCharacterBase_CharacterMovementUpdated");
static_assert(sizeof(MatchaCharacterBase_CharacterMovementUpdated) == 0x000038, "Wrong size on MatchaCharacterBase_CharacterMovementUpdated");
static_assert(offsetof(MatchaCharacterBase_CharacterMovementUpdated, DeltaSeconds) == 0x000000, "Member 'MatchaCharacterBase_CharacterMovementUpdated::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_CharacterMovementUpdated, OldLocation) == 0x000008, "Member 'MatchaCharacterBase_CharacterMovementUpdated::OldLocation' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_CharacterMovementUpdated, OldVelocity) == 0x000020, "Member 'MatchaCharacterBase_CharacterMovementUpdated::OldVelocity' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.CharacterTeleport
// 0x0038 (0x0038 - 0x0000)
struct MatchaCharacterBase_CharacterTeleport final
{
public:
	struct FVector                                DestinationLocation;                               // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DestinationRotation;                               // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsATest;                                          // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCheck;                                          // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0032(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBase_CharacterTeleport) == 0x000008, "Wrong alignment on MatchaCharacterBase_CharacterTeleport");
static_assert(sizeof(MatchaCharacterBase_CharacterTeleport) == 0x000038, "Wrong size on MatchaCharacterBase_CharacterTeleport");
static_assert(offsetof(MatchaCharacterBase_CharacterTeleport, DestinationLocation) == 0x000000, "Member 'MatchaCharacterBase_CharacterTeleport::DestinationLocation' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_CharacterTeleport, DestinationRotation) == 0x000018, "Member 'MatchaCharacterBase_CharacterTeleport::DestinationRotation' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_CharacterTeleport, bIsATest) == 0x000030, "Member 'MatchaCharacterBase_CharacterTeleport::bIsATest' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_CharacterTeleport, bNoCheck) == 0x000031, "Member 'MatchaCharacterBase_CharacterTeleport::bNoCheck' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_CharacterTeleport, ReturnValue) == 0x000032, "Member 'MatchaCharacterBase_CharacterTeleport::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.DestroyTrackedEntity
// 0x0008 (0x0008 - 0x0000)
struct MatchaCharacterBase_DestroyTrackedEntity final
{
public:
	struct FGameplayTag                           EntityTag;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_DestroyTrackedEntity) == 0x000004, "Wrong alignment on MatchaCharacterBase_DestroyTrackedEntity");
static_assert(sizeof(MatchaCharacterBase_DestroyTrackedEntity) == 0x000008, "Wrong size on MatchaCharacterBase_DestroyTrackedEntity");
static_assert(offsetof(MatchaCharacterBase_DestroyTrackedEntity, EntityTag) == 0x000000, "Member 'MatchaCharacterBase_DestroyTrackedEntity::EntityTag' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetTrackedEntity
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBase_GetTrackedEntity final
{
public:
	struct FGameplayTag                           EntityTag;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetTrackedEntity) == 0x000008, "Wrong alignment on MatchaCharacterBase_GetTrackedEntity");
static_assert(sizeof(MatchaCharacterBase_GetTrackedEntity) == 0x000010, "Wrong size on MatchaCharacterBase_GetTrackedEntity");
static_assert(offsetof(MatchaCharacterBase_GetTrackedEntity, EntityTag) == 0x000000, "Member 'MatchaCharacterBase_GetTrackedEntity::EntityTag' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_GetTrackedEntity, ReturnValue) == 0x000008, "Member 'MatchaCharacterBase_GetTrackedEntity::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.InflictDamage
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBase_InflictDamage final
{
public:
	class AActor*                                 DamageInstigator;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBase_InflictDamage) == 0x000008, "Wrong alignment on MatchaCharacterBase_InflictDamage");
static_assert(sizeof(MatchaCharacterBase_InflictDamage) == 0x000010, "Wrong size on MatchaCharacterBase_InflictDamage");
static_assert(offsetof(MatchaCharacterBase_InflictDamage, DamageInstigator) == 0x000000, "Member 'MatchaCharacterBase_InflictDamage::DamageInstigator' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_InflictDamage, Damage) == 0x000008, "Member 'MatchaCharacterBase_InflictDamage::Damage' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.PerformAoEHeal
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBase_PerformAoEHeal final
{
public:
	struct FActorFilterInfo                       ActorFilterInfo;                                   // 0x0000(0x0006)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealAmount;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_PerformAoEHeal) == 0x000004, "Wrong alignment on MatchaCharacterBase_PerformAoEHeal");
static_assert(sizeof(MatchaCharacterBase_PerformAoEHeal) == 0x000010, "Wrong size on MatchaCharacterBase_PerformAoEHeal");
static_assert(offsetof(MatchaCharacterBase_PerformAoEHeal, ActorFilterInfo) == 0x000000, "Member 'MatchaCharacterBase_PerformAoEHeal::ActorFilterInfo' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformAoEHeal, HealAmount) == 0x000008, "Member 'MatchaCharacterBase_PerformAoEHeal::HealAmount' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformAoEHeal, Range) == 0x00000C, "Member 'MatchaCharacterBase_PerformAoEHeal::Range' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.PerformAoEStun
// 0x0020 (0x0020 - 0x0000)
struct MatchaCharacterBase_PerformAoEStun final
{
public:
	struct FActorFilterInfo                       ActorFilterInfo;                                   // 0x0000(0x0006)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunTimeInSeconds;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetFromCharacter;                               // 0x0010(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_PerformAoEStun) == 0x000008, "Wrong alignment on MatchaCharacterBase_PerformAoEStun");
static_assert(sizeof(MatchaCharacterBase_PerformAoEStun) == 0x000020, "Wrong size on MatchaCharacterBase_PerformAoEStun");
static_assert(offsetof(MatchaCharacterBase_PerformAoEStun, ActorFilterInfo) == 0x000000, "Member 'MatchaCharacterBase_PerformAoEStun::ActorFilterInfo' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformAoEStun, StunTimeInSeconds) == 0x000008, "Member 'MatchaCharacterBase_PerformAoEStun::StunTimeInSeconds' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformAoEStun, Range) == 0x00000C, "Member 'MatchaCharacterBase_PerformAoEStun::Range' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformAoEStun, OffsetFromCharacter) == 0x000010, "Member 'MatchaCharacterBase_PerformAoEStun::OffsetFromCharacter' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.PerformCharacterLaunchAngleSpeed
// 0x001C (0x001C - 0x0000)
struct MatchaCharacterBase_PerformCharacterLaunchAngleSpeed final
{
public:
	ELaunchType                                   LaunchType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELaunchActionRestrictionType                  ActionRestrictionType;                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchSpeed;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAngle;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration_0;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionRestrictionDuration;                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyIntangibility;                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed) == 0x000004, "Wrong alignment on MatchaCharacterBase_PerformCharacterLaunchAngleSpeed");
static_assert(sizeof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed) == 0x00001C, "Wrong size on MatchaCharacterBase_PerformCharacterLaunchAngleSpeed");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed, LaunchType) == 0x000000, "Member 'MatchaCharacterBase_PerformCharacterLaunchAngleSpeed::LaunchType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed, ActionRestrictionType) == 0x000001, "Member 'MatchaCharacterBase_PerformCharacterLaunchAngleSpeed::ActionRestrictionType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed, LaunchSpeed) == 0x000004, "Member 'MatchaCharacterBase_PerformCharacterLaunchAngleSpeed::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed, LaunchAngle) == 0x000008, "Member 'MatchaCharacterBase_PerformCharacterLaunchAngleSpeed::LaunchAngle' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed, Acceleration_0) == 0x00000C, "Member 'MatchaCharacterBase_PerformCharacterLaunchAngleSpeed::Acceleration_0' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed, Gravity) == 0x000010, "Member 'MatchaCharacterBase_PerformCharacterLaunchAngleSpeed::Gravity' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed, ActionRestrictionDuration) == 0x000014, "Member 'MatchaCharacterBase_PerformCharacterLaunchAngleSpeed::ActionRestrictionDuration' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchAngleSpeed, bApplyIntangibility) == 0x000018, "Member 'MatchaCharacterBase_PerformCharacterLaunchAngleSpeed::bApplyIntangibility' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.PerformCharacterLaunchVelocity
// 0x0030 (0x0030 - 0x0000)
struct MatchaCharacterBase_PerformCharacterLaunchVelocity final
{
public:
	ELaunchType                                   LaunchType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELaunchActionRestrictionType                  ActionRestrictionType;                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LaunchVelocity;                                    // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration_0;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionRestrictionDuration;                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyIntangibility;                               // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearCurrentMontage;                              // 0x002D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBase_PerformCharacterLaunchVelocity) == 0x000008, "Wrong alignment on MatchaCharacterBase_PerformCharacterLaunchVelocity");
static_assert(sizeof(MatchaCharacterBase_PerformCharacterLaunchVelocity) == 0x000030, "Wrong size on MatchaCharacterBase_PerformCharacterLaunchVelocity");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchVelocity, LaunchType) == 0x000000, "Member 'MatchaCharacterBase_PerformCharacterLaunchVelocity::LaunchType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchVelocity, ActionRestrictionType) == 0x000001, "Member 'MatchaCharacterBase_PerformCharacterLaunchVelocity::ActionRestrictionType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchVelocity, LaunchVelocity) == 0x000008, "Member 'MatchaCharacterBase_PerformCharacterLaunchVelocity::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchVelocity, Acceleration_0) == 0x000020, "Member 'MatchaCharacterBase_PerformCharacterLaunchVelocity::Acceleration_0' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchVelocity, Gravity) == 0x000024, "Member 'MatchaCharacterBase_PerformCharacterLaunchVelocity::Gravity' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchVelocity, ActionRestrictionDuration) == 0x000028, "Member 'MatchaCharacterBase_PerformCharacterLaunchVelocity::ActionRestrictionDuration' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchVelocity, bApplyIntangibility) == 0x00002C, "Member 'MatchaCharacterBase_PerformCharacterLaunchVelocity::bApplyIntangibility' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_PerformCharacterLaunchVelocity, bClearCurrentMontage) == 0x00002D, "Member 'MatchaCharacterBase_PerformCharacterLaunchVelocity::bClearCurrentMontage' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.RequestHitFreeze
// 0x0008 (0x0008 - 0x0000)
struct MatchaCharacterBase_RequestHitFreeze final
{
public:
	int32                                         HitFreezeMilliseconds;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldShake;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPetrify;                                    // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBase_RequestHitFreeze) == 0x000004, "Wrong alignment on MatchaCharacterBase_RequestHitFreeze");
static_assert(sizeof(MatchaCharacterBase_RequestHitFreeze) == 0x000008, "Wrong size on MatchaCharacterBase_RequestHitFreeze");
static_assert(offsetof(MatchaCharacterBase_RequestHitFreeze, HitFreezeMilliseconds) == 0x000000, "Member 'MatchaCharacterBase_RequestHitFreeze::HitFreezeMilliseconds' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestHitFreeze, bShouldShake) == 0x000004, "Member 'MatchaCharacterBase_RequestHitFreeze::bShouldShake' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestHitFreeze, bShouldPetrify) == 0x000005, "Member 'MatchaCharacterBase_RequestHitFreeze::bShouldPetrify' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.RequestStun
// 0x0004 (0x0004 - 0x0000)
struct MatchaCharacterBase_RequestStun final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_RequestStun) == 0x000004, "Wrong alignment on MatchaCharacterBase_RequestStun");
static_assert(sizeof(MatchaCharacterBase_RequestStun) == 0x000004, "Wrong size on MatchaCharacterBase_RequestStun");
static_assert(offsetof(MatchaCharacterBase_RequestStun, DurationSeconds) == 0x000000, "Member 'MatchaCharacterBase_RequestStun::DurationSeconds' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.RequestTargetedGlitchDash
// 0x0028 (0x0028 - 0x0000)
struct MatchaCharacterBase_RequestTargetedGlitchDash final
{
public:
	int32                                         TargetEntityIndex;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirStallTimeMilliseconds;                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TravelTimeMilliseconds;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OffsetVector;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetedGlitchDashFacingType                 FacingType;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageToPlayOnRequest;                            // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   PostTravelMontage;                                 // 0x0022(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaRootMotionType                         PostTravelRootMotion;                              // 0x0023(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBase_RequestTargetedGlitchDash) == 0x000008, "Wrong alignment on MatchaCharacterBase_RequestTargetedGlitchDash");
static_assert(sizeof(MatchaCharacterBase_RequestTargetedGlitchDash) == 0x000028, "Wrong size on MatchaCharacterBase_RequestTargetedGlitchDash");
static_assert(offsetof(MatchaCharacterBase_RequestTargetedGlitchDash, TargetEntityIndex) == 0x000000, "Member 'MatchaCharacterBase_RequestTargetedGlitchDash::TargetEntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTargetedGlitchDash, AirStallTimeMilliseconds) == 0x000004, "Member 'MatchaCharacterBase_RequestTargetedGlitchDash::AirStallTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTargetedGlitchDash, TravelTimeMilliseconds) == 0x000008, "Member 'MatchaCharacterBase_RequestTargetedGlitchDash::TravelTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTargetedGlitchDash, OffsetVector) == 0x000010, "Member 'MatchaCharacterBase_RequestTargetedGlitchDash::OffsetVector' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTargetedGlitchDash, FacingType) == 0x000020, "Member 'MatchaCharacterBase_RequestTargetedGlitchDash::FacingType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTargetedGlitchDash, MontageToPlayOnRequest) == 0x000021, "Member 'MatchaCharacterBase_RequestTargetedGlitchDash::MontageToPlayOnRequest' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTargetedGlitchDash, PostTravelMontage) == 0x000022, "Member 'MatchaCharacterBase_RequestTargetedGlitchDash::PostTravelMontage' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTargetedGlitchDash, PostTravelRootMotion) == 0x000023, "Member 'MatchaCharacterBase_RequestTargetedGlitchDash::PostTravelRootMotion' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.RequestTraversalEntityRootMotionForce
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBase_RequestTraversalEntityRootMotionForce final
{
public:
	const class AMatchaSplineTraversalEntity*     TraversalEntity;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelSpeed;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequestedDisable;                                 // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequestedIntangibility;                           // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCapsuleCollision;                          // 0x000E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBase_RequestTraversalEntityRootMotionForce) == 0x000008, "Wrong alignment on MatchaCharacterBase_RequestTraversalEntityRootMotionForce");
static_assert(sizeof(MatchaCharacterBase_RequestTraversalEntityRootMotionForce) == 0x000010, "Wrong size on MatchaCharacterBase_RequestTraversalEntityRootMotionForce");
static_assert(offsetof(MatchaCharacterBase_RequestTraversalEntityRootMotionForce, TraversalEntity) == 0x000000, "Member 'MatchaCharacterBase_RequestTraversalEntityRootMotionForce::TraversalEntity' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTraversalEntityRootMotionForce, TravelSpeed) == 0x000008, "Member 'MatchaCharacterBase_RequestTraversalEntityRootMotionForce::TravelSpeed' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTraversalEntityRootMotionForce, bRequestedDisable) == 0x00000C, "Member 'MatchaCharacterBase_RequestTraversalEntityRootMotionForce::bRequestedDisable' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTraversalEntityRootMotionForce, bRequestedIntangibility) == 0x00000D, "Member 'MatchaCharacterBase_RequestTraversalEntityRootMotionForce::bRequestedIntangibility' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_RequestTraversalEntityRootMotionForce, bDisableCapsuleCollision) == 0x00000E, "Member 'MatchaCharacterBase_RequestTraversalEntityRootMotionForce::bDisableCapsuleCollision' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.SetShouldBeRevealedToAllPlayers
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_SetShouldBeRevealedToAllPlayers final
{
public:
	bool                                          bShouldBeRevealed;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_SetShouldBeRevealedToAllPlayers) == 0x000001, "Wrong alignment on MatchaCharacterBase_SetShouldBeRevealedToAllPlayers");
static_assert(sizeof(MatchaCharacterBase_SetShouldBeRevealedToAllPlayers) == 0x000001, "Wrong size on MatchaCharacterBase_SetShouldBeRevealedToAllPlayers");
static_assert(offsetof(MatchaCharacterBase_SetShouldBeRevealedToAllPlayers, bShouldBeRevealed) == 0x000000, "Member 'MatchaCharacterBase_SetShouldBeRevealedToAllPlayers::bShouldBeRevealed' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.SpawnTrackedEntity
// 0x0038 (0x0038 - 0x0000)
struct MatchaCharacterBase_SpawnTrackedEntity final
{
public:
	struct FGameplayTag                           EntityTag;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_SpawnTrackedEntity) == 0x000008, "Wrong alignment on MatchaCharacterBase_SpawnTrackedEntity");
static_assert(sizeof(MatchaCharacterBase_SpawnTrackedEntity) == 0x000038, "Wrong size on MatchaCharacterBase_SpawnTrackedEntity");
static_assert(offsetof(MatchaCharacterBase_SpawnTrackedEntity, EntityTag) == 0x000000, "Member 'MatchaCharacterBase_SpawnTrackedEntity::EntityTag' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_SpawnTrackedEntity, Location) == 0x000008, "Member 'MatchaCharacterBase_SpawnTrackedEntity::Location' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBase_SpawnTrackedEntity, Rotation) == 0x000020, "Member 'MatchaCharacterBase_SpawnTrackedEntity::Rotation' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.ToggleStunImmunity
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_ToggleStunImmunity final
{
public:
	bool                                          bShouldEnable;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_ToggleStunImmunity) == 0x000001, "Wrong alignment on MatchaCharacterBase_ToggleStunImmunity");
static_assert(sizeof(MatchaCharacterBase_ToggleStunImmunity) == 0x000001, "Wrong size on MatchaCharacterBase_ToggleStunImmunity");
static_assert(offsetof(MatchaCharacterBase_ToggleStunImmunity, bShouldEnable) == 0x000000, "Member 'MatchaCharacterBase_ToggleStunImmunity::bShouldEnable' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetAliveState
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_GetAliveState final
{
public:
	EAliveState                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetAliveState) == 0x000001, "Wrong alignment on MatchaCharacterBase_GetAliveState");
static_assert(sizeof(MatchaCharacterBase_GetAliveState) == 0x000001, "Wrong size on MatchaCharacterBase_GetAliveState");
static_assert(offsetof(MatchaCharacterBase_GetAliveState, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetAliveState::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetCurrentAutoTravelType
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_GetCurrentAutoTravelType final
{
public:
	EAutoTravelRootMotionType                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetCurrentAutoTravelType) == 0x000001, "Wrong alignment on MatchaCharacterBase_GetCurrentAutoTravelType");
static_assert(sizeof(MatchaCharacterBase_GetCurrentAutoTravelType) == 0x000001, "Wrong size on MatchaCharacterBase_GetCurrentAutoTravelType");
static_assert(offsetof(MatchaCharacterBase_GetCurrentAutoTravelType, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetCurrentAutoTravelType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetCurrentFallType
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_GetCurrentFallType final
{
public:
	EFallType                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetCurrentFallType) == 0x000001, "Wrong alignment on MatchaCharacterBase_GetCurrentFallType");
static_assert(sizeof(MatchaCharacterBase_GetCurrentFallType) == 0x000001, "Wrong size on MatchaCharacterBase_GetCurrentFallType");
static_assert(offsetof(MatchaCharacterBase_GetCurrentFallType, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetCurrentFallType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetCurrentJumpType
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_GetCurrentJumpType final
{
public:
	EJumpType                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetCurrentJumpType) == 0x000001, "Wrong alignment on MatchaCharacterBase_GetCurrentJumpType");
static_assert(sizeof(MatchaCharacterBase_GetCurrentJumpType) == 0x000001, "Wrong size on MatchaCharacterBase_GetCurrentJumpType");
static_assert(offsetof(MatchaCharacterBase_GetCurrentJumpType, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetCurrentJumpType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetCurrentlyPlayingMontageTime
// 0x0004 (0x0004 - 0x0000)
struct MatchaCharacterBase_GetCurrentlyPlayingMontageTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetCurrentlyPlayingMontageTime) == 0x000004, "Wrong alignment on MatchaCharacterBase_GetCurrentlyPlayingMontageTime");
static_assert(sizeof(MatchaCharacterBase_GetCurrentlyPlayingMontageTime) == 0x000004, "Wrong size on MatchaCharacterBase_GetCurrentlyPlayingMontageTime");
static_assert(offsetof(MatchaCharacterBase_GetCurrentlyPlayingMontageTime, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetCurrentlyPlayingMontageTime::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetCurrentMontageType
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_GetCurrentMontageType final
{
public:
	EMatchaCharacterMontageType                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetCurrentMontageType) == 0x000001, "Wrong alignment on MatchaCharacterBase_GetCurrentMontageType");
static_assert(sizeof(MatchaCharacterBase_GetCurrentMontageType) == 0x000001, "Wrong size on MatchaCharacterBase_GetCurrentMontageType");
static_assert(offsetof(MatchaCharacterBase_GetCurrentMontageType, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetCurrentMontageType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetCurrentTraversalEntityType
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_GetCurrentTraversalEntityType final
{
public:
	ETraversalEntityType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetCurrentTraversalEntityType) == 0x000001, "Wrong alignment on MatchaCharacterBase_GetCurrentTraversalEntityType");
static_assert(sizeof(MatchaCharacterBase_GetCurrentTraversalEntityType) == 0x000001, "Wrong size on MatchaCharacterBase_GetCurrentTraversalEntityType");
static_assert(offsetof(MatchaCharacterBase_GetCurrentTraversalEntityType, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetCurrentTraversalEntityType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetEntityIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaCharacterBase_GetEntityIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetEntityIndex) == 0x000004, "Wrong alignment on MatchaCharacterBase_GetEntityIndex");
static_assert(sizeof(MatchaCharacterBase_GetEntityIndex) == 0x000004, "Wrong size on MatchaCharacterBase_GetEntityIndex");
static_assert(offsetof(MatchaCharacterBase_GetEntityIndex, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetEntityIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetMovementMode
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_GetMovementMode final
{
public:
	EMovementMode                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetMovementMode) == 0x000001, "Wrong alignment on MatchaCharacterBase_GetMovementMode");
static_assert(sizeof(MatchaCharacterBase_GetMovementMode) == 0x000001, "Wrong size on MatchaCharacterBase_GetMovementMode");
static_assert(offsetof(MatchaCharacterBase_GetMovementMode, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetMovementMode::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetOwnerPlayerIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaCharacterBase_GetOwnerPlayerIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetOwnerPlayerIndex) == 0x000004, "Wrong alignment on MatchaCharacterBase_GetOwnerPlayerIndex");
static_assert(sizeof(MatchaCharacterBase_GetOwnerPlayerIndex) == 0x000004, "Wrong size on MatchaCharacterBase_GetOwnerPlayerIndex");
static_assert(offsetof(MatchaCharacterBase_GetOwnerPlayerIndex, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetOwnerPlayerIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.GetVisibilityOverrides
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBase_GetVisibilityOverrides final
{
public:
	TArray<struct FVisibilityOverride>            ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_GetVisibilityOverrides) == 0x000008, "Wrong alignment on MatchaCharacterBase_GetVisibilityOverrides");
static_assert(sizeof(MatchaCharacterBase_GetVisibilityOverrides) == 0x000010, "Wrong size on MatchaCharacterBase_GetVisibilityOverrides");
static_assert(offsetof(MatchaCharacterBase_GetVisibilityOverrides, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_GetVisibilityOverrides::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.IsTargetedGlitchDashing
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_IsTargetedGlitchDashing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_IsTargetedGlitchDashing) == 0x000001, "Wrong alignment on MatchaCharacterBase_IsTargetedGlitchDashing");
static_assert(sizeof(MatchaCharacterBase_IsTargetedGlitchDashing) == 0x000001, "Wrong size on MatchaCharacterBase_IsTargetedGlitchDashing");
static_assert(offsetof(MatchaCharacterBase_IsTargetedGlitchDashing, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_IsTargetedGlitchDashing::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBase.ShouldBeRevealedToAllPlayers
// 0x0001 (0x0001 - 0x0000)
struct MatchaCharacterBase_ShouldBeRevealedToAllPlayers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterBase_ShouldBeRevealedToAllPlayers) == 0x000001, "Wrong alignment on MatchaCharacterBase_ShouldBeRevealedToAllPlayers");
static_assert(sizeof(MatchaCharacterBase_ShouldBeRevealedToAllPlayers) == 0x000001, "Wrong size on MatchaCharacterBase_ShouldBeRevealedToAllPlayers");
static_assert(offsetof(MatchaCharacterBase_ShouldBeRevealedToAllPlayers, ReturnValue) == 0x000000, "Member 'MatchaCharacterBase_ShouldBeRevealedToAllPlayers::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaAttachableCompanionEntity.GetOwnerEntityIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaAttachableCompanionEntity_GetOwnerEntityIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAttachableCompanionEntity_GetOwnerEntityIndex) == 0x000004, "Wrong alignment on MatchaAttachableCompanionEntity_GetOwnerEntityIndex");
static_assert(sizeof(MatchaAttachableCompanionEntity_GetOwnerEntityIndex) == 0x000004, "Wrong size on MatchaAttachableCompanionEntity_GetOwnerEntityIndex");
static_assert(offsetof(MatchaAttachableCompanionEntity_GetOwnerEntityIndex, ReturnValue) == 0x000000, "Member 'MatchaAttachableCompanionEntity_GetOwnerEntityIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaAttachableCompanionEntity.IsAttachedToOwner
// 0x0001 (0x0001 - 0x0000)
struct MatchaAttachableCompanionEntity_IsAttachedToOwner final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaAttachableCompanionEntity_IsAttachedToOwner) == 0x000001, "Wrong alignment on MatchaAttachableCompanionEntity_IsAttachedToOwner");
static_assert(sizeof(MatchaAttachableCompanionEntity_IsAttachedToOwner) == 0x000001, "Wrong size on MatchaAttachableCompanionEntity_IsAttachedToOwner");
static_assert(offsetof(MatchaAttachableCompanionEntity_IsAttachedToOwner, ReturnValue) == 0x000000, "Member 'MatchaAttachableCompanionEntity_IsAttachedToOwner::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.Get
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetPlayerEntity_Get final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          WorldContextObject;                                // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetPlayerEntity*             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_Get) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerEntity_Get");
static_assert(sizeof(MatchaSnapNetPlayerEntity_Get) == 0x000018, "Wrong size on MatchaSnapNetPlayerEntity_Get");
static_assert(offsetof(MatchaSnapNetPlayerEntity_Get, PlayerIndex) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_Get::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayerEntity_Get, WorldContextObject) == 0x000008, "Member 'MatchaSnapNetPlayerEntity_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayerEntity_Get, ReturnValue) == 0x000010, "Member 'MatchaSnapNetPlayerEntity_Get::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GetByTeamIndex
// 0x0020 (0x0020 - 0x0000)
struct MatchaSnapNetPlayerEntity_GetByTeamIndex final
{
public:
	int32                                         TeamNumber_0;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          WorldContextObject;                                // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AMatchaSnapNetPlayerEntity*>     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GetByTeamIndex) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerEntity_GetByTeamIndex");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GetByTeamIndex) == 0x000020, "Wrong size on MatchaSnapNetPlayerEntity_GetByTeamIndex");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetByTeamIndex, TeamNumber_0) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GetByTeamIndex::TeamNumber_0' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetByTeamIndex, WorldContextObject) == 0x000008, "Member 'MatchaSnapNetPlayerEntity_GetByTeamIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetByTeamIndex, ReturnValue) == 0x000010, "Member 'MatchaSnapNetPlayerEntity_GetByTeamIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GetFromSimulation
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetPlayerEntity_GetFromSimulation final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class USnapNetSimulation*               SnapNetSimulation;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetPlayerEntity*             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GetFromSimulation) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerEntity_GetFromSimulation");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GetFromSimulation) == 0x000018, "Wrong size on MatchaSnapNetPlayerEntity_GetFromSimulation");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetFromSimulation, PlayerIndex) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GetFromSimulation::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetFromSimulation, SnapNetSimulation) == 0x000008, "Member 'MatchaSnapNetPlayerEntity_GetFromSimulation::SnapNetSimulation' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetFromSimulation, ReturnValue) == 0x000010, "Member 'MatchaSnapNetPlayerEntity_GetFromSimulation::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GiveTeamCoins
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetPlayerEntity_GiveTeamCoins final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GiveTeamCoins) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerEntity_GiveTeamCoins");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GiveTeamCoins) == 0x000004, "Wrong size on MatchaSnapNetPlayerEntity_GiveTeamCoins");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GiveTeamCoins, Amount) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GiveTeamCoins::Amount' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GiveTeamPowerSparks
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetPlayerEntity_GiveTeamPowerSparks final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GiveTeamPowerSparks) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerEntity_GiveTeamPowerSparks");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GiveTeamPowerSparks) == 0x000004, "Wrong size on MatchaSnapNetPlayerEntity_GiveTeamPowerSparks");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GiveTeamPowerSparks, Amount) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GiveTeamPowerSparks::Amount' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.SetSharedTeamCoins
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetPlayerEntity_SetSharedTeamCoins final
{
public:
	int32                                         SharedTeamCoins_0;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_SetSharedTeamCoins) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerEntity_SetSharedTeamCoins");
static_assert(sizeof(MatchaSnapNetPlayerEntity_SetSharedTeamCoins) == 0x000004, "Wrong size on MatchaSnapNetPlayerEntity_SetSharedTeamCoins");
static_assert(offsetof(MatchaSnapNetPlayerEntity_SetSharedTeamCoins, SharedTeamCoins_0) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_SetSharedTeamCoins::SharedTeamCoins_0' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.SetSharedTeamPowerSparks
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetPlayerEntity_SetSharedTeamPowerSparks final
{
public:
	int32                                         InSharedTeamPowerSparks;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_SetSharedTeamPowerSparks) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerEntity_SetSharedTeamPowerSparks");
static_assert(sizeof(MatchaSnapNetPlayerEntity_SetSharedTeamPowerSparks) == 0x000004, "Wrong size on MatchaSnapNetPlayerEntity_SetSharedTeamPowerSparks");
static_assert(offsetof(MatchaSnapNetPlayerEntity_SetSharedTeamPowerSparks, InSharedTeamPowerSparks) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_SetSharedTeamPowerSparks::InSharedTeamPowerSparks' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GetDisplayName
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetPlayerEntity_GetDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GetDisplayName) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerEntity_GetDisplayName");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GetDisplayName) == 0x000010, "Wrong size on MatchaSnapNetPlayerEntity_GetDisplayName");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetDisplayName, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GetDisplayName::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GetInventoryComponent
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetPlayerEntity_GetInventoryComponent final
{
public:
	class UMatchaInventoryComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GetInventoryComponent) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerEntity_GetInventoryComponent");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GetInventoryComponent) == 0x000008, "Wrong size on MatchaSnapNetPlayerEntity_GetInventoryComponent");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetInventoryComponent, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GetInventoryComponent::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GetOwnedCharacter
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetPlayerEntity_GetOwnedCharacter final
{
public:
	class AMatchaSnapNetCharacterEntity*          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GetOwnedCharacter) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerEntity_GetOwnedCharacter");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GetOwnedCharacter) == 0x000008, "Wrong size on MatchaSnapNetPlayerEntity_GetOwnedCharacter");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetOwnedCharacter, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GetOwnedCharacter::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GetOwnerPlayerIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetPlayerEntity_GetOwnerPlayerIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GetOwnerPlayerIndex) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerEntity_GetOwnerPlayerIndex");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GetOwnerPlayerIndex) == 0x000004, "Wrong size on MatchaSnapNetPlayerEntity_GetOwnerPlayerIndex");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetOwnerPlayerIndex, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GetOwnerPlayerIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GetSharedTeamCoins
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetPlayerEntity_GetSharedTeamCoins final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GetSharedTeamCoins) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerEntity_GetSharedTeamCoins");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GetSharedTeamCoins) == 0x000004, "Wrong size on MatchaSnapNetPlayerEntity_GetSharedTeamCoins");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetSharedTeamCoins, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GetSharedTeamCoins::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerEntity.GetSharedTeamPowerSparks
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetPlayerEntity_GetSharedTeamPowerSparks final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerEntity_GetSharedTeamPowerSparks) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerEntity_GetSharedTeamPowerSparks");
static_assert(sizeof(MatchaSnapNetPlayerEntity_GetSharedTeamPowerSparks) == 0x000004, "Wrong size on MatchaSnapNetPlayerEntity_GetSharedTeamPowerSparks");
static_assert(offsetof(MatchaSnapNetPlayerEntity_GetSharedTeamPowerSparks, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerEntity_GetSharedTeamPowerSparks::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetRenderer.GetInstigatorRenderer
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetRenderer_GetInstigatorRenderer final
{
public:
	class AMatchaSnapNetCharacterRenderer*        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetRenderer_GetInstigatorRenderer) == 0x000008, "Wrong alignment on MatchaSnapNetRenderer_GetInstigatorRenderer");
static_assert(sizeof(MatchaSnapNetRenderer_GetInstigatorRenderer) == 0x000008, "Wrong size on MatchaSnapNetRenderer_GetInstigatorRenderer");
static_assert(offsetof(MatchaSnapNetRenderer_GetInstigatorRenderer, ReturnValue) == 0x000000, "Member 'MatchaSnapNetRenderer_GetInstigatorRenderer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaServerScript.InflictDamageActors
// 0x0018 (0x0018 - 0x0000)
struct MatchaServerScript_InflictDamageActors final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_InflictDamageActors) == 0x000008, "Wrong alignment on MatchaServerScript_InflictDamageActors");
static_assert(sizeof(MatchaServerScript_InflictDamageActors) == 0x000018, "Wrong size on MatchaServerScript_InflictDamageActors");
static_assert(offsetof(MatchaServerScript_InflictDamageActors, DamageAmount) == 0x000000, "Member 'MatchaServerScript_InflictDamageActors::DamageAmount' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_InflictDamageActors, Victim) == 0x000008, "Member 'MatchaServerScript_InflictDamageActors::Victim' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_InflictDamageActors, Instigator) == 0x000010, "Member 'MatchaServerScript_InflictDamageActors::Instigator' has a wrong offset!");

// Function Matcha.MatchaServerScript.OnCharacterKnockedOut
// 0x0018 (0x0018 - 0x0000)
struct MatchaServerScript_OnCharacterKnockedOut final
{
public:
	class AMatchaSnapNetCharacterEntity*          CharacterThatWasKnockedOut;                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaKnockoutData                    KnockoutData;                                      // 0x0008(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_OnCharacterKnockedOut) == 0x000008, "Wrong alignment on MatchaServerScript_OnCharacterKnockedOut");
static_assert(sizeof(MatchaServerScript_OnCharacterKnockedOut) == 0x000018, "Wrong size on MatchaServerScript_OnCharacterKnockedOut");
static_assert(offsetof(MatchaServerScript_OnCharacterKnockedOut, CharacterThatWasKnockedOut) == 0x000000, "Member 'MatchaServerScript_OnCharacterKnockedOut::CharacterThatWasKnockedOut' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_OnCharacterKnockedOut, KnockoutData) == 0x000008, "Member 'MatchaServerScript_OnCharacterKnockedOut::KnockoutData' has a wrong offset!");

// Function Matcha.MatchaServerScript.OnCharacterKnockedOutOtherCharacter
// 0x0008 (0x0008 - 0x0000)
struct MatchaServerScript_OnCharacterKnockedOutOtherCharacter final
{
public:
	class AMatchaSnapNetCharacterEntity*          CharacterThatKnocked;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_OnCharacterKnockedOutOtherCharacter) == 0x000008, "Wrong alignment on MatchaServerScript_OnCharacterKnockedOutOtherCharacter");
static_assert(sizeof(MatchaServerScript_OnCharacterKnockedOutOtherCharacter) == 0x000008, "Wrong size on MatchaServerScript_OnCharacterKnockedOutOtherCharacter");
static_assert(offsetof(MatchaServerScript_OnCharacterKnockedOutOtherCharacter, CharacterThatKnocked) == 0x000000, "Member 'MatchaServerScript_OnCharacterKnockedOutOtherCharacter::CharacterThatKnocked' has a wrong offset!");

// Function Matcha.MatchaServerScript.OnGameInfoRequestCompleted
// 0x00A0 (0x00A0 - 0x0000)
struct MatchaServerScript_OnGameInfoRequestCompleted final
{
public:
	bool                                          Succeeded;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RequestID;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaApiV1GamesInfoResponse          GameInfo;                                          // 0x0018(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FErrorResponseV1                       ErrorResponse;                                     // 0x0048(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_OnGameInfoRequestCompleted) == 0x000008, "Wrong alignment on MatchaServerScript_OnGameInfoRequestCompleted");
static_assert(sizeof(MatchaServerScript_OnGameInfoRequestCompleted) == 0x0000A0, "Wrong size on MatchaServerScript_OnGameInfoRequestCompleted");
static_assert(offsetof(MatchaServerScript_OnGameInfoRequestCompleted, Succeeded) == 0x000000, "Member 'MatchaServerScript_OnGameInfoRequestCompleted::Succeeded' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_OnGameInfoRequestCompleted, RequestID) == 0x000008, "Member 'MatchaServerScript_OnGameInfoRequestCompleted::RequestID' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_OnGameInfoRequestCompleted, GameInfo) == 0x000018, "Member 'MatchaServerScript_OnGameInfoRequestCompleted::GameInfo' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_OnGameInfoRequestCompleted, ErrorResponse) == 0x000048, "Member 'MatchaServerScript_OnGameInfoRequestCompleted::ErrorResponse' has a wrong offset!");

// Function Matcha.MatchaServerScript.RespawnPlayer
// 0x0008 (0x0008 - 0x0000)
struct MatchaServerScript_RespawnPlayer final
{
public:
	class AMatchaSnapNetPlayerEntity*             PlayerEntity;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_RespawnPlayer) == 0x000008, "Wrong alignment on MatchaServerScript_RespawnPlayer");
static_assert(sizeof(MatchaServerScript_RespawnPlayer) == 0x000008, "Wrong size on MatchaServerScript_RespawnPlayer");
static_assert(offsetof(MatchaServerScript_RespawnPlayer, PlayerEntity) == 0x000000, "Member 'MatchaServerScript_RespawnPlayer::PlayerEntity' has a wrong offset!");

// Function Matcha.MatchaServerScript.SetPlayerName
// 0x0018 (0x0018 - 0x0000)
struct MatchaServerScript_SetPlayerName final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_0;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_SetPlayerName) == 0x000008, "Wrong alignment on MatchaServerScript_SetPlayerName");
static_assert(sizeof(MatchaServerScript_SetPlayerName) == 0x000018, "Wrong size on MatchaServerScript_SetPlayerName");
static_assert(offsetof(MatchaServerScript_SetPlayerName, PlayerIndex) == 0x000000, "Member 'MatchaServerScript_SetPlayerName::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_SetPlayerName, Name_0) == 0x000008, "Member 'MatchaServerScript_SetPlayerName::Name_0' has a wrong offset!");

// Function Matcha.MatchaServerScript.SpawnBot
// 0x0038 (0x0038 - 0x0000)
struct MatchaServerScript_SpawnBot final
{
public:
	TSubclassOf<class AMatchaSnapNetCharacterEntity> CharacterEntityClass;                              // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_SpawnBot) == 0x000008, "Wrong alignment on MatchaServerScript_SpawnBot");
static_assert(sizeof(MatchaServerScript_SpawnBot) == 0x000038, "Wrong size on MatchaServerScript_SpawnBot");
static_assert(offsetof(MatchaServerScript_SpawnBot, CharacterEntityClass) == 0x000000, "Member 'MatchaServerScript_SpawnBot::CharacterEntityClass' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_SpawnBot, SpawnLocation) == 0x000008, "Member 'MatchaServerScript_SpawnBot::SpawnLocation' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_SpawnBot, SpawnRotation) == 0x000020, "Member 'MatchaServerScript_SpawnBot::SpawnRotation' has a wrong offset!");

// Function Matcha.MatchaServerScript.TrySpectatePlayer
// 0x000C (0x000C - 0x0000)
struct MatchaServerScript_TrySpectatePlayer final
{
public:
	int32                                         RequestingPlayerIndex;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetPlayerIndex;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_TrySpectatePlayer) == 0x000004, "Wrong alignment on MatchaServerScript_TrySpectatePlayer");
static_assert(sizeof(MatchaServerScript_TrySpectatePlayer) == 0x00000C, "Wrong size on MatchaServerScript_TrySpectatePlayer");
static_assert(offsetof(MatchaServerScript_TrySpectatePlayer, RequestingPlayerIndex) == 0x000000, "Member 'MatchaServerScript_TrySpectatePlayer::RequestingPlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_TrySpectatePlayer, TargetPlayerIndex) == 0x000004, "Member 'MatchaServerScript_TrySpectatePlayer::TargetPlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_TrySpectatePlayer, ReturnValue) == 0x000008, "Member 'MatchaServerScript_TrySpectatePlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaServerScript.ValidateDTLSToken
// 0x0018 (0x0018 - 0x0000)
struct MatchaServerScript_ValidateDTLSToken final
{
public:
	class FString                                 Token;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaServerScript_ValidateDTLSToken) == 0x000008, "Wrong alignment on MatchaServerScript_ValidateDTLSToken");
static_assert(sizeof(MatchaServerScript_ValidateDTLSToken) == 0x000018, "Wrong size on MatchaServerScript_ValidateDTLSToken");
static_assert(offsetof(MatchaServerScript_ValidateDTLSToken, Token) == 0x000000, "Member 'MatchaServerScript_ValidateDTLSToken::Token' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_ValidateDTLSToken, ReturnValue) == 0x000010, "Member 'MatchaServerScript_ValidateDTLSToken::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaServerScript.FindPlayerEntityForPlayerIndex
// 0x0010 (0x0010 - 0x0000)
struct MatchaServerScript_FindPlayerEntityForPlayerIndex final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMatchaSnapNetPlayerEntity*             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_FindPlayerEntityForPlayerIndex) == 0x000008, "Wrong alignment on MatchaServerScript_FindPlayerEntityForPlayerIndex");
static_assert(sizeof(MatchaServerScript_FindPlayerEntityForPlayerIndex) == 0x000010, "Wrong size on MatchaServerScript_FindPlayerEntityForPlayerIndex");
static_assert(offsetof(MatchaServerScript_FindPlayerEntityForPlayerIndex, PlayerIndex) == 0x000000, "Member 'MatchaServerScript_FindPlayerEntityForPlayerIndex::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_FindPlayerEntityForPlayerIndex, ReturnValue) == 0x000008, "Member 'MatchaServerScript_FindPlayerEntityForPlayerIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaServerScript.FindPlayerIndexForPlayerId
// 0x000C (0x000C - 0x0000)
struct MatchaServerScript_FindPlayerIndexForPlayerId final
{
public:
	class FName                                   PlayerId;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_FindPlayerIndexForPlayerId) == 0x000004, "Wrong alignment on MatchaServerScript_FindPlayerIndexForPlayerId");
static_assert(sizeof(MatchaServerScript_FindPlayerIndexForPlayerId) == 0x00000C, "Wrong size on MatchaServerScript_FindPlayerIndexForPlayerId");
static_assert(offsetof(MatchaServerScript_FindPlayerIndexForPlayerId, PlayerId) == 0x000000, "Member 'MatchaServerScript_FindPlayerIndexForPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_FindPlayerIndexForPlayerId, ReturnValue) == 0x000008, "Member 'MatchaServerScript_FindPlayerIndexForPlayerId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaServerScript.FindTeamNumberForPlayerIndex
// 0x0008 (0x0008 - 0x0000)
struct MatchaServerScript_FindTeamNumberForPlayerIndex final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_FindTeamNumberForPlayerIndex) == 0x000004, "Wrong alignment on MatchaServerScript_FindTeamNumberForPlayerIndex");
static_assert(sizeof(MatchaServerScript_FindTeamNumberForPlayerIndex) == 0x000008, "Wrong size on MatchaServerScript_FindTeamNumberForPlayerIndex");
static_assert(offsetof(MatchaServerScript_FindTeamNumberForPlayerIndex, PlayerIndex) == 0x000000, "Member 'MatchaServerScript_FindTeamNumberForPlayerIndex::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_FindTeamNumberForPlayerIndex, ReturnValue) == 0x000004, "Member 'MatchaServerScript_FindTeamNumberForPlayerIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaServerScript.GetDefaultCharacterEntityClass
// 0x0008 (0x0008 - 0x0000)
struct MatchaServerScript_GetDefaultCharacterEntityClass final
{
public:
	TSubclassOf<class AMatchaSnapNetCharacterEntity> ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_GetDefaultCharacterEntityClass) == 0x000008, "Wrong alignment on MatchaServerScript_GetDefaultCharacterEntityClass");
static_assert(sizeof(MatchaServerScript_GetDefaultCharacterEntityClass) == 0x000008, "Wrong size on MatchaServerScript_GetDefaultCharacterEntityClass");
static_assert(offsetof(MatchaServerScript_GetDefaultCharacterEntityClass, ReturnValue) == 0x000000, "Member 'MatchaServerScript_GetDefaultCharacterEntityClass::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaServerScript.GetNewPlayerTeamNumber
// 0x0004 (0x0004 - 0x0000)
struct MatchaServerScript_GetNewPlayerTeamNumber final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_GetNewPlayerTeamNumber) == 0x000004, "Wrong alignment on MatchaServerScript_GetNewPlayerTeamNumber");
static_assert(sizeof(MatchaServerScript_GetNewPlayerTeamNumber) == 0x000004, "Wrong size on MatchaServerScript_GetNewPlayerTeamNumber");
static_assert(offsetof(MatchaServerScript_GetNewPlayerTeamNumber, ReturnValue) == 0x000000, "Member 'MatchaServerScript_GetNewPlayerTeamNumber::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaServerScript.GetPlayersOnTeam
// 0x0018 (0x0018 - 0x0000)
struct MatchaServerScript_GetPlayersOnTeam final
{
public:
	int32                                         TeamNumber;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMatchaSnapNetPlayerEntity*>     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaServerScript_GetPlayersOnTeam) == 0x000008, "Wrong alignment on MatchaServerScript_GetPlayersOnTeam");
static_assert(sizeof(MatchaServerScript_GetPlayersOnTeam) == 0x000018, "Wrong size on MatchaServerScript_GetPlayersOnTeam");
static_assert(offsetof(MatchaServerScript_GetPlayersOnTeam, TeamNumber) == 0x000000, "Member 'MatchaServerScript_GetPlayersOnTeam::TeamNumber' has a wrong offset!");
static_assert(offsetof(MatchaServerScript_GetPlayersOnTeam, ReturnValue) == 0x000008, "Member 'MatchaServerScript_GetPlayersOnTeam::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBattleRoyaleServerScript.FindRandomSpawnPointInRegion
// 0x0018 (0x0018 - 0x0000)
struct MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion final
{
public:
	ESpawnRegion                                  SpawnRegion;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamNumber;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldFindPointWithTeammates;                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMatchaPlayerStart*                     ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion) == 0x000008, "Wrong alignment on MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion");
static_assert(sizeof(MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion) == 0x000018, "Wrong size on MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion");
static_assert(offsetof(MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion, SpawnRegion) == 0x000000, "Member 'MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion::SpawnRegion' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion, TeamNumber) == 0x000004, "Member 'MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion::TeamNumber' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion, bShouldFindPointWithTeammates) == 0x000008, "Member 'MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion::bShouldFindPointWithTeammates' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion, ReturnValue) == 0x000010, "Member 'MatchaBattleRoyaleServerScript_FindRandomSpawnPointInRegion::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBattleRoyaleServerScript.ProcessSoulOrbRevival
// 0x0038 (0x0038 - 0x0000)
struct MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival final
{
public:
	class AMatchaSnapNetCharacterEntity*          ReviverCharacter;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReviveLocation;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReviveRotation;                                    // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival) == 0x000008, "Wrong alignment on MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival");
static_assert(sizeof(MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival) == 0x000038, "Wrong size on MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival");
static_assert(offsetof(MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival, ReviverCharacter) == 0x000000, "Member 'MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival::ReviverCharacter' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival, ReviveLocation) == 0x000008, "Member 'MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival::ReviveLocation' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival, ReviveRotation) == 0x000020, "Member 'MatchaBattleRoyaleServerScript_ProcessSoulOrbRevival::ReviveRotation' has a wrong offset!");

// Function Matcha.MatchaBattleRoyaleServerScript.TrySpendCoins
// 0x0010 (0x0010 - 0x0000)
struct MatchaBattleRoyaleServerScript_TrySpendCoins final
{
public:
	const class AMatchaSnapNetCharacterEntity*    SpenderCharacter;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CoinsToSpend;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaBattleRoyaleServerScript_TrySpendCoins) == 0x000008, "Wrong alignment on MatchaBattleRoyaleServerScript_TrySpendCoins");
static_assert(sizeof(MatchaBattleRoyaleServerScript_TrySpendCoins) == 0x000010, "Wrong size on MatchaBattleRoyaleServerScript_TrySpendCoins");
static_assert(offsetof(MatchaBattleRoyaleServerScript_TrySpendCoins, SpenderCharacter) == 0x000000, "Member 'MatchaBattleRoyaleServerScript_TrySpendCoins::SpenderCharacter' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_TrySpendCoins, CoinsToSpend) == 0x000008, "Member 'MatchaBattleRoyaleServerScript_TrySpendCoins::CoinsToSpend' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_TrySpendCoins, ReturnValue) == 0x00000C, "Member 'MatchaBattleRoyaleServerScript_TrySpendCoins::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBattleRoyaleServerScript.TrySpendCurrency
// 0x0010 (0x0010 - 0x0000)
struct MatchaBattleRoyaleServerScript_TrySpendCurrency final
{
public:
	const class AMatchaSnapNetCharacterEntity*    SpenderCharacter;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountToSpend;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInGameCurrencyType                           CurrencyType;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaBattleRoyaleServerScript_TrySpendCurrency) == 0x000008, "Wrong alignment on MatchaBattleRoyaleServerScript_TrySpendCurrency");
static_assert(sizeof(MatchaBattleRoyaleServerScript_TrySpendCurrency) == 0x000010, "Wrong size on MatchaBattleRoyaleServerScript_TrySpendCurrency");
static_assert(offsetof(MatchaBattleRoyaleServerScript_TrySpendCurrency, SpenderCharacter) == 0x000000, "Member 'MatchaBattleRoyaleServerScript_TrySpendCurrency::SpenderCharacter' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_TrySpendCurrency, AmountToSpend) == 0x000008, "Member 'MatchaBattleRoyaleServerScript_TrySpendCurrency::AmountToSpend' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_TrySpendCurrency, CurrencyType) == 0x00000C, "Member 'MatchaBattleRoyaleServerScript_TrySpendCurrency::CurrencyType' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_TrySpendCurrency, ReturnValue) == 0x00000D, "Member 'MatchaBattleRoyaleServerScript_TrySpendCurrency::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBattleRoyaleServerScript.ChooseSpawnFurthestFromPlayers
// 0x0080 (0x0080 - 0x0000)
struct MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers final
{
public:
	TArray<struct FTransform>                     SpawnPoints;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	const class AMatchaSnapNetCharacterEntity*    CharacterEntity;                                   // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0020(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers) == 0x000010, "Wrong alignment on MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers");
static_assert(sizeof(MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers) == 0x000080, "Wrong size on MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers");
static_assert(offsetof(MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers, SpawnPoints) == 0x000000, "Member 'MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers::SpawnPoints' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers, CharacterEntity) == 0x000010, "Member 'MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers::CharacterEntity' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers, ReturnValue) == 0x000020, "Member 'MatchaBattleRoyaleServerScript_ChooseSpawnFurthestFromPlayers::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBattleRoyaleServerScript.FindSpawnPointsWithTag
// 0x0018 (0x0018 - 0x0000)
struct MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag final
{
public:
	class FName                                   SpawnTag;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag) == 0x000008, "Wrong alignment on MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag");
static_assert(sizeof(MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag) == 0x000018, "Wrong size on MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag");
static_assert(offsetof(MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag, SpawnTag) == 0x000000, "Member 'MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag::SpawnTag' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag, ReturnValue) == 0x000008, "Member 'MatchaBattleRoyaleServerScript_FindSpawnPointsWithTag::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBattleRoyaleServerScript.HasEnoughCoins
// 0x0010 (0x0010 - 0x0000)
struct MatchaBattleRoyaleServerScript_HasEnoughCoins final
{
public:
	const class AMatchaSnapNetCharacterEntity*    Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CoinAmountToCheck;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaBattleRoyaleServerScript_HasEnoughCoins) == 0x000008, "Wrong alignment on MatchaBattleRoyaleServerScript_HasEnoughCoins");
static_assert(sizeof(MatchaBattleRoyaleServerScript_HasEnoughCoins) == 0x000010, "Wrong size on MatchaBattleRoyaleServerScript_HasEnoughCoins");
static_assert(offsetof(MatchaBattleRoyaleServerScript_HasEnoughCoins, Character) == 0x000000, "Member 'MatchaBattleRoyaleServerScript_HasEnoughCoins::Character' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_HasEnoughCoins, CoinAmountToCheck) == 0x000008, "Member 'MatchaBattleRoyaleServerScript_HasEnoughCoins::CoinAmountToCheck' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_HasEnoughCoins, ReturnValue) == 0x00000C, "Member 'MatchaBattleRoyaleServerScript_HasEnoughCoins::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBattleRoyaleServerScript.HasEnoughCurrencyOfType
// 0x0010 (0x0010 - 0x0000)
struct MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType final
{
public:
	const class AMatchaSnapNetCharacterEntity*    Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountToCheck;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInGameCurrencyType                           CurrencyType;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType) == 0x000008, "Wrong alignment on MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType");
static_assert(sizeof(MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType) == 0x000010, "Wrong size on MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType");
static_assert(offsetof(MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType, Character) == 0x000000, "Member 'MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType::Character' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType, AmountToCheck) == 0x000008, "Member 'MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType::AmountToCheck' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType, CurrencyType) == 0x00000C, "Member 'MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType::CurrencyType' has a wrong offset!");
static_assert(offsetof(MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType, ReturnValue) == 0x00000D, "Member 'MatchaBattleRoyaleServerScript_HasEnoughCurrencyOfType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBreakableEntity.GetDamage
// 0x0004 (0x0004 - 0x0000)
struct MatchaBreakableEntity_GetDamage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBreakableEntity_GetDamage) == 0x000004, "Wrong alignment on MatchaBreakableEntity_GetDamage");
static_assert(sizeof(MatchaBreakableEntity_GetDamage) == 0x000004, "Wrong size on MatchaBreakableEntity_GetDamage");
static_assert(offsetof(MatchaBreakableEntity_GetDamage, ReturnValue) == 0x000000, "Member 'MatchaBreakableEntity_GetDamage::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBreakableEntity.GetMaxDamage
// 0x0004 (0x0004 - 0x0000)
struct MatchaBreakableEntity_GetMaxDamage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBreakableEntity_GetMaxDamage) == 0x000004, "Wrong alignment on MatchaBreakableEntity_GetMaxDamage");
static_assert(sizeof(MatchaBreakableEntity_GetMaxDamage) == 0x000004, "Wrong size on MatchaBreakableEntity_GetMaxDamage");
static_assert(offsetof(MatchaBreakableEntity_GetMaxDamage, ReturnValue) == 0x000000, "Member 'MatchaBreakableEntity_GetMaxDamage::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBreakableEntity.IsAlive
// 0x0001 (0x0001 - 0x0000)
struct MatchaBreakableEntity_IsAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBreakableEntity_IsAlive) == 0x000001, "Wrong alignment on MatchaBreakableEntity_IsAlive");
static_assert(sizeof(MatchaBreakableEntity_IsAlive) == 0x000001, "Wrong size on MatchaBreakableEntity_IsAlive");
static_assert(offsetof(MatchaBreakableEntity_IsAlive, ReturnValue) == 0x000000, "Member 'MatchaBreakableEntity_IsAlive::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBreakableEntity.IsBroken
// 0x0001 (0x0001 - 0x0000)
struct MatchaBreakableEntity_IsBroken final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBreakableEntity_IsBroken) == 0x000001, "Wrong alignment on MatchaBreakableEntity_IsBroken");
static_assert(sizeof(MatchaBreakableEntity_IsBroken) == 0x000001, "Wrong size on MatchaBreakableEntity_IsBroken");
static_assert(offsetof(MatchaBreakableEntity_IsBroken, ReturnValue) == 0x000000, "Member 'MatchaBreakableEntity_IsBroken::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaBreakableRenderer.OnIsAliveChanged
// 0x0001 (0x0001 - 0x0000)
struct MatchaBreakableRenderer_OnIsAliveChanged final
{
public:
	bool                                          bNewIsAlive;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaBreakableRenderer_OnIsAliveChanged) == 0x000001, "Wrong alignment on MatchaBreakableRenderer_OnIsAliveChanged");
static_assert(sizeof(MatchaBreakableRenderer_OnIsAliveChanged) == 0x000001, "Wrong size on MatchaBreakableRenderer_OnIsAliveChanged");
static_assert(offsetof(MatchaBreakableRenderer_OnIsAliveChanged, bNewIsAlive) == 0x000000, "Member 'MatchaBreakableRenderer_OnIsAliveChanged::bNewIsAlive' has a wrong offset!");

// Function Matcha.MatchaClientServicesConfiguration.GetWebSocketUrl
// 0x0010 (0x0010 - 0x0000)
struct MatchaClientServicesConfiguration_GetWebSocketUrl final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaClientServicesConfiguration_GetWebSocketUrl) == 0x000008, "Wrong alignment on MatchaClientServicesConfiguration_GetWebSocketUrl");
static_assert(sizeof(MatchaClientServicesConfiguration_GetWebSocketUrl) == 0x000010, "Wrong size on MatchaClientServicesConfiguration_GetWebSocketUrl");
static_assert(offsetof(MatchaClientServicesConfiguration_GetWebSocketUrl, ReturnValue) == 0x000000, "Member 'MatchaClientServicesConfiguration_GetWebSocketUrl::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaChallengeHandlerBase.OnGameplayEvent
// 0x0014 (0x0014 - 0x0000)
struct MatchaChallengeHandlerBase_OnGameplayEvent final
{
public:
	struct FMatchaGameplayEvent                   MatchaGameplayEvent;                               // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaChallengeHandlerBase_OnGameplayEvent) == 0x000004, "Wrong alignment on MatchaChallengeHandlerBase_OnGameplayEvent");
static_assert(sizeof(MatchaChallengeHandlerBase_OnGameplayEvent) == 0x000014, "Wrong size on MatchaChallengeHandlerBase_OnGameplayEvent");
static_assert(offsetof(MatchaChallengeHandlerBase_OnGameplayEvent, MatchaGameplayEvent) == 0x000000, "Member 'MatchaChallengeHandlerBase_OnGameplayEvent::MatchaGameplayEvent' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.ModifyOutGoingHitBoxDamage
// 0x0018 (0x0018 - 0x0000)
struct MatchaCharacterBuff_ModifyOutGoingHitBoxDamage final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseHitBoxDamage;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_ModifyOutGoingHitBoxDamage) == 0x000008, "Wrong alignment on MatchaCharacterBuff_ModifyOutGoingHitBoxDamage");
static_assert(sizeof(MatchaCharacterBuff_ModifyOutGoingHitBoxDamage) == 0x000018, "Wrong size on MatchaCharacterBuff_ModifyOutGoingHitBoxDamage");
static_assert(offsetof(MatchaCharacterBuff_ModifyOutGoingHitBoxDamage, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_ModifyOutGoingHitBoxDamage::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_ModifyOutGoingHitBoxDamage, BaseHitBoxDamage) == 0x000008, "Member 'MatchaCharacterBuff_ModifyOutGoingHitBoxDamage::BaseHitBoxDamage' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_ModifyOutGoingHitBoxDamage, BuffRarity) == 0x00000C, "Member 'MatchaCharacterBuff_ModifyOutGoingHitBoxDamage::BuffRarity' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_ModifyOutGoingHitBoxDamage, ReturnValue) == 0x000010, "Member 'MatchaCharacterBuff_ModifyOutGoingHitBoxDamage::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnBuffApplied
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnBuffApplied final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnBuffApplied) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnBuffApplied");
static_assert(sizeof(MatchaCharacterBuff_OnBuffApplied) == 0x000010, "Wrong size on MatchaCharacterBuff_OnBuffApplied");
static_assert(offsetof(MatchaCharacterBuff_OnBuffApplied, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnBuffApplied::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnBuffApplied, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnBuffApplied::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnBuffRefreshed
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnBuffRefreshed final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnBuffRefreshed) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnBuffRefreshed");
static_assert(sizeof(MatchaCharacterBuff_OnBuffRefreshed) == 0x000010, "Wrong size on MatchaCharacterBuff_OnBuffRefreshed");
static_assert(offsetof(MatchaCharacterBuff_OnBuffRefreshed, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnBuffRefreshed::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnBuffRefreshed, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnBuffRefreshed::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnBuffRemoved
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnBuffRemoved final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnBuffRemoved) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnBuffRemoved");
static_assert(sizeof(MatchaCharacterBuff_OnBuffRemoved) == 0x000010, "Wrong size on MatchaCharacterBuff_OnBuffRemoved");
static_assert(offsetof(MatchaCharacterBuff_OnBuffRemoved, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnBuffRemoved::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnBuffRemoved, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnBuffRemoved::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterCrouchEnd
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterCrouchEnd final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterCrouchEnd) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterCrouchEnd");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterCrouchEnd) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterCrouchEnd");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterCrouchEnd, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterCrouchEnd::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterCrouchEnd, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterCrouchEnd::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterCrouchStart
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterCrouchStart final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterCrouchStart) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterCrouchStart");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterCrouchStart) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterCrouchStart");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterCrouchStart, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterCrouchStart::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterCrouchStart, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterCrouchStart::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterEnteredKOZone
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterEnteredKOZone final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterEnteredKOZone) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterEnteredKOZone");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterEnteredKOZone) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterEnteredKOZone");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterEnteredKOZone, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterEnteredKOZone::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterEnteredKOZone, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterEnteredKOZone::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterExitedKOZone
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterExitedKOZone final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterExitedKOZone) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterExitedKOZone");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterExitedKOZone) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterExitedKOZone");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterExitedKOZone, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterExitedKOZone::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterExitedKOZone, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterExitedKOZone::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterJump
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterJump final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJumpType                                     JumpType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterJump) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterJump");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterJump) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterJump");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterJump, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterJump::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterJump, JumpType) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterJump::JumpType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterJump, BuffRarity) == 0x000009, "Member 'MatchaCharacterBuff_OnCharacterJump::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterLand
// 0x0018 (0x0018 - 0x0000)
struct MatchaCharacterBuff_OnCharacterLand final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFallType                                     FallTypeBeforeLand;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageBeforeLand;                                 // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MillisecondsInAirBeforeLand;                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterLand) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterLand");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterLand) == 0x000018, "Wrong size on MatchaCharacterBuff_OnCharacterLand");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterLand, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterLand::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterLand, FallTypeBeforeLand) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterLand::FallTypeBeforeLand' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterLand, MontageBeforeLand) == 0x000009, "Member 'MatchaCharacterBuff_OnCharacterLand::MontageBeforeLand' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterLand, MillisecondsInAirBeforeLand) == 0x00000C, "Member 'MatchaCharacterBuff_OnCharacterLand::MillisecondsInAirBeforeLand' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterLand, BuffRarity) == 0x000010, "Member 'MatchaCharacterBuff_OnCharacterLand::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterMontageEnd
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterMontageEnd final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterMontageEnd) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterMontageEnd");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterMontageEnd) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterMontageEnd");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterMontageEnd, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterMontageEnd::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterMontageEnd, MontageType) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterMontageEnd::MontageType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterMontageEnd, BuffRarity) == 0x000009, "Member 'MatchaCharacterBuff_OnCharacterMontageEnd::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterMontageStart
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterMontageStart final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageDuration;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageType;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   PreviousMontageType;                               // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x000E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterMontageStart) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterMontageStart");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterMontageStart) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterMontageStart");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterMontageStart, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterMontageStart::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterMontageStart, MontageDuration) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterMontageStart::MontageDuration' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterMontageStart, MontageType) == 0x00000C, "Member 'MatchaCharacterBuff_OnCharacterMontageStart::MontageType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterMontageStart, PreviousMontageType) == 0x00000D, "Member 'MatchaCharacterBuff_OnCharacterMontageStart::PreviousMontageType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterMontageStart, BuffRarity) == 0x00000E, "Member 'MatchaCharacterBuff_OnCharacterMontageStart::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterPeformedTech
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterPeformedTech final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterPeformedTech) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterPeformedTech");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterPeformedTech) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterPeformedTech");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterPeformedTech, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterPeformedTech::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterPeformedTech, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterPeformedTech::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterShieldStateChanged
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterShieldStateChanged final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaShieldState                            PreviousShieldState;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaShieldState                            NewShieldState;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterShieldStateChanged) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterShieldStateChanged");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterShieldStateChanged) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterShieldStateChanged");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterShieldStateChanged, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterShieldStateChanged::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterShieldStateChanged, PreviousShieldState) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterShieldStateChanged::PreviousShieldState' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterShieldStateChanged, NewShieldState) == 0x000009, "Member 'MatchaCharacterBuff_OnCharacterShieldStateChanged::NewShieldState' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterShieldStateChanged, BuffRarity) == 0x00000A, "Member 'MatchaCharacterBuff_OnCharacterShieldStateChanged::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterStartDash
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterStartDash final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterStartDash) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterStartDash");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterStartDash) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterStartDash");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterStartDash, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterStartDash::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterStartDash, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterStartDash::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterStartDodge
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterStartDodge final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterStartDodge) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterStartDodge");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterStartDodge) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterStartDodge");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterStartDodge, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterStartDodge::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterStartDodge, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterStartDodge::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnCharacterStartGroundedJump
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnCharacterStartGroundedJump final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnCharacterStartGroundedJump) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnCharacterStartGroundedJump");
static_assert(sizeof(MatchaCharacterBuff_OnCharacterStartGroundedJump) == 0x000010, "Wrong size on MatchaCharacterBuff_OnCharacterStartGroundedJump");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterStartGroundedJump, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnCharacterStartGroundedJump::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnCharacterStartGroundedJump, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnCharacterStartGroundedJump::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnKnockedOutAnEnemyCharacter
// 0x0018 (0x0018 - 0x0000)
struct MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EnemyCharacter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter");
static_assert(sizeof(MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter) == 0x000018, "Wrong size on MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter");
static_assert(offsetof(MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter, EnemyCharacter) == 0x000008, "Member 'MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter::EnemyCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter, BuffRarity) == 0x000010, "Member 'MatchaCharacterBuff_OnKnockedOutAnEnemyCharacter::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnMontageSpawnedHitBox
// 0x0018 (0x0018 - 0x0000)
struct MatchaCharacterBuff_OnMontageSpawnedHitBox final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MontageHitBoxCount;                                // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnMontageSpawnedHitBox) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnMontageSpawnedHitBox");
static_assert(sizeof(MatchaCharacterBuff_OnMontageSpawnedHitBox) == 0x000018, "Wrong size on MatchaCharacterBuff_OnMontageSpawnedHitBox");
static_assert(offsetof(MatchaCharacterBuff_OnMontageSpawnedHitBox, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnMontageSpawnedHitBox::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnMontageSpawnedHitBox, MontageType) == 0x000008, "Member 'MatchaCharacterBuff_OnMontageSpawnedHitBox::MontageType' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnMontageSpawnedHitBox, MontageHitBoxCount) == 0x00000C, "Member 'MatchaCharacterBuff_OnMontageSpawnedHitBox::MontageHitBoxCount' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnMontageSpawnedHitBox, BuffRarity) == 0x000010, "Member 'MatchaCharacterBuff_OnMontageSpawnedHitBox::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnOtherBuffApplied
// 0x0018 (0x0018 - 0x0000)
struct MatchaCharacterBuff_OnOtherBuffApplied final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UMatchaCharacterBuff*             OtherBuff;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 OtherBuffRarity;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnOtherBuffApplied) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnOtherBuffApplied");
static_assert(sizeof(MatchaCharacterBuff_OnOtherBuffApplied) == 0x000018, "Wrong size on MatchaCharacterBuff_OnOtherBuffApplied");
static_assert(offsetof(MatchaCharacterBuff_OnOtherBuffApplied, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnOtherBuffApplied::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnOtherBuffApplied, OtherBuff) == 0x000008, "Member 'MatchaCharacterBuff_OnOtherBuffApplied::OtherBuff' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnOtherBuffApplied, OtherBuffRarity) == 0x000010, "Member 'MatchaCharacterBuff_OnOtherBuffApplied::OtherBuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnOtherBuffRemoved
// 0x0018 (0x0018 - 0x0000)
struct MatchaCharacterBuff_OnOtherBuffRemoved final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UMatchaCharacterBuff*             OtherBuff;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnOtherBuffRemoved) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnOtherBuffRemoved");
static_assert(sizeof(MatchaCharacterBuff_OnOtherBuffRemoved) == 0x000018, "Wrong size on MatchaCharacterBuff_OnOtherBuffRemoved");
static_assert(offsetof(MatchaCharacterBuff_OnOtherBuffRemoved, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnOtherBuffRemoved::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnOtherBuffRemoved, OtherBuff) == 0x000008, "Member 'MatchaCharacterBuff_OnOtherBuffRemoved::OtherBuff' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnOtherBuffRemoved, BuffRarity) == 0x000010, "Member 'MatchaCharacterBuff_OnOtherBuffRemoved::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnPerfectShield
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnPerfectShield final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnPerfectShield) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnPerfectShield");
static_assert(sizeof(MatchaCharacterBuff_OnPerfectShield) == 0x000010, "Wrong size on MatchaCharacterBuff_OnPerfectShield");
static_assert(offsetof(MatchaCharacterBuff_OnPerfectShield, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnPerfectShield::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPerfectShield, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnPerfectShield::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnPostApplyIncomingHit
// 0x0098 (0x0098 - 0x0000)
struct MatchaCharacterBuff_OnPostApplyIncomingHit final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitInstigator;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaHitData                         TakenHitData;                                      // 0x0010(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bDidResistWithSuperArmor;                          // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasStunHitInsteadOfKnockBack;                     // 0x0089(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CombinedDamage;                                    // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinedShieldDamage;                              // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnPostApplyIncomingHit) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnPostApplyIncomingHit");
static_assert(sizeof(MatchaCharacterBuff_OnPostApplyIncomingHit) == 0x000098, "Wrong size on MatchaCharacterBuff_OnPostApplyIncomingHit");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyIncomingHit, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnPostApplyIncomingHit::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyIncomingHit, HitInstigator) == 0x000008, "Member 'MatchaCharacterBuff_OnPostApplyIncomingHit::HitInstigator' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyIncomingHit, TakenHitData) == 0x000010, "Member 'MatchaCharacterBuff_OnPostApplyIncomingHit::TakenHitData' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyIncomingHit, bDidResistWithSuperArmor) == 0x000088, "Member 'MatchaCharacterBuff_OnPostApplyIncomingHit::bDidResistWithSuperArmor' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyIncomingHit, bWasStunHitInsteadOfKnockBack) == 0x000089, "Member 'MatchaCharacterBuff_OnPostApplyIncomingHit::bWasStunHitInsteadOfKnockBack' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyIncomingHit, CombinedDamage) == 0x00008C, "Member 'MatchaCharacterBuff_OnPostApplyIncomingHit::CombinedDamage' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyIncomingHit, CombinedShieldDamage) == 0x000090, "Member 'MatchaCharacterBuff_OnPostApplyIncomingHit::CombinedShieldDamage' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyIncomingHit, BuffRarity) == 0x000094, "Member 'MatchaCharacterBuff_OnPostApplyIncomingHit::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnPostApplyOutgoingHit
// 0x0098 (0x0098 - 0x0000)
struct MatchaCharacterBuff_OnPostApplyOutgoingHit final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetHit;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PreviousTargetHit;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaHitData                         HitData;                                           // 0x0018(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         AppliedHitFlags;                                   // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageDuringHit;                                  // 0x0091(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0092(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnPostApplyOutgoingHit) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnPostApplyOutgoingHit");
static_assert(sizeof(MatchaCharacterBuff_OnPostApplyOutgoingHit) == 0x000098, "Wrong size on MatchaCharacterBuff_OnPostApplyOutgoingHit");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyOutgoingHit, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnPostApplyOutgoingHit::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyOutgoingHit, TargetHit) == 0x000008, "Member 'MatchaCharacterBuff_OnPostApplyOutgoingHit::TargetHit' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyOutgoingHit, PreviousTargetHit) == 0x000010, "Member 'MatchaCharacterBuff_OnPostApplyOutgoingHit::PreviousTargetHit' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyOutgoingHit, HitData) == 0x000018, "Member 'MatchaCharacterBuff_OnPostApplyOutgoingHit::HitData' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyOutgoingHit, AppliedHitFlags) == 0x000090, "Member 'MatchaCharacterBuff_OnPostApplyOutgoingHit::AppliedHitFlags' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyOutgoingHit, MontageDuringHit) == 0x000091, "Member 'MatchaCharacterBuff_OnPostApplyOutgoingHit::MontageDuringHit' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPostApplyOutgoingHit, BuffRarity) == 0x000092, "Member 'MatchaCharacterBuff_OnPostApplyOutgoingHit::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnPreApplyIncomingHit
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnPreApplyIncomingHit final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnPreApplyIncomingHit) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnPreApplyIncomingHit");
static_assert(sizeof(MatchaCharacterBuff_OnPreApplyIncomingHit) == 0x000010, "Wrong size on MatchaCharacterBuff_OnPreApplyIncomingHit");
static_assert(offsetof(MatchaCharacterBuff_OnPreApplyIncomingHit, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnPreApplyIncomingHit::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPreApplyIncomingHit, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnPreApplyIncomingHit::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnPreApplyOutgoingHit
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnPreApplyOutgoingHit final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnPreApplyOutgoingHit) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnPreApplyOutgoingHit");
static_assert(sizeof(MatchaCharacterBuff_OnPreApplyOutgoingHit) == 0x000010, "Wrong size on MatchaCharacterBuff_OnPreApplyOutgoingHit");
static_assert(offsetof(MatchaCharacterBuff_OnPreApplyOutgoingHit, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnPreApplyOutgoingHit::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnPreApplyOutgoingHit, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnPreApplyOutgoingHit::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnShieldBlockedAHit
// 0x0020 (0x0020 - 0x0000)
struct MatchaCharacterBuff_OnShieldBlockedAHit final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitInstigator;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreHitShieldHealth;                                // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDidShieldBreak;                                   // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageShielded;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDidPerfectShieldHit;                              // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnShieldBlockedAHit) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnShieldBlockedAHit");
static_assert(sizeof(MatchaCharacterBuff_OnShieldBlockedAHit) == 0x000020, "Wrong size on MatchaCharacterBuff_OnShieldBlockedAHit");
static_assert(offsetof(MatchaCharacterBuff_OnShieldBlockedAHit, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnShieldBlockedAHit::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnShieldBlockedAHit, HitInstigator) == 0x000008, "Member 'MatchaCharacterBuff_OnShieldBlockedAHit::HitInstigator' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnShieldBlockedAHit, PreHitShieldHealth) == 0x000010, "Member 'MatchaCharacterBuff_OnShieldBlockedAHit::PreHitShieldHealth' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnShieldBlockedAHit, bDidShieldBreak) == 0x000014, "Member 'MatchaCharacterBuff_OnShieldBlockedAHit::bDidShieldBreak' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnShieldBlockedAHit, DamageShielded) == 0x000018, "Member 'MatchaCharacterBuff_OnShieldBlockedAHit::DamageShielded' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnShieldBlockedAHit, bDidPerfectShieldHit) == 0x00001C, "Member 'MatchaCharacterBuff_OnShieldBlockedAHit::bDidPerfectShieldHit' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnShieldBlockedAHit, BuffRarity) == 0x00001D, "Member 'MatchaCharacterBuff_OnShieldBlockedAHit::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnSpawnedOwnedEntity
// 0x0018 (0x0018 - 0x0000)
struct MatchaCharacterBuff_OnSpawnedOwnedEntity final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedEntity;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnSpawnedOwnedEntity) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnSpawnedOwnedEntity");
static_assert(sizeof(MatchaCharacterBuff_OnSpawnedOwnedEntity) == 0x000018, "Wrong size on MatchaCharacterBuff_OnSpawnedOwnedEntity");
static_assert(offsetof(MatchaCharacterBuff_OnSpawnedOwnedEntity, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnSpawnedOwnedEntity::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnSpawnedOwnedEntity, SpawnedEntity) == 0x000008, "Member 'MatchaCharacterBuff_OnSpawnedOwnedEntity::SpawnedEntity' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnSpawnedOwnedEntity, BuffRarity) == 0x000010, "Member 'MatchaCharacterBuff_OnSpawnedOwnedEntity::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterBuff.OnTechCanceledTumbling
// 0x0010 (0x0010 - 0x0000)
struct MatchaCharacterBuff_OnTechCanceledTumbling final
{
public:
	class AMatchaSnapNetCharacterEntity*          BuffedCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 BuffRarity;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaCharacterBuff_OnTechCanceledTumbling) == 0x000008, "Wrong alignment on MatchaCharacterBuff_OnTechCanceledTumbling");
static_assert(sizeof(MatchaCharacterBuff_OnTechCanceledTumbling) == 0x000010, "Wrong size on MatchaCharacterBuff_OnTechCanceledTumbling");
static_assert(offsetof(MatchaCharacterBuff_OnTechCanceledTumbling, BuffedCharacter) == 0x000000, "Member 'MatchaCharacterBuff_OnTechCanceledTumbling::BuffedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaCharacterBuff_OnTechCanceledTumbling, BuffRarity) == 0x000008, "Member 'MatchaCharacterBuff_OnTechCanceledTumbling::BuffRarity' has a wrong offset!");

// Function Matcha.MatchaCharacterLaunchComponent.PerformLaunch
// 0x0008 (0x0008 - 0x0000)
struct MatchaCharacterLaunchComponent_PerformLaunch final
{
public:
	class AMatchaCharacterBase*                   Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaCharacterLaunchComponent_PerformLaunch) == 0x000008, "Wrong alignment on MatchaCharacterLaunchComponent_PerformLaunch");
static_assert(sizeof(MatchaCharacterLaunchComponent_PerformLaunch) == 0x000008, "Wrong size on MatchaCharacterLaunchComponent_PerformLaunch");
static_assert(offsetof(MatchaCharacterLaunchComponent_PerformLaunch, Character) == 0x000000, "Member 'MatchaCharacterLaunchComponent_PerformLaunch::Character' has a wrong offset!");

// Function Matcha.MatchaClientServices.OnWebsocketConnectionStateChanged
// 0x0008 (0x0008 - 0x0000)
struct MatchaClientServices_OnWebsocketConnectionStateChanged final
{
public:
	class UOdyServicesModelBase*                  ModelBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaClientServices_OnWebsocketConnectionStateChanged) == 0x000008, "Wrong alignment on MatchaClientServices_OnWebsocketConnectionStateChanged");
static_assert(sizeof(MatchaClientServices_OnWebsocketConnectionStateChanged) == 0x000008, "Wrong size on MatchaClientServices_OnWebsocketConnectionStateChanged");
static_assert(offsetof(MatchaClientServices_OnWebsocketConnectionStateChanged, ModelBase) == 0x000000, "Member 'MatchaClientServices_OnWebsocketConnectionStateChanged::ModelBase' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.Conv_SnapNetPropertyVector2DToVector2D
// 0x0078 (0x0078 - 0x0000)
struct MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D final
{
public:
	struct FSnapNetPropertyVector2D               SnapNetPropertyVector2D;                           // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0068(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D");
static_assert(sizeof(MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D) == 0x000078, "Wrong size on MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D");
static_assert(offsetof(MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D, SnapNetPropertyVector2D) == 0x000000, "Member 'MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D::SnapNetPropertyVector2D' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D, ReturnValue) == 0x000068, "Member 'MatchaSnapNetStatics_Conv_SnapNetPropertyVector2DToVector2D::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.DestroyEntity
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_DestroyEntity final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_DestroyEntity) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_DestroyEntity");
static_assert(sizeof(MatchaSnapNetStatics_DestroyEntity) == 0x000010, "Wrong size on MatchaSnapNetStatics_DestroyEntity");
static_assert(offsetof(MatchaSnapNetStatics_DestroyEntity, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_DestroyEntity::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_DestroyEntity, EntityIndex) == 0x000008, "Member 'MatchaSnapNetStatics_DestroyEntity::EntityIndex' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetCharacterEntityClassFromIndex
// 0x0038 (0x0038 - 0x0000)
struct MatchaSnapNetStatics_GetCharacterEntityClassFromIndex final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClassIndex;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ReturnValue;                                       // 0x0010(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetCharacterEntityClassFromIndex) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetCharacterEntityClassFromIndex");
static_assert(sizeof(MatchaSnapNetStatics_GetCharacterEntityClassFromIndex) == 0x000038, "Wrong size on MatchaSnapNetStatics_GetCharacterEntityClassFromIndex");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityClassFromIndex, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetCharacterEntityClassFromIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityClassFromIndex, ClassIndex) == 0x000008, "Member 'MatchaSnapNetStatics_GetCharacterEntityClassFromIndex::ClassIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityClassFromIndex, ReturnValue) == 0x000010, "Member 'MatchaSnapNetStatics_GetCharacterEntityClassFromIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetCharacterEntityClassIndex
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetStatics_GetCharacterEntityClassIndex final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AMatchaSnapNetCharacterEntity*    CharacterEntity;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetCharacterEntityClassIndex) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetCharacterEntityClassIndex");
static_assert(sizeof(MatchaSnapNetStatics_GetCharacterEntityClassIndex) == 0x000018, "Wrong size on MatchaSnapNetStatics_GetCharacterEntityClassIndex");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityClassIndex, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetCharacterEntityClassIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityClassIndex, CharacterEntity) == 0x000008, "Member 'MatchaSnapNetStatics_GetCharacterEntityClassIndex::CharacterEntity' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityClassIndex, ReturnValue) == 0x000010, "Member 'MatchaSnapNetStatics_GetCharacterEntityClassIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetCharacterEntityForFirstLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetCharacterEntity*          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetCharacterEntityForFirstLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetCharacterEntityForLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer final
{
public:
	class ULocalPlayer*                           LocalPlayer;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetCharacterEntity*          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer, LocalPlayer) == 0x000000, "Member 'MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer::LocalPlayer' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetCharacterEntityForLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetCharacterRendererForFirstLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetCharacterRenderer*        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetCharacterRendererForFirstLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetCharacterRendererForLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer final
{
public:
	class ULocalPlayer*                           LocalPlayer;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetCharacterRenderer*        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer, LocalPlayer) == 0x000000, "Member 'MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer::LocalPlayer' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetCharacterRendererForLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetDebugVisualizerWorld
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetDebugVisualizerWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetDebugVisualizerWorld) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetDebugVisualizerWorld");
static_assert(sizeof(MatchaSnapNetStatics_GetDebugVisualizerWorld) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetDebugVisualizerWorld");
static_assert(offsetof(MatchaSnapNetStatics_GetDebugVisualizerWorld, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetDebugVisualizerWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetDebugVisualizerWorld, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetDebugVisualizerWorld::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetEntityByClass
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetStatics_GetEntityByClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UClass*                           EntityClass;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetEntityByClass) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetEntityByClass");
static_assert(sizeof(MatchaSnapNetStatics_GetEntityByClass) == 0x000018, "Wrong size on MatchaSnapNetStatics_GetEntityByClass");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityByClass, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetEntityByClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityByClass, EntityClass) == 0x000008, "Member 'MatchaSnapNetStatics_GetEntityByClass::EntityClass' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityByClass, ReturnValue) == 0x000010, "Member 'MatchaSnapNetStatics_GetEntityByClass::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetEntityByIndex
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetStatics_GetEntityByIndex final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetEntityByIndex) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetEntityByIndex");
static_assert(sizeof(MatchaSnapNetStatics_GetEntityByIndex) == 0x000018, "Wrong size on MatchaSnapNetStatics_GetEntityByIndex");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityByIndex, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetEntityByIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityByIndex, EntityIndex) == 0x000008, "Member 'MatchaSnapNetStatics_GetEntityByIndex::EntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityByIndex, ReturnValue) == 0x000010, "Member 'MatchaSnapNetStatics_GetEntityByIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetEntityIndex
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetEntityIndex final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetEntityIndex) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetEntityIndex");
static_assert(sizeof(MatchaSnapNetStatics_GetEntityIndex) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetEntityIndex");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityIndex, Actor) == 0x000000, "Member 'MatchaSnapNetStatics_GetEntityIndex::Actor' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityIndex, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetEntityIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetEntityRendererByIndex
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetStatics_GetEntityRendererByIndex final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetEntityRendererByIndex) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetEntityRendererByIndex");
static_assert(sizeof(MatchaSnapNetStatics_GetEntityRendererByIndex) == 0x000018, "Wrong size on MatchaSnapNetStatics_GetEntityRendererByIndex");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityRendererByIndex, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetEntityRendererByIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityRendererByIndex, EntityIndex) == 0x000008, "Member 'MatchaSnapNetStatics_GetEntityRendererByIndex::EntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityRendererByIndex, ReturnValue) == 0x000010, "Member 'MatchaSnapNetStatics_GetEntityRendererByIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetEntityRendererComponentByIndex
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetStatics_GetEntityRendererComponentByIndex final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USnapNetEntityRendererComponent*        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetEntityRendererComponentByIndex) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetEntityRendererComponentByIndex");
static_assert(sizeof(MatchaSnapNetStatics_GetEntityRendererComponentByIndex) == 0x000018, "Wrong size on MatchaSnapNetStatics_GetEntityRendererComponentByIndex");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityRendererComponentByIndex, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetEntityRendererComponentByIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityRendererComponentByIndex, EntityIndex) == 0x000008, "Member 'MatchaSnapNetStatics_GetEntityRendererComponentByIndex::EntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetEntityRendererComponentByIndex, ReturnValue) == 0x000010, "Member 'MatchaSnapNetStatics_GetEntityRendererComponentByIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetFirstLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetFirstLocalPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULocalPlayer*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetFirstLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetFirstLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetFirstLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetFirstLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetFirstLocalPlayer, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetFirstLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetFirstLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetFirstLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetListenPort
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetStatics_GetListenPort final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetListenPort) == 0x000004, "Wrong alignment on MatchaSnapNetStatics_GetListenPort");
static_assert(sizeof(MatchaSnapNetStatics_GetListenPort) == 0x000004, "Wrong size on MatchaSnapNetStatics_GetListenPort");
static_assert(offsetof(MatchaSnapNetStatics_GetListenPort, ReturnValue) == 0x000000, "Member 'MatchaSnapNetStatics_GetListenPort::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetLocalPlayerIndexForFirstLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetLocalPlayerIndexForFirstLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetLocalPlayerIndexForLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer final
{
public:
	class ULocalPlayer*                           LocalPlayer;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer, LocalPlayer) == 0x000000, "Member 'MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer::LocalPlayer' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetLocalPlayerIndexForLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetPlayerEntityForFirstLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetPlayerEntity*             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetPlayerEntityForFirstLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetPlayerEntityForLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer final
{
public:
	class ULocalPlayer*                           LocalPlayer;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetPlayerEntity*             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer, LocalPlayer) == 0x000000, "Member 'MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer::LocalPlayer' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetPlayerEntityForLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetPlayerIndexForFirstLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetPlayerIndexForFirstLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetPlayerIndexForLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer final
{
public:
	class ULocalPlayer*                           LocalPlayer;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer, LocalPlayer) == 0x000000, "Member 'MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer::LocalPlayer' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetPlayerIndexForLocalPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetSnapNetSimulationFrameType
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetSnapNetSimulationFrameType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapNetSimulationFrameType                   ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetSnapNetSimulationFrameType) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetSnapNetSimulationFrameType");
static_assert(sizeof(MatchaSnapNetStatics_GetSnapNetSimulationFrameType) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetSnapNetSimulationFrameType");
static_assert(offsetof(MatchaSnapNetStatics_GetSnapNetSimulationFrameType, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetSnapNetSimulationFrameType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetSnapNetSimulationFrameType, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetSnapNetSimulationFrameType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetSnapNetWorldType
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetSnapNetWorldType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapNetWorldType                             ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetSnapNetWorldType) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetSnapNetWorldType");
static_assert(sizeof(MatchaSnapNetStatics_GetSnapNetWorldType) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetSnapNetWorldType");
static_assert(offsetof(MatchaSnapNetStatics_GetSnapNetWorldType, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetSnapNetWorldType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetSnapNetWorldType, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetSnapNetWorldType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetSpectatedCharacterEntityIndex
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex");
static_assert(sizeof(MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex");
static_assert(offsetof(MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetSpectatedCharacterEntityIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetSpectatedPlayerIndex
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetSpectatedPlayerIndex final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetSpectatedPlayerIndex) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetSpectatedPlayerIndex");
static_assert(sizeof(MatchaSnapNetStatics_GetSpectatedPlayerIndex) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetSpectatedPlayerIndex");
static_assert(offsetof(MatchaSnapNetStatics_GetSpectatedPlayerIndex, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetSpectatedPlayerIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetSpectatedPlayerIndex, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetSpectatedPlayerIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetSpectatedTeamNumber
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_GetSpectatedTeamNumber final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetSpectatedTeamNumber) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetSpectatedTeamNumber");
static_assert(sizeof(MatchaSnapNetStatics_GetSpectatedTeamNumber) == 0x000010, "Wrong size on MatchaSnapNetStatics_GetSpectatedTeamNumber");
static_assert(offsetof(MatchaSnapNetStatics_GetSpectatedTeamNumber, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetSpectatedTeamNumber::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetSpectatedTeamNumber, ReturnValue) == 0x000008, "Member 'MatchaSnapNetStatics_GetSpectatedTeamNumber::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetWorldRenderPositionForEntity
// 0x0030 (0x0030 - 0x0000)
struct MatchaSnapNetStatics_GetWorldRenderPositionForEntity final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutPosition;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetWorldRenderPositionForEntity) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetWorldRenderPositionForEntity");
static_assert(sizeof(MatchaSnapNetStatics_GetWorldRenderPositionForEntity) == 0x000030, "Wrong size on MatchaSnapNetStatics_GetWorldRenderPositionForEntity");
static_assert(offsetof(MatchaSnapNetStatics_GetWorldRenderPositionForEntity, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetWorldRenderPositionForEntity::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetWorldRenderPositionForEntity, EntityIndex) == 0x000008, "Member 'MatchaSnapNetStatics_GetWorldRenderPositionForEntity::EntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetWorldRenderPositionForEntity, OutPosition) == 0x000010, "Member 'MatchaSnapNetStatics_GetWorldRenderPositionForEntity::OutPosition' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetWorldRenderPositionForEntity, ReturnValue) == 0x000028, "Member 'MatchaSnapNetStatics_GetWorldRenderPositionForEntity::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.GetWorldRenderPositionForPlayer
// 0x0030 (0x0030 - 0x0000)
struct MatchaSnapNetStatics_GetWorldRenderPositionForPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutPosition;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_GetWorldRenderPositionForPlayer) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_GetWorldRenderPositionForPlayer");
static_assert(sizeof(MatchaSnapNetStatics_GetWorldRenderPositionForPlayer) == 0x000030, "Wrong size on MatchaSnapNetStatics_GetWorldRenderPositionForPlayer");
static_assert(offsetof(MatchaSnapNetStatics_GetWorldRenderPositionForPlayer, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_GetWorldRenderPositionForPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetWorldRenderPositionForPlayer, PlayerIndex) == 0x000008, "Member 'MatchaSnapNetStatics_GetWorldRenderPositionForPlayer::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetWorldRenderPositionForPlayer, OutPosition) == 0x000010, "Member 'MatchaSnapNetStatics_GetWorldRenderPositionForPlayer::OutPosition' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_GetWorldRenderPositionForPlayer, ReturnValue) == 0x000028, "Member 'MatchaSnapNetStatics_GetWorldRenderPositionForPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.IsEntityIndexPropertyValid
// 0x0070 (0x0070 - 0x0000)
struct MatchaSnapNetStatics_IsEntityIndexPropertyValid final
{
public:
	struct FSnapNetPropertyEntityIndex            EntityIndex;                                       // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_IsEntityIndexPropertyValid) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_IsEntityIndexPropertyValid");
static_assert(sizeof(MatchaSnapNetStatics_IsEntityIndexPropertyValid) == 0x000070, "Wrong size on MatchaSnapNetStatics_IsEntityIndexPropertyValid");
static_assert(offsetof(MatchaSnapNetStatics_IsEntityIndexPropertyValid, EntityIndex) == 0x000000, "Member 'MatchaSnapNetStatics_IsEntityIndexPropertyValid::EntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_IsEntityIndexPropertyValid, ReturnValue) == 0x000068, "Member 'MatchaSnapNetStatics_IsEntityIndexPropertyValid::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.IsEntityIndexValid
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetStatics_IsEntityIndexValid final
{
public:
	int32                                         EntityIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_IsEntityIndexValid) == 0x000004, "Wrong alignment on MatchaSnapNetStatics_IsEntityIndexValid");
static_assert(sizeof(MatchaSnapNetStatics_IsEntityIndexValid) == 0x000008, "Wrong size on MatchaSnapNetStatics_IsEntityIndexValid");
static_assert(offsetof(MatchaSnapNetStatics_IsEntityIndexValid, EntityIndex) == 0x000000, "Member 'MatchaSnapNetStatics_IsEntityIndexValid::EntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_IsEntityIndexValid, ReturnValue) == 0x000004, "Member 'MatchaSnapNetStatics_IsEntityIndexValid::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.IsEntityOnSpectatedTeam
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetStatics_IsEntityOnSpectatedTeam final
{
public:
	int32                                         EntityIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          WorldContextObject;                                // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_IsEntityOnSpectatedTeam) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_IsEntityOnSpectatedTeam");
static_assert(sizeof(MatchaSnapNetStatics_IsEntityOnSpectatedTeam) == 0x000018, "Wrong size on MatchaSnapNetStatics_IsEntityOnSpectatedTeam");
static_assert(offsetof(MatchaSnapNetStatics_IsEntityOnSpectatedTeam, EntityIndex) == 0x000000, "Member 'MatchaSnapNetStatics_IsEntityOnSpectatedTeam::EntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_IsEntityOnSpectatedTeam, WorldContextObject) == 0x000008, "Member 'MatchaSnapNetStatics_IsEntityOnSpectatedTeam::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_IsEntityOnSpectatedTeam, ReturnValue) == 0x000010, "Member 'MatchaSnapNetStatics_IsEntityOnSpectatedTeam::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.SpawnEntity
// 0x0050 (0x0050 - 0x0000)
struct MatchaSnapNetStatics_SpawnEntity final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     EntityTemplate;                                    // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         OwnerPlayerIndex;                                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_SpawnEntity) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_SpawnEntity");
static_assert(sizeof(MatchaSnapNetStatics_SpawnEntity) == 0x000050, "Wrong size on MatchaSnapNetStatics_SpawnEntity");
static_assert(offsetof(MatchaSnapNetStatics_SpawnEntity, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_SpawnEntity::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnEntity, EntityTemplate) == 0x000008, "Member 'MatchaSnapNetStatics_SpawnEntity::EntityTemplate' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnEntity, Location) == 0x000010, "Member 'MatchaSnapNetStatics_SpawnEntity::Location' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnEntity, Rotation) == 0x000028, "Member 'MatchaSnapNetStatics_SpawnEntity::Rotation' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnEntity, OwnerPlayerIndex) == 0x000040, "Member 'MatchaSnapNetStatics_SpawnEntity::OwnerPlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnEntity, ReturnValue) == 0x000048, "Member 'MatchaSnapNetStatics_SpawnEntity::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.SpawnOwnedEntity
// 0x0048 (0x0048 - 0x0000)
struct MatchaSnapNetStatics_SpawnOwnedEntity final
{
public:
	TSubclassOf<class AActor>                     EntityTemplate;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           OwnerActor;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetStatics_SpawnOwnedEntity) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_SpawnOwnedEntity");
static_assert(sizeof(MatchaSnapNetStatics_SpawnOwnedEntity) == 0x000048, "Wrong size on MatchaSnapNetStatics_SpawnOwnedEntity");
static_assert(offsetof(MatchaSnapNetStatics_SpawnOwnedEntity, EntityTemplate) == 0x000000, "Member 'MatchaSnapNetStatics_SpawnOwnedEntity::EntityTemplate' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnOwnedEntity, OwnerActor) == 0x000008, "Member 'MatchaSnapNetStatics_SpawnOwnedEntity::OwnerActor' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnOwnedEntity, Location) == 0x000010, "Member 'MatchaSnapNetStatics_SpawnOwnedEntity::Location' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnOwnedEntity, Rotation) == 0x000028, "Member 'MatchaSnapNetStatics_SpawnOwnedEntity::Rotation' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SpawnOwnedEntity, ReturnValue) == 0x000040, "Member 'MatchaSnapNetStatics_SpawnOwnedEntity::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetStatics.SwitchSnapNetWorldType
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetStatics_SwitchSnapNetWorldType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapNetWorldType                             WorldType;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetStatics_SwitchSnapNetWorldType) == 0x000008, "Wrong alignment on MatchaSnapNetStatics_SwitchSnapNetWorldType");
static_assert(sizeof(MatchaSnapNetStatics_SwitchSnapNetWorldType) == 0x000010, "Wrong size on MatchaSnapNetStatics_SwitchSnapNetWorldType");
static_assert(offsetof(MatchaSnapNetStatics_SwitchSnapNetWorldType, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetStatics_SwitchSnapNetWorldType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetStatics_SwitchSnapNetWorldType, WorldType) == 0x000008, "Member 'MatchaSnapNetStatics_SwitchSnapNetWorldType::WorldType' has a wrong offset!");

// Function Matcha.MatchaProjectileEntity.ManualDetonateProjectile
// 0x0001 (0x0001 - 0x0000)
struct MatchaProjectileEntity_ManualDetonateProjectile final
{
public:
	bool                                          bDisableAfterDetonation;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaProjectileEntity_ManualDetonateProjectile) == 0x000001, "Wrong alignment on MatchaProjectileEntity_ManualDetonateProjectile");
static_assert(sizeof(MatchaProjectileEntity_ManualDetonateProjectile) == 0x000001, "Wrong size on MatchaProjectileEntity_ManualDetonateProjectile");
static_assert(offsetof(MatchaProjectileEntity_ManualDetonateProjectile, bDisableAfterDetonation) == 0x000000, "Member 'MatchaProjectileEntity_ManualDetonateProjectile::bDisableAfterDetonation' has a wrong offset!");

// Function Matcha.MatchaProjectileEntity.OnProjectileExplosion
// 0x0008 (0x0008 - 0x0000)
struct MatchaProjectileEntity_OnProjectileExplosion final
{
public:
	class AActor*                                 TargetHit;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaProjectileEntity_OnProjectileExplosion) == 0x000008, "Wrong alignment on MatchaProjectileEntity_OnProjectileExplosion");
static_assert(sizeof(MatchaProjectileEntity_OnProjectileExplosion) == 0x000008, "Wrong size on MatchaProjectileEntity_OnProjectileExplosion");
static_assert(offsetof(MatchaProjectileEntity_OnProjectileExplosion, TargetHit) == 0x000000, "Member 'MatchaProjectileEntity_OnProjectileExplosion::TargetHit' has a wrong offset!");

// Function Matcha.MatchaProjectileEntity.OnProjectileHit
// 0x0080 (0x0080 - 0x0000)
struct MatchaProjectileEntity_OnProjectileHit final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaHitData                         HitData;                                           // 0x0008(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaProjectileEntity_OnProjectileHit) == 0x000008, "Wrong alignment on MatchaProjectileEntity_OnProjectileHit");
static_assert(sizeof(MatchaProjectileEntity_OnProjectileHit) == 0x000080, "Wrong size on MatchaProjectileEntity_OnProjectileHit");
static_assert(offsetof(MatchaProjectileEntity_OnProjectileHit, HitActor) == 0x000000, "Member 'MatchaProjectileEntity_OnProjectileHit::HitActor' has a wrong offset!");
static_assert(offsetof(MatchaProjectileEntity_OnProjectileHit, HitData) == 0x000008, "Member 'MatchaProjectileEntity_OnProjectileHit::HitData' has a wrong offset!");

// Function Matcha.MatchaProjectileEntity.SetVelocity
// 0x0018 (0x0018 - 0x0000)
struct MatchaProjectileEntity_SetVelocity final
{
public:
	struct FVector                                Velocity_0;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaProjectileEntity_SetVelocity) == 0x000008, "Wrong alignment on MatchaProjectileEntity_SetVelocity");
static_assert(sizeof(MatchaProjectileEntity_SetVelocity) == 0x000018, "Wrong size on MatchaProjectileEntity_SetVelocity");
static_assert(offsetof(MatchaProjectileEntity_SetVelocity, Velocity_0) == 0x000000, "Member 'MatchaProjectileEntity_SetVelocity::Velocity_0' has a wrong offset!");

// Function Matcha.MatchaEnvironmentHazardsCommon.CharacterHazardOverlap
// 0x0100 (0x0100 - 0x0000)
struct MatchaEnvironmentHazardsCommon_CharacterHazardOverlap final
{
public:
	class AMatchaSnapNetCharacterEntity*          Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaEnvironmentHazardsCommon_CharacterHazardOverlap) == 0x000008, "Wrong alignment on MatchaEnvironmentHazardsCommon_CharacterHazardOverlap");
static_assert(sizeof(MatchaEnvironmentHazardsCommon_CharacterHazardOverlap) == 0x000100, "Wrong size on MatchaEnvironmentHazardsCommon_CharacterHazardOverlap");
static_assert(offsetof(MatchaEnvironmentHazardsCommon_CharacterHazardOverlap, Character) == 0x000000, "Member 'MatchaEnvironmentHazardsCommon_CharacterHazardOverlap::Character' has a wrong offset!");
static_assert(offsetof(MatchaEnvironmentHazardsCommon_CharacterHazardOverlap, HitResult) == 0x000008, "Member 'MatchaEnvironmentHazardsCommon_CharacterHazardOverlap::HitResult' has a wrong offset!");

// Function Matcha.MatchaEnvironmentHazardsCommon.GetAlwaysKnockoutTag
// 0x0008 (0x0008 - 0x0000)
struct MatchaEnvironmentHazardsCommon_GetAlwaysKnockoutTag final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaEnvironmentHazardsCommon_GetAlwaysKnockoutTag) == 0x000004, "Wrong alignment on MatchaEnvironmentHazardsCommon_GetAlwaysKnockoutTag");
static_assert(sizeof(MatchaEnvironmentHazardsCommon_GetAlwaysKnockoutTag) == 0x000008, "Wrong size on MatchaEnvironmentHazardsCommon_GetAlwaysKnockoutTag");
static_assert(offsetof(MatchaEnvironmentHazardsCommon_GetAlwaysKnockoutTag, ReturnValue) == 0x000000, "Member 'MatchaEnvironmentHazardsCommon_GetAlwaysKnockoutTag::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaEnvironmentHazardsCommon.GetMinimumDamageTag
// 0x0008 (0x0008 - 0x0000)
struct MatchaEnvironmentHazardsCommon_GetMinimumDamageTag final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaEnvironmentHazardsCommon_GetMinimumDamageTag) == 0x000004, "Wrong alignment on MatchaEnvironmentHazardsCommon_GetMinimumDamageTag");
static_assert(sizeof(MatchaEnvironmentHazardsCommon_GetMinimumDamageTag) == 0x000008, "Wrong size on MatchaEnvironmentHazardsCommon_GetMinimumDamageTag");
static_assert(offsetof(MatchaEnvironmentHazardsCommon_GetMinimumDamageTag, ReturnValue) == 0x000000, "Member 'MatchaEnvironmentHazardsCommon_GetMinimumDamageTag::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPlayerControllerBase.OnInputMethodChanged
// 0x0001 (0x0001 - 0x0000)
struct MatchaPlayerControllerBase_OnInputMethodChanged final
{
public:
	EInputMethod                                  InputMethod;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPlayerControllerBase_OnInputMethodChanged) == 0x000001, "Wrong alignment on MatchaPlayerControllerBase_OnInputMethodChanged");
static_assert(sizeof(MatchaPlayerControllerBase_OnInputMethodChanged) == 0x000001, "Wrong size on MatchaPlayerControllerBase_OnInputMethodChanged");
static_assert(offsetof(MatchaPlayerControllerBase_OnInputMethodChanged, InputMethod) == 0x000000, "Member 'MatchaPlayerControllerBase_OnInputMethodChanged::InputMethod' has a wrong offset!");

// Function Matcha.MatchaPlayerControllerBase.SetImguiEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaPlayerControllerBase_SetImguiEnabled final
{
public:
	bool                                          bImguiEnabled;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPlayerControllerBase_SetImguiEnabled) == 0x000001, "Wrong alignment on MatchaPlayerControllerBase_SetImguiEnabled");
static_assert(sizeof(MatchaPlayerControllerBase_SetImguiEnabled) == 0x000001, "Wrong size on MatchaPlayerControllerBase_SetImguiEnabled");
static_assert(offsetof(MatchaPlayerControllerBase_SetImguiEnabled, bImguiEnabled) == 0x000000, "Member 'MatchaPlayerControllerBase_SetImguiEnabled::bImguiEnabled' has a wrong offset!");

// Function Matcha.MatchaPlayerControllerBase.SetSelectedCharacter
// 0x0028 (0x0028 - 0x0000)
struct MatchaPlayerControllerBase_SetSelectedCharacter final
{
public:
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPlayerControllerBase_SetSelectedCharacter) == 0x000008, "Wrong alignment on MatchaPlayerControllerBase_SetSelectedCharacter");
static_assert(sizeof(MatchaPlayerControllerBase_SetSelectedCharacter) == 0x000028, "Wrong size on MatchaPlayerControllerBase_SetSelectedCharacter");
static_assert(offsetof(MatchaPlayerControllerBase_SetSelectedCharacter, CharacterClass) == 0x000000, "Member 'MatchaPlayerControllerBase_SetSelectedCharacter::CharacterClass' has a wrong offset!");

// Function Matcha.MatchaPlayerControllerBase.TravelTo
// 0x0010 (0x0010 - 0x0000)
struct MatchaPlayerControllerBase_TravelTo final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPlayerControllerBase_TravelTo) == 0x000008, "Wrong alignment on MatchaPlayerControllerBase_TravelTo");
static_assert(sizeof(MatchaPlayerControllerBase_TravelTo) == 0x000010, "Wrong size on MatchaPlayerControllerBase_TravelTo");
static_assert(offsetof(MatchaPlayerControllerBase_TravelTo, URL) == 0x000000, "Member 'MatchaPlayerControllerBase_TravelTo::URL' has a wrong offset!");

// Function Matcha.MatchaPlayerControllerBase.GetCurrentInputMappingContext
// 0x0008 (0x0008 - 0x0000)
struct MatchaPlayerControllerBase_GetCurrentInputMappingContext final
{
public:
	const class UInputMappingContext*             ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPlayerControllerBase_GetCurrentInputMappingContext) == 0x000008, "Wrong alignment on MatchaPlayerControllerBase_GetCurrentInputMappingContext");
static_assert(sizeof(MatchaPlayerControllerBase_GetCurrentInputMappingContext) == 0x000008, "Wrong size on MatchaPlayerControllerBase_GetCurrentInputMappingContext");
static_assert(offsetof(MatchaPlayerControllerBase_GetCurrentInputMappingContext, ReturnValue) == 0x000000, "Member 'MatchaPlayerControllerBase_GetCurrentInputMappingContext::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameEntityRenderer.Get
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameEntityRenderer_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaGameEntityRenderer*              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameEntityRenderer_Get) == 0x000008, "Wrong alignment on MatchaGameEntityRenderer_Get");
static_assert(sizeof(MatchaGameEntityRenderer_Get) == 0x000010, "Wrong size on MatchaGameEntityRenderer_Get");
static_assert(offsetof(MatchaGameEntityRenderer_Get, WorldContextObject) == 0x000000, "Member 'MatchaGameEntityRenderer_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameEntityRenderer_Get, ReturnValue) == 0x000008, "Member 'MatchaGameEntityRenderer_Get::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayAction.HandleGameplayEvent
// 0x0014 (0x0014 - 0x0000)
struct MatchaGameplayAction_HandleGameplayEvent final
{
public:
	struct FMatchaGameplayEvent                   Event;                                             // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayAction_HandleGameplayEvent) == 0x000004, "Wrong alignment on MatchaGameplayAction_HandleGameplayEvent");
static_assert(sizeof(MatchaGameplayAction_HandleGameplayEvent) == 0x000014, "Wrong size on MatchaGameplayAction_HandleGameplayEvent");
static_assert(offsetof(MatchaGameplayAction_HandleGameplayEvent, Event) == 0x000000, "Member 'MatchaGameplayAction_HandleGameplayEvent::Event' has a wrong offset!");

// Function Matcha.MatchaTrapEntity.OnCharacterOverlapContinued
// 0x0010 (0x0010 - 0x0000)
struct MatchaTrapEntity_OnCharacterOverlapContinued final
{
public:
	class AMatchaSnapNetCharacterEntity*          OverlappedCharacter;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedOverlapTime;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaTrapEntity_OnCharacterOverlapContinued) == 0x000008, "Wrong alignment on MatchaTrapEntity_OnCharacterOverlapContinued");
static_assert(sizeof(MatchaTrapEntity_OnCharacterOverlapContinued) == 0x000010, "Wrong size on MatchaTrapEntity_OnCharacterOverlapContinued");
static_assert(offsetof(MatchaTrapEntity_OnCharacterOverlapContinued, OverlappedCharacter) == 0x000000, "Member 'MatchaTrapEntity_OnCharacterOverlapContinued::OverlappedCharacter' has a wrong offset!");
static_assert(offsetof(MatchaTrapEntity_OnCharacterOverlapContinued, ElapsedOverlapTime) == 0x000008, "Member 'MatchaTrapEntity_OnCharacterOverlapContinued::ElapsedOverlapTime' has a wrong offset!");

// Function Matcha.MatchaTrapEntity.OnCharacterOverlapEnded
// 0x0008 (0x0008 - 0x0000)
struct MatchaTrapEntity_OnCharacterOverlapEnded final
{
public:
	class AMatchaSnapNetCharacterEntity*          OverlappedCharacter;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaTrapEntity_OnCharacterOverlapEnded) == 0x000008, "Wrong alignment on MatchaTrapEntity_OnCharacterOverlapEnded");
static_assert(sizeof(MatchaTrapEntity_OnCharacterOverlapEnded) == 0x000008, "Wrong size on MatchaTrapEntity_OnCharacterOverlapEnded");
static_assert(offsetof(MatchaTrapEntity_OnCharacterOverlapEnded, OverlappedCharacter) == 0x000000, "Member 'MatchaTrapEntity_OnCharacterOverlapEnded::OverlappedCharacter' has a wrong offset!");

// Function Matcha.MatchaTrapEntity.OnCharacterOverlapStarted
// 0x0008 (0x0008 - 0x0000)
struct MatchaTrapEntity_OnCharacterOverlapStarted final
{
public:
	class AMatchaSnapNetCharacterEntity*          OverlappedCharacter;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaTrapEntity_OnCharacterOverlapStarted) == 0x000008, "Wrong alignment on MatchaTrapEntity_OnCharacterOverlapStarted");
static_assert(sizeof(MatchaTrapEntity_OnCharacterOverlapStarted) == 0x000008, "Wrong size on MatchaTrapEntity_OnCharacterOverlapStarted");
static_assert(offsetof(MatchaTrapEntity_OnCharacterOverlapStarted, OverlappedCharacter) == 0x000000, "Member 'MatchaTrapEntity_OnCharacterOverlapStarted::OverlappedCharacter' has a wrong offset!");

// Function Matcha.MatchaTrapEntity.GetOverlappingCharacters
// 0x0010 (0x0010 - 0x0000)
struct MatchaTrapEntity_GetOverlappingCharacters final
{
public:
	TArray<class AMatchaSnapNetCharacterEntity*>  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaTrapEntity_GetOverlappingCharacters) == 0x000008, "Wrong alignment on MatchaTrapEntity_GetOverlappingCharacters");
static_assert(sizeof(MatchaTrapEntity_GetOverlappingCharacters) == 0x000010, "Wrong size on MatchaTrapEntity_GetOverlappingCharacters");
static_assert(offsetof(MatchaTrapEntity_GetOverlappingCharacters, ReturnValue) == 0x000000, "Member 'MatchaTrapEntity_GetOverlappingCharacters::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayEventSubsystem.BroadcastGameplayEvent
// 0x001C (0x001C - 0x0000)
struct MatchaGameplayEventSubsystem_BroadcastGameplayEvent final
{
public:
	struct FGameplayTag                           Channel;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaGameplayEvent                   GameplayEvent;                                     // 0x0008(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayEventSubsystem_BroadcastGameplayEvent) == 0x000004, "Wrong alignment on MatchaGameplayEventSubsystem_BroadcastGameplayEvent");
static_assert(sizeof(MatchaGameplayEventSubsystem_BroadcastGameplayEvent) == 0x00001C, "Wrong size on MatchaGameplayEventSubsystem_BroadcastGameplayEvent");
static_assert(offsetof(MatchaGameplayEventSubsystem_BroadcastGameplayEvent, Channel) == 0x000000, "Member 'MatchaGameplayEventSubsystem_BroadcastGameplayEvent::Channel' has a wrong offset!");
static_assert(offsetof(MatchaGameplayEventSubsystem_BroadcastGameplayEvent, GameplayEvent) == 0x000008, "Member 'MatchaGameplayEventSubsystem_BroadcastGameplayEvent::GameplayEvent' has a wrong offset!");

// Function Matcha.CanBeKnockedOut.ProcessKnockout
// 0x0038 (0x0038 - 0x0000)
struct CanBeKnockedOut_ProcessKnockout final
{
public:
	const class AActor*                           Instigator;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                KnockoutNormal;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceDirection;                                    // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanBeKnockedOut_ProcessKnockout) == 0x000008, "Wrong alignment on CanBeKnockedOut_ProcessKnockout");
static_assert(sizeof(CanBeKnockedOut_ProcessKnockout) == 0x000038, "Wrong size on CanBeKnockedOut_ProcessKnockout");
static_assert(offsetof(CanBeKnockedOut_ProcessKnockout, Instigator) == 0x000000, "Member 'CanBeKnockedOut_ProcessKnockout::Instigator' has a wrong offset!");
static_assert(offsetof(CanBeKnockedOut_ProcessKnockout, KnockoutNormal) == 0x000008, "Member 'CanBeKnockedOut_ProcessKnockout::KnockoutNormal' has a wrong offset!");
static_assert(offsetof(CanBeKnockedOut_ProcessKnockout, TraceDirection) == 0x000020, "Member 'CanBeKnockedOut_ProcessKnockout::TraceDirection' has a wrong offset!");

// Function Matcha.CanBeKnockedOut.CanBeKnockedOut
// 0x0001 (0x0001 - 0x0000)
struct CanBeKnockedOut_CanBeKnockedOut final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanBeKnockedOut_CanBeKnockedOut) == 0x000001, "Wrong alignment on CanBeKnockedOut_CanBeKnockedOut");
static_assert(sizeof(CanBeKnockedOut_CanBeKnockedOut) == 0x000001, "Wrong size on CanBeKnockedOut_CanBeKnockedOut");
static_assert(offsetof(CanBeKnockedOut_CanBeKnockedOut, ReturnValue) == 0x000000, "Member 'CanBeKnockedOut_CanBeKnockedOut::ReturnValue' has a wrong offset!");

// Function Matcha.CanBeInteractedWith.AfterInteractionCancelledOrCompleted
// 0x0010 (0x0010 - 0x0000)
struct CanBeInteractedWith_AfterInteractionCancelledOrCompleted final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCancelled;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CanBeInteractedWith_AfterInteractionCancelledOrCompleted) == 0x000008, "Wrong alignment on CanBeInteractedWith_AfterInteractionCancelledOrCompleted");
static_assert(sizeof(CanBeInteractedWith_AfterInteractionCancelledOrCompleted) == 0x000010, "Wrong size on CanBeInteractedWith_AfterInteractionCancelledOrCompleted");
static_assert(offsetof(CanBeInteractedWith_AfterInteractionCancelledOrCompleted, InteractingActor) == 0x000000, "Member 'CanBeInteractedWith_AfterInteractionCancelledOrCompleted::InteractingActor' has a wrong offset!");
static_assert(offsetof(CanBeInteractedWith_AfterInteractionCancelledOrCompleted, bWasCancelled) == 0x000008, "Member 'CanBeInteractedWith_AfterInteractionCancelledOrCompleted::bWasCancelled' has a wrong offset!");

// Function Matcha.CanBeInteractedWith.AfterInteractionStarted
// 0x0008 (0x0008 - 0x0000)
struct CanBeInteractedWith_AfterInteractionStarted final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanBeInteractedWith_AfterInteractionStarted) == 0x000008, "Wrong alignment on CanBeInteractedWith_AfterInteractionStarted");
static_assert(sizeof(CanBeInteractedWith_AfterInteractionStarted) == 0x000008, "Wrong size on CanBeInteractedWith_AfterInteractionStarted");
static_assert(offsetof(CanBeInteractedWith_AfterInteractionStarted, InteractingActor) == 0x000000, "Member 'CanBeInteractedWith_AfterInteractionStarted::InteractingActor' has a wrong offset!");

// Function Matcha.CanBeInteractedWith.InteractionCancelled
// 0x0008 (0x0008 - 0x0000)
struct CanBeInteractedWith_InteractionCancelled final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanBeInteractedWith_InteractionCancelled) == 0x000008, "Wrong alignment on CanBeInteractedWith_InteractionCancelled");
static_assert(sizeof(CanBeInteractedWith_InteractionCancelled) == 0x000008, "Wrong size on CanBeInteractedWith_InteractionCancelled");
static_assert(offsetof(CanBeInteractedWith_InteractionCancelled, InteractingActor) == 0x000000, "Member 'CanBeInteractedWith_InteractionCancelled::InteractingActor' has a wrong offset!");

// Function Matcha.CanBeInteractedWith.InteractionCompleted
// 0x0008 (0x0008 - 0x0000)
struct CanBeInteractedWith_InteractionCompleted final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanBeInteractedWith_InteractionCompleted) == 0x000008, "Wrong alignment on CanBeInteractedWith_InteractionCompleted");
static_assert(sizeof(CanBeInteractedWith_InteractionCompleted) == 0x000008, "Wrong size on CanBeInteractedWith_InteractionCompleted");
static_assert(offsetof(CanBeInteractedWith_InteractionCompleted, InteractingActor) == 0x000000, "Member 'CanBeInteractedWith_InteractionCompleted::InteractingActor' has a wrong offset!");

// Function Matcha.CanBeInteractedWith.InteractionProgressed
// 0x0010 (0x0010 - 0x0000)
struct CanBeInteractedWith_InteractionProgressed final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionProgressTimeSeconds;                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CanBeInteractedWith_InteractionProgressed) == 0x000008, "Wrong alignment on CanBeInteractedWith_InteractionProgressed");
static_assert(sizeof(CanBeInteractedWith_InteractionProgressed) == 0x000010, "Wrong size on CanBeInteractedWith_InteractionProgressed");
static_assert(offsetof(CanBeInteractedWith_InteractionProgressed, InteractingActor) == 0x000000, "Member 'CanBeInteractedWith_InteractionProgressed::InteractingActor' has a wrong offset!");
static_assert(offsetof(CanBeInteractedWith_InteractionProgressed, InteractionProgressTimeSeconds) == 0x000008, "Member 'CanBeInteractedWith_InteractionProgressed::InteractionProgressTimeSeconds' has a wrong offset!");

// Function Matcha.CanBeInteractedWith.CanStartInteraction
// 0x0010 (0x0010 - 0x0000)
struct CanBeInteractedWith_CanStartInteraction final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CanBeInteractedWith_CanStartInteraction) == 0x000008, "Wrong alignment on CanBeInteractedWith_CanStartInteraction");
static_assert(sizeof(CanBeInteractedWith_CanStartInteraction) == 0x000010, "Wrong size on CanBeInteractedWith_CanStartInteraction");
static_assert(offsetof(CanBeInteractedWith_CanStartInteraction, InteractingActor) == 0x000000, "Member 'CanBeInteractedWith_CanStartInteraction::InteractingActor' has a wrong offset!");
static_assert(offsetof(CanBeInteractedWith_CanStartInteraction, ReturnValue) == 0x000008, "Member 'CanBeInteractedWith_CanStartInteraction::ReturnValue' has a wrong offset!");

// Function Matcha.CanBeInteractedWith.GetInteractionPriority
// 0x0010 (0x0010 - 0x0000)
struct CanBeInteractedWith_GetInteractionPriority final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CanBeInteractedWith_GetInteractionPriority) == 0x000008, "Wrong alignment on CanBeInteractedWith_GetInteractionPriority");
static_assert(sizeof(CanBeInteractedWith_GetInteractionPriority) == 0x000010, "Wrong size on CanBeInteractedWith_GetInteractionPriority");
static_assert(offsetof(CanBeInteractedWith_GetInteractionPriority, InteractingActor) == 0x000000, "Member 'CanBeInteractedWith_GetInteractionPriority::InteractingActor' has a wrong offset!");
static_assert(offsetof(CanBeInteractedWith_GetInteractionPriority, ReturnValue) == 0x000008, "Member 'CanBeInteractedWith_GetInteractionPriority::ReturnValue' has a wrong offset!");

// Function Matcha.CanBeInteractedWith.GetInteractionRequirements
// 0x0008 (0x0008 - 0x0000)
struct CanBeInteractedWith_GetInteractionRequirements final
{
public:
	struct FMatchaInteractionRequirements         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanBeInteractedWith_GetInteractionRequirements) == 0x000004, "Wrong alignment on CanBeInteractedWith_GetInteractionRequirements");
static_assert(sizeof(CanBeInteractedWith_GetInteractionRequirements) == 0x000008, "Wrong size on CanBeInteractedWith_GetInteractionRequirements");
static_assert(offsetof(CanBeInteractedWith_GetInteractionRequirements, ReturnValue) == 0x000000, "Member 'CanBeInteractedWith_GetInteractionRequirements::ReturnValue' has a wrong offset!");

// Function Matcha.InteractionTargetRenderer.SetTargeted
// 0x0001 (0x0001 - 0x0000)
struct InteractionTargetRenderer_SetTargeted final
{
public:
	bool                                          bNewTargeted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionTargetRenderer_SetTargeted) == 0x000001, "Wrong alignment on InteractionTargetRenderer_SetTargeted");
static_assert(sizeof(InteractionTargetRenderer_SetTargeted) == 0x000001, "Wrong size on InteractionTargetRenderer_SetTargeted");
static_assert(offsetof(InteractionTargetRenderer_SetTargeted, bNewTargeted) == 0x000000, "Member 'InteractionTargetRenderer_SetTargeted::bNewTargeted' has a wrong offset!");

// Function Matcha.InteractionTargetRenderer.GetInteractionProgressData
// 0x0020 (0x0020 - 0x0000)
struct InteractionTargetRenderer_GetInteractionProgressData final
{
public:
	const class AActor*                           InteractingRenderer;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionProgressData               ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionTargetRenderer_GetInteractionProgressData) == 0x000008, "Wrong alignment on InteractionTargetRenderer_GetInteractionProgressData");
static_assert(sizeof(InteractionTargetRenderer_GetInteractionProgressData) == 0x000020, "Wrong size on InteractionTargetRenderer_GetInteractionProgressData");
static_assert(offsetof(InteractionTargetRenderer_GetInteractionProgressData, InteractingRenderer) == 0x000000, "Member 'InteractionTargetRenderer_GetInteractionProgressData::InteractingRenderer' has a wrong offset!");
static_assert(offsetof(InteractionTargetRenderer_GetInteractionProgressData, ReturnValue) == 0x000008, "Member 'InteractionTargetRenderer_GetInteractionProgressData::ReturnValue' has a wrong offset!");

// Function Matcha.InteractionTargetRenderer.GetInteractionPromptLocation
// 0x0020 (0x0020 - 0x0000)
struct InteractionTargetRenderer_GetInteractionPromptLocation final
{
public:
	const class AActor*                           InteractingRenderer;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionTargetRenderer_GetInteractionPromptLocation) == 0x000008, "Wrong alignment on InteractionTargetRenderer_GetInteractionPromptLocation");
static_assert(sizeof(InteractionTargetRenderer_GetInteractionPromptLocation) == 0x000020, "Wrong size on InteractionTargetRenderer_GetInteractionPromptLocation");
static_assert(offsetof(InteractionTargetRenderer_GetInteractionPromptLocation, InteractingRenderer) == 0x000000, "Member 'InteractionTargetRenderer_GetInteractionPromptLocation::InteractingRenderer' has a wrong offset!");
static_assert(offsetof(InteractionTargetRenderer_GetInteractionPromptLocation, ReturnValue) == 0x000008, "Member 'InteractionTargetRenderer_GetInteractionPromptLocation::ReturnValue' has a wrong offset!");

// Function Matcha.CameraTarget.GetCameraViewTargetOffset
// 0x0018 (0x0018 - 0x0000)
struct CameraTarget_GetCameraViewTargetOffset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraTarget_GetCameraViewTargetOffset) == 0x000008, "Wrong alignment on CameraTarget_GetCameraViewTargetOffset");
static_assert(sizeof(CameraTarget_GetCameraViewTargetOffset) == 0x000018, "Wrong size on CameraTarget_GetCameraViewTargetOffset");
static_assert(offsetof(CameraTarget_GetCameraViewTargetOffset, ReturnValue) == 0x000000, "Member 'CameraTarget_GetCameraViewTargetOffset::ReturnValue' has a wrong offset!");

// Function Matcha.CanAttachFX.GetFXAttachmentComponent
// 0x0008 (0x0008 - 0x0000)
struct CanAttachFX_GetFXAttachmentComponent final
{
public:
	class USceneComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanAttachFX_GetFXAttachmentComponent) == 0x000008, "Wrong alignment on CanAttachFX_GetFXAttachmentComponent");
static_assert(sizeof(CanAttachFX_GetFXAttachmentComponent) == 0x000008, "Wrong size on CanAttachFX_GetFXAttachmentComponent");
static_assert(offsetof(CanAttachFX_GetFXAttachmentComponent, ReturnValue) == 0x000000, "Member 'CanAttachFX_GetFXAttachmentComponent::ReturnValue' has a wrong offset!");

// Function Matcha.CanBeTriggered.OnTriggered
// 0x0008 (0x0008 - 0x0000)
struct CanBeTriggered_OnTriggered final
{
public:
	class AActor*                                 OverlappingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanBeTriggered_OnTriggered) == 0x000008, "Wrong alignment on CanBeTriggered_OnTriggered");
static_assert(sizeof(CanBeTriggered_OnTriggered) == 0x000008, "Wrong size on CanBeTriggered_OnTriggered");
static_assert(offsetof(CanBeTriggered_OnTriggered, OverlappingActor) == 0x000000, "Member 'CanBeTriggered_OnTriggered::OverlappingActor' has a wrong offset!");

// Function Matcha.CanBroadcastGameplayEvents.GetBroadcastChannel
// 0x0008 (0x0008 - 0x0000)
struct CanBroadcastGameplayEvents_GetBroadcastChannel final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanBroadcastGameplayEvents_GetBroadcastChannel) == 0x000004, "Wrong alignment on CanBroadcastGameplayEvents_GetBroadcastChannel");
static_assert(sizeof(CanBroadcastGameplayEvents_GetBroadcastChannel) == 0x000008, "Wrong size on CanBroadcastGameplayEvents_GetBroadcastChannel");
static_assert(offsetof(CanBroadcastGameplayEvents_GetBroadcastChannel, ReturnValue) == 0x000000, "Member 'CanBroadcastGameplayEvents_GetBroadcastChannel::ReturnValue' has a wrong offset!");

// Function Matcha.InventoryProvider.GetInventoryComponent
// 0x0008 (0x0008 - 0x0000)
struct InventoryProvider_GetInventoryComponent final
{
public:
	class UMatchaInventoryComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryProvider_GetInventoryComponent) == 0x000008, "Wrong alignment on InventoryProvider_GetInventoryComponent");
static_assert(sizeof(InventoryProvider_GetInventoryComponent) == 0x000008, "Wrong size on InventoryProvider_GetInventoryComponent");
static_assert(offsetof(InventoryProvider_GetInventoryComponent, ReturnValue) == 0x000000, "Member 'InventoryProvider_GetInventoryComponent::ReturnValue' has a wrong offset!");

// Function Matcha.ContextReceiver.OnReceiveIntContext
// 0x0004 (0x0004 - 0x0000)
struct ContextReceiver_OnReceiveIntContext final
{
public:
	int32                                         Context;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContextReceiver_OnReceiveIntContext) == 0x000004, "Wrong alignment on ContextReceiver_OnReceiveIntContext");
static_assert(sizeof(ContextReceiver_OnReceiveIntContext) == 0x000004, "Wrong size on ContextReceiver_OnReceiveIntContext");
static_assert(offsetof(ContextReceiver_OnReceiveIntContext, Context) == 0x000000, "Member 'ContextReceiver_OnReceiveIntContext::Context' has a wrong offset!");

// Function Matcha.ScheduledObjective.GetScheduledObjectiveDisplayText
// 0x0010 (0x0010 - 0x0000)
struct ScheduledObjective_GetScheduledObjectiveDisplayText final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScheduledObjective_GetScheduledObjectiveDisplayText) == 0x000008, "Wrong alignment on ScheduledObjective_GetScheduledObjectiveDisplayText");
static_assert(sizeof(ScheduledObjective_GetScheduledObjectiveDisplayText) == 0x000010, "Wrong size on ScheduledObjective_GetScheduledObjectiveDisplayText");
static_assert(offsetof(ScheduledObjective_GetScheduledObjectiveDisplayText, ReturnValue) == 0x000000, "Member 'ScheduledObjective_GetScheduledObjectiveDisplayText::ReturnValue' has a wrong offset!");

// Function Matcha.ScheduledObjective.GetScheduledObjectiveType
// 0x0001 (0x0001 - 0x0000)
struct ScheduledObjective_GetScheduledObjectiveType final
{
public:
	EScheduledObjectiveType                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScheduledObjective_GetScheduledObjectiveType) == 0x000001, "Wrong alignment on ScheduledObjective_GetScheduledObjectiveType");
static_assert(sizeof(ScheduledObjective_GetScheduledObjectiveType) == 0x000001, "Wrong size on ScheduledObjective_GetScheduledObjectiveType");
static_assert(offsetof(ScheduledObjective_GetScheduledObjectiveType, ReturnValue) == 0x000000, "Member 'ScheduledObjective_GetScheduledObjectiveType::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.CharacterIndexToCharacterClass
// 0x0038 (0x0038 - 0x0000)
struct MatchaGameplayStatics_CharacterIndexToCharacterClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterIdx;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ReturnValue;                                       // 0x0010(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_CharacterIndexToCharacterClass) == 0x000008, "Wrong alignment on MatchaGameplayStatics_CharacterIndexToCharacterClass");
static_assert(sizeof(MatchaGameplayStatics_CharacterIndexToCharacterClass) == 0x000038, "Wrong size on MatchaGameplayStatics_CharacterIndexToCharacterClass");
static_assert(offsetof(MatchaGameplayStatics_CharacterIndexToCharacterClass, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_CharacterIndexToCharacterClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_CharacterIndexToCharacterClass, CharacterIdx) == 0x000008, "Member 'MatchaGameplayStatics_CharacterIndexToCharacterClass::CharacterIdx' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_CharacterIndexToCharacterClass, ReturnValue) == 0x000010, "Member 'MatchaGameplayStatics_CharacterIndexToCharacterClass::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.ConvertFramesToMilliseconds
// 0x0008 (0x0008 - 0x0000)
struct MatchaGameplayStatics_ConvertFramesToMilliseconds final
{
public:
	int32                                         Frames;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_ConvertFramesToMilliseconds) == 0x000004, "Wrong alignment on MatchaGameplayStatics_ConvertFramesToMilliseconds");
static_assert(sizeof(MatchaGameplayStatics_ConvertFramesToMilliseconds) == 0x000008, "Wrong size on MatchaGameplayStatics_ConvertFramesToMilliseconds");
static_assert(offsetof(MatchaGameplayStatics_ConvertFramesToMilliseconds, Frames) == 0x000000, "Member 'MatchaGameplayStatics_ConvertFramesToMilliseconds::Frames' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_ConvertFramesToMilliseconds, ReturnValue) == 0x000004, "Member 'MatchaGameplayStatics_ConvertFramesToMilliseconds::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.ConvertSecondsToFrames
// 0x0008 (0x0008 - 0x0000)
struct MatchaGameplayStatics_ConvertSecondsToFrames final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_ConvertSecondsToFrames) == 0x000004, "Wrong alignment on MatchaGameplayStatics_ConvertSecondsToFrames");
static_assert(sizeof(MatchaGameplayStatics_ConvertSecondsToFrames) == 0x000008, "Wrong size on MatchaGameplayStatics_ConvertSecondsToFrames");
static_assert(offsetof(MatchaGameplayStatics_ConvertSecondsToFrames, Seconds) == 0x000000, "Member 'MatchaGameplayStatics_ConvertSecondsToFrames::Seconds' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_ConvertSecondsToFrames, ReturnValue) == 0x000004, "Member 'MatchaGameplayStatics_ConvertSecondsToFrames::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.ConvertSecondsToMilliseconds
// 0x0008 (0x0008 - 0x0000)
struct MatchaGameplayStatics_ConvertSecondsToMilliseconds final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_ConvertSecondsToMilliseconds) == 0x000004, "Wrong alignment on MatchaGameplayStatics_ConvertSecondsToMilliseconds");
static_assert(sizeof(MatchaGameplayStatics_ConvertSecondsToMilliseconds) == 0x000008, "Wrong size on MatchaGameplayStatics_ConvertSecondsToMilliseconds");
static_assert(offsetof(MatchaGameplayStatics_ConvertSecondsToMilliseconds, Seconds) == 0x000000, "Member 'MatchaGameplayStatics_ConvertSecondsToMilliseconds::Seconds' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_ConvertSecondsToMilliseconds, ReturnValue) == 0x000004, "Member 'MatchaGameplayStatics_ConvertSecondsToMilliseconds::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.DestroyAttachedFXFromEntity
// 0x0018 (0x0018 - 0x0000)
struct MatchaGameplayStatics_DestroyAttachedFXFromEntity final
{
public:
	const class AActor*                           SpawningEntity;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NiagaraSystemId;                                   // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioEventId;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_DestroyAttachedFXFromEntity) == 0x000008, "Wrong alignment on MatchaGameplayStatics_DestroyAttachedFXFromEntity");
static_assert(sizeof(MatchaGameplayStatics_DestroyAttachedFXFromEntity) == 0x000018, "Wrong size on MatchaGameplayStatics_DestroyAttachedFXFromEntity");
static_assert(offsetof(MatchaGameplayStatics_DestroyAttachedFXFromEntity, SpawningEntity) == 0x000000, "Member 'MatchaGameplayStatics_DestroyAttachedFXFromEntity::SpawningEntity' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_DestroyAttachedFXFromEntity, NiagaraSystemId) == 0x000008, "Member 'MatchaGameplayStatics_DestroyAttachedFXFromEntity::NiagaraSystemId' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_DestroyAttachedFXFromEntity, AudioEventId) == 0x000010, "Member 'MatchaGameplayStatics_DestroyAttachedFXFromEntity::AudioEventId' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.FilterActorsFromArray
// 0x0030 (0x0030 - 0x0000)
struct MatchaGameplayStatics_FilterActorsFromArray final
{
public:
	int32                                         InputTeamNumber;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         InputActors;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FilteredActors;                                    // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	ETeamFilter                                   TeamFilter;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAliveState                                   AliveStateFilter;                                  // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldFilterForShieldState;                       // 0x002A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaShieldState                            ShieldStateFilter;                                 // 0x002B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilterNotIntangible;                              // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_FilterActorsFromArray) == 0x000008, "Wrong alignment on MatchaGameplayStatics_FilterActorsFromArray");
static_assert(sizeof(MatchaGameplayStatics_FilterActorsFromArray) == 0x000030, "Wrong size on MatchaGameplayStatics_FilterActorsFromArray");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArray, InputTeamNumber) == 0x000000, "Member 'MatchaGameplayStatics_FilterActorsFromArray::InputTeamNumber' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArray, InputActors) == 0x000008, "Member 'MatchaGameplayStatics_FilterActorsFromArray::InputActors' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArray, FilteredActors) == 0x000018, "Member 'MatchaGameplayStatics_FilterActorsFromArray::FilteredActors' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArray, TeamFilter) == 0x000028, "Member 'MatchaGameplayStatics_FilterActorsFromArray::TeamFilter' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArray, AliveStateFilter) == 0x000029, "Member 'MatchaGameplayStatics_FilterActorsFromArray::AliveStateFilter' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArray, bShouldFilterForShieldState) == 0x00002A, "Member 'MatchaGameplayStatics_FilterActorsFromArray::bShouldFilterForShieldState' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArray, ShieldStateFilter) == 0x00002B, "Member 'MatchaGameplayStatics_FilterActorsFromArray::ShieldStateFilter' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArray, bFilterNotIntangible) == 0x00002C, "Member 'MatchaGameplayStatics_FilterActorsFromArray::bFilterNotIntangible' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.FilterActorsFromArrayWithFilterInfo
// 0x0030 (0x0030 - 0x0000)
struct MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo final
{
public:
	int32                                         InputTeamNumber;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         InputActors;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActorFilterInfo                       ActorFilterInfo;                                   // 0x0018(0x0006)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         OutFilteredActors;                                 // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo) == 0x000008, "Wrong alignment on MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo");
static_assert(sizeof(MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo) == 0x000030, "Wrong size on MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo, InputTeamNumber) == 0x000000, "Member 'MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo::InputTeamNumber' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo, InputActors) == 0x000008, "Member 'MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo::InputActors' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo, ActorFilterInfo) == 0x000018, "Member 'MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo::ActorFilterInfo' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo, OutFilteredActors) == 0x000020, "Member 'MatchaGameplayStatics_FilterActorsFromArrayWithFilterInfo::OutFilteredActors' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.FindClosestEmptySpaceBetweenLocationsForCharacter
// 0x00A0 (0x00A0 - 0x0000)
struct MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocation;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialDesiredLocation;                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalDesiredLocation;                              // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rotation;                                          // 0x0050(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0078(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bAvoidInstantKOZones;                              // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvoidTwoWayPlatforms;                             // 0x0089(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvoidCharacters;                                  // 0x008A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebug;                                        // 0x008B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugTime;                                         // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter) == 0x000010, "Wrong alignment on MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter");
static_assert(sizeof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter) == 0x0000A0, "Wrong size on MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, OutLocation) == 0x000008, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::OutLocation' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, InitialDesiredLocation) == 0x000020, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::InitialDesiredLocation' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, FinalDesiredLocation) == 0x000038, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::FinalDesiredLocation' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, Rotation) == 0x000050, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::Rotation' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, CapsuleRadius) == 0x000070, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, CapsuleHalfHeight) == 0x000074, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, ActorsToIgnore) == 0x000078, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, bAvoidInstantKOZones) == 0x000088, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::bAvoidInstantKOZones' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, bAvoidTwoWayPlatforms) == 0x000089, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::bAvoidTwoWayPlatforms' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, bAvoidCharacters) == 0x00008A, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::bAvoidCharacters' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, bShowDebug) == 0x00008B, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::bShowDebug' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, DebugTime) == 0x00008C, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::DebugTime' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter, ReturnValue) == 0x000090, "Member 'MatchaGameplayStatics_FindClosestEmptySpaceBetweenLocationsForCharacter::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.FindFilteredActorsInRadius
// 0x0058 (0x0058 - 0x0000)
struct MatchaGameplayStatics_FindFilteredActorsInRadius final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           Instigator;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputTeamNumber;                                   // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActorFilterInfo                       ActorFilterInfo;                                   // 0x0030(0x0006)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FilteredActors;                                    // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_FindFilteredActorsInRadius) == 0x000008, "Wrong alignment on MatchaGameplayStatics_FindFilteredActorsInRadius");
static_assert(sizeof(MatchaGameplayStatics_FindFilteredActorsInRadius) == 0x000058, "Wrong size on MatchaGameplayStatics_FindFilteredActorsInRadius");
static_assert(offsetof(MatchaGameplayStatics_FindFilteredActorsInRadius, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_FindFilteredActorsInRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindFilteredActorsInRadius, Instigator) == 0x000008, "Member 'MatchaGameplayStatics_FindFilteredActorsInRadius::Instigator' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindFilteredActorsInRadius, Location) == 0x000010, "Member 'MatchaGameplayStatics_FindFilteredActorsInRadius::Location' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindFilteredActorsInRadius, Radius) == 0x000028, "Member 'MatchaGameplayStatics_FindFilteredActorsInRadius::Radius' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindFilteredActorsInRadius, InputTeamNumber) == 0x00002C, "Member 'MatchaGameplayStatics_FindFilteredActorsInRadius::InputTeamNumber' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindFilteredActorsInRadius, ActorFilterInfo) == 0x000030, "Member 'MatchaGameplayStatics_FindFilteredActorsInRadius::ActorFilterInfo' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindFilteredActorsInRadius, ActorsToIgnore) == 0x000038, "Member 'MatchaGameplayStatics_FindFilteredActorsInRadius::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_FindFilteredActorsInRadius, FilteredActors) == 0x000048, "Member 'MatchaGameplayStatics_FindFilteredActorsInRadius::FilteredActors' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.Get2DLocation
// 0x0018 (0x0018 - 0x0000)
struct MatchaGameplayStatics_Get2DLocation final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_Get2DLocation) == 0x000008, "Wrong alignment on MatchaGameplayStatics_Get2DLocation");
static_assert(sizeof(MatchaGameplayStatics_Get2DLocation) == 0x000018, "Wrong size on MatchaGameplayStatics_Get2DLocation");
static_assert(offsetof(MatchaGameplayStatics_Get2DLocation, Actor) == 0x000000, "Member 'MatchaGameplayStatics_Get2DLocation::Actor' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_Get2DLocation, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_Get2DLocation::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetAllyRTPC
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameplayStatics_GetAllyRTPC final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAkRtpc*                          ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetAllyRTPC) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetAllyRTPC");
static_assert(sizeof(MatchaGameplayStatics_GetAllyRTPC) == 0x000010, "Wrong size on MatchaGameplayStatics_GetAllyRTPC");
static_assert(offsetof(MatchaGameplayStatics_GetAllyRTPC, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetAllyRTPC::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetAllyRTPC, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_GetAllyRTPC::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetAudioEventFromId
// 0x0028 (0x0028 - 0x0000)
struct MatchaGameplayStatics_GetAudioEventFromId final
{
public:
	class FName                                   AudioEventId;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectEventType                              EffectEventType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class AActor*                           SpawningRenderer;                                  // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssociatedEntityIndex;                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetAudioEventFromId) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetAudioEventFromId");
static_assert(sizeof(MatchaGameplayStatics_GetAudioEventFromId) == 0x000028, "Wrong size on MatchaGameplayStatics_GetAudioEventFromId");
static_assert(offsetof(MatchaGameplayStatics_GetAudioEventFromId, AudioEventId) == 0x000000, "Member 'MatchaGameplayStatics_GetAudioEventFromId::AudioEventId' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetAudioEventFromId, EffectEventType) == 0x000008, "Member 'MatchaGameplayStatics_GetAudioEventFromId::EffectEventType' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetAudioEventFromId, SpawningRenderer) == 0x000010, "Member 'MatchaGameplayStatics_GetAudioEventFromId::SpawningRenderer' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetAudioEventFromId, AssociatedEntityIndex) == 0x000018, "Member 'MatchaGameplayStatics_GetAudioEventFromId::AssociatedEntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetAudioEventFromId, ReturnValue) == 0x000020, "Member 'MatchaGameplayStatics_GetAudioEventFromId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetAvailableCharacters
// 0x0018 (0x0018 - 0x0000)
struct MatchaGameplayStatics_GetAvailableCharacters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ReturnValue;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetAvailableCharacters) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetAvailableCharacters");
static_assert(sizeof(MatchaGameplayStatics_GetAvailableCharacters) == 0x000018, "Wrong size on MatchaGameplayStatics_GetAvailableCharacters");
static_assert(offsetof(MatchaGameplayStatics_GetAvailableCharacters, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetAvailableCharacters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetAvailableCharacters, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_GetAvailableCharacters::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetClientServies
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameplayStatics_GetClientServies final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaClientServices*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetClientServies) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetClientServies");
static_assert(sizeof(MatchaGameplayStatics_GetClientServies) == 0x000010, "Wrong size on MatchaGameplayStatics_GetClientServies");
static_assert(offsetof(MatchaGameplayStatics_GetClientServies, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetClientServies::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetClientServies, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_GetClientServies::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetClosestAngleBetweenNormalizedVectors
// 0x0038 (0x0038 - 0x0000)
struct MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors");
static_assert(sizeof(MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors) == 0x000038, "Wrong size on MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors");
static_assert(offsetof(MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors, A) == 0x000000, "Member 'MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors::A' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors, B) == 0x000018, "Member 'MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors::B' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors, ReturnValue) == 0x000030, "Member 'MatchaGameplayStatics_GetClosestAngleBetweenNormalizedVectors::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetColorForTeamNumber
// 0x0020 (0x0020 - 0x0000)
struct MatchaGameplayStatics_GetColorForTeamNumber final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamNumber;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_GetColorForTeamNumber) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetColorForTeamNumber");
static_assert(sizeof(MatchaGameplayStatics_GetColorForTeamNumber) == 0x000020, "Wrong size on MatchaGameplayStatics_GetColorForTeamNumber");
static_assert(offsetof(MatchaGameplayStatics_GetColorForTeamNumber, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetColorForTeamNumber::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetColorForTeamNumber, TeamNumber) == 0x000008, "Member 'MatchaGameplayStatics_GetColorForTeamNumber::TeamNumber' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetColorForTeamNumber, ReturnValue) == 0x00000C, "Member 'MatchaGameplayStatics_GetColorForTeamNumber::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetCurrentTeamForActor
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameplayStatics_GetCurrentTeamForActor final
{
public:
	const class AActor*                           AActor;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_GetCurrentTeamForActor) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetCurrentTeamForActor");
static_assert(sizeof(MatchaGameplayStatics_GetCurrentTeamForActor) == 0x000010, "Wrong size on MatchaGameplayStatics_GetCurrentTeamForActor");
static_assert(offsetof(MatchaGameplayStatics_GetCurrentTeamForActor, AActor) == 0x000000, "Member 'MatchaGameplayStatics_GetCurrentTeamForActor::AActor' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetCurrentTeamForActor, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_GetCurrentTeamForActor::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetDisplayNameForRegion
// 0x0020 (0x0020 - 0x0000)
struct MatchaGameplayStatics_GetDisplayNameForRegion final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnRegion                                  SpawnRegion;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetDisplayNameForRegion) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetDisplayNameForRegion");
static_assert(sizeof(MatchaGameplayStatics_GetDisplayNameForRegion) == 0x000020, "Wrong size on MatchaGameplayStatics_GetDisplayNameForRegion");
static_assert(offsetof(MatchaGameplayStatics_GetDisplayNameForRegion, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetDisplayNameForRegion::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetDisplayNameForRegion, SpawnRegion) == 0x000008, "Member 'MatchaGameplayStatics_GetDisplayNameForRegion::SpawnRegion' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetDisplayNameForRegion, ReturnValue) == 0x000010, "Member 'MatchaGameplayStatics_GetDisplayNameForRegion::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetEnvironmentHazardOverlapsBox
// 0x0080 (0x0080 - 0x0000)
struct MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEnvironmentOverlapResult>      Results;                                           // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rotation;                                          // 0x0030(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxHalfSize;                                       // 0x0050(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreTags;                                        // 0x0068(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	const class AActor*                           IgnoreActor;                                       // 0x0078(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox) == 0x000010, "Wrong alignment on MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox");
static_assert(sizeof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox) == 0x000080, "Wrong size on MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox, Results) == 0x000008, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox::Results' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox, Position) == 0x000018, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox::Position' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox, Rotation) == 0x000030, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox::Rotation' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox, BoxHalfSize) == 0x000050, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox::BoxHalfSize' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox, IgnoreTags) == 0x000068, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox::IgnoreTags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox, IgnoreActor) == 0x000078, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsBox::IgnoreActor' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetEnvironmentHazardOverlapsCapsule
// 0x0070 (0x0070 - 0x0000)
struct MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEnvironmentOverlapResult>      Results;                                           // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rotation;                                          // 0x0030(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreTags;                                        // 0x0058(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	const class AActor*                           IgnoreActor;                                       // 0x0068(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule) == 0x000010, "Wrong alignment on MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule");
static_assert(sizeof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule) == 0x000070, "Wrong size on MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule, Results) == 0x000008, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule::Results' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule, Position) == 0x000018, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule::Position' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule, Rotation) == 0x000030, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule::Rotation' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule, CapsuleRadius) == 0x000050, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule, CapsuleHalfHeight) == 0x000054, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule, IgnoreTags) == 0x000058, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule::IgnoreTags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule, IgnoreActor) == 0x000068, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsCapsule::IgnoreActor' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetEnvironmentHazardOverlapsSphere
// 0x0070 (0x0070 - 0x0000)
struct MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEnvironmentOverlapResult>      Results;                                           // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rotation;                                          // 0x0030(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IgnoreTags;                                        // 0x0058(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	const class AActor*                           IgnoreActor;                                       // 0x0068(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere) == 0x000010, "Wrong alignment on MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere");
static_assert(sizeof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere) == 0x000070, "Wrong size on MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere, Results) == 0x000008, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere::Results' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere, Position) == 0x000018, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere::Position' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere, Rotation) == 0x000030, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere::Rotation' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere, SphereRadius) == 0x000050, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere::SphereRadius' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere, IgnoreTags) == 0x000058, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere::IgnoreTags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere, IgnoreActor) == 0x000068, "Member 'MatchaGameplayStatics_GetEnvironmentHazardOverlapsSphere::IgnoreActor' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetKnockBackUnitDirectionForAngle
// 0x0020 (0x0020 - 0x0000)
struct MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle final
{
public:
	float                                         HitAngle;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFacingRight;                                    // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle");
static_assert(sizeof(MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle) == 0x000020, "Wrong size on MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle");
static_assert(offsetof(MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle, HitAngle) == 0x000000, "Member 'MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle::HitAngle' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle, bIsFacingRight) == 0x000004, "Member 'MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle::bIsFacingRight' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_GetKnockBackUnitDirectionForAngle::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetLocallySpectatedRTPC
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameplayStatics_GetLocallySpectatedRTPC final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAkRtpc*                          ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetLocallySpectatedRTPC) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetLocallySpectatedRTPC");
static_assert(sizeof(MatchaGameplayStatics_GetLocallySpectatedRTPC) == 0x000010, "Wrong size on MatchaGameplayStatics_GetLocallySpectatedRTPC");
static_assert(offsetof(MatchaGameplayStatics_GetLocallySpectatedRTPC, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetLocallySpectatedRTPC::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetLocallySpectatedRTPC, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_GetLocallySpectatedRTPC::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetMatchaSnapNetGameInstance
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameplayStatics_GetMatchaSnapNetGameInstance final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaSnapNetGameInstance*             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetMatchaSnapNetGameInstance) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetMatchaSnapNetGameInstance");
static_assert(sizeof(MatchaGameplayStatics_GetMatchaSnapNetGameInstance) == 0x000010, "Wrong size on MatchaGameplayStatics_GetMatchaSnapNetGameInstance");
static_assert(offsetof(MatchaGameplayStatics_GetMatchaSnapNetGameInstance, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetMatchaSnapNetGameInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetMatchaSnapNetGameInstance, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_GetMatchaSnapNetGameInstance::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetNiagaraSystemFromId
// 0x0028 (0x0028 - 0x0000)
struct MatchaGameplayStatics_GetNiagaraSystemFromId final
{
public:
	class FName                                   NiagaraSystemId;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectEventType                              EffectEventType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class AActor*                           SpawningRenderer;                                  // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssociatedEntityIndex;                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetNiagaraSystemFromId) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetNiagaraSystemFromId");
static_assert(sizeof(MatchaGameplayStatics_GetNiagaraSystemFromId) == 0x000028, "Wrong size on MatchaGameplayStatics_GetNiagaraSystemFromId");
static_assert(offsetof(MatchaGameplayStatics_GetNiagaraSystemFromId, NiagaraSystemId) == 0x000000, "Member 'MatchaGameplayStatics_GetNiagaraSystemFromId::NiagaraSystemId' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetNiagaraSystemFromId, EffectEventType) == 0x000008, "Member 'MatchaGameplayStatics_GetNiagaraSystemFromId::EffectEventType' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetNiagaraSystemFromId, SpawningRenderer) == 0x000010, "Member 'MatchaGameplayStatics_GetNiagaraSystemFromId::SpawningRenderer' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetNiagaraSystemFromId, AssociatedEntityIndex) == 0x000018, "Member 'MatchaGameplayStatics_GetNiagaraSystemFromId::AssociatedEntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetNiagaraSystemFromId, ReturnValue) == 0x000020, "Member 'MatchaGameplayStatics_GetNiagaraSystemFromId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetNormalizedAngleBetweenNormalizedVectors
// 0x0038 (0x0038 - 0x0000)
struct MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors");
static_assert(sizeof(MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors) == 0x000038, "Wrong size on MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors");
static_assert(offsetof(MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors, A) == 0x000000, "Member 'MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors::A' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors, B) == 0x000018, "Member 'MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors::B' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors, ReturnValue) == 0x000030, "Member 'MatchaGameplayStatics_GetNormalizedAngleBetweenNormalizedVectors::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetOfflineMapPath
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameplayStatics_GetOfflineMapPath final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetOfflineMapPath) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetOfflineMapPath");
static_assert(sizeof(MatchaGameplayStatics_GetOfflineMapPath) == 0x000010, "Wrong size on MatchaGameplayStatics_GetOfflineMapPath");
static_assert(offsetof(MatchaGameplayStatics_GetOfflineMapPath, ReturnValue) == 0x000000, "Member 'MatchaGameplayStatics_GetOfflineMapPath::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetRendererFXAttachComponent
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameplayStatics_GetRendererFXAttachComponent final
{
public:
	const class AActor*                           RendererActor;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetRendererFXAttachComponent) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetRendererFXAttachComponent");
static_assert(sizeof(MatchaGameplayStatics_GetRendererFXAttachComponent) == 0x000010, "Wrong size on MatchaGameplayStatics_GetRendererFXAttachComponent");
static_assert(offsetof(MatchaGameplayStatics_GetRendererFXAttachComponent, RendererActor) == 0x000000, "Member 'MatchaGameplayStatics_GetRendererFXAttachComponent::RendererActor' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetRendererFXAttachComponent, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_GetRendererFXAttachComponent::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetRotationTowards
// 0x0028 (0x0028 - 0x0000)
struct MatchaGameplayStatics_GetRotationTowards final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           OtherActor;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetRotationTowards) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetRotationTowards");
static_assert(sizeof(MatchaGameplayStatics_GetRotationTowards) == 0x000028, "Wrong size on MatchaGameplayStatics_GetRotationTowards");
static_assert(offsetof(MatchaGameplayStatics_GetRotationTowards, Actor) == 0x000000, "Member 'MatchaGameplayStatics_GetRotationTowards::Actor' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetRotationTowards, OtherActor) == 0x000008, "Member 'MatchaGameplayStatics_GetRotationTowards::OtherActor' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetRotationTowards, ReturnValue) == 0x000010, "Member 'MatchaGameplayStatics_GetRotationTowards::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetTickRateIntendedDeltaMilliseconds
// 0x0004 (0x0004 - 0x0000)
struct MatchaGameplayStatics_GetTickRateIntendedDeltaMilliseconds final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetTickRateIntendedDeltaMilliseconds) == 0x000004, "Wrong alignment on MatchaGameplayStatics_GetTickRateIntendedDeltaMilliseconds");
static_assert(sizeof(MatchaGameplayStatics_GetTickRateIntendedDeltaMilliseconds) == 0x000004, "Wrong size on MatchaGameplayStatics_GetTickRateIntendedDeltaMilliseconds");
static_assert(offsetof(MatchaGameplayStatics_GetTickRateIntendedDeltaMilliseconds, ReturnValue) == 0x000000, "Member 'MatchaGameplayStatics_GetTickRateIntendedDeltaMilliseconds::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetTickRateIntendedDeltaTime
// 0x0004 (0x0004 - 0x0000)
struct MatchaGameplayStatics_GetTickRateIntendedDeltaTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_GetTickRateIntendedDeltaTime) == 0x000004, "Wrong alignment on MatchaGameplayStatics_GetTickRateIntendedDeltaTime");
static_assert(sizeof(MatchaGameplayStatics_GetTickRateIntendedDeltaTime) == 0x000004, "Wrong size on MatchaGameplayStatics_GetTickRateIntendedDeltaTime");
static_assert(offsetof(MatchaGameplayStatics_GetTickRateIntendedDeltaTime, ReturnValue) == 0x000000, "Member 'MatchaGameplayStatics_GetTickRateIntendedDeltaTime::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetUISelectableSpawnRegions
// 0x0020 (0x0020 - 0x0000)
struct MatchaGameplayStatics_GetUISelectableSpawnRegions final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESpawnRegion>                          OutSelectableSpawnRegions;                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeRandom;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_GetUISelectableSpawnRegions) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetUISelectableSpawnRegions");
static_assert(sizeof(MatchaGameplayStatics_GetUISelectableSpawnRegions) == 0x000020, "Wrong size on MatchaGameplayStatics_GetUISelectableSpawnRegions");
static_assert(offsetof(MatchaGameplayStatics_GetUISelectableSpawnRegions, WorldContextObject) == 0x000000, "Member 'MatchaGameplayStatics_GetUISelectableSpawnRegions::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetUISelectableSpawnRegions, OutSelectableSpawnRegions) == 0x000008, "Member 'MatchaGameplayStatics_GetUISelectableSpawnRegions::OutSelectableSpawnRegions' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetUISelectableSpawnRegions, bIncludeRandom) == 0x000018, "Member 'MatchaGameplayStatics_GetUISelectableSpawnRegions::bIncludeRandom' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.GetVectorSideFromAnotherCCW
// 0x0038 (0x0038 - 0x0000)
struct MatchaGameplayStatics_GetVectorSideFromAnotherCCW final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_GetVectorSideFromAnotherCCW) == 0x000008, "Wrong alignment on MatchaGameplayStatics_GetVectorSideFromAnotherCCW");
static_assert(sizeof(MatchaGameplayStatics_GetVectorSideFromAnotherCCW) == 0x000038, "Wrong size on MatchaGameplayStatics_GetVectorSideFromAnotherCCW");
static_assert(offsetof(MatchaGameplayStatics_GetVectorSideFromAnotherCCW, A) == 0x000000, "Member 'MatchaGameplayStatics_GetVectorSideFromAnotherCCW::A' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetVectorSideFromAnotherCCW, B) == 0x000018, "Member 'MatchaGameplayStatics_GetVectorSideFromAnotherCCW::B' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_GetVectorSideFromAnotherCCW, ReturnValue) == 0x000030, "Member 'MatchaGameplayStatics_GetVectorSideFromAnotherCCW::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.HasQueuedJump
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_HasQueuedJump final
{
public:
	uint8                                         QueuedJumpFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_HasQueuedJump) == 0x000001, "Wrong alignment on MatchaGameplayStatics_HasQueuedJump");
static_assert(sizeof(MatchaGameplayStatics_HasQueuedJump) == 0x000002, "Wrong size on MatchaGameplayStatics_HasQueuedJump");
static_assert(offsetof(MatchaGameplayStatics_HasQueuedJump, QueuedJumpFlags) == 0x000000, "Member 'MatchaGameplayStatics_HasQueuedJump::QueuedJumpFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_HasQueuedJump, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_HasQueuedJump::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsActorFacingTowardsOtherActor
// 0x0018 (0x0018 - 0x0000)
struct MatchaGameplayStatics_IsActorFacingTowardsOtherActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           OtherActor;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_IsActorFacingTowardsOtherActor) == 0x000008, "Wrong alignment on MatchaGameplayStatics_IsActorFacingTowardsOtherActor");
static_assert(sizeof(MatchaGameplayStatics_IsActorFacingTowardsOtherActor) == 0x000018, "Wrong size on MatchaGameplayStatics_IsActorFacingTowardsOtherActor");
static_assert(offsetof(MatchaGameplayStatics_IsActorFacingTowardsOtherActor, Actor) == 0x000000, "Member 'MatchaGameplayStatics_IsActorFacingTowardsOtherActor::Actor' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsActorFacingTowardsOtherActor, OtherActor) == 0x000008, "Member 'MatchaGameplayStatics_IsActorFacingTowardsOtherActor::OtherActor' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsActorFacingTowardsOtherActor, ReturnValue) == 0x000010, "Member 'MatchaGameplayStatics_IsActorFacingTowardsOtherActor::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsActorWithin2DExtents
// 0x0038 (0x0038 - 0x0000)
struct MatchaGameplayStatics_IsActorWithin2DExtents final
{
public:
	const class AActor*                           AActor;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 Extents;                                           // 0x0008(0x0028)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_IsActorWithin2DExtents) == 0x000008, "Wrong alignment on MatchaGameplayStatics_IsActorWithin2DExtents");
static_assert(sizeof(MatchaGameplayStatics_IsActorWithin2DExtents) == 0x000038, "Wrong size on MatchaGameplayStatics_IsActorWithin2DExtents");
static_assert(offsetof(MatchaGameplayStatics_IsActorWithin2DExtents, AActor) == 0x000000, "Member 'MatchaGameplayStatics_IsActorWithin2DExtents::AActor' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsActorWithin2DExtents, Extents) == 0x000008, "Member 'MatchaGameplayStatics_IsActorWithin2DExtents::Extents' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsActorWithin2DExtents, ReturnValue) == 0x000030, "Member 'MatchaGameplayStatics_IsActorWithin2DExtents::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsCapsuleOverlappingCapsule
// 0x0050 (0x0050 - 0x0000)
struct MatchaGameplayStatics_IsCapsuleOverlappingCapsule final
{
public:
	struct FVector2D                              CapsuleAStart;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CapsuleAEnd;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleARadius;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CapsuleBStart;                                     // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CapsuleBEnd;                                       // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleBRadius;                                    // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x004C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule) == 0x000008, "Wrong alignment on MatchaGameplayStatics_IsCapsuleOverlappingCapsule");
static_assert(sizeof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule) == 0x000050, "Wrong size on MatchaGameplayStatics_IsCapsuleOverlappingCapsule");
static_assert(offsetof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule, CapsuleAStart) == 0x000000, "Member 'MatchaGameplayStatics_IsCapsuleOverlappingCapsule::CapsuleAStart' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule, CapsuleAEnd) == 0x000010, "Member 'MatchaGameplayStatics_IsCapsuleOverlappingCapsule::CapsuleAEnd' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule, CapsuleARadius) == 0x000020, "Member 'MatchaGameplayStatics_IsCapsuleOverlappingCapsule::CapsuleARadius' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule, CapsuleBStart) == 0x000028, "Member 'MatchaGameplayStatics_IsCapsuleOverlappingCapsule::CapsuleBStart' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule, CapsuleBEnd) == 0x000038, "Member 'MatchaGameplayStatics_IsCapsuleOverlappingCapsule::CapsuleBEnd' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule, CapsuleBRadius) == 0x000048, "Member 'MatchaGameplayStatics_IsCapsuleOverlappingCapsule::CapsuleBRadius' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCapsuleOverlappingCapsule, ReturnValue) == 0x00004C, "Member 'MatchaGameplayStatics_IsCapsuleOverlappingCapsule::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsCircleOverlappingCapsule
// 0x0040 (0x0040 - 0x0000)
struct MatchaGameplayStatics_IsCircleOverlappingCapsule final
{
public:
	struct FVector2D                              CircleCenter;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircleRadius;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CapsuleStart;                                      // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CapsuleEnd;                                        // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_IsCircleOverlappingCapsule) == 0x000008, "Wrong alignment on MatchaGameplayStatics_IsCircleOverlappingCapsule");
static_assert(sizeof(MatchaGameplayStatics_IsCircleOverlappingCapsule) == 0x000040, "Wrong size on MatchaGameplayStatics_IsCircleOverlappingCapsule");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCapsule, CircleCenter) == 0x000000, "Member 'MatchaGameplayStatics_IsCircleOverlappingCapsule::CircleCenter' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCapsule, CircleRadius) == 0x000010, "Member 'MatchaGameplayStatics_IsCircleOverlappingCapsule::CircleRadius' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCapsule, CapsuleStart) == 0x000018, "Member 'MatchaGameplayStatics_IsCircleOverlappingCapsule::CapsuleStart' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCapsule, CapsuleEnd) == 0x000028, "Member 'MatchaGameplayStatics_IsCircleOverlappingCapsule::CapsuleEnd' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCapsule, CapsuleRadius) == 0x000038, "Member 'MatchaGameplayStatics_IsCircleOverlappingCapsule::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCapsule, ReturnValue) == 0x00003C, "Member 'MatchaGameplayStatics_IsCircleOverlappingCapsule::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsCircleOverlappingCircle
// 0x0030 (0x0030 - 0x0000)
struct MatchaGameplayStatics_IsCircleOverlappingCircle final
{
public:
	struct FVector2D                              CenterA;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusA;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CenterB;                                           // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusB;                                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_IsCircleOverlappingCircle) == 0x000008, "Wrong alignment on MatchaGameplayStatics_IsCircleOverlappingCircle");
static_assert(sizeof(MatchaGameplayStatics_IsCircleOverlappingCircle) == 0x000030, "Wrong size on MatchaGameplayStatics_IsCircleOverlappingCircle");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCircle, CenterA) == 0x000000, "Member 'MatchaGameplayStatics_IsCircleOverlappingCircle::CenterA' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCircle, RadiusA) == 0x000010, "Member 'MatchaGameplayStatics_IsCircleOverlappingCircle::RadiusA' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCircle, CenterB) == 0x000018, "Member 'MatchaGameplayStatics_IsCircleOverlappingCircle::CenterB' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCircle, RadiusB) == 0x000028, "Member 'MatchaGameplayStatics_IsCircleOverlappingCircle::RadiusB' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCircleOverlappingCircle, ReturnValue) == 0x00002C, "Member 'MatchaGameplayStatics_IsCircleOverlappingCircle::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsCounterHit
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsCounterHit final
{
public:
	uint8                                         AppliedHitFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsCounterHit) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsCounterHit");
static_assert(sizeof(MatchaGameplayStatics_IsCounterHit) == 0x000002, "Wrong size on MatchaGameplayStatics_IsCounterHit");
static_assert(offsetof(MatchaGameplayStatics_IsCounterHit, AppliedHitFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsCounterHit::AppliedHitFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsCounterHit, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsCounterHit::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsLedgeGrantsIntangibility
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsLedgeGrantsIntangibility final
{
public:
	uint8                                         LedgePropertyFlags;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsLedgeGrantsIntangibility) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsLedgeGrantsIntangibility");
static_assert(sizeof(MatchaGameplayStatics_IsLedgeGrantsIntangibility) == 0x000002, "Wrong size on MatchaGameplayStatics_IsLedgeGrantsIntangibility");
static_assert(offsetof(MatchaGameplayStatics_IsLedgeGrantsIntangibility, LedgePropertyFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsLedgeGrantsIntangibility::LedgePropertyFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsLedgeGrantsIntangibility, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsLedgeGrantsIntangibility::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsLedgeOnlyAllowsJump
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsLedgeOnlyAllowsJump final
{
public:
	uint8                                         LedgePropertyFlags;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsLedgeOnlyAllowsJump) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsLedgeOnlyAllowsJump");
static_assert(sizeof(MatchaGameplayStatics_IsLedgeOnlyAllowsJump) == 0x000002, "Wrong size on MatchaGameplayStatics_IsLedgeOnlyAllowsJump");
static_assert(offsetof(MatchaGameplayStatics_IsLedgeOnlyAllowsJump, LedgePropertyFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsLedgeOnlyAllowsJump::LedgePropertyFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsLedgeOnlyAllowsJump, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsLedgeOnlyAllowsJump::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsLethalKnockBackHit
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsLethalKnockBackHit final
{
public:
	uint8                                         AppliedHitFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsLethalKnockBackHit) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsLethalKnockBackHit");
static_assert(sizeof(MatchaGameplayStatics_IsLethalKnockBackHit) == 0x000002, "Wrong size on MatchaGameplayStatics_IsLethalKnockBackHit");
static_assert(offsetof(MatchaGameplayStatics_IsLethalKnockBackHit, AppliedHitFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsLethalKnockBackHit::AppliedHitFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsLethalKnockBackHit, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsLethalKnockBackHit::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsOwnedEntityHit
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsOwnedEntityHit final
{
public:
	uint8                                         AppliedHitFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsOwnedEntityHit) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsOwnedEntityHit");
static_assert(sizeof(MatchaGameplayStatics_IsOwnedEntityHit) == 0x000002, "Wrong size on MatchaGameplayStatics_IsOwnedEntityHit");
static_assert(offsetof(MatchaGameplayStatics_IsOwnedEntityHit, AppliedHitFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsOwnedEntityHit::AppliedHitFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsOwnedEntityHit, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsOwnedEntityHit::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsPerfectShieldHit
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsPerfectShieldHit final
{
public:
	uint8                                         AppliedHitFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsPerfectShieldHit) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsPerfectShieldHit");
static_assert(sizeof(MatchaGameplayStatics_IsPerfectShieldHit) == 0x000002, "Wrong size on MatchaGameplayStatics_IsPerfectShieldHit");
static_assert(offsetof(MatchaGameplayStatics_IsPerfectShieldHit, AppliedHitFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsPerfectShieldHit::AppliedHitFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsPerfectShieldHit, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsPerfectShieldHit::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsQueuedJumpFullGroundJump
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsQueuedJumpFullGroundJump final
{
public:
	uint8                                         QueuedJumpFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsQueuedJumpFullGroundJump) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsQueuedJumpFullGroundJump");
static_assert(sizeof(MatchaGameplayStatics_IsQueuedJumpFullGroundJump) == 0x000002, "Wrong size on MatchaGameplayStatics_IsQueuedJumpFullGroundJump");
static_assert(offsetof(MatchaGameplayStatics_IsQueuedJumpFullGroundJump, QueuedJumpFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsQueuedJumpFullGroundJump::QueuedJumpFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsQueuedJumpFullGroundJump, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsQueuedJumpFullGroundJump::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsQueuedJumpLedgeJump
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsQueuedJumpLedgeJump final
{
public:
	uint8                                         QueuedJumpFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsQueuedJumpLedgeJump) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsQueuedJumpLedgeJump");
static_assert(sizeof(MatchaGameplayStatics_IsQueuedJumpLedgeJump) == 0x000002, "Wrong size on MatchaGameplayStatics_IsQueuedJumpLedgeJump");
static_assert(offsetof(MatchaGameplayStatics_IsQueuedJumpLedgeJump, QueuedJumpFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsQueuedJumpLedgeJump::QueuedJumpFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsQueuedJumpLedgeJump, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsQueuedJumpLedgeJump::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsQueuedJumpShortGroundJump
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsQueuedJumpShortGroundJump final
{
public:
	uint8                                         QueuedJumpFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsQueuedJumpShortGroundJump) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsQueuedJumpShortGroundJump");
static_assert(sizeof(MatchaGameplayStatics_IsQueuedJumpShortGroundJump) == 0x000002, "Wrong size on MatchaGameplayStatics_IsQueuedJumpShortGroundJump");
static_assert(offsetof(MatchaGameplayStatics_IsQueuedJumpShortGroundJump, QueuedJumpFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsQueuedJumpShortGroundJump::QueuedJumpFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsQueuedJumpShortGroundJump, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsQueuedJumpShortGroundJump::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsRectangleOverlappingRectangle
// 0x0048 (0x0048 - 0x0000)
struct MatchaGameplayStatics_IsRectangleOverlappingRectangle final
{
public:
	struct FVector2D                              CenterA;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ExtentsA;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CenterB;                                           // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ExtentsB;                                          // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_IsRectangleOverlappingRectangle) == 0x000008, "Wrong alignment on MatchaGameplayStatics_IsRectangleOverlappingRectangle");
static_assert(sizeof(MatchaGameplayStatics_IsRectangleOverlappingRectangle) == 0x000048, "Wrong size on MatchaGameplayStatics_IsRectangleOverlappingRectangle");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangle, CenterA) == 0x000000, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangle::CenterA' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangle, ExtentsA) == 0x000010, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangle::ExtentsA' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangle, CenterB) == 0x000020, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangle::CenterB' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangle, ExtentsB) == 0x000030, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangle::ExtentsB' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangle, ReturnValue) == 0x000040, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangle::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsRectangleOverlappingRectangleByEdges
// 0x0024 (0x0024 - 0x0000)
struct MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges final
{
public:
	float                                         TopA;                                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottomA;                                           // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftA;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightA;                                            // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopB;                                              // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottomB;                                           // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftB;                                             // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightB;                                            // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges) == 0x000004, "Wrong alignment on MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges");
static_assert(sizeof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges) == 0x000024, "Wrong size on MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, TopA) == 0x000000, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::TopA' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, BottomA) == 0x000004, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::BottomA' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, LeftA) == 0x000008, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::LeftA' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, RightA) == 0x00000C, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::RightA' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, TopB) == 0x000010, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::TopB' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, BottomB) == 0x000014, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::BottomB' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, LeftB) == 0x000018, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::LeftB' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, RightB) == 0x00001C, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::RightB' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges, ReturnValue) == 0x000020, "Member 'MatchaGameplayStatics_IsRectangleOverlappingRectangleByEdges::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.IsShieldHit
// 0x0002 (0x0002 - 0x0000)
struct MatchaGameplayStatics_IsShieldHit final
{
public:
	uint8                                         AppliedHitFlags;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_IsShieldHit) == 0x000001, "Wrong alignment on MatchaGameplayStatics_IsShieldHit");
static_assert(sizeof(MatchaGameplayStatics_IsShieldHit) == 0x000002, "Wrong size on MatchaGameplayStatics_IsShieldHit");
static_assert(offsetof(MatchaGameplayStatics_IsShieldHit, AppliedHitFlags) == 0x000000, "Member 'MatchaGameplayStatics_IsShieldHit::AppliedHitFlags' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_IsShieldHit, ReturnValue) == 0x000001, "Member 'MatchaGameplayStatics_IsShieldHit::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.SmoothVectorLerp
// 0x0058 (0x0058 - 0x0000)
struct MatchaGameplayStatics_SmoothVectorLerp final
{
public:
	struct FVector                                Current;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpTime;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_SmoothVectorLerp) == 0x000008, "Wrong alignment on MatchaGameplayStatics_SmoothVectorLerp");
static_assert(sizeof(MatchaGameplayStatics_SmoothVectorLerp) == 0x000058, "Wrong size on MatchaGameplayStatics_SmoothVectorLerp");
static_assert(offsetof(MatchaGameplayStatics_SmoothVectorLerp, Current) == 0x000000, "Member 'MatchaGameplayStatics_SmoothVectorLerp::Current' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SmoothVectorLerp, Target) == 0x000018, "Member 'MatchaGameplayStatics_SmoothVectorLerp::Target' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SmoothVectorLerp, DeltaTime) == 0x000030, "Member 'MatchaGameplayStatics_SmoothVectorLerp::DeltaTime' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SmoothVectorLerp, Precision) == 0x000034, "Member 'MatchaGameplayStatics_SmoothVectorLerp::Precision' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SmoothVectorLerp, LerpTime) == 0x000038, "Member 'MatchaGameplayStatics_SmoothVectorLerp::LerpTime' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SmoothVectorLerp, ReturnValue) == 0x000040, "Member 'MatchaGameplayStatics_SmoothVectorLerp::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.SpawnFXFromEntity
// 0x00A0 (0x00A0 - 0x0000)
struct MatchaGameplayStatics_SpawnFXFromEntity final
{
public:
	const class AActor*                           SpawningEntity;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectEventType                              EffectEventType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCombinedFXInfo                        EffectInfo;                                        // 0x0010(0x0088)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AssociatedEntityIndex;                             // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_SpawnFXFromEntity) == 0x000008, "Wrong alignment on MatchaGameplayStatics_SpawnFXFromEntity");
static_assert(sizeof(MatchaGameplayStatics_SpawnFXFromEntity) == 0x0000A0, "Wrong size on MatchaGameplayStatics_SpawnFXFromEntity");
static_assert(offsetof(MatchaGameplayStatics_SpawnFXFromEntity, SpawningEntity) == 0x000000, "Member 'MatchaGameplayStatics_SpawnFXFromEntity::SpawningEntity' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SpawnFXFromEntity, EffectEventType) == 0x000008, "Member 'MatchaGameplayStatics_SpawnFXFromEntity::EffectEventType' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SpawnFXFromEntity, EffectInfo) == 0x000010, "Member 'MatchaGameplayStatics_SpawnFXFromEntity::EffectInfo' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SpawnFXFromEntity, AssociatedEntityIndex) == 0x000098, "Member 'MatchaGameplayStatics_SpawnFXFromEntity::AssociatedEntityIndex' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.SpawnRenderActorFromEntity
// 0x0050 (0x0050 - 0x0000)
struct MatchaGameplayStatics_SpawnRenderActorFromEntity final
{
public:
	const class AActor*                           SpawningEntity;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnForEveryone;                                 // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_SpawnRenderActorFromEntity) == 0x000008, "Wrong alignment on MatchaGameplayStatics_SpawnRenderActorFromEntity");
static_assert(sizeof(MatchaGameplayStatics_SpawnRenderActorFromEntity) == 0x000050, "Wrong size on MatchaGameplayStatics_SpawnRenderActorFromEntity");
static_assert(offsetof(MatchaGameplayStatics_SpawnRenderActorFromEntity, SpawningEntity) == 0x000000, "Member 'MatchaGameplayStatics_SpawnRenderActorFromEntity::SpawningEntity' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SpawnRenderActorFromEntity, ActorClass) == 0x000008, "Member 'MatchaGameplayStatics_SpawnRenderActorFromEntity::ActorClass' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SpawnRenderActorFromEntity, LocationOffset) == 0x000030, "Member 'MatchaGameplayStatics_SpawnRenderActorFromEntity::LocationOffset' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_SpawnRenderActorFromEntity, bSpawnForEveryone) == 0x000048, "Member 'MatchaGameplayStatics_SpawnRenderActorFromEntity::bSpawnForEveryone' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.TryFindVisibilityOverrideInList
// 0x0030 (0x0030 - 0x0000)
struct MatchaGameplayStatics_TryFindVisibilityOverrideInList final
{
public:
	TArray<struct FVisibilityOverride>            OverridesList;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisibilityOverrideTargetType                 Type;                                              // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVisibilityOverride                    OutOverride;                                       // 0x001C(0x000C)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaGameplayStatics_TryFindVisibilityOverrideInList) == 0x000008, "Wrong alignment on MatchaGameplayStatics_TryFindVisibilityOverrideInList");
static_assert(sizeof(MatchaGameplayStatics_TryFindVisibilityOverrideInList) == 0x000030, "Wrong size on MatchaGameplayStatics_TryFindVisibilityOverrideInList");
static_assert(offsetof(MatchaGameplayStatics_TryFindVisibilityOverrideInList, OverridesList) == 0x000000, "Member 'MatchaGameplayStatics_TryFindVisibilityOverrideInList::OverridesList' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_TryFindVisibilityOverrideInList, Identifier) == 0x000010, "Member 'MatchaGameplayStatics_TryFindVisibilityOverrideInList::Identifier' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_TryFindVisibilityOverrideInList, Type) == 0x000018, "Member 'MatchaGameplayStatics_TryFindVisibilityOverrideInList::Type' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_TryFindVisibilityOverrideInList, OutOverride) == 0x00001C, "Member 'MatchaGameplayStatics_TryFindVisibilityOverrideInList::OutOverride' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_TryFindVisibilityOverrideInList, ReturnValue) == 0x000028, "Member 'MatchaGameplayStatics_TryFindVisibilityOverrideInList::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameplayStatics.TryGetEquippedHackItem
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameplayStatics_TryGetEquippedHackItem final
{
public:
	const class AMatchaSnapNetCharacterEntity*    CharacterEntity;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UMatchaItemAsset*                 ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameplayStatics_TryGetEquippedHackItem) == 0x000008, "Wrong alignment on MatchaGameplayStatics_TryGetEquippedHackItem");
static_assert(sizeof(MatchaGameplayStatics_TryGetEquippedHackItem) == 0x000010, "Wrong size on MatchaGameplayStatics_TryGetEquippedHackItem");
static_assert(offsetof(MatchaGameplayStatics_TryGetEquippedHackItem, CharacterEntity) == 0x000000, "Member 'MatchaGameplayStatics_TryGetEquippedHackItem::CharacterEntity' has a wrong offset!");
static_assert(offsetof(MatchaGameplayStatics_TryGetEquippedHackItem, ReturnValue) == 0x000008, "Member 'MatchaGameplayStatics_TryGetEquippedHackItem::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.FindPlayerUIDataForPlayerIndex
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddIfNotFound;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaPlayerUIData*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex) == 0x000008, "Wrong alignment on MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex");
static_assert(sizeof(MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex) == 0x000010, "Wrong size on MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex");
static_assert(offsetof(MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex, PlayerIndex) == 0x000000, "Member 'MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex, bAddIfNotFound) == 0x000004, "Member 'MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex::bAddIfNotFound' has a wrong offset!");
static_assert(offsetof(MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex, ReturnValue) == 0x000008, "Member 'MatchaGameWorldUIData_FindPlayerUIDataForPlayerIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.FindTeamUIDataForPlayerIndex
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaTeamUIData*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex) == 0x000008, "Wrong alignment on MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex");
static_assert(sizeof(MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex) == 0x000010, "Wrong size on MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex");
static_assert(offsetof(MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex, PlayerIndex) == 0x000000, "Member 'MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex, ReturnValue) == 0x000008, "Member 'MatchaGameWorldUIData_FindTeamUIDataForPlayerIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.FindTeamUIDataForTeamNumber
// 0x0010 (0x0010 - 0x0000)
struct MatchaGameWorldUIData_FindTeamUIDataForTeamNumber final
{
public:
	int32                                         TeamNumber;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddIfNotFound;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaTeamUIData*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_FindTeamUIDataForTeamNumber) == 0x000008, "Wrong alignment on MatchaGameWorldUIData_FindTeamUIDataForTeamNumber");
static_assert(sizeof(MatchaGameWorldUIData_FindTeamUIDataForTeamNumber) == 0x000010, "Wrong size on MatchaGameWorldUIData_FindTeamUIDataForTeamNumber");
static_assert(offsetof(MatchaGameWorldUIData_FindTeamUIDataForTeamNumber, TeamNumber) == 0x000000, "Member 'MatchaGameWorldUIData_FindTeamUIDataForTeamNumber::TeamNumber' has a wrong offset!");
static_assert(offsetof(MatchaGameWorldUIData_FindTeamUIDataForTeamNumber, bAddIfNotFound) == 0x000004, "Member 'MatchaGameWorldUIData_FindTeamUIDataForTeamNumber::bAddIfNotFound' has a wrong offset!");
static_assert(offsetof(MatchaGameWorldUIData_FindTeamUIDataForTeamNumber, ReturnValue) == 0x000008, "Member 'MatchaGameWorldUIData_FindTeamUIDataForTeamNumber::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.GetPlayerUIDataForSpectatedPlayer
// 0x0008 (0x0008 - 0x0000)
struct MatchaGameWorldUIData_GetPlayerUIDataForSpectatedPlayer final
{
public:
	class UMatchaPlayerUIData*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_GetPlayerUIDataForSpectatedPlayer) == 0x000008, "Wrong alignment on MatchaGameWorldUIData_GetPlayerUIDataForSpectatedPlayer");
static_assert(sizeof(MatchaGameWorldUIData_GetPlayerUIDataForSpectatedPlayer) == 0x000008, "Wrong size on MatchaGameWorldUIData_GetPlayerUIDataForSpectatedPlayer");
static_assert(offsetof(MatchaGameWorldUIData_GetPlayerUIDataForSpectatedPlayer, ReturnValue) == 0x000000, "Member 'MatchaGameWorldUIData_GetPlayerUIDataForSpectatedPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.OnSpectatedPlayerIndexChanged
// 0x000C (0x000C - 0x0000)
struct MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged final
{
public:
	int32                                         InPlayerIndexForLocalPlayer;                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousPlayerIndex;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPlayerIndex;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged) == 0x000004, "Wrong alignment on MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged");
static_assert(sizeof(MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged) == 0x00000C, "Wrong size on MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged");
static_assert(offsetof(MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged, InPlayerIndexForLocalPlayer) == 0x000000, "Member 'MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged::InPlayerIndexForLocalPlayer' has a wrong offset!");
static_assert(offsetof(MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged, PreviousPlayerIndex) == 0x000004, "Member 'MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged::PreviousPlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged, CurrentPlayerIndex) == 0x000008, "Member 'MatchaGameWorldUIData_OnSpectatedPlayerIndexChanged::CurrentPlayerIndex' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.RegisterActiveHackChest
// 0x0001 (0x0001 - 0x0000)
struct MatchaGameWorldUIData_RegisterActiveHackChest final
{
public:
	EHackType                                     HackType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_RegisterActiveHackChest) == 0x000001, "Wrong alignment on MatchaGameWorldUIData_RegisterActiveHackChest");
static_assert(sizeof(MatchaGameWorldUIData_RegisterActiveHackChest) == 0x000001, "Wrong size on MatchaGameWorldUIData_RegisterActiveHackChest");
static_assert(offsetof(MatchaGameWorldUIData_RegisterActiveHackChest, HackType) == 0x000000, "Member 'MatchaGameWorldUIData_RegisterActiveHackChest::HackType' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.UnregisterActiveHackChest
// 0x0001 (0x0001 - 0x0000)
struct MatchaGameWorldUIData_UnregisterActiveHackChest final
{
public:
	EHackType                                     HackType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_UnregisterActiveHackChest) == 0x000001, "Wrong alignment on MatchaGameWorldUIData_UnregisterActiveHackChest");
static_assert(sizeof(MatchaGameWorldUIData_UnregisterActiveHackChest) == 0x000001, "Wrong size on MatchaGameWorldUIData_UnregisterActiveHackChest");
static_assert(offsetof(MatchaGameWorldUIData_UnregisterActiveHackChest, HackType) == 0x000000, "Member 'MatchaGameWorldUIData_UnregisterActiveHackChest::HackType' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.GetAlivePlayerCount
// 0x0004 (0x0004 - 0x0000)
struct MatchaGameWorldUIData_GetAlivePlayerCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_GetAlivePlayerCount) == 0x000004, "Wrong alignment on MatchaGameWorldUIData_GetAlivePlayerCount");
static_assert(sizeof(MatchaGameWorldUIData_GetAlivePlayerCount) == 0x000004, "Wrong size on MatchaGameWorldUIData_GetAlivePlayerCount");
static_assert(offsetof(MatchaGameWorldUIData_GetAlivePlayerCount, ReturnValue) == 0x000000, "Member 'MatchaGameWorldUIData_GetAlivePlayerCount::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaGameWorldUIData.GetTotalPlayerCount
// 0x0004 (0x0004 - 0x0000)
struct MatchaGameWorldUIData_GetTotalPlayerCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaGameWorldUIData_GetTotalPlayerCount) == 0x000004, "Wrong alignment on MatchaGameWorldUIData_GetTotalPlayerCount");
static_assert(sizeof(MatchaGameWorldUIData_GetTotalPlayerCount) == 0x000004, "Wrong size on MatchaGameWorldUIData_GetTotalPlayerCount");
static_assert(offsetof(MatchaGameWorldUIData_GetTotalPlayerCount, ReturnValue) == 0x000000, "Member 'MatchaGameWorldUIData_GetTotalPlayerCount::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetInteractiveEntity.GetPlayerColliderBounds
// 0x0030 (0x0030 - 0x0000)
struct MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds final
{
public:
	struct FVector                                OutOrigin;                                         // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutBounds;                                         // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds) == 0x000008, "Wrong alignment on MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds");
static_assert(sizeof(MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds) == 0x000030, "Wrong size on MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds");
static_assert(offsetof(MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds, OutOrigin) == 0x000000, "Member 'MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds::OutOrigin' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds, OutBounds) == 0x000018, "Member 'MatchaSnapNetInteractiveEntity_GetPlayerColliderBounds::OutBounds' has a wrong offset!");

// Function Matcha.MatchaHittableInteractiveEntity.OnHitReceived
// 0x0088 (0x0088 - 0x0000)
struct MatchaHittableInteractiveEntity_OnHitReceived final
{
public:
	const class AActor*                           HitInstigator;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           HitActor;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaHitData                         HitData;                                           // 0x0010(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaHittableInteractiveEntity_OnHitReceived) == 0x000008, "Wrong alignment on MatchaHittableInteractiveEntity_OnHitReceived");
static_assert(sizeof(MatchaHittableInteractiveEntity_OnHitReceived) == 0x000088, "Wrong size on MatchaHittableInteractiveEntity_OnHitReceived");
static_assert(offsetof(MatchaHittableInteractiveEntity_OnHitReceived, HitInstigator) == 0x000000, "Member 'MatchaHittableInteractiveEntity_OnHitReceived::HitInstigator' has a wrong offset!");
static_assert(offsetof(MatchaHittableInteractiveEntity_OnHitReceived, HitActor) == 0x000008, "Member 'MatchaHittableInteractiveEntity_OnHitReceived::HitActor' has a wrong offset!");
static_assert(offsetof(MatchaHittableInteractiveEntity_OnHitReceived, HitData) == 0x000010, "Member 'MatchaHittableInteractiveEntity_OnHitReceived::HitData' has a wrong offset!");

// Function Matcha.MatchaHitVolumeEntity.OnVolumeHitATarget
// 0x0080 (0x0080 - 0x0000)
struct MatchaHitVolumeEntity_OnVolumeHitATarget final
{
public:
	class AActor*                                 TargetHit;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaHitData                         HitData;                                           // 0x0008(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaHitVolumeEntity_OnVolumeHitATarget) == 0x000008, "Wrong alignment on MatchaHitVolumeEntity_OnVolumeHitATarget");
static_assert(sizeof(MatchaHitVolumeEntity_OnVolumeHitATarget) == 0x000080, "Wrong size on MatchaHitVolumeEntity_OnVolumeHitATarget");
static_assert(offsetof(MatchaHitVolumeEntity_OnVolumeHitATarget, TargetHit) == 0x000000, "Member 'MatchaHitVolumeEntity_OnVolumeHitATarget::TargetHit' has a wrong offset!");
static_assert(offsetof(MatchaHitVolumeEntity_OnVolumeHitATarget, HitData) == 0x000008, "Member 'MatchaHitVolumeEntity_OnVolumeHitATarget::HitData' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.HandleFailedLoginResponse
// 0x0058 (0x0058 - 0x0000)
struct MatchaIdentityServiceModel_HandleFailedLoginResponse final
{
public:
	struct FErrorResponseV1                       LoginError;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_HandleFailedLoginResponse) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_HandleFailedLoginResponse");
static_assert(sizeof(MatchaIdentityServiceModel_HandleFailedLoginResponse) == 0x000058, "Wrong size on MatchaIdentityServiceModel_HandleFailedLoginResponse");
static_assert(offsetof(MatchaIdentityServiceModel_HandleFailedLoginResponse, LoginError) == 0x000000, "Member 'MatchaIdentityServiceModel_HandleFailedLoginResponse::LoginError' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.HandleSuccessfulLoginResponse
// 0x0058 (0x0058 - 0x0000)
struct MatchaIdentityServiceModel_HandleSuccessfulLoginResponse final
{
public:
	struct FLoginResponseV1                       LoginResponse;                                     // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_HandleSuccessfulLoginResponse) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_HandleSuccessfulLoginResponse");
static_assert(sizeof(MatchaIdentityServiceModel_HandleSuccessfulLoginResponse) == 0x000058, "Wrong size on MatchaIdentityServiceModel_HandleSuccessfulLoginResponse");
static_assert(offsetof(MatchaIdentityServiceModel_HandleSuccessfulLoginResponse, LoginResponse) == 0x000000, "Member 'MatchaIdentityServiceModel_HandleSuccessfulLoginResponse::LoginResponse' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.RegisterPlayer
// 0x0020 (0x0020 - 0x0000)
struct MatchaIdentityServiceModel_RegisterPlayer final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelfRating;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_RegisterPlayer) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_RegisterPlayer");
static_assert(sizeof(MatchaIdentityServiceModel_RegisterPlayer) == 0x000020, "Wrong size on MatchaIdentityServiceModel_RegisterPlayer");
static_assert(offsetof(MatchaIdentityServiceModel_RegisterPlayer, Name_0) == 0x000000, "Member 'MatchaIdentityServiceModel_RegisterPlayer::Name_0' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_RegisterPlayer, SelfRating) == 0x000010, "Member 'MatchaIdentityServiceModel_RegisterPlayer::SelfRating' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.SendLoginSteamV1Request
// 0x0038 (0x0038 - 0x0000)
struct MatchaIdentityServiceModel_SendLoginSteamV1Request final
{
public:
	class FString                                 SteamAuthSessionTicket;                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentGameLanguage;                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasSent;                                           // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaIdentityServiceModel_SendLoginSteamV1Request) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_SendLoginSteamV1Request");
static_assert(sizeof(MatchaIdentityServiceModel_SendLoginSteamV1Request) == 0x000038, "Wrong size on MatchaIdentityServiceModel_SendLoginSteamV1Request");
static_assert(offsetof(MatchaIdentityServiceModel_SendLoginSteamV1Request, SteamAuthSessionTicket) == 0x000000, "Member 'MatchaIdentityServiceModel_SendLoginSteamV1Request::SteamAuthSessionTicket' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_SendLoginSteamV1Request, CurrentGameLanguage) == 0x000010, "Member 'MatchaIdentityServiceModel_SendLoginSteamV1Request::CurrentGameLanguage' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_SendLoginSteamV1Request, DisplayName) == 0x000020, "Member 'MatchaIdentityServiceModel_SendLoginSteamV1Request::DisplayName' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_SendLoginSteamV1Request, WasSent) == 0x000030, "Member 'MatchaIdentityServiceModel_SendLoginSteamV1Request::WasSent' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.SendLoginTokenV1Request
// 0x0028 (0x0028 - 0x0000)
struct MatchaIdentityServiceModel_SendLoginTokenV1Request final
{
public:
	bool                                          WasSent;                                           // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Token;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutRequestId;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_SendLoginTokenV1Request) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_SendLoginTokenV1Request");
static_assert(sizeof(MatchaIdentityServiceModel_SendLoginTokenV1Request) == 0x000028, "Wrong size on MatchaIdentityServiceModel_SendLoginTokenV1Request");
static_assert(offsetof(MatchaIdentityServiceModel_SendLoginTokenV1Request, WasSent) == 0x000000, "Member 'MatchaIdentityServiceModel_SendLoginTokenV1Request::WasSent' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_SendLoginTokenV1Request, Token) == 0x000008, "Member 'MatchaIdentityServiceModel_SendLoginTokenV1Request::Token' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_SendLoginTokenV1Request, OutRequestId) == 0x000018, "Member 'MatchaIdentityServiceModel_SendLoginTokenV1Request::OutRequestId' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.SetIdentityState
// 0x0001 (0x0001 - 0x0000)
struct MatchaIdentityServiceModel_SetIdentityState final
{
public:
	EIdentityState                                NextState;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_SetIdentityState) == 0x000001, "Wrong alignment on MatchaIdentityServiceModel_SetIdentityState");
static_assert(sizeof(MatchaIdentityServiceModel_SetIdentityState) == 0x000001, "Wrong size on MatchaIdentityServiceModel_SetIdentityState");
static_assert(offsetof(MatchaIdentityServiceModel_SetIdentityState, NextState) == 0x000000, "Member 'MatchaIdentityServiceModel_SetIdentityState::NextState' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.SetName
// 0x0010 (0x0010 - 0x0000)
struct MatchaIdentityServiceModel_SetName final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_SetName) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_SetName");
static_assert(sizeof(MatchaIdentityServiceModel_SetName) == 0x000010, "Wrong size on MatchaIdentityServiceModel_SetName");
static_assert(offsetof(MatchaIdentityServiceModel_SetName, Name_0) == 0x000000, "Member 'MatchaIdentityServiceModel_SetName::Name_0' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.TryLogin
// 0x0018 (0x0018 - 0x0000)
struct MatchaIdentityServiceModel_TryLogin final
{
public:
	bool                                          Attempted;                                         // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_TryLogin) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_TryLogin");
static_assert(sizeof(MatchaIdentityServiceModel_TryLogin) == 0x000018, "Wrong size on MatchaIdentityServiceModel_TryLogin");
static_assert(offsetof(MatchaIdentityServiceModel_TryLogin, Attempted) == 0x000000, "Member 'MatchaIdentityServiceModel_TryLogin::Attempted' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_TryLogin, DisplayName) == 0x000008, "Member 'MatchaIdentityServiceModel_TryLogin::DisplayName' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.UpdateAccessTokens
// 0x0020 (0x0020 - 0x0000)
struct MatchaIdentityServiceModel_UpdateAccessTokens final
{
public:
	struct FAccessTokens                          Tokens;                                            // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_UpdateAccessTokens) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_UpdateAccessTokens");
static_assert(sizeof(MatchaIdentityServiceModel_UpdateAccessTokens) == 0x000020, "Wrong size on MatchaIdentityServiceModel_UpdateAccessTokens");
static_assert(offsetof(MatchaIdentityServiceModel_UpdateAccessTokens, Tokens) == 0x000000, "Member 'MatchaIdentityServiceModel_UpdateAccessTokens::Tokens' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.GetAccessTokens
// 0x0028 (0x0028 - 0x0000)
struct MatchaIdentityServiceModel_GetAccessTokens final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAccessTokens                          Tokens;                                            // 0x0008(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_GetAccessTokens) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_GetAccessTokens");
static_assert(sizeof(MatchaIdentityServiceModel_GetAccessTokens) == 0x000028, "Wrong size on MatchaIdentityServiceModel_GetAccessTokens");
static_assert(offsetof(MatchaIdentityServiceModel_GetAccessTokens, Success) == 0x000000, "Member 'MatchaIdentityServiceModel_GetAccessTokens::Success' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_GetAccessTokens, Tokens) == 0x000008, "Member 'MatchaIdentityServiceModel_GetAccessTokens::Tokens' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.GetCachedLoginResponse
// 0x0060 (0x0060 - 0x0000)
struct MatchaIdentityServiceModel_GetCachedLoginResponse final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoginResponseV1                       LoginResponse;                                     // 0x0008(0x0058)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_GetCachedLoginResponse) == 0x000008, "Wrong alignment on MatchaIdentityServiceModel_GetCachedLoginResponse");
static_assert(sizeof(MatchaIdentityServiceModel_GetCachedLoginResponse) == 0x000060, "Wrong size on MatchaIdentityServiceModel_GetCachedLoginResponse");
static_assert(offsetof(MatchaIdentityServiceModel_GetCachedLoginResponse, Success) == 0x000000, "Member 'MatchaIdentityServiceModel_GetCachedLoginResponse::Success' has a wrong offset!");
static_assert(offsetof(MatchaIdentityServiceModel_GetCachedLoginResponse, LoginResponse) == 0x000008, "Member 'MatchaIdentityServiceModel_GetCachedLoginResponse::LoginResponse' has a wrong offset!");

// Function Matcha.MatchaIdentityServiceModel.GetIdentityState
// 0x0001 (0x0001 - 0x0000)
struct MatchaIdentityServiceModel_GetIdentityState final
{
public:
	EIdentityState                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaIdentityServiceModel_GetIdentityState) == 0x000001, "Wrong alignment on MatchaIdentityServiceModel_GetIdentityState");
static_assert(sizeof(MatchaIdentityServiceModel_GetIdentityState) == 0x000001, "Wrong size on MatchaIdentityServiceModel_GetIdentityState");
static_assert(offsetof(MatchaIdentityServiceModel_GetIdentityState, ReturnValue) == 0x000000, "Member 'MatchaIdentityServiceModel_GetIdentityState::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInteractionUtils.TryCancelInteraction
// 0x0150 (0x0150 - 0x0000)
struct MatchaInteractionUtils_TryCancelInteraction final
{
public:
	struct FInProgressInteraction                 InProgressInteraction;                             // 0x0000(0x0140)(Parm, OutParm, NativeAccessSpecifierPublic)
	const class UWorld*                           World;                                             // 0x0140(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0148(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInteractionUtils_TryCancelInteraction) == 0x000008, "Wrong alignment on MatchaInteractionUtils_TryCancelInteraction");
static_assert(sizeof(MatchaInteractionUtils_TryCancelInteraction) == 0x000150, "Wrong size on MatchaInteractionUtils_TryCancelInteraction");
static_assert(offsetof(MatchaInteractionUtils_TryCancelInteraction, InProgressInteraction) == 0x000000, "Member 'MatchaInteractionUtils_TryCancelInteraction::InProgressInteraction' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryCancelInteraction, World) == 0x000140, "Member 'MatchaInteractionUtils_TryCancelInteraction::World' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryCancelInteraction, ReturnValue) == 0x000148, "Member 'MatchaInteractionUtils_TryCancelInteraction::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInteractionUtils.TryProgressInteraction
// 0x0150 (0x0150 - 0x0000)
struct MatchaInteractionUtils_TryProgressInteraction final
{
public:
	struct FInProgressInteraction                 InProgressInteraction;                             // 0x0000(0x0140)(Parm, OutParm, NativeAccessSpecifierPublic)
	const class UWorld*                           World;                                             // 0x0140(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0148(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInteractionUtils_TryProgressInteraction) == 0x000008, "Wrong alignment on MatchaInteractionUtils_TryProgressInteraction");
static_assert(sizeof(MatchaInteractionUtils_TryProgressInteraction) == 0x000150, "Wrong size on MatchaInteractionUtils_TryProgressInteraction");
static_assert(offsetof(MatchaInteractionUtils_TryProgressInteraction, InProgressInteraction) == 0x000000, "Member 'MatchaInteractionUtils_TryProgressInteraction::InProgressInteraction' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryProgressInteraction, World) == 0x000140, "Member 'MatchaInteractionUtils_TryProgressInteraction::World' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryProgressInteraction, ReturnValue) == 0x000148, "Member 'MatchaInteractionUtils_TryProgressInteraction::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInteractionUtils.TryStartInteraction
// 0x0160 (0x0160 - 0x0000)
struct MatchaInteractionUtils_TryStartInteraction final
{
public:
	const class USnapNetEntityComponent*          InstigatorEntityComponent;                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetEntityIndex;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetChannelTime;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UWorld*                           World;                                             // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInProgressInteraction                 CurrentInteraction;                                // 0x0018(0x0140)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0158(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInteractionUtils_TryStartInteraction) == 0x000008, "Wrong alignment on MatchaInteractionUtils_TryStartInteraction");
static_assert(sizeof(MatchaInteractionUtils_TryStartInteraction) == 0x000160, "Wrong size on MatchaInteractionUtils_TryStartInteraction");
static_assert(offsetof(MatchaInteractionUtils_TryStartInteraction, InstigatorEntityComponent) == 0x000000, "Member 'MatchaInteractionUtils_TryStartInteraction::InstigatorEntityComponent' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryStartInteraction, TargetEntityIndex) == 0x000008, "Member 'MatchaInteractionUtils_TryStartInteraction::TargetEntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryStartInteraction, TargetChannelTime) == 0x00000C, "Member 'MatchaInteractionUtils_TryStartInteraction::TargetChannelTime' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryStartInteraction, World) == 0x000010, "Member 'MatchaInteractionUtils_TryStartInteraction::World' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryStartInteraction, CurrentInteraction) == 0x000018, "Member 'MatchaInteractionUtils_TryStartInteraction::CurrentInteraction' has a wrong offset!");
static_assert(offsetof(MatchaInteractionUtils_TryStartInteraction, ReturnValue) == 0x000158, "Member 'MatchaInteractionUtils_TryStartInteraction::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryStatics.FromItemAsset
// 0x0060 (0x0060 - 0x0000)
struct MatchaInventoryStatics_FromItemAsset final
{
public:
	const class UMatchaItemAsset*                 ItemAsset;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaInventoryItem                   ReturnValue;                                       // 0x0008(0x0058)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaInventoryStatics_FromItemAsset) == 0x000008, "Wrong alignment on MatchaInventoryStatics_FromItemAsset");
static_assert(sizeof(MatchaInventoryStatics_FromItemAsset) == 0x000060, "Wrong size on MatchaInventoryStatics_FromItemAsset");
static_assert(offsetof(MatchaInventoryStatics_FromItemAsset, ItemAsset) == 0x000000, "Member 'MatchaInventoryStatics_FromItemAsset::ItemAsset' has a wrong offset!");
static_assert(offsetof(MatchaInventoryStatics_FromItemAsset, ReturnValue) == 0x000008, "Member 'MatchaInventoryStatics_FromItemAsset::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryStatics.GetValue_ItemAsset
// 0x0060 (0x0060 - 0x0000)
struct MatchaInventoryStatics_GetValue_ItemAsset final
{
public:
	struct FMatchaInventoryItem                   InventoryItem;                                     // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UMatchaItemAsset*                 ReturnValue;                                       // 0x0058(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaInventoryStatics_GetValue_ItemAsset) == 0x000008, "Wrong alignment on MatchaInventoryStatics_GetValue_ItemAsset");
static_assert(sizeof(MatchaInventoryStatics_GetValue_ItemAsset) == 0x000060, "Wrong size on MatchaInventoryStatics_GetValue_ItemAsset");
static_assert(offsetof(MatchaInventoryStatics_GetValue_ItemAsset, InventoryItem) == 0x000000, "Member 'MatchaInventoryStatics_GetValue_ItemAsset::InventoryItem' has a wrong offset!");
static_assert(offsetof(MatchaInventoryStatics_GetValue_ItemAsset, ReturnValue) == 0x000058, "Member 'MatchaInventoryStatics_GetValue_ItemAsset::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.CanCombineAnyItemStacksWithInventory
// 0x0020 (0x0020 - 0x0000)
struct MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory final
{
public:
	struct FGameplayTag                           SourceSlotCategory;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UMatchaInventoryComponent*        DestinationInventoryComponent;                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DestinationSlotCategory;                           // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory) == 0x000008, "Wrong alignment on MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory");
static_assert(sizeof(MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory) == 0x000020, "Wrong size on MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory");
static_assert(offsetof(MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory, SourceSlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory::SourceSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory, DestinationInventoryComponent) == 0x000008, "Member 'MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory::DestinationInventoryComponent' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory, DestinationSlotCategory) == 0x000010, "Member 'MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory::DestinationSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory, ReturnValue) == 0x000018, "Member 'MatchaInventoryComponent_CanCombineAnyItemStacksWithInventory::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.CanCombineSlots
// 0x0020 (0x0020 - 0x0000)
struct MatchaInventoryComponent_CanCombineSlots final
{
public:
	struct FGameplayTag                           SourceSlotCategory;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceSlotIndex;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DestinationSlotCategory;                           // 0x000C(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestinationSlotIndex;                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_CanCombineSlots) == 0x000004, "Wrong alignment on MatchaInventoryComponent_CanCombineSlots");
static_assert(sizeof(MatchaInventoryComponent_CanCombineSlots) == 0x000020, "Wrong size on MatchaInventoryComponent_CanCombineSlots");
static_assert(offsetof(MatchaInventoryComponent_CanCombineSlots, SourceSlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_CanCombineSlots::SourceSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_CanCombineSlots, SourceSlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_CanCombineSlots::SourceSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_CanCombineSlots, DestinationSlotCategory) == 0x00000C, "Member 'MatchaInventoryComponent_CanCombineSlots::DestinationSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_CanCombineSlots, DestinationSlotIndex) == 0x000014, "Member 'MatchaInventoryComponent_CanCombineSlots::DestinationSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_CanCombineSlots, Count) == 0x000018, "Member 'MatchaInventoryComponent_CanCombineSlots::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_CanCombineSlots, ReturnValue) == 0x00001C, "Member 'MatchaInventoryComponent_CanCombineSlots::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.GetItemInSlot
// 0x0110 (0x0110 - 0x0000)
struct MatchaInventoryComponent_GetItemInSlot final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchaInventorySlot                   ReturnValue;                                       // 0x0010(0x0100)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaInventoryComponent_GetItemInSlot) == 0x000008, "Wrong alignment on MatchaInventoryComponent_GetItemInSlot");
static_assert(sizeof(MatchaInventoryComponent_GetItemInSlot) == 0x000110, "Wrong size on MatchaInventoryComponent_GetItemInSlot");
static_assert(offsetof(MatchaInventoryComponent_GetItemInSlot, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_GetItemInSlot::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_GetItemInSlot, SlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_GetItemInSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_GetItemInSlot, ReturnValue) == 0x000010, "Member 'MatchaInventoryComponent_GetItemInSlot::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.HasAnEmptySlotForCategory
// 0x000C (0x000C - 0x0000)
struct MatchaInventoryComponent_HasAnEmptySlotForCategory final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_HasAnEmptySlotForCategory) == 0x000004, "Wrong alignment on MatchaInventoryComponent_HasAnEmptySlotForCategory");
static_assert(sizeof(MatchaInventoryComponent_HasAnEmptySlotForCategory) == 0x00000C, "Wrong size on MatchaInventoryComponent_HasAnEmptySlotForCategory");
static_assert(offsetof(MatchaInventoryComponent_HasAnEmptySlotForCategory, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_HasAnEmptySlotForCategory::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_HasAnEmptySlotForCategory, ReturnValue) == 0x000008, "Member 'MatchaInventoryComponent_HasAnEmptySlotForCategory::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.HasItemInCategory
// 0x0068 (0x0068 - 0x0000)
struct MatchaInventoryComponent_HasItemInCategory final
{
public:
	struct FMatchaInventoryItem                   Item;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotCategory;                                      // 0x0058(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_HasItemInCategory) == 0x000008, "Wrong alignment on MatchaInventoryComponent_HasItemInCategory");
static_assert(sizeof(MatchaInventoryComponent_HasItemInCategory) == 0x000068, "Wrong size on MatchaInventoryComponent_HasItemInCategory");
static_assert(offsetof(MatchaInventoryComponent_HasItemInCategory, Item) == 0x000000, "Member 'MatchaInventoryComponent_HasItemInCategory::Item' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_HasItemInCategory, SlotCategory) == 0x000058, "Member 'MatchaInventoryComponent_HasItemInCategory::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_HasItemInCategory, ReturnValue) == 0x000060, "Member 'MatchaInventoryComponent_HasItemInCategory::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryAddItem
// 0x0060 (0x0060 - 0x0000)
struct MatchaInventoryComponent_TryAddItem final
{
public:
	struct FMatchaInventoryItem                   Item;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x005C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaInventoryComponent_TryAddItem) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryAddItem");
static_assert(sizeof(MatchaInventoryComponent_TryAddItem) == 0x000060, "Wrong size on MatchaInventoryComponent_TryAddItem");
static_assert(offsetof(MatchaInventoryComponent_TryAddItem, Item) == 0x000000, "Member 'MatchaInventoryComponent_TryAddItem::Item' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryAddItem, Count) == 0x000058, "Member 'MatchaInventoryComponent_TryAddItem::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryAddItem, ReturnValue) == 0x00005C, "Member 'MatchaInventoryComponent_TryAddItem::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryAddItemChecked
// 0x0060 (0x0060 - 0x0000)
struct MatchaInventoryComponent_TryAddItemChecked final
{
public:
	struct FMatchaInventoryItem                   Item;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x005C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryAddItemChecked) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryAddItemChecked");
static_assert(sizeof(MatchaInventoryComponent_TryAddItemChecked) == 0x000060, "Wrong size on MatchaInventoryComponent_TryAddItemChecked");
static_assert(offsetof(MatchaInventoryComponent_TryAddItemChecked, Item) == 0x000000, "Member 'MatchaInventoryComponent_TryAddItemChecked::Item' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryAddItemChecked, Count) == 0x000058, "Member 'MatchaInventoryComponent_TryAddItemChecked::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryAddItemChecked, ReturnValue) == 0x00005C, "Member 'MatchaInventoryComponent_TryAddItemChecked::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryAddOrReplaceItem
// 0x0070 (0x0070 - 0x0000)
struct MatchaInventoryComponent_TryAddOrReplaceItem final
{
public:
	struct FMatchaInventoryItem                   Item;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReplaceSlotCategory;                               // 0x005C(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplaceSlotIndex;                                  // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryAddOrReplaceItem) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryAddOrReplaceItem");
static_assert(sizeof(MatchaInventoryComponent_TryAddOrReplaceItem) == 0x000070, "Wrong size on MatchaInventoryComponent_TryAddOrReplaceItem");
static_assert(offsetof(MatchaInventoryComponent_TryAddOrReplaceItem, Item) == 0x000000, "Member 'MatchaInventoryComponent_TryAddOrReplaceItem::Item' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryAddOrReplaceItem, Count) == 0x000058, "Member 'MatchaInventoryComponent_TryAddOrReplaceItem::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryAddOrReplaceItem, ReplaceSlotCategory) == 0x00005C, "Member 'MatchaInventoryComponent_TryAddOrReplaceItem::ReplaceSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryAddOrReplaceItem, ReplaceSlotIndex) == 0x000064, "Member 'MatchaInventoryComponent_TryAddOrReplaceItem::ReplaceSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryAddOrReplaceItem, ReturnValue) == 0x000068, "Member 'MatchaInventoryComponent_TryAddOrReplaceItem::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryConsumeItemInSlot
// 0x0010 (0x0010 - 0x0000)
struct MatchaInventoryComponent_TryConsumeItemInSlot final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryConsumeItemInSlot) == 0x000004, "Wrong alignment on MatchaInventoryComponent_TryConsumeItemInSlot");
static_assert(sizeof(MatchaInventoryComponent_TryConsumeItemInSlot) == 0x000010, "Wrong size on MatchaInventoryComponent_TryConsumeItemInSlot");
static_assert(offsetof(MatchaInventoryComponent_TryConsumeItemInSlot, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryConsumeItemInSlot::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryConsumeItemInSlot, SlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TryConsumeItemInSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryConsumeItemInSlot, ReturnValue) == 0x00000C, "Member 'MatchaInventoryComponent_TryConsumeItemInSlot::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryDropAllItems
// 0x0020 (0x0020 - 0x0000)
struct MatchaInventoryComponent_TryDropAllItems final
{
public:
	const class AActor*                           ItemOwner;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartingSpawnLocation;                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaInventoryComponent_TryDropAllItems) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryDropAllItems");
static_assert(sizeof(MatchaInventoryComponent_TryDropAllItems) == 0x000020, "Wrong size on MatchaInventoryComponent_TryDropAllItems");
static_assert(offsetof(MatchaInventoryComponent_TryDropAllItems, ItemOwner) == 0x000000, "Member 'MatchaInventoryComponent_TryDropAllItems::ItemOwner' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryDropAllItems, StartingSpawnLocation) == 0x000008, "Member 'MatchaInventoryComponent_TryDropAllItems::StartingSpawnLocation' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryDropItem
// 0x0030 (0x0030 - 0x0000)
struct MatchaInventoryComponent_TryDropItem final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceSlotIndex;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryDropItem) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryDropItem");
static_assert(sizeof(MatchaInventoryComponent_TryDropItem) == 0x000030, "Wrong size on MatchaInventoryComponent_TryDropItem");
static_assert(offsetof(MatchaInventoryComponent_TryDropItem, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryDropItem::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryDropItem, SourceSlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TryDropItem::SourceSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryDropItem, Count) == 0x00000C, "Member 'MatchaInventoryComponent_TryDropItem::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryDropItem, SpawnLocation) == 0x000010, "Member 'MatchaInventoryComponent_TryDropItem::SpawnLocation' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryDropItem, ReturnValue) == 0x000028, "Member 'MatchaInventoryComponent_TryDropItem::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryDropRandomItemInCategory
// 0x0030 (0x0030 - 0x0000)
struct MatchaInventoryComponent_TryDropRandomItemInCategory final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryDropRandomItemInCategory) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryDropRandomItemInCategory");
static_assert(sizeof(MatchaInventoryComponent_TryDropRandomItemInCategory) == 0x000030, "Wrong size on MatchaInventoryComponent_TryDropRandomItemInCategory");
static_assert(offsetof(MatchaInventoryComponent_TryDropRandomItemInCategory, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryDropRandomItemInCategory::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryDropRandomItemInCategory, Count) == 0x000008, "Member 'MatchaInventoryComponent_TryDropRandomItemInCategory::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryDropRandomItemInCategory, SpawnLocation) == 0x000010, "Member 'MatchaInventoryComponent_TryDropRandomItemInCategory::SpawnLocation' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryDropRandomItemInCategory, ReturnValue) == 0x000028, "Member 'MatchaInventoryComponent_TryDropRandomItemInCategory::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryEnergizeSlot
// 0x0010 (0x0010 - 0x0000)
struct MatchaInventoryComponent_TryEnergizeSlot final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryEnergizeSlot) == 0x000004, "Wrong alignment on MatchaInventoryComponent_TryEnergizeSlot");
static_assert(sizeof(MatchaInventoryComponent_TryEnergizeSlot) == 0x000010, "Wrong size on MatchaInventoryComponent_TryEnergizeSlot");
static_assert(offsetof(MatchaInventoryComponent_TryEnergizeSlot, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryEnergizeSlot::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryEnergizeSlot, SlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TryEnergizeSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryEnergizeSlot, ReturnValue) == 0x00000C, "Member 'MatchaInventoryComponent_TryEnergizeSlot::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryHoldItemSlot
// 0x0010 (0x0010 - 0x0000)
struct MatchaInventoryComponent_TryHoldItemSlot final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryHoldItemSlot) == 0x000004, "Wrong alignment on MatchaInventoryComponent_TryHoldItemSlot");
static_assert(sizeof(MatchaInventoryComponent_TryHoldItemSlot) == 0x000010, "Wrong size on MatchaInventoryComponent_TryHoldItemSlot");
static_assert(offsetof(MatchaInventoryComponent_TryHoldItemSlot, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryHoldItemSlot::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryHoldItemSlot, SlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TryHoldItemSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryHoldItemSlot, ReturnValue) == 0x00000C, "Member 'MatchaInventoryComponent_TryHoldItemSlot::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryMoveItem
// 0x0020 (0x0020 - 0x0000)
struct MatchaInventoryComponent_TryMoveItem final
{
public:
	struct FGameplayTag                           SourceSlotCategory;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceSlotIndex;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DestinationSlotCategory;                           // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestinationSlotIndex;                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryMoveItem) == 0x000004, "Wrong alignment on MatchaInventoryComponent_TryMoveItem");
static_assert(sizeof(MatchaInventoryComponent_TryMoveItem) == 0x000020, "Wrong size on MatchaInventoryComponent_TryMoveItem");
static_assert(offsetof(MatchaInventoryComponent_TryMoveItem, SourceSlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryMoveItem::SourceSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryMoveItem, SourceSlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TryMoveItem::SourceSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryMoveItem, Count) == 0x00000C, "Member 'MatchaInventoryComponent_TryMoveItem::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryMoveItem, DestinationSlotCategory) == 0x000010, "Member 'MatchaInventoryComponent_TryMoveItem::DestinationSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryMoveItem, DestinationSlotIndex) == 0x000018, "Member 'MatchaInventoryComponent_TryMoveItem::DestinationSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryMoveItem, ReturnValue) == 0x00001C, "Member 'MatchaInventoryComponent_TryMoveItem::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryRemoveItemFromSlot
// 0x0014 (0x0014 - 0x0000)
struct MatchaInventoryComponent_TryRemoveItemFromSlot final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryRemoveItemFromSlot) == 0x000004, "Wrong alignment on MatchaInventoryComponent_TryRemoveItemFromSlot");
static_assert(sizeof(MatchaInventoryComponent_TryRemoveItemFromSlot) == 0x000014, "Wrong size on MatchaInventoryComponent_TryRemoveItemFromSlot");
static_assert(offsetof(MatchaInventoryComponent_TryRemoveItemFromSlot, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryRemoveItemFromSlot::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryRemoveItemFromSlot, SlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TryRemoveItemFromSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryRemoveItemFromSlot, Count) == 0x00000C, "Member 'MatchaInventoryComponent_TryRemoveItemFromSlot::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryRemoveItemFromSlot, ReturnValue) == 0x000010, "Member 'MatchaInventoryComponent_TryRemoveItemFromSlot::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryRemoveItemInCategory
// 0x0068 (0x0068 - 0x0000)
struct MatchaInventoryComponent_TryRemoveItemInCategory final
{
public:
	struct FMatchaInventoryItem                   Item;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotCategory;                                      // 0x0058(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0064(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryRemoveItemInCategory) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryRemoveItemInCategory");
static_assert(sizeof(MatchaInventoryComponent_TryRemoveItemInCategory) == 0x000068, "Wrong size on MatchaInventoryComponent_TryRemoveItemInCategory");
static_assert(offsetof(MatchaInventoryComponent_TryRemoveItemInCategory, Item) == 0x000000, "Member 'MatchaInventoryComponent_TryRemoveItemInCategory::Item' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryRemoveItemInCategory, SlotCategory) == 0x000058, "Member 'MatchaInventoryComponent_TryRemoveItemInCategory::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryRemoveItemInCategory, Count) == 0x000060, "Member 'MatchaInventoryComponent_TryRemoveItemInCategory::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryRemoveItemInCategory, ReturnValue) == 0x000064, "Member 'MatchaInventoryComponent_TryRemoveItemInCategory::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryReplaceItemInSlot
// 0x0070 (0x0070 - 0x0000)
struct MatchaInventoryComponent_TryReplaceItemInSlot final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchaInventoryItem                   Item;                                              // 0x0010(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x006C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryReplaceItemInSlot) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryReplaceItemInSlot");
static_assert(sizeof(MatchaInventoryComponent_TryReplaceItemInSlot) == 0x000070, "Wrong size on MatchaInventoryComponent_TryReplaceItemInSlot");
static_assert(offsetof(MatchaInventoryComponent_TryReplaceItemInSlot, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryReplaceItemInSlot::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryReplaceItemInSlot, SlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TryReplaceItemInSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryReplaceItemInSlot, Item) == 0x000010, "Member 'MatchaInventoryComponent_TryReplaceItemInSlot::Item' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryReplaceItemInSlot, Count) == 0x000068, "Member 'MatchaInventoryComponent_TryReplaceItemInSlot::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryReplaceItemInSlot, ReturnValue) == 0x00006C, "Member 'MatchaInventoryComponent_TryReplaceItemInSlot::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TrySwapItem
// 0x001C (0x001C - 0x0000)
struct MatchaInventoryComponent_TrySwapItem final
{
public:
	struct FGameplayTag                           SourceSlotCategory;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceSlotIndex;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DestinationSlotCategory;                           // 0x000C(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestinationSlotIndex;                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TrySwapItem) == 0x000004, "Wrong alignment on MatchaInventoryComponent_TrySwapItem");
static_assert(sizeof(MatchaInventoryComponent_TrySwapItem) == 0x00001C, "Wrong size on MatchaInventoryComponent_TrySwapItem");
static_assert(offsetof(MatchaInventoryComponent_TrySwapItem, SourceSlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TrySwapItem::SourceSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TrySwapItem, SourceSlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TrySwapItem::SourceSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TrySwapItem, DestinationSlotCategory) == 0x00000C, "Member 'MatchaInventoryComponent_TrySwapItem::DestinationSlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TrySwapItem, DestinationSlotIndex) == 0x000014, "Member 'MatchaInventoryComponent_TrySwapItem::DestinationSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TrySwapItem, ReturnValue) == 0x000018, "Member 'MatchaInventoryComponent_TrySwapItem::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.TryThrowItem
// 0x0040 (0x0040 - 0x0000)
struct MatchaInventoryComponent_TryThrowItem final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceSlotIndex;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ThrowDirection;                                    // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_TryThrowItem) == 0x000008, "Wrong alignment on MatchaInventoryComponent_TryThrowItem");
static_assert(sizeof(MatchaInventoryComponent_TryThrowItem) == 0x000040, "Wrong size on MatchaInventoryComponent_TryThrowItem");
static_assert(offsetof(MatchaInventoryComponent_TryThrowItem, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_TryThrowItem::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryThrowItem, SourceSlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_TryThrowItem::SourceSlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryThrowItem, Count) == 0x00000C, "Member 'MatchaInventoryComponent_TryThrowItem::Count' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryThrowItem, SpawnLocation) == 0x000010, "Member 'MatchaInventoryComponent_TryThrowItem::SpawnLocation' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryThrowItem, ThrowDirection) == 0x000028, "Member 'MatchaInventoryComponent_TryThrowItem::ThrowDirection' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_TryThrowItem, ReturnValue) == 0x000038, "Member 'MatchaInventoryComponent_TryThrowItem::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.GetHeldItemSlotIndexInCategory
// 0x000C (0x000C - 0x0000)
struct MatchaInventoryComponent_GetHeldItemSlotIndexInCategory final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaInventoryComponent_GetHeldItemSlotIndexInCategory) == 0x000004, "Wrong alignment on MatchaInventoryComponent_GetHeldItemSlotIndexInCategory");
static_assert(sizeof(MatchaInventoryComponent_GetHeldItemSlotIndexInCategory) == 0x00000C, "Wrong size on MatchaInventoryComponent_GetHeldItemSlotIndexInCategory");
static_assert(offsetof(MatchaInventoryComponent_GetHeldItemSlotIndexInCategory, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_GetHeldItemSlotIndexInCategory::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_GetHeldItemSlotIndexInCategory, ReturnValue) == 0x000008, "Member 'MatchaInventoryComponent_GetHeldItemSlotIndexInCategory::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryComponent.HasItemInSlot
// 0x0010 (0x0010 - 0x0000)
struct MatchaInventoryComponent_HasItemInSlot final
{
public:
	struct FGameplayTag                           SlotCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaInventoryComponent_HasItemInSlot) == 0x000004, "Wrong alignment on MatchaInventoryComponent_HasItemInSlot");
static_assert(sizeof(MatchaInventoryComponent_HasItemInSlot) == 0x000010, "Wrong size on MatchaInventoryComponent_HasItemInSlot");
static_assert(offsetof(MatchaInventoryComponent_HasItemInSlot, SlotCategory) == 0x000000, "Member 'MatchaInventoryComponent_HasItemInSlot::SlotCategory' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_HasItemInSlot, SlotIndex) == 0x000008, "Member 'MatchaInventoryComponent_HasItemInSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(MatchaInventoryComponent_HasItemInSlot, ReturnValue) == 0x00000C, "Member 'MatchaInventoryComponent_HasItemInSlot::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaInventoryItemUIData.OnInteractionRendererUpdated
// 0x0010 (0x0010 - 0x0000)
struct MatchaInventoryItemUIData_OnInteractionRendererUpdated final
{
public:
	class AActor*                                 NewInteractionRenderer;                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OldInteractionRenderer;                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaInventoryItemUIData_OnInteractionRendererUpdated) == 0x000008, "Wrong alignment on MatchaInventoryItemUIData_OnInteractionRendererUpdated");
static_assert(sizeof(MatchaInventoryItemUIData_OnInteractionRendererUpdated) == 0x000010, "Wrong size on MatchaInventoryItemUIData_OnInteractionRendererUpdated");
static_assert(offsetof(MatchaInventoryItemUIData_OnInteractionRendererUpdated, NewInteractionRenderer) == 0x000000, "Member 'MatchaInventoryItemUIData_OnInteractionRendererUpdated::NewInteractionRenderer' has a wrong offset!");
static_assert(offsetof(MatchaInventoryItemUIData_OnInteractionRendererUpdated, OldInteractionRenderer) == 0x000008, "Member 'MatchaInventoryItemUIData_OnInteractionRendererUpdated::OldInteractionRenderer' has a wrong offset!");

// Function Matcha.MatchaItemRenderer.ConfigureFromItem
// 0x0008 (0x0008 - 0x0000)
struct MatchaItemRenderer_ConfigureFromItem final
{
public:
	const class UMatchaItemAsset*                 ItemAsset;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaItemRenderer_ConfigureFromItem) == 0x000008, "Wrong alignment on MatchaItemRenderer_ConfigureFromItem");
static_assert(sizeof(MatchaItemRenderer_ConfigureFromItem) == 0x000008, "Wrong size on MatchaItemRenderer_ConfigureFromItem");
static_assert(offsetof(MatchaItemRenderer_ConfigureFromItem, ItemAsset) == 0x000000, "Member 'MatchaItemRenderer_ConfigureFromItem::ItemAsset' has a wrong offset!");

// Function Matcha.MatchaItemRenderer.OnUpdateFromEntity
// 0x0008 (0x0008 - 0x0000)
struct MatchaItemRenderer_OnUpdateFromEntity final
{
public:
	class AActor*                                 Entity;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaItemRenderer_OnUpdateFromEntity) == 0x000008, "Wrong alignment on MatchaItemRenderer_OnUpdateFromEntity");
static_assert(sizeof(MatchaItemRenderer_OnUpdateFromEntity) == 0x000008, "Wrong size on MatchaItemRenderer_OnUpdateFromEntity");
static_assert(offsetof(MatchaItemRenderer_OnUpdateFromEntity, Entity) == 0x000000, "Member 'MatchaItemRenderer_OnUpdateFromEntity::Entity' has a wrong offset!");

// Function Matcha.MatchaItemRenderer.SetHighlightState
// 0x0001 (0x0001 - 0x0000)
struct MatchaItemRenderer_SetHighlightState final
{
public:
	bool                                          bIsHighlighted;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaItemRenderer_SetHighlightState) == 0x000001, "Wrong alignment on MatchaItemRenderer_SetHighlightState");
static_assert(sizeof(MatchaItemRenderer_SetHighlightState) == 0x000001, "Wrong size on MatchaItemRenderer_SetHighlightState");
static_assert(offsetof(MatchaItemRenderer_SetHighlightState, bIsHighlighted) == 0x000000, "Member 'MatchaItemRenderer_SetHighlightState::bIsHighlighted' has a wrong offset!");

// Function Matcha.MatchaItemRenderer.UpdateItemCount
// 0x0004 (0x0004 - 0x0000)
struct MatchaItemRenderer_UpdateItemCount final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaItemRenderer_UpdateItemCount) == 0x000004, "Wrong alignment on MatchaItemRenderer_UpdateItemCount");
static_assert(sizeof(MatchaItemRenderer_UpdateItemCount) == 0x000004, "Wrong size on MatchaItemRenderer_UpdateItemCount");
static_assert(offsetof(MatchaItemRenderer_UpdateItemCount, Count) == 0x000000, "Member 'MatchaItemRenderer_UpdateItemCount::Count' has a wrong offset!");

// Function Matcha.MatchaSnapNetDamageVolumeEntity.OnEndOverlapWithCharacter
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetDamageVolumeEntity_OnEndOverlapWithCharacter final
{
public:
	class AMatchaSnapNetCharacterEntity*          Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetDamageVolumeEntity_OnEndOverlapWithCharacter) == 0x000008, "Wrong alignment on MatchaSnapNetDamageVolumeEntity_OnEndOverlapWithCharacter");
static_assert(sizeof(MatchaSnapNetDamageVolumeEntity_OnEndOverlapWithCharacter) == 0x000008, "Wrong size on MatchaSnapNetDamageVolumeEntity_OnEndOverlapWithCharacter");
static_assert(offsetof(MatchaSnapNetDamageVolumeEntity_OnEndOverlapWithCharacter, Character) == 0x000000, "Member 'MatchaSnapNetDamageVolumeEntity_OnEndOverlapWithCharacter::Character' has a wrong offset!");

// Function Matcha.MatchaSnapNetDamageVolumeEntity.OnOverlapCharacter
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter final
{
public:
	class AMatchaSnapNetCharacterEntity*          Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter) == 0x000008, "Wrong alignment on MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter");
static_assert(sizeof(MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter) == 0x000010, "Wrong size on MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter");
static_assert(offsetof(MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter, Character) == 0x000000, "Member 'MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter::Character' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter, DeltaSeconds) == 0x000008, "Member 'MatchaSnapNetDamageVolumeEntity_OnOverlapCharacter::DeltaSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.ComputeNextZone
// 0x0438 (0x0438 - 0x0000)
struct MatchaSnapNetKOZoneEntity_ComputeNextZone final
{
public:
	struct FActiveKOZone                          OutNextZone;                                       // 0x0000(0x0438)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_ComputeNextZone) == 0x000008, "Wrong alignment on MatchaSnapNetKOZoneEntity_ComputeNextZone");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_ComputeNextZone) == 0x000438, "Wrong size on MatchaSnapNetKOZoneEntity_ComputeNextZone");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_ComputeNextZone, OutNextZone) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_ComputeNextZone::OutNextZone' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.SetTimeScale
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetKOZoneEntity_SetTimeScale final
{
public:
	float                                         TimeScale_0;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_SetTimeScale) == 0x000004, "Wrong alignment on MatchaSnapNetKOZoneEntity_SetTimeScale");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_SetTimeScale) == 0x000004, "Wrong size on MatchaSnapNetKOZoneEntity_SetTimeScale");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_SetTimeScale, TimeScale_0) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_SetTimeScale::TimeScale_0' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.UpdateCollisionToZoneBounds
// 0x0438 (0x0438 - 0x0000)
struct MatchaSnapNetKOZoneEntity_UpdateCollisionToZoneBounds final
{
public:
	struct FActiveKOZone                          Zone;                                              // 0x0000(0x0438)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_UpdateCollisionToZoneBounds) == 0x000008, "Wrong alignment on MatchaSnapNetKOZoneEntity_UpdateCollisionToZoneBounds");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_UpdateCollisionToZoneBounds) == 0x000438, "Wrong size on MatchaSnapNetKOZoneEntity_UpdateCollisionToZoneBounds");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_UpdateCollisionToZoneBounds, Zone) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_UpdateCollisionToZoneBounds::Zone' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.GetActiveZone
// 0x0438 (0x0438 - 0x0000)
struct MatchaSnapNetKOZoneEntity_GetActiveZone final
{
public:
	struct FActiveKOZone                          ReturnValue;                                       // 0x0000(0x0438)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_GetActiveZone) == 0x000008, "Wrong alignment on MatchaSnapNetKOZoneEntity_GetActiveZone");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_GetActiveZone) == 0x000438, "Wrong size on MatchaSnapNetKOZoneEntity_GetActiveZone");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_GetActiveZone, ReturnValue) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_GetActiveZone::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.GetCurrentCycleIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetKOZoneEntity_GetCurrentCycleIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_GetCurrentCycleIndex) == 0x000004, "Wrong alignment on MatchaSnapNetKOZoneEntity_GetCurrentCycleIndex");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_GetCurrentCycleIndex) == 0x000004, "Wrong size on MatchaSnapNetKOZoneEntity_GetCurrentCycleIndex");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_GetCurrentCycleIndex, ReturnValue) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_GetCurrentCycleIndex::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.GetCurrentCycleTime
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetKOZoneEntity_GetCurrentCycleTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_GetCurrentCycleTime) == 0x000004, "Wrong alignment on MatchaSnapNetKOZoneEntity_GetCurrentCycleTime");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_GetCurrentCycleTime) == 0x000004, "Wrong size on MatchaSnapNetKOZoneEntity_GetCurrentCycleTime");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_GetCurrentCycleTime, ReturnValue) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_GetCurrentCycleTime::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.GetCurrentSafeZoneExtents
// 0x0020 (0x0020 - 0x0000)
struct MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents final
{
public:
	struct FVector2D                              OutSafeZoneMin;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutSafeZoneMax;                                    // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents) == 0x000008, "Wrong alignment on MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents) == 0x000020, "Wrong size on MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents, OutSafeZoneMin) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents::OutSafeZoneMin' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents, OutSafeZoneMax) == 0x000010, "Member 'MatchaSnapNetKOZoneEntity_GetCurrentSafeZoneExtents::OutSafeZoneMax' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.IsFinalZone
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetKOZoneEntity_IsFinalZone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_IsFinalZone) == 0x000001, "Wrong alignment on MatchaSnapNetKOZoneEntity_IsFinalZone");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_IsFinalZone) == 0x000001, "Wrong size on MatchaSnapNetKOZoneEntity_IsFinalZone");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_IsFinalZone, ReturnValue) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_IsFinalZone::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetKOZoneEntity.IsLastStand
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetKOZoneEntity_IsLastStand final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetKOZoneEntity_IsLastStand) == 0x000001, "Wrong alignment on MatchaSnapNetKOZoneEntity_IsLastStand");
static_assert(sizeof(MatchaSnapNetKOZoneEntity_IsLastStand) == 0x000001, "Wrong size on MatchaSnapNetKOZoneEntity_IsLastStand");
static_assert(offsetof(MatchaSnapNetKOZoneEntity_IsLastStand, ReturnValue) == 0x000000, "Member 'MatchaSnapNetKOZoneEntity_IsLastStand::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaKnockoutVolume.K2_BeginOverlap
// 0x0100 (0x0100 - 0x0000)
struct MatchaKnockoutVolume_K2_BeginOverlap final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaKnockoutVolume_K2_BeginOverlap) == 0x000008, "Wrong alignment on MatchaKnockoutVolume_K2_BeginOverlap");
static_assert(sizeof(MatchaKnockoutVolume_K2_BeginOverlap) == 0x000100, "Wrong size on MatchaKnockoutVolume_K2_BeginOverlap");
static_assert(offsetof(MatchaKnockoutVolume_K2_BeginOverlap, Target) == 0x000000, "Member 'MatchaKnockoutVolume_K2_BeginOverlap::Target' has a wrong offset!");
static_assert(offsetof(MatchaKnockoutVolume_K2_BeginOverlap, HitResult) == 0x000008, "Member 'MatchaKnockoutVolume_K2_BeginOverlap::HitResult' has a wrong offset!");

// Function Matcha.MatchaKnockoutVolume.K2_EndOverlap
// 0x0008 (0x0008 - 0x0000)
struct MatchaKnockoutVolume_K2_EndOverlap final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaKnockoutVolume_K2_EndOverlap) == 0x000008, "Wrong alignment on MatchaKnockoutVolume_K2_EndOverlap");
static_assert(sizeof(MatchaKnockoutVolume_K2_EndOverlap) == 0x000008, "Wrong size on MatchaKnockoutVolume_K2_EndOverlap");
static_assert(offsetof(MatchaKnockoutVolume_K2_EndOverlap, Target) == 0x000000, "Member 'MatchaKnockoutVolume_K2_EndOverlap::Target' has a wrong offset!");

// Function Matcha.MatchaLeaderboardUIData.OnGetGameLeaderboardV1Completed
// 0x0090 (0x0090 - 0x0000)
struct MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RequestID;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetGameLeaderboardV1Response          GameLeaderboardResponse;                           // 0x0018(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FErrorResponseV1                       ErrorResponse;                                     // 0x0038(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed) == 0x000008, "Wrong alignment on MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed");
static_assert(sizeof(MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed) == 0x000090, "Wrong size on MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed");
static_assert(offsetof(MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed, Success) == 0x000000, "Member 'MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed::Success' has a wrong offset!");
static_assert(offsetof(MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed, RequestID) == 0x000008, "Member 'MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed::RequestID' has a wrong offset!");
static_assert(offsetof(MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed, GameLeaderboardResponse) == 0x000018, "Member 'MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed::GameLeaderboardResponse' has a wrong offset!");
static_assert(offsetof(MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed, ErrorResponse) == 0x000038, "Member 'MatchaLeaderboardUIData_OnGetGameLeaderboardV1Completed::ErrorResponse' has a wrong offset!");

// Function Matcha.MatchaLeaderboardUIData.OnSearchGameLeaderboardV1Completed
// 0x0090 (0x0090 - 0x0000)
struct MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RequestID;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetGameLeaderboardV1Response          GameLeaderboardResponse;                           // 0x0018(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FErrorResponseV1                       ErrorResponse;                                     // 0x0038(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed) == 0x000008, "Wrong alignment on MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed");
static_assert(sizeof(MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed) == 0x000090, "Wrong size on MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed");
static_assert(offsetof(MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed, Success) == 0x000000, "Member 'MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed::Success' has a wrong offset!");
static_assert(offsetof(MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed, RequestID) == 0x000008, "Member 'MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed::RequestID' has a wrong offset!");
static_assert(offsetof(MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed, GameLeaderboardResponse) == 0x000018, "Member 'MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed::GameLeaderboardResponse' has a wrong offset!");
static_assert(offsetof(MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed, ErrorResponse) == 0x000038, "Member 'MatchaLeaderboardUIData_OnSearchGameLeaderboardV1Completed::ErrorResponse' has a wrong offset!");

// Function Matcha.MatchaLeaderboardUIData.Reload
// 0x0004 (0x0004 - 0x0000)
struct MatchaLeaderboardUIData_Reload final
{
public:
	int32                                         Offset;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLeaderboardUIData_Reload) == 0x000004, "Wrong alignment on MatchaLeaderboardUIData_Reload");
static_assert(sizeof(MatchaLeaderboardUIData_Reload) == 0x000004, "Wrong size on MatchaLeaderboardUIData_Reload");
static_assert(offsetof(MatchaLeaderboardUIData_Reload, Offset) == 0x000000, "Member 'MatchaLeaderboardUIData_Reload::Offset' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.GetLocalPlayerNetworkId
// 0x0018 (0x0018 - 0x0000)
struct MatchaLocalPlayerUIData_GetLocalPlayerNetworkId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_GetLocalPlayerNetworkId) == 0x000008, "Wrong alignment on MatchaLocalPlayerUIData_GetLocalPlayerNetworkId");
static_assert(sizeof(MatchaLocalPlayerUIData_GetLocalPlayerNetworkId) == 0x000018, "Wrong size on MatchaLocalPlayerUIData_GetLocalPlayerNetworkId");
static_assert(offsetof(MatchaLocalPlayerUIData_GetLocalPlayerNetworkId, WorldContextObject) == 0x000000, "Member 'MatchaLocalPlayerUIData_GetLocalPlayerNetworkId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaLocalPlayerUIData_GetLocalPlayerNetworkId, ReturnValue) == 0x000008, "Member 'MatchaLocalPlayerUIData_GetLocalPlayerNetworkId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnIdentityStateChanged
// 0x0002 (0x0002 - 0x0000)
struct MatchaLocalPlayerUIData_OnIdentityStateChanged final
{
public:
	EIdentityState                                PreviousIdentityState;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIdentityState                                IdentityState;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnIdentityStateChanged) == 0x000001, "Wrong alignment on MatchaLocalPlayerUIData_OnIdentityStateChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnIdentityStateChanged) == 0x000002, "Wrong size on MatchaLocalPlayerUIData_OnIdentityStateChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnIdentityStateChanged, PreviousIdentityState) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnIdentityStateChanged::PreviousIdentityState' has a wrong offset!");
static_assert(offsetof(MatchaLocalPlayerUIData_OnIdentityStateChanged, IdentityState) == 0x000001, "Member 'MatchaLocalPlayerUIData_OnIdentityStateChanged::IdentityState' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnLocalPlayerJoin
// 0x000C (0x000C - 0x0000)
struct MatchaLocalPlayerUIData_OnLocalPlayerJoin final
{
public:
	int32                                         LocalPlayerIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnLocalPlayerJoin) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_OnLocalPlayerJoin");
static_assert(sizeof(MatchaLocalPlayerUIData_OnLocalPlayerJoin) == 0x00000C, "Wrong size on MatchaLocalPlayerUIData_OnLocalPlayerJoin");
static_assert(offsetof(MatchaLocalPlayerUIData_OnLocalPlayerJoin, LocalPlayerIndex) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnLocalPlayerJoin::LocalPlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaLocalPlayerUIData_OnLocalPlayerJoin, PlayerIndex) == 0x000004, "Member 'MatchaLocalPlayerUIData_OnLocalPlayerJoin::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaLocalPlayerUIData_OnLocalPlayerJoin, ErrorCode) == 0x000008, "Member 'MatchaLocalPlayerUIData_OnLocalPlayerJoin::ErrorCode' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnLoginResponseChanged
// 0x0058 (0x0058 - 0x0000)
struct MatchaLocalPlayerUIData_OnLoginResponseChanged final
{
public:
	struct FLoginResponseV1                       LoginResponse;                                     // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnLoginResponseChanged) == 0x000008, "Wrong alignment on MatchaLocalPlayerUIData_OnLoginResponseChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnLoginResponseChanged) == 0x000058, "Wrong size on MatchaLocalPlayerUIData_OnLoginResponseChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnLoginResponseChanged, LoginResponse) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnLoginResponseChanged::LoginResponse' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnMasterVolumeChanged
// 0x0004 (0x0004 - 0x0000)
struct MatchaLocalPlayerUIData_OnMasterVolumeChanged final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnMasterVolumeChanged) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_OnMasterVolumeChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnMasterVolumeChanged) == 0x000004, "Wrong size on MatchaLocalPlayerUIData_OnMasterVolumeChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnMasterVolumeChanged, Volume) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnMasterVolumeChanged::Volume' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnMusicVolumeChanged
// 0x0004 (0x0004 - 0x0000)
struct MatchaLocalPlayerUIData_OnMusicVolumeChanged final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnMusicVolumeChanged) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_OnMusicVolumeChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnMusicVolumeChanged) == 0x000004, "Wrong size on MatchaLocalPlayerUIData_OnMusicVolumeChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnMusicVolumeChanged, Volume) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnMusicVolumeChanged::Volume' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnPartyChanged
// 0x0008 (0x0008 - 0x0000)
struct MatchaLocalPlayerUIData_OnPartyChanged final
{
public:
	class UMatchaPartyServiceModel*               ServicesSubsystem;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnPartyChanged) == 0x000008, "Wrong alignment on MatchaLocalPlayerUIData_OnPartyChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnPartyChanged) == 0x000008, "Wrong size on MatchaLocalPlayerUIData_OnPartyChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnPartyChanged, ServicesSubsystem) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnPartyChanged::ServicesSubsystem' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnQueuesAvailableChanged
// 0x0008 (0x0008 - 0x0000)
struct MatchaLocalPlayerUIData_OnQueuesAvailableChanged final
{
public:
	class UMatchaPartyServiceModel*               PartyServiceModel;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnQueuesAvailableChanged) == 0x000008, "Wrong alignment on MatchaLocalPlayerUIData_OnQueuesAvailableChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnQueuesAvailableChanged) == 0x000008, "Wrong size on MatchaLocalPlayerUIData_OnQueuesAvailableChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnQueuesAvailableChanged, PartyServiceModel) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnQueuesAvailableChanged::PartyServiceModel' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnReceivedInvitesChanged
// 0x0008 (0x0008 - 0x0000)
struct MatchaLocalPlayerUIData_OnReceivedInvitesChanged final
{
public:
	class UMatchaPartyServiceModel*               ServicesSubsystem;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnReceivedInvitesChanged) == 0x000008, "Wrong alignment on MatchaLocalPlayerUIData_OnReceivedInvitesChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnReceivedInvitesChanged) == 0x000008, "Wrong size on MatchaLocalPlayerUIData_OnReceivedInvitesChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnReceivedInvitesChanged, ServicesSubsystem) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnReceivedInvitesChanged::ServicesSubsystem' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnSentInvitesChanged
// 0x0008 (0x0008 - 0x0000)
struct MatchaLocalPlayerUIData_OnSentInvitesChanged final
{
public:
	class UMatchaPartyServiceModel*               ServicesSubsystem;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnSentInvitesChanged) == 0x000008, "Wrong alignment on MatchaLocalPlayerUIData_OnSentInvitesChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnSentInvitesChanged) == 0x000008, "Wrong size on MatchaLocalPlayerUIData_OnSentInvitesChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnSentInvitesChanged, ServicesSubsystem) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnSentInvitesChanged::ServicesSubsystem' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.OnSFXVolumeChanged
// 0x0004 (0x0004 - 0x0000)
struct MatchaLocalPlayerUIData_OnSFXVolumeChanged final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_OnSFXVolumeChanged) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_OnSFXVolumeChanged");
static_assert(sizeof(MatchaLocalPlayerUIData_OnSFXVolumeChanged) == 0x000004, "Wrong size on MatchaLocalPlayerUIData_OnSFXVolumeChanged");
static_assert(offsetof(MatchaLocalPlayerUIData_OnSFXVolumeChanged, Volume) == 0x000000, "Member 'MatchaLocalPlayerUIData_OnSFXVolumeChanged::Volume' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SelectQueueAtIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaLocalPlayerUIData_SelectQueueAtIndex final
{
public:
	int32                                         QueueIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SelectQueueAtIndex) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_SelectQueueAtIndex");
static_assert(sizeof(MatchaLocalPlayerUIData_SelectQueueAtIndex) == 0x000004, "Wrong size on MatchaLocalPlayerUIData_SelectQueueAtIndex");
static_assert(offsetof(MatchaLocalPlayerUIData_SelectQueueAtIndex, QueueIndex) == 0x000000, "Member 'MatchaLocalPlayerUIData_SelectQueueAtIndex::QueueIndex' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SelectQueueWithId
// 0x0008 (0x0008 - 0x0000)
struct MatchaLocalPlayerUIData_SelectQueueWithId final
{
public:
	class FName                                   QueueId;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SelectQueueWithId) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_SelectQueueWithId");
static_assert(sizeof(MatchaLocalPlayerUIData_SelectQueueWithId) == 0x000008, "Wrong size on MatchaLocalPlayerUIData_SelectQueueWithId");
static_assert(offsetof(MatchaLocalPlayerUIData_SelectQueueWithId, QueueId) == 0x000000, "Member 'MatchaLocalPlayerUIData_SelectQueueWithId::QueueId' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetAllowHeavyAttackFromMoveStickMode
// 0x0001 (0x0001 - 0x0000)
struct MatchaLocalPlayerUIData_SetAllowHeavyAttackFromMoveStickMode final
{
public:
	bool                                          bAllow;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetAllowHeavyAttackFromMoveStickMode) == 0x000001, "Wrong alignment on MatchaLocalPlayerUIData_SetAllowHeavyAttackFromMoveStickMode");
static_assert(sizeof(MatchaLocalPlayerUIData_SetAllowHeavyAttackFromMoveStickMode) == 0x000001, "Wrong size on MatchaLocalPlayerUIData_SetAllowHeavyAttackFromMoveStickMode");
static_assert(offsetof(MatchaLocalPlayerUIData_SetAllowHeavyAttackFromMoveStickMode, bAllow) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetAllowHeavyAttackFromMoveStickMode::bAllow' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetAttackStickMode
// 0x0001 (0x0001 - 0x0000)
struct MatchaLocalPlayerUIData_SetAttackStickMode final
{
public:
	EAttackStickMoveType                          MoveTypeToCast;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetAttackStickMode) == 0x000001, "Wrong alignment on MatchaLocalPlayerUIData_SetAttackStickMode");
static_assert(sizeof(MatchaLocalPlayerUIData_SetAttackStickMode) == 0x000001, "Wrong size on MatchaLocalPlayerUIData_SetAttackStickMode");
static_assert(offsetof(MatchaLocalPlayerUIData_SetAttackStickMode, MoveTypeToCast) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetAttackStickMode::MoveTypeToCast' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetAutoDashSettingEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaLocalPlayerUIData_SetAutoDashSettingEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetAutoDashSettingEnabled) == 0x000001, "Wrong alignment on MatchaLocalPlayerUIData_SetAutoDashSettingEnabled");
static_assert(sizeof(MatchaLocalPlayerUIData_SetAutoDashSettingEnabled) == 0x000001, "Wrong size on MatchaLocalPlayerUIData_SetAutoDashSettingEnabled");
static_assert(offsetof(MatchaLocalPlayerUIData_SetAutoDashSettingEnabled, bEnabled) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetAutoDashSettingEnabled::bEnabled' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetFrameRateCap
// 0x0001 (0x0001 - 0x0000)
struct MatchaLocalPlayerUIData_SetFrameRateCap final
{
public:
	EFrameRateCap                                 NewCap;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetFrameRateCap) == 0x000001, "Wrong alignment on MatchaLocalPlayerUIData_SetFrameRateCap");
static_assert(sizeof(MatchaLocalPlayerUIData_SetFrameRateCap) == 0x000001, "Wrong size on MatchaLocalPlayerUIData_SetFrameRateCap");
static_assert(offsetof(MatchaLocalPlayerUIData_SetFrameRateCap, NewCap) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetFrameRateCap::NewCap' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetInventoryHeldSlotStackingMode
// 0x0001 (0x0001 - 0x0000)
struct MatchaLocalPlayerUIData_SetInventoryHeldSlotStackingMode final
{
public:
	EInventoryHeldSlotStackingMode                StackingMode;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetInventoryHeldSlotStackingMode) == 0x000001, "Wrong alignment on MatchaLocalPlayerUIData_SetInventoryHeldSlotStackingMode");
static_assert(sizeof(MatchaLocalPlayerUIData_SetInventoryHeldSlotStackingMode) == 0x000001, "Wrong size on MatchaLocalPlayerUIData_SetInventoryHeldSlotStackingMode");
static_assert(offsetof(MatchaLocalPlayerUIData_SetInventoryHeldSlotStackingMode, StackingMode) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetInventoryHeldSlotStackingMode::StackingMode' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetMasterVolume
// 0x0004 (0x0004 - 0x0000)
struct MatchaLocalPlayerUIData_SetMasterVolume final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetMasterVolume) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_SetMasterVolume");
static_assert(sizeof(MatchaLocalPlayerUIData_SetMasterVolume) == 0x000004, "Wrong size on MatchaLocalPlayerUIData_SetMasterVolume");
static_assert(offsetof(MatchaLocalPlayerUIData_SetMasterVolume, Volume) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetMasterVolume::Volume' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetMusicVolume
// 0x0004 (0x0004 - 0x0000)
struct MatchaLocalPlayerUIData_SetMusicVolume final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetMusicVolume) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_SetMusicVolume");
static_assert(sizeof(MatchaLocalPlayerUIData_SetMusicVolume) == 0x000004, "Wrong size on MatchaLocalPlayerUIData_SetMusicVolume");
static_assert(offsetof(MatchaLocalPlayerUIData_SetMusicVolume, Volume) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetMusicVolume::Volume' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetSelectedCharacterIndex
// 0x0004 (0x0004 - 0x0000)
struct MatchaLocalPlayerUIData_SetSelectedCharacterIndex final
{
public:
	int32                                         CharacterIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetSelectedCharacterIndex) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_SetSelectedCharacterIndex");
static_assert(sizeof(MatchaLocalPlayerUIData_SetSelectedCharacterIndex) == 0x000004, "Wrong size on MatchaLocalPlayerUIData_SetSelectedCharacterIndex");
static_assert(offsetof(MatchaLocalPlayerUIData_SetSelectedCharacterIndex, CharacterIndex) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetSelectedCharacterIndex::CharacterIndex' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.SetSFXVolume
// 0x0004 (0x0004 - 0x0000)
struct MatchaLocalPlayerUIData_SetSFXVolume final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_SetSFXVolume) == 0x000004, "Wrong alignment on MatchaLocalPlayerUIData_SetSFXVolume");
static_assert(sizeof(MatchaLocalPlayerUIData_SetSFXVolume) == 0x000004, "Wrong size on MatchaLocalPlayerUIData_SetSFXVolume");
static_assert(offsetof(MatchaLocalPlayerUIData_SetSFXVolume, Volume) == 0x000000, "Member 'MatchaLocalPlayerUIData_SetSFXVolume::Volume' has a wrong offset!");

// Function Matcha.MatchaLocalPlayerUIData.TryJoinRemoteServer
// 0x0010 (0x0010 - 0x0000)
struct MatchaLocalPlayerUIData_TryJoinRemoteServer final
{
public:
	class FString                                 ConnectionURL;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaLocalPlayerUIData_TryJoinRemoteServer) == 0x000008, "Wrong alignment on MatchaLocalPlayerUIData_TryJoinRemoteServer");
static_assert(sizeof(MatchaLocalPlayerUIData_TryJoinRemoteServer) == 0x000010, "Wrong size on MatchaLocalPlayerUIData_TryJoinRemoteServer");
static_assert(offsetof(MatchaLocalPlayerUIData_TryJoinRemoteServer, ConnectionURL) == 0x000000, "Member 'MatchaLocalPlayerUIData_TryJoinRemoteServer::ConnectionURL' has a wrong offset!");

// Function Matcha.MatchaLootComponent.DropLootFromTable
// 0x0020 (0x0020 - 0x0000)
struct MatchaLootComponent_DropLootFromTable final
{
public:
	struct FVector                                StartingSpawnLocation;                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropItemsIgnoringOwnerCollision;                  // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaLootComponent_DropLootFromTable) == 0x000008, "Wrong alignment on MatchaLootComponent_DropLootFromTable");
static_assert(sizeof(MatchaLootComponent_DropLootFromTable) == 0x000020, "Wrong size on MatchaLootComponent_DropLootFromTable");
static_assert(offsetof(MatchaLootComponent_DropLootFromTable, StartingSpawnLocation) == 0x000000, "Member 'MatchaLootComponent_DropLootFromTable::StartingSpawnLocation' has a wrong offset!");
static_assert(offsetof(MatchaLootComponent_DropLootFromTable, bDropItemsIgnoringOwnerCollision) == 0x000018, "Member 'MatchaLootComponent_DropLootFromTable::bDropItemsIgnoringOwnerCollision' has a wrong offset!");

// Function Matcha.MatchaSnapNetInteractableRenderer.K2_OnUpdateFromEntity
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity final
{
public:
	const class AMatchaSnapNetInteractiveEntity*  EntityActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity) == 0x000008, "Wrong alignment on MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity");
static_assert(sizeof(MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity) == 0x000010, "Wrong size on MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity");
static_assert(offsetof(MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity, EntityActor) == 0x000000, "Member 'MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity::EntityActor' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity, DeltaSeconds) == 0x000008, "Member 'MatchaSnapNetInteractableRenderer_K2_OnUpdateFromEntity::DeltaSeconds' has a wrong offset!");

// Function Matcha.MatchaMovingPlatformEntity.GetCurrentPhase
// 0x0001 (0x0001 - 0x0000)
struct MatchaMovingPlatformEntity_GetCurrentPhase final
{
public:
	EMatchaMovingPlatformPhase                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaMovingPlatformEntity_GetCurrentPhase) == 0x000001, "Wrong alignment on MatchaMovingPlatformEntity_GetCurrentPhase");
static_assert(sizeof(MatchaMovingPlatformEntity_GetCurrentPhase) == 0x000001, "Wrong size on MatchaMovingPlatformEntity_GetCurrentPhase");
static_assert(offsetof(MatchaMovingPlatformEntity_GetCurrentPhase, ReturnValue) == 0x000000, "Member 'MatchaMovingPlatformEntity_GetCurrentPhase::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaMovingPlatformEntity.GetCurrentPhaseDuration
// 0x0004 (0x0004 - 0x0000)
struct MatchaMovingPlatformEntity_GetCurrentPhaseDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaMovingPlatformEntity_GetCurrentPhaseDuration) == 0x000004, "Wrong alignment on MatchaMovingPlatformEntity_GetCurrentPhaseDuration");
static_assert(sizeof(MatchaMovingPlatformEntity_GetCurrentPhaseDuration) == 0x000004, "Wrong size on MatchaMovingPlatformEntity_GetCurrentPhaseDuration");
static_assert(offsetof(MatchaMovingPlatformEntity_GetCurrentPhaseDuration, ReturnValue) == 0x000000, "Member 'MatchaMovingPlatformEntity_GetCurrentPhaseDuration::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaMovingPlatformEntity.GetCurrentPhaseNormalizedProgress
// 0x0004 (0x0004 - 0x0000)
struct MatchaMovingPlatformEntity_GetCurrentPhaseNormalizedProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaMovingPlatformEntity_GetCurrentPhaseNormalizedProgress) == 0x000004, "Wrong alignment on MatchaMovingPlatformEntity_GetCurrentPhaseNormalizedProgress");
static_assert(sizeof(MatchaMovingPlatformEntity_GetCurrentPhaseNormalizedProgress) == 0x000004, "Wrong size on MatchaMovingPlatformEntity_GetCurrentPhaseNormalizedProgress");
static_assert(offsetof(MatchaMovingPlatformEntity_GetCurrentPhaseNormalizedProgress, ReturnValue) == 0x000000, "Member 'MatchaMovingPlatformEntity_GetCurrentPhaseNormalizedProgress::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.AcceptPartyInvite
// 0x0008 (0x0008 - 0x0000)
struct MatchaPartyServiceModel_AcceptPartyInvite final
{
public:
	class FName                                   SendingPlayerId;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_AcceptPartyInvite) == 0x000004, "Wrong alignment on MatchaPartyServiceModel_AcceptPartyInvite");
static_assert(sizeof(MatchaPartyServiceModel_AcceptPartyInvite) == 0x000008, "Wrong size on MatchaPartyServiceModel_AcceptPartyInvite");
static_assert(offsetof(MatchaPartyServiceModel_AcceptPartyInvite, SendingPlayerId) == 0x000000, "Member 'MatchaPartyServiceModel_AcceptPartyInvite::SendingPlayerId' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.CancelPartyInvite
// 0x0008 (0x0008 - 0x0000)
struct MatchaPartyServiceModel_CancelPartyInvite final
{
public:
	class FName                                   TargetPlayerId;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_CancelPartyInvite) == 0x000004, "Wrong alignment on MatchaPartyServiceModel_CancelPartyInvite");
static_assert(sizeof(MatchaPartyServiceModel_CancelPartyInvite) == 0x000008, "Wrong size on MatchaPartyServiceModel_CancelPartyInvite");
static_assert(offsetof(MatchaPartyServiceModel_CancelPartyInvite, TargetPlayerId) == 0x000000, "Member 'MatchaPartyServiceModel_CancelPartyInvite::TargetPlayerId' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.GetPartyId
// 0x0008 (0x0008 - 0x0000)
struct MatchaPartyServiceModel_GetPartyId final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_GetPartyId) == 0x000004, "Wrong alignment on MatchaPartyServiceModel_GetPartyId");
static_assert(sizeof(MatchaPartyServiceModel_GetPartyId) == 0x000008, "Wrong size on MatchaPartyServiceModel_GetPartyId");
static_assert(offsetof(MatchaPartyServiceModel_GetPartyId, ReturnValue) == 0x000000, "Member 'MatchaPartyServiceModel_GetPartyId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.GetPartyLeaderPlayerId
// 0x0008 (0x0008 - 0x0000)
struct MatchaPartyServiceModel_GetPartyLeaderPlayerId final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_GetPartyLeaderPlayerId) == 0x000004, "Wrong alignment on MatchaPartyServiceModel_GetPartyLeaderPlayerId");
static_assert(sizeof(MatchaPartyServiceModel_GetPartyLeaderPlayerId) == 0x000008, "Wrong size on MatchaPartyServiceModel_GetPartyLeaderPlayerId");
static_assert(offsetof(MatchaPartyServiceModel_GetPartyLeaderPlayerId, ReturnValue) == 0x000000, "Member 'MatchaPartyServiceModel_GetPartyLeaderPlayerId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.GetPartyMembers
// 0x0010 (0x0010 - 0x0000)
struct MatchaPartyServiceModel_GetPartyMembers final
{
public:
	TArray<struct FPartyMember>                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_GetPartyMembers) == 0x000008, "Wrong alignment on MatchaPartyServiceModel_GetPartyMembers");
static_assert(sizeof(MatchaPartyServiceModel_GetPartyMembers) == 0x000010, "Wrong size on MatchaPartyServiceModel_GetPartyMembers");
static_assert(offsetof(MatchaPartyServiceModel_GetPartyMembers, ReturnValue) == 0x000000, "Member 'MatchaPartyServiceModel_GetPartyMembers::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.GetQueuesAvailable
// 0x0018 (0x0018 - 0x0000)
struct MatchaPartyServiceModel_GetQueuesAvailable final
{
public:
	TArray<struct FQueuesAvailableResponseV1Entry> OutQueuesAvailable;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaPartyServiceModel_GetQueuesAvailable) == 0x000008, "Wrong alignment on MatchaPartyServiceModel_GetQueuesAvailable");
static_assert(sizeof(MatchaPartyServiceModel_GetQueuesAvailable) == 0x000018, "Wrong size on MatchaPartyServiceModel_GetQueuesAvailable");
static_assert(offsetof(MatchaPartyServiceModel_GetQueuesAvailable, OutQueuesAvailable) == 0x000000, "Member 'MatchaPartyServiceModel_GetQueuesAvailable::OutQueuesAvailable' has a wrong offset!");
static_assert(offsetof(MatchaPartyServiceModel_GetQueuesAvailable, ReturnValue) == 0x000010, "Member 'MatchaPartyServiceModel_GetQueuesAvailable::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.GetReceivedPartyInvites
// 0x0010 (0x0010 - 0x0000)
struct MatchaPartyServiceModel_GetReceivedPartyInvites final
{
public:
	TArray<struct FReceivedPartyInvite>           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_GetReceivedPartyInvites) == 0x000008, "Wrong alignment on MatchaPartyServiceModel_GetReceivedPartyInvites");
static_assert(sizeof(MatchaPartyServiceModel_GetReceivedPartyInvites) == 0x000010, "Wrong size on MatchaPartyServiceModel_GetReceivedPartyInvites");
static_assert(offsetof(MatchaPartyServiceModel_GetReceivedPartyInvites, ReturnValue) == 0x000000, "Member 'MatchaPartyServiceModel_GetReceivedPartyInvites::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.GetSentPartyInvites
// 0x0010 (0x0010 - 0x0000)
struct MatchaPartyServiceModel_GetSentPartyInvites final
{
public:
	TArray<struct FSentPartyInvite>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_GetSentPartyInvites) == 0x000008, "Wrong alignment on MatchaPartyServiceModel_GetSentPartyInvites");
static_assert(sizeof(MatchaPartyServiceModel_GetSentPartyInvites) == 0x000010, "Wrong size on MatchaPartyServiceModel_GetSentPartyInvites");
static_assert(offsetof(MatchaPartyServiceModel_GetSentPartyInvites, ReturnValue) == 0x000000, "Member 'MatchaPartyServiceModel_GetSentPartyInvites::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.JoinQueue
// 0x0008 (0x0008 - 0x0000)
struct MatchaPartyServiceModel_JoinQueue final
{
public:
	class FName                                   QueueId;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_JoinQueue) == 0x000004, "Wrong alignment on MatchaPartyServiceModel_JoinQueue");
static_assert(sizeof(MatchaPartyServiceModel_JoinQueue) == 0x000008, "Wrong size on MatchaPartyServiceModel_JoinQueue");
static_assert(offsetof(MatchaPartyServiceModel_JoinQueue, QueueId) == 0x000000, "Member 'MatchaPartyServiceModel_JoinQueue::QueueId' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.LoadQueuesAvailableV1
// 0x0018 (0x0018 - 0x0000)
struct MatchaPartyServiceModel_LoadQueuesAvailableV1 final
{
public:
	class FString                                 OutRequestId;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaPartyServiceModel_LoadQueuesAvailableV1) == 0x000008, "Wrong alignment on MatchaPartyServiceModel_LoadQueuesAvailableV1");
static_assert(sizeof(MatchaPartyServiceModel_LoadQueuesAvailableV1) == 0x000018, "Wrong size on MatchaPartyServiceModel_LoadQueuesAvailableV1");
static_assert(offsetof(MatchaPartyServiceModel_LoadQueuesAvailableV1, OutRequestId) == 0x000000, "Member 'MatchaPartyServiceModel_LoadQueuesAvailableV1::OutRequestId' has a wrong offset!");
static_assert(offsetof(MatchaPartyServiceModel_LoadQueuesAvailableV1, ReturnValue) == 0x000010, "Member 'MatchaPartyServiceModel_LoadQueuesAvailableV1::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.OnWebsocketConnectionStateChanged
// 0x0008 (0x0008 - 0x0000)
struct MatchaPartyServiceModel_OnWebsocketConnectionStateChanged final
{
public:
	class UOdyServicesModelBase*                  InServicesSubsystem;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_OnWebsocketConnectionStateChanged) == 0x000008, "Wrong alignment on MatchaPartyServiceModel_OnWebsocketConnectionStateChanged");
static_assert(sizeof(MatchaPartyServiceModel_OnWebsocketConnectionStateChanged) == 0x000008, "Wrong size on MatchaPartyServiceModel_OnWebsocketConnectionStateChanged");
static_assert(offsetof(MatchaPartyServiceModel_OnWebsocketConnectionStateChanged, InServicesSubsystem) == 0x000000, "Member 'MatchaPartyServiceModel_OnWebsocketConnectionStateChanged::InServicesSubsystem' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.RejectPartyInvite
// 0x0008 (0x0008 - 0x0000)
struct MatchaPartyServiceModel_RejectPartyInvite final
{
public:
	class FName                                   SendingPlayerId;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_RejectPartyInvite) == 0x000004, "Wrong alignment on MatchaPartyServiceModel_RejectPartyInvite");
static_assert(sizeof(MatchaPartyServiceModel_RejectPartyInvite) == 0x000008, "Wrong size on MatchaPartyServiceModel_RejectPartyInvite");
static_assert(offsetof(MatchaPartyServiceModel_RejectPartyInvite, SendingPlayerId) == 0x000000, "Member 'MatchaPartyServiceModel_RejectPartyInvite::SendingPlayerId' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.SendPartyInvite
// 0x0010 (0x0010 - 0x0000)
struct MatchaPartyServiceModel_SendPartyInvite final
{
public:
	class FString                                 TargetPlayerName;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_SendPartyInvite) == 0x000008, "Wrong alignment on MatchaPartyServiceModel_SendPartyInvite");
static_assert(sizeof(MatchaPartyServiceModel_SendPartyInvite) == 0x000010, "Wrong size on MatchaPartyServiceModel_SendPartyInvite");
static_assert(offsetof(MatchaPartyServiceModel_SendPartyInvite, TargetPlayerName) == 0x000000, "Member 'MatchaPartyServiceModel_SendPartyInvite::TargetPlayerName' has a wrong offset!");

// Function Matcha.MatchaPartyServiceModel.GetPlayerParty
// 0x0088 (0x0088 - 0x0000)
struct MatchaPartyServiceModel_GetPlayerParty final
{
public:
	struct FPlayerParty                           ReturnValue;                                       // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPartyServiceModel_GetPlayerParty) == 0x000008, "Wrong alignment on MatchaPartyServiceModel_GetPlayerParty");
static_assert(sizeof(MatchaPartyServiceModel_GetPlayerParty) == 0x000088, "Wrong size on MatchaPartyServiceModel_GetPlayerParty");
static_assert(offsetof(MatchaPartyServiceModel_GetPlayerParty, ReturnValue) == 0x000000, "Member 'MatchaPartyServiceModel_GetPlayerParty::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaPlayerProfileUIData.OnPlayerProfileUpdated
// 0x0018 (0x0018 - 0x0000)
struct MatchaPlayerProfileUIData_OnPlayerProfileUpdated final
{
public:
	struct FMatchaPlayerProfileV1                 PlayerProfile;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaPlayerProfileUIData_OnPlayerProfileUpdated) == 0x000008, "Wrong alignment on MatchaPlayerProfileUIData_OnPlayerProfileUpdated");
static_assert(sizeof(MatchaPlayerProfileUIData_OnPlayerProfileUpdated) == 0x000018, "Wrong size on MatchaPlayerProfileUIData_OnPlayerProfileUpdated");
static_assert(offsetof(MatchaPlayerProfileUIData_OnPlayerProfileUpdated, PlayerProfile) == 0x000000, "Member 'MatchaPlayerProfileUIData_OnPlayerProfileUpdated::PlayerProfile' has a wrong offset!");

// Function Matcha.MatchaRegionServiceModel.OnWebsocketConnectionStateChanged
// 0x0008 (0x0008 - 0x0000)
struct MatchaRegionServiceModel_OnWebsocketConnectionStateChanged final
{
public:
	class UOdyServicesModelBase*                  InServicesSubsystem;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaRegionServiceModel_OnWebsocketConnectionStateChanged) == 0x000008, "Wrong alignment on MatchaRegionServiceModel_OnWebsocketConnectionStateChanged");
static_assert(sizeof(MatchaRegionServiceModel_OnWebsocketConnectionStateChanged) == 0x000008, "Wrong size on MatchaRegionServiceModel_OnWebsocketConnectionStateChanged");
static_assert(offsetof(MatchaRegionServiceModel_OnWebsocketConnectionStateChanged, InServicesSubsystem) == 0x000000, "Member 'MatchaRegionServiceModel_OnWebsocketConnectionStateChanged::InServicesSubsystem' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.Get
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetCharacterEntity_Get final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          WorldContextObject;                                // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetCharacterEntity*          ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_Get) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_Get");
static_assert(sizeof(MatchaSnapNetCharacterEntity_Get) == 0x000018, "Wrong size on MatchaSnapNetCharacterEntity_Get");
static_assert(offsetof(MatchaSnapNetCharacterEntity_Get, PlayerIndex) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_Get::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_Get, WorldContextObject) == 0x000008, "Member 'MatchaSnapNetCharacterEntity_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_Get, ReturnValue) == 0x000010, "Member 'MatchaSnapNetCharacterEntity_Get::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetFromSimulation
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetFromSimulation final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class USnapNetSimulation*               SnapNetSimulation;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetCharacterEntity*          ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetFromSimulation) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_GetFromSimulation");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetFromSimulation) == 0x000018, "Wrong size on MatchaSnapNetCharacterEntity_GetFromSimulation");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetFromSimulation, PlayerIndex) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetFromSimulation::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetFromSimulation, SnapNetSimulation) == 0x000008, "Member 'MatchaSnapNetCharacterEntity_GetFromSimulation::SnapNetSimulation' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetFromSimulation, ReturnValue) == 0x000010, "Member 'MatchaSnapNetCharacterEntity_GetFromSimulation::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetUIAssetData
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetUIAssetData final
{
public:
	TSubclassOf<class AMatchaSnapNetCharacterEntity> CharacterEntityClass;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOdyUIAssetData*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetUIAssetData) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_GetUIAssetData");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetUIAssetData) == 0x000010, "Wrong size on MatchaSnapNetCharacterEntity_GetUIAssetData");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetUIAssetData, CharacterEntityClass) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetUIAssetData::CharacterEntityClass' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetUIAssetData, ReturnValue) == 0x000008, "Member 'MatchaSnapNetCharacterEntity_GetUIAssetData::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.AddEnergy
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_AddEnergy final
{
public:
	float                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_AddEnergy) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_AddEnergy");
static_assert(sizeof(MatchaSnapNetCharacterEntity_AddEnergy) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_AddEnergy");
static_assert(offsetof(MatchaSnapNetCharacterEntity_AddEnergy, Amount) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_AddEnergy::Amount' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.AddImmuneToCrowdControlFromHitTags
// 0x0020 (0x0020 - 0x0000)
struct MatchaSnapNetCharacterEntity_AddImmuneToCrowdControlFromHitTags final
{
public:
	struct FGameplayTagContainer                  ImmuneToCCTags;                                    // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_AddImmuneToCrowdControlFromHitTags) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_AddImmuneToCrowdControlFromHitTags");
static_assert(sizeof(MatchaSnapNetCharacterEntity_AddImmuneToCrowdControlFromHitTags) == 0x000020, "Wrong size on MatchaSnapNetCharacterEntity_AddImmuneToCrowdControlFromHitTags");
static_assert(offsetof(MatchaSnapNetCharacterEntity_AddImmuneToCrowdControlFromHitTags, ImmuneToCCTags) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_AddImmuneToCrowdControlFromHitTags::ImmuneToCCTags' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.AddImmuneToDamageFromHitTags
// 0x0020 (0x0020 - 0x0000)
struct MatchaSnapNetCharacterEntity_AddImmuneToDamageFromHitTags final
{
public:
	struct FGameplayTagContainer                  CannotBeDamagedByTags;                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_AddImmuneToDamageFromHitTags) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_AddImmuneToDamageFromHitTags");
static_assert(sizeof(MatchaSnapNetCharacterEntity_AddImmuneToDamageFromHitTags) == 0x000020, "Wrong size on MatchaSnapNetCharacterEntity_AddImmuneToDamageFromHitTags");
static_assert(offsetof(MatchaSnapNetCharacterEntity_AddImmuneToDamageFromHitTags, CannotBeDamagedByTags) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_AddImmuneToDamageFromHitTags::CannotBeDamagedByTags' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.AddRecentlyScannedCharacter
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter final
{
public:
	int32                                         EntityIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter");
static_assert(sizeof(MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter");
static_assert(offsetof(MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter, EntityIndex) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter::EntityIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter, Timestamp) == 0x000004, "Member 'MatchaSnapNetCharacterEntity_AddRecentlyScannedCharacter::Timestamp' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.ApplyBuff
// 0x0014 (0x0014 - 0x0000)
struct MatchaSnapNetCharacterEntity_ApplyBuff final
{
public:
	struct FBuffInfo                              BuffInfo;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EObjectRarity                                 ObjectRarity;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetCharacterEntity_ApplyBuff) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_ApplyBuff");
static_assert(sizeof(MatchaSnapNetCharacterEntity_ApplyBuff) == 0x000014, "Wrong size on MatchaSnapNetCharacterEntity_ApplyBuff");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyBuff, BuffInfo) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_ApplyBuff::BuffInfo' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyBuff, ObjectRarity) == 0x000010, "Member 'MatchaSnapNetCharacterEntity_ApplyBuff::ObjectRarity' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.ApplyGlitchMark
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterEntity_ApplyGlitchMark final
{
public:
	class AActor*                                 GlitchMarkTarget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarkFromItem;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationSeconds;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_ApplyGlitchMark) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_ApplyGlitchMark");
static_assert(sizeof(MatchaSnapNetCharacterEntity_ApplyGlitchMark) == 0x000010, "Wrong size on MatchaSnapNetCharacterEntity_ApplyGlitchMark");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyGlitchMark, GlitchMarkTarget) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_ApplyGlitchMark::GlitchMarkTarget' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyGlitchMark, bIsMarkFromItem) == 0x000008, "Member 'MatchaSnapNetCharacterEntity_ApplyGlitchMark::bIsMarkFromItem' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyGlitchMark, DurationSeconds) == 0x00000C, "Member 'MatchaSnapNetCharacterEntity_ApplyGlitchMark::DurationSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.ApplyPeriodicDamageEffect
// 0x0020 (0x0020 - 0x0000)
struct MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect final
{
public:
	struct FGameplayTag                           PeriodicDamageEffectTag;                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           PeriodicDamageInstigator;                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSeconds;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeriodicDamageIntervalSeconds;                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect");
static_assert(sizeof(MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect) == 0x000020, "Wrong size on MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect, PeriodicDamageEffectTag) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect::PeriodicDamageEffectTag' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect, PeriodicDamageInstigator) == 0x000008, "Member 'MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect::PeriodicDamageInstigator' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect, DamageAmount) == 0x000010, "Member 'MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect::DamageAmount' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect, DurationSeconds) == 0x000014, "Member 'MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect::DurationSeconds' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect, PeriodicDamageIntervalSeconds) == 0x000018, "Member 'MatchaSnapNetCharacterEntity_ApplyPeriodicDamageEffect::PeriodicDamageIntervalSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.CanGlitchBeamAttack
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_CanGlitchBeamAttack final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_CanGlitchBeamAttack) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_CanGlitchBeamAttack");
static_assert(sizeof(MatchaSnapNetCharacterEntity_CanGlitchBeamAttack) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_CanGlitchBeamAttack");
static_assert(offsetof(MatchaSnapNetCharacterEntity_CanGlitchBeamAttack, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_CanGlitchBeamAttack::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.ClearCurrentGrab
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_ClearCurrentGrab final
{
public:
	bool                                          bResetThrowDirection;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_ClearCurrentGrab) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_ClearCurrentGrab");
static_assert(sizeof(MatchaSnapNetCharacterEntity_ClearCurrentGrab) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_ClearCurrentGrab");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ClearCurrentGrab, bResetThrowDirection) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_ClearCurrentGrab::bResetThrowDirection' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.ClearStatesForExternalLaunch
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_ClearStatesForExternalLaunch final
{
public:
	bool                                          bClearCurrentMontage;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_ClearStatesForExternalLaunch) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_ClearStatesForExternalLaunch");
static_assert(sizeof(MatchaSnapNetCharacterEntity_ClearStatesForExternalLaunch) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_ClearStatesForExternalLaunch");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ClearStatesForExternalLaunch, bClearCurrentMontage) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_ClearStatesForExternalLaunch::bClearCurrentMontage' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.DisableGravity
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_DisableGravity final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_DisableGravity) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_DisableGravity");
static_assert(sizeof(MatchaSnapNetCharacterEntity_DisableGravity) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_DisableGravity");
static_assert(offsetof(MatchaSnapNetCharacterEntity_DisableGravity, DurationSeconds) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_DisableGravity::DurationSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.EnableProjectileReflectionWhenShielding
// 0x000C (0x000C - 0x0000)
struct MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding final
{
public:
	float                                         ReflectAngle;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectSpeedMultiplier;                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectDamageMultiplier;                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding");
static_assert(sizeof(MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding) == 0x00000C, "Wrong size on MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding");
static_assert(offsetof(MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding, ReflectAngle) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding::ReflectAngle' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding, ReflectSpeedMultiplier) == 0x000004, "Member 'MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding::ReflectSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding, ReflectDamageMultiplier) == 0x000008, "Member 'MatchaSnapNetCharacterEntity_EnableProjectileReflectionWhenShielding::ReflectDamageMultiplier' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetHeldItem
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetHeldItem final
{
public:
	const class UMatchaItemAsset*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetHeldItem) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_GetHeldItem");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetHeldItem) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_GetHeldItem");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetHeldItem, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetHeldItem::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsInGlitchBeamWindUp
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsInGlitchBeamWindUp final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsInGlitchBeamWindUp) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsInGlitchBeamWindUp");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsInGlitchBeamWindUp) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsInGlitchBeamWindUp");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsInGlitchBeamWindUp, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsInGlitchBeamWindUp::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.OnCharacterJump
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_OnCharacterJump final
{
public:
	EJumpType                                     JumpType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_OnCharacterJump) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_OnCharacterJump");
static_assert(sizeof(MatchaSnapNetCharacterEntity_OnCharacterJump) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_OnCharacterJump");
static_assert(offsetof(MatchaSnapNetCharacterEntity_OnCharacterJump, JumpType) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_OnCharacterJump::JumpType' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.OnCharacterKnockBackApplied
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_OnCharacterKnockBackApplied final
{
public:
	const class AActor*                           InInstigator;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_OnCharacterKnockBackApplied) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_OnCharacterKnockBackApplied");
static_assert(sizeof(MatchaSnapNetCharacterEntity_OnCharacterKnockBackApplied) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_OnCharacterKnockBackApplied");
static_assert(offsetof(MatchaSnapNetCharacterEntity_OnCharacterKnockBackApplied, InInstigator) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_OnCharacterKnockBackApplied::InInstigator' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.OnKnockedOutAnEnemyCharacter
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_OnKnockedOutAnEnemyCharacter final
{
public:
	class AActor*                                 KnockedEnemyCharacter;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_OnKnockedOutAnEnemyCharacter) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_OnKnockedOutAnEnemyCharacter");
static_assert(sizeof(MatchaSnapNetCharacterEntity_OnKnockedOutAnEnemyCharacter) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_OnKnockedOutAnEnemyCharacter");
static_assert(offsetof(MatchaSnapNetCharacterEntity_OnKnockedOutAnEnemyCharacter, KnockedEnemyCharacter) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_OnKnockedOutAnEnemyCharacter::KnockedEnemyCharacter' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.PerformSpecialTeleport
// 0x0060 (0x0060 - 0x0000)
struct MatchaSnapNetCharacterEntity_PerformSpecialTeleport final
{
public:
	struct FSpecialTeleportSettings               TeleportSettings;                                  // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_PerformSpecialTeleport) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_PerformSpecialTeleport");
static_assert(sizeof(MatchaSnapNetCharacterEntity_PerformSpecialTeleport) == 0x000060, "Wrong size on MatchaSnapNetCharacterEntity_PerformSpecialTeleport");
static_assert(offsetof(MatchaSnapNetCharacterEntity_PerformSpecialTeleport, TeleportSettings) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_PerformSpecialTeleport::TeleportSettings' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_PerformSpecialTeleport, ReturnValue) == 0x000058, "Member 'MatchaSnapNetCharacterEntity_PerformSpecialTeleport::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RemoveBuffsWithTag
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_RemoveBuffsWithTag final
{
public:
	struct FGameplayTag                           BuffTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RemoveBuffsWithTag) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_RemoveBuffsWithTag");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RemoveBuffsWithTag) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_RemoveBuffsWithTag");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RemoveBuffsWithTag, BuffTag) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RemoveBuffsWithTag::BuffTag' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RemoveImmuneToCrowdControlFromHitTags
// 0x0020 (0x0020 - 0x0000)
struct MatchaSnapNetCharacterEntity_RemoveImmuneToCrowdControlFromHitTags final
{
public:
	struct FGameplayTagContainer                  ImmuneToCCTags;                                    // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RemoveImmuneToCrowdControlFromHitTags) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_RemoveImmuneToCrowdControlFromHitTags");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RemoveImmuneToCrowdControlFromHitTags) == 0x000020, "Wrong size on MatchaSnapNetCharacterEntity_RemoveImmuneToCrowdControlFromHitTags");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RemoveImmuneToCrowdControlFromHitTags, ImmuneToCCTags) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RemoveImmuneToCrowdControlFromHitTags::ImmuneToCCTags' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RemoveImmuneToDamageFromHitTags
// 0x0020 (0x0020 - 0x0000)
struct MatchaSnapNetCharacterEntity_RemoveImmuneToDamageFromHitTags final
{
public:
	struct FGameplayTagContainer                  CannotBeDamagedByTags;                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RemoveImmuneToDamageFromHitTags) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_RemoveImmuneToDamageFromHitTags");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RemoveImmuneToDamageFromHitTags) == 0x000020, "Wrong size on MatchaSnapNetCharacterEntity_RemoveImmuneToDamageFromHitTags");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RemoveImmuneToDamageFromHitTags, CannotBeDamagedByTags) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RemoveImmuneToDamageFromHitTags::CannotBeDamagedByTags' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RemovePeriodicDamageEffect
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect final
{
public:
	class AActor*                                 PeriodicDamageInstigator;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PeriodicDamageEffectTag;                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect) == 0x000010, "Wrong size on MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect, PeriodicDamageInstigator) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect::PeriodicDamageInstigator' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect, PeriodicDamageEffectTag) == 0x000008, "Member 'MatchaSnapNetCharacterEntity_RemovePeriodicDamageEffect::PeriodicDamageEffectTag' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RequestCameraScanMode
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_RequestCameraScanMode final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RequestCameraScanMode) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_RequestCameraScanMode");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RequestCameraScanMode) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_RequestCameraScanMode");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RequestCameraScanMode, DurationSeconds) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RequestCameraScanMode::DurationSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RequestDisable
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_RequestDisable final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RequestDisable) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_RequestDisable");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RequestDisable) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_RequestDisable");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RequestDisable, DurationSeconds) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RequestDisable::DurationSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RequestIntangibility
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_RequestIntangibility final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RequestIntangibility) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_RequestIntangibility");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RequestIntangibility) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_RequestIntangibility");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RequestIntangibility, DurationSeconds) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RequestIntangibility::DurationSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RequestLandingState
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_RequestLandingState final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RequestLandingState) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_RequestLandingState");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RequestLandingState) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_RequestLandingState");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RequestLandingState, DurationSeconds) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RequestLandingState::DurationSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RequestPeriodicCoinGeneration
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration, Amount) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration::Amount' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration, Interval) == 0x000004, "Member 'MatchaSnapNetCharacterEntity_RequestPeriodicCoinGeneration::Interval' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.RequestSuperArmor
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_RequestSuperArmor final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_RequestSuperArmor) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_RequestSuperArmor");
static_assert(sizeof(MatchaSnapNetCharacterEntity_RequestSuperArmor) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_RequestSuperArmor");
static_assert(offsetof(MatchaSnapNetCharacterEntity_RequestSuperArmor, DurationSeconds) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_RequestSuperArmor::DurationSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.SetCurrentGameplayPromptID
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_SetCurrentGameplayPromptID final
{
public:
	int32                                         IntID;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_SetCurrentGameplayPromptID) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_SetCurrentGameplayPromptID");
static_assert(sizeof(MatchaSnapNetCharacterEntity_SetCurrentGameplayPromptID) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_SetCurrentGameplayPromptID");
static_assert(offsetof(MatchaSnapNetCharacterEntity_SetCurrentGameplayPromptID, IntID) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_SetCurrentGameplayPromptID::IntID' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.SetDisguiseEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_SetDisguiseEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_SetDisguiseEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_SetDisguiseEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_SetDisguiseEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_SetDisguiseEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_SetDisguiseEnabled, bEnabled) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_SetDisguiseEnabled::bEnabled' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.SetEnhancedAirDodgeEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_SetEnhancedAirDodgeEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_SetEnhancedAirDodgeEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_SetEnhancedAirDodgeEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_SetEnhancedAirDodgeEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_SetEnhancedAirDodgeEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_SetEnhancedAirDodgeEnabled, bEnabled) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_SetEnhancedAirDodgeEnabled::bEnabled' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.SetShieldInvincible
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_SetShieldInvincible final
{
public:
	bool                                          bIsInvincible;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_SetShieldInvincible) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_SetShieldInvincible");
static_assert(sizeof(MatchaSnapNetCharacterEntity_SetShieldInvincible) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_SetShieldInvincible");
static_assert(offsetof(MatchaSnapNetCharacterEntity_SetShieldInvincible, bIsInvincible) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_SetShieldInvincible::bIsInvincible' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.SetWallClingEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_SetWallClingEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_SetWallClingEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_SetWallClingEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_SetWallClingEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_SetWallClingEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_SetWallClingEnabled, bEnabled) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_SetWallClingEnabled::bEnabled' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.SetWallRunEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_SetWallRunEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_SetWallRunEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_SetWallRunEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_SetWallRunEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_SetWallRunEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_SetWallRunEnabled, bEnabled) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_SetWallRunEnabled::bEnabled' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.SetZAirDashGrabEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_SetZAirDashGrabEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_SetZAirDashGrabEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_SetZAirDashGrabEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_SetZAirDashGrabEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_SetZAirDashGrabEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_SetZAirDashGrabEnabled, bEnabled) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_SetZAirDashGrabEnabled::bEnabled' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.SetZAirGrabEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_SetZAirGrabEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_SetZAirGrabEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_SetZAirGrabEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_SetZAirGrabEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_SetZAirGrabEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_SetZAirGrabEnabled, bEnabled) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_SetZAirGrabEnabled::bEnabled' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.ToggleAutoTech
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_ToggleAutoTech final
{
public:
	bool                                          bShouldEnable;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_ToggleAutoTech) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_ToggleAutoTech");
static_assert(sizeof(MatchaSnapNetCharacterEntity_ToggleAutoTech) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_ToggleAutoTech");
static_assert(offsetof(MatchaSnapNetCharacterEntity_ToggleAutoTech, bShouldEnable) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_ToggleAutoTech::bShouldEnable' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetCompanionEntity
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetCompanionEntity final
{
public:
	class AMatchaAttachableCompanionEntity*       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetCompanionEntity) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_GetCompanionEntity");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetCompanionEntity) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_GetCompanionEntity");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetCompanionEntity, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetCompanionEntity::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetCurrentShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetCurrentShieldHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetCurrentShieldHealth) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetCurrentShieldHealth");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetCurrentShieldHealth) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetCurrentShieldHealth");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetCurrentShieldHealth, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetCurrentShieldHealth::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetCurrentTeam
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetCurrentTeam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetCurrentTeam) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetCurrentTeam");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetCurrentTeam) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetCurrentTeam");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetCurrentTeam, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetCurrentTeam::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetDisguiseElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetDisguiseElapsedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetDisguiseElapsedTime) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetDisguiseElapsedTime");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetDisguiseElapsedTime) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetDisguiseElapsedTime");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetDisguiseElapsedTime, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetDisguiseElapsedTime::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetDisguiseId
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetDisguiseId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetDisguiseId) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetDisguiseId");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetDisguiseId) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetDisguiseId");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetDisguiseId, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetDisguiseId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetEnergy
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetEnergy final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetEnergy) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetEnergy");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetEnergy) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetEnergy");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetEnergy, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetEnergy::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetEnergyGenerationRatio
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetEnergyGenerationRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetEnergyGenerationRatio) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetEnergyGenerationRatio");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetEnergyGenerationRatio) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetEnergyGenerationRatio");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetEnergyGenerationRatio, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetEnergyGenerationRatio::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetGlitchMarkedTargetActor
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor final
{
public:
	bool                                          bFromItemSource;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor) == 0x000010, "Wrong size on MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor, bFromItemSource) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor::bFromItemSource' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor, ReturnValue) == 0x000008, "Member 'MatchaSnapNetCharacterEntity_GetGlitchMarkedTargetActor::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetHitStunRemainingTime
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetHitStunRemainingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetHitStunRemainingTime) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetHitStunRemainingTime");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetHitStunRemainingTime) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetHitStunRemainingTime");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetHitStunRemainingTime, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetHitStunRemainingTime::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetJuiceStat
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetJuiceStat final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetJuiceStat) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetJuiceStat");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetJuiceStat) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetJuiceStat");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetJuiceStat, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetJuiceStat::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetMaxAirJumps
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetMaxAirJumps final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetMaxAirJumps) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetMaxAirJumps");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetMaxAirJumps) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetMaxAirJumps");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetMaxAirJumps, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetMaxAirJumps::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetMaxEnergy
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetMaxEnergy final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetMaxEnergy) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetMaxEnergy");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetMaxEnergy) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetMaxEnergy");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetMaxEnergy, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetMaxEnergy::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetMaxShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetMaxShieldHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetMaxShieldHealth) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetMaxShieldHealth");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetMaxShieldHealth) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetMaxShieldHealth");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetMaxShieldHealth, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetMaxShieldHealth::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetMostRecentlyHitEnemyPlayerWithinTimeWindow
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow final
{
public:
	float                                         WindowTimeSeconds;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow, WindowTimeSeconds) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow::WindowTimeSeconds' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow, ReturnValue) == 0x000004, "Member 'MatchaSnapNetCharacterEntity_GetMostRecentlyHitEnemyPlayerWithinTimeWindow::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetOwningPlayerEntity
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetOwningPlayerEntity final
{
public:
	class AMatchaSnapNetPlayerEntity*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetOwningPlayerEntity) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_GetOwningPlayerEntity");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetOwningPlayerEntity) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_GetOwningPlayerEntity");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetOwningPlayerEntity, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetOwningPlayerEntity::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetRemainingAirJumps
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetRemainingAirJumps final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetRemainingAirJumps) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetRemainingAirJumps");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetRemainingAirJumps) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetRemainingAirJumps");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetRemainingAirJumps, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetRemainingAirJumps::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetRevealedCharacterEntityIndices
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetRevealedCharacterEntityIndices final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetRevealedCharacterEntityIndices) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterEntity_GetRevealedCharacterEntityIndices");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetRevealedCharacterEntityIndices) == 0x000010, "Wrong size on MatchaSnapNetCharacterEntity_GetRevealedCharacterEntityIndices");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetRevealedCharacterEntityIndices, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetRevealedCharacterEntityIndices::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetSharedTeamCoinsCount
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetSharedTeamCoinsCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetSharedTeamCoinsCount) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetSharedTeamCoinsCount");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetSharedTeamCoinsCount) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetSharedTeamCoinsCount");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetSharedTeamCoinsCount, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetSharedTeamCoinsCount::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetSharedTeamPowerSparksCount
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetSharedTeamPowerSparksCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetSharedTeamPowerSparksCount) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetSharedTeamPowerSparksCount");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetSharedTeamPowerSparksCount) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetSharedTeamPowerSparksCount");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetSharedTeamPowerSparksCount, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetSharedTeamPowerSparksCount::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetShieldLastInputTime
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetShieldLastInputTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetShieldLastInputTime) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetShieldLastInputTime");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetShieldLastInputTime) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetShieldLastInputTime");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetShieldLastInputTime, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetShieldLastInputTime::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetShieldState
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetShieldState final
{
public:
	EMatchaShieldState                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetShieldState) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_GetShieldState");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetShieldState) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_GetShieldState");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetShieldState, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetShieldState::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetSlowAmountStat
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetSlowAmountStat final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetSlowAmountStat) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetSlowAmountStat");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetSlowAmountStat) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetSlowAmountStat");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetSlowAmountStat, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetSlowAmountStat::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.GetTimeSinceLastDashingStateMilliseconds
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetCharacterEntity_GetTimeSinceLastDashingStateMilliseconds final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_GetTimeSinceLastDashingStateMilliseconds) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_GetTimeSinceLastDashingStateMilliseconds");
static_assert(sizeof(MatchaSnapNetCharacterEntity_GetTimeSinceLastDashingStateMilliseconds) == 0x000004, "Wrong size on MatchaSnapNetCharacterEntity_GetTimeSinceLastDashingStateMilliseconds");
static_assert(offsetof(MatchaSnapNetCharacterEntity_GetTimeSinceLastDashingStateMilliseconds, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_GetTimeSinceLastDashingStateMilliseconds::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.HasEnoughEnergy
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterEntity_HasEnoughEnergy final
{
public:
	float                                         NeededAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetCharacterEntity_HasEnoughEnergy) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterEntity_HasEnoughEnergy");
static_assert(sizeof(MatchaSnapNetCharacterEntity_HasEnoughEnergy) == 0x000008, "Wrong size on MatchaSnapNetCharacterEntity_HasEnoughEnergy");
static_assert(offsetof(MatchaSnapNetCharacterEntity_HasEnoughEnergy, NeededAmount) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_HasEnoughEnergy::NeededAmount' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterEntity_HasEnoughEnergy, ReturnValue) == 0x000004, "Member 'MatchaSnapNetCharacterEntity_HasEnoughEnergy::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.HasSuperArmor
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_HasSuperArmor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_HasSuperArmor) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_HasSuperArmor");
static_assert(sizeof(MatchaSnapNetCharacterEntity_HasSuperArmor) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_HasSuperArmor");
static_assert(offsetof(MatchaSnapNetCharacterEntity_HasSuperArmor, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_HasSuperArmor::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsDashing
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsDashing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsDashing) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsDashing");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsDashing) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsDashing");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsDashing, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsDashing::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsDisguised
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsDisguised final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsDisguised) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsDisguised");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsDisguised) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsDisguised");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsDisguised, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsDisguised::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsDisguiseEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsDisguiseEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsDisguiseEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsDisguiseEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsDisguiseEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsDisguiseEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsDisguiseEnabled, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsDisguiseEnabled::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsEnhancedAirDodgeEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsEnhancedAirDodgeEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsEnhancedAirDodgeEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsEnhancedAirDodgeEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsEnhancedAirDodgeEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsEnhancedAirDodgeEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsEnhancedAirDodgeEnabled, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsEnhancedAirDodgeEnabled::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsHelpless
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsHelpless final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsHelpless) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsHelpless");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsHelpless) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsHelpless");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsHelpless, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsHelpless::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsInHitStun
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsInHitStun final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsInHitStun) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsInHitStun");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsInHitStun) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsInHitStun");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsInHitStun, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsInHitStun::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsInPetrifyHitFreeze
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsInPetrifyHitFreeze final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsInPetrifyHitFreeze) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsInPetrifyHitFreeze");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsInPetrifyHitFreeze) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsInPetrifyHitFreeze");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsInPetrifyHitFreeze, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsInPetrifyHitFreeze::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsInsideZone
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsInsideZone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsInsideZone) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsInsideZone");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsInsideZone) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsInsideZone");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsInsideZone, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsInsideZone::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsInSoulState
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsInSoulState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsInSoulState) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsInSoulState");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsInSoulState) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsInSoulState");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsInSoulState, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsInSoulState::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsIntangible
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsIntangible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsIntangible) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsIntangible");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsIntangible) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsIntangible");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsIntangible, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsIntangible::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsZAirDashGrabEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsZAirDashGrabEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsZAirDashGrabEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsZAirDashGrabEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsZAirDashGrabEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsZAirDashGrabEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsZAirDashGrabEnabled, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsZAirDashGrabEnabled::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterEntity.IsZAirGrabEnabled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterEntity_IsZAirGrabEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterEntity_IsZAirGrabEnabled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterEntity_IsZAirGrabEnabled");
static_assert(sizeof(MatchaSnapNetCharacterEntity_IsZAirGrabEnabled) == 0x000001, "Wrong size on MatchaSnapNetCharacterEntity_IsZAirGrabEnabled");
static_assert(offsetof(MatchaSnapNetCharacterEntity_IsZAirGrabEnabled, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterEntity_IsZAirGrabEnabled::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.AnchorTooltipWidgetToActor
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetCharacterRenderer_AnchorTooltipWidgetToActor final
{
public:
	class AActor*                                 InTooltipAnchorActor;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_AnchorTooltipWidgetToActor) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterRenderer_AnchorTooltipWidgetToActor");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_AnchorTooltipWidgetToActor) == 0x000008, "Wrong size on MatchaSnapNetCharacterRenderer_AnchorTooltipWidgetToActor");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_AnchorTooltipWidgetToActor, InTooltipAnchorActor) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_AnchorTooltipWidgetToActor::InTooltipAnchorActor' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.ApplyVisibilityOverrides
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides final
{
public:
	const class AMatchaSnapNetCharacterEntity*    CharacterEntity;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVisibilityOverride>            VisibilityOverrides;                               // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides) == 0x000018, "Wrong size on MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides, CharacterEntity) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides::CharacterEntity' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides, VisibilityOverrides) == 0x000008, "Member 'MatchaSnapNetCharacterRenderer_ApplyVisibilityOverrides::VisibilityOverrides' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.EnableExternalViewTargetControl
// 0x0002 (0x0002 - 0x0000)
struct MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl final
{
public:
	bool                                          bNewEnable;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl) == 0x000002, "Wrong size on MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl, bNewEnable) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl::bNewEnable' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl, ReturnValue) == 0x000001, "Member 'MatchaSnapNetCharacterRenderer_EnableExternalViewTargetControl::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.K2_CalcCamera
// 0x0810 (0x0810 - 0x0000)
struct MatchaSnapNetCharacterRenderer_K2_CalcCamera final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       OutResult;                                         // 0x0010(0x0800)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_K2_CalcCamera) == 0x000010, "Wrong alignment on MatchaSnapNetCharacterRenderer_K2_CalcCamera");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_K2_CalcCamera) == 0x000810, "Wrong size on MatchaSnapNetCharacterRenderer_K2_CalcCamera");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_K2_CalcCamera, DeltaTime) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_K2_CalcCamera::DeltaTime' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_K2_CalcCamera, OutResult) == 0x000010, "Member 'MatchaSnapNetCharacterRenderer_K2_CalcCamera::OutResult' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnAliveStateChanged
// 0x0002 (0x0002 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnAliveStateChanged final
{
public:
	EAliveState                                   OldAliveState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAliveState                                   NewAliveState;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnAliveStateChanged) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnAliveStateChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnAliveStateChanged) == 0x000002, "Wrong size on MatchaSnapNetCharacterRenderer_OnAliveStateChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnAliveStateChanged, OldAliveState) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnAliveStateChanged::OldAliveState' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnAliveStateChanged, NewAliveState) == 0x000001, "Member 'MatchaSnapNetCharacterRenderer_OnAliveStateChanged::NewAliveState' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnAliveStateInitialized
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnAliveStateInitialized final
{
public:
	EAliveState                                   CurrentAliveState;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnAliveStateInitialized) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnAliveStateInitialized");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnAliveStateInitialized) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_OnAliveStateInitialized");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnAliveStateInitialized, CurrentAliveState) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnAliveStateInitialized::CurrentAliveState' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnGlitchMarkChanged
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnGlitchMarkChanged final
{
public:
	bool                                          bNewHasGlitchMark;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnGlitchMarkChanged) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnGlitchMarkChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnGlitchMarkChanged) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_OnGlitchMarkChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnGlitchMarkChanged, bNewHasGlitchMark) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnGlitchMarkChanged::bNewHasGlitchMark' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnHasInteractTargetChanged
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnHasInteractTargetChanged final
{
public:
	bool                                          bHasInteractTarget;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnHasInteractTargetChanged) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnHasInteractTargetChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnHasInteractTargetChanged) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_OnHasInteractTargetChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnHasInteractTargetChanged, bHasInteractTarget) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnHasInteractTargetChanged::bHasInteractTarget' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnInstigatedHitInfoChanged
// 0x0018 (0x0018 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged final
{
public:
	const class AActor*                           NewHitCauser;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           NewHitReceiver;                                    // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewHitFlags;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewHitFreezeSeconds;                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged) == 0x000018, "Wrong size on MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged, NewHitCauser) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged::NewHitCauser' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged, NewHitReceiver) == 0x000008, "Member 'MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged::NewHitReceiver' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged, NewHitFlags) == 0x000010, "Member 'MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged::NewHitFlags' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged, NewHitFreezeSeconds) == 0x000014, "Member 'MatchaSnapNetCharacterRenderer_OnInstigatedHitInfoChanged::NewHitFreezeSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnInteractionProgressChanged
// 0x000C (0x000C - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged final
{
public:
	bool                                          bIsProgressingInteraction;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionTotalTime;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionCurrentTime;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged) == 0x000004, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged) == 0x00000C, "Wrong size on MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged, bIsProgressingInteraction) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged::bIsProgressingInteraction' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged, InteractionTotalTime) == 0x000004, "Member 'MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged::InteractionTotalTime' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged, InteractionCurrentTime) == 0x000008, "Member 'MatchaSnapNetCharacterRenderer_OnInteractionProgressChanged::InteractionCurrentTime' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnReceivedHitInfoChanged
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged final
{
public:
	const class AActor*                           NewHitCauser;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewHitFlags;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewHitFreezeSeconds;                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged) == 0x000010, "Wrong size on MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged, NewHitCauser) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged::NewHitCauser' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged, NewHitFlags) == 0x000008, "Member 'MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged::NewHitFlags' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged, NewHitFreezeSeconds) == 0x00000C, "Member 'MatchaSnapNetCharacterRenderer_OnReceivedHitInfoChanged::NewHitFreezeSeconds' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnTeamAttackTargetChanged
// 0x0002 (0x0002 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged final
{
public:
	bool                                          bCurrentlyTargeted;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetedByAlly;                                   // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged) == 0x000002, "Wrong size on MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged, bCurrentlyTargeted) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged::bCurrentlyTargeted' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged, bTargetedByAlly) == 0x000001, "Member 'MatchaSnapNetCharacterRenderer_OnTeamAttackTargetChanged::bTargetedByAlly' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnTeamAttackWarningChanged
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnTeamAttackWarningChanged final
{
public:
	bool                                          bShouldShowWarning;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnTeamAttackWarningChanged) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnTeamAttackWarningChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnTeamAttackWarningChanged) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_OnTeamAttackWarningChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnTeamAttackWarningChanged, bShouldShowWarning) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnTeamAttackWarningChanged::bShouldShowWarning' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.OnZoneStateChanged
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_OnZoneStateChanged final
{
public:
	bool                                          bNewInsideZone;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_OnZoneStateChanged) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_OnZoneStateChanged");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_OnZoneStateChanged) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_OnZoneStateChanged");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_OnZoneStateChanged, bNewInsideZone) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_OnZoneStateChanged::bNewInsideZone' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.UpdatePropertyVisuals
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals final
{
public:
	const class AMatchaSnapNetCharacterEntity*    CharacterEntity;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleported;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals) == 0x000010, "Wrong size on MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals, CharacterEntity) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals::CharacterEntity' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals, bTeleported) == 0x000008, "Member 'MatchaSnapNetCharacterRenderer_UpdatePropertyVisuals::bTeleported' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.GetAudioEventFromSkinData
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData final
{
public:
	class FName                                   AudioEventId;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData) == 0x000010, "Wrong size on MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData, AudioEventId) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData::AudioEventId' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData, ReturnValue) == 0x000008, "Member 'MatchaSnapNetCharacterRenderer_GetAudioEventFromSkinData::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.GetNiagaraSystemFromSkinData
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData final
{
public:
	class FName                                   NiagaraSystemId;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData) == 0x000008, "Wrong alignment on MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData) == 0x000010, "Wrong size on MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData, NiagaraSystemId) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData::NiagaraSystemId' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData, ReturnValue) == 0x000008, "Member 'MatchaSnapNetCharacterRenderer_GetNiagaraSystemFromSkinData::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.IsGameplayVisibleToSpectatedPlayer
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_IsGameplayVisibleToSpectatedPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_IsGameplayVisibleToSpectatedPlayer) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_IsGameplayVisibleToSpectatedPlayer");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_IsGameplayVisibleToSpectatedPlayer) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_IsGameplayVisibleToSpectatedPlayer");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_IsGameplayVisibleToSpectatedPlayer, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_IsGameplayVisibleToSpectatedPlayer::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.IsLocallySpectated
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_IsLocallySpectated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_IsLocallySpectated) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_IsLocallySpectated");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_IsLocallySpectated) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_IsLocallySpectated");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_IsLocallySpectated, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_IsLocallySpectated::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.IsTeamMateWithLocallySpectatedCharacter
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_IsTeamMateWithLocallySpectatedCharacter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_IsTeamMateWithLocallySpectatedCharacter) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_IsTeamMateWithLocallySpectatedCharacter");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_IsTeamMateWithLocallySpectatedCharacter) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_IsTeamMateWithLocallySpectatedCharacter");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_IsTeamMateWithLocallySpectatedCharacter, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_IsTeamMateWithLocallySpectatedCharacter::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.IsViewTargetExternallyControlled
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_IsViewTargetExternallyControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_IsViewTargetExternallyControlled) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_IsViewTargetExternallyControlled");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_IsViewTargetExternallyControlled) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_IsViewTargetExternallyControlled");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_IsViewTargetExternallyControlled, ReturnValue) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_IsViewTargetExternallyControlled::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetCharacterRenderer.UpdateBPOnlyComponentsGameplayVisibility
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetCharacterRenderer_UpdateBPOnlyComponentsGameplayVisibility final
{
public:
	bool                                          bIsGameplayVisible;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetCharacterRenderer_UpdateBPOnlyComponentsGameplayVisibility) == 0x000001, "Wrong alignment on MatchaSnapNetCharacterRenderer_UpdateBPOnlyComponentsGameplayVisibility");
static_assert(sizeof(MatchaSnapNetCharacterRenderer_UpdateBPOnlyComponentsGameplayVisibility) == 0x000001, "Wrong size on MatchaSnapNetCharacterRenderer_UpdateBPOnlyComponentsGameplayVisibility");
static_assert(offsetof(MatchaSnapNetCharacterRenderer_UpdateBPOnlyComponentsGameplayVisibility, bIsGameplayVisible) == 0x000000, "Member 'MatchaSnapNetCharacterRenderer_UpdateBPOnlyComponentsGameplayVisibility::bIsGameplayVisible' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.SetMasterVolume
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetGameInstance_SetMasterVolume final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_SetMasterVolume) == 0x000004, "Wrong alignment on MatchaSnapNetGameInstance_SetMasterVolume");
static_assert(sizeof(MatchaSnapNetGameInstance_SetMasterVolume) == 0x000004, "Wrong size on MatchaSnapNetGameInstance_SetMasterVolume");
static_assert(offsetof(MatchaSnapNetGameInstance_SetMasterVolume, Volume) == 0x000000, "Member 'MatchaSnapNetGameInstance_SetMasterVolume::Volume' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetAllyRTPC
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetGameInstance_GetAllyRTPC final
{
public:
	const class UAkRtpc*                          ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetAllyRTPC) == 0x000008, "Wrong alignment on MatchaSnapNetGameInstance_GetAllyRTPC");
static_assert(sizeof(MatchaSnapNetGameInstance_GetAllyRTPC) == 0x000008, "Wrong size on MatchaSnapNetGameInstance_GetAllyRTPC");
static_assert(offsetof(MatchaSnapNetGameInstance_GetAllyRTPC, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetAllyRTPC::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetColorForAllies
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetGameInstance_GetColorForAllies final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetColorForAllies) == 0x000004, "Wrong alignment on MatchaSnapNetGameInstance_GetColorForAllies");
static_assert(sizeof(MatchaSnapNetGameInstance_GetColorForAllies) == 0x000010, "Wrong size on MatchaSnapNetGameInstance_GetColorForAllies");
static_assert(offsetof(MatchaSnapNetGameInstance_GetColorForAllies, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetColorForAllies::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetColorForEnemies
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetGameInstance_GetColorForEnemies final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetColorForEnemies) == 0x000004, "Wrong alignment on MatchaSnapNetGameInstance_GetColorForEnemies");
static_assert(sizeof(MatchaSnapNetGameInstance_GetColorForEnemies) == 0x000010, "Wrong size on MatchaSnapNetGameInstance_GetColorForEnemies");
static_assert(offsetof(MatchaSnapNetGameInstance_GetColorForEnemies, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetColorForEnemies::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetColorForSelf
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetGameInstance_GetColorForSelf final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetColorForSelf) == 0x000004, "Wrong alignment on MatchaSnapNetGameInstance_GetColorForSelf");
static_assert(sizeof(MatchaSnapNetGameInstance_GetColorForSelf) == 0x000010, "Wrong size on MatchaSnapNetGameInstance_GetColorForSelf");
static_assert(offsetof(MatchaSnapNetGameInstance_GetColorForSelf, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetColorForSelf::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetColorForTeamNumber
// 0x0014 (0x0014 - 0x0000)
struct MatchaSnapNetGameInstance_GetColorForTeamNumber final
{
public:
	int32                                         TeamNumber;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetColorForTeamNumber) == 0x000004, "Wrong alignment on MatchaSnapNetGameInstance_GetColorForTeamNumber");
static_assert(sizeof(MatchaSnapNetGameInstance_GetColorForTeamNumber) == 0x000014, "Wrong size on MatchaSnapNetGameInstance_GetColorForTeamNumber");
static_assert(offsetof(MatchaSnapNetGameInstance_GetColorForTeamNumber, TeamNumber) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetColorForTeamNumber::TeamNumber' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetGameInstance_GetColorForTeamNumber, ReturnValue) == 0x000004, "Member 'MatchaSnapNetGameInstance_GetColorForTeamNumber::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetEnabledSpawnRegions
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetGameInstance_GetEnabledSpawnRegions final
{
public:
	TArray<ESpawnRegion>                          ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetEnabledSpawnRegions) == 0x000008, "Wrong alignment on MatchaSnapNetGameInstance_GetEnabledSpawnRegions");
static_assert(sizeof(MatchaSnapNetGameInstance_GetEnabledSpawnRegions) == 0x000010, "Wrong size on MatchaSnapNetGameInstance_GetEnabledSpawnRegions");
static_assert(offsetof(MatchaSnapNetGameInstance_GetEnabledSpawnRegions, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetEnabledSpawnRegions::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetGameplayEventNotificationChannel
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetGameInstance_GetGameplayEventNotificationChannel final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetGameplayEventNotificationChannel) == 0x000004, "Wrong alignment on MatchaSnapNetGameInstance_GetGameplayEventNotificationChannel");
static_assert(sizeof(MatchaSnapNetGameInstance_GetGameplayEventNotificationChannel) == 0x000008, "Wrong size on MatchaSnapNetGameInstance_GetGameplayEventNotificationChannel");
static_assert(offsetof(MatchaSnapNetGameInstance_GetGameplayEventNotificationChannel, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetGameplayEventNotificationChannel::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetGenericAudioEventFromId
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetGameInstance_GetGenericAudioEventFromId final
{
public:
	class FName                                   AudioEventId;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetGenericAudioEventFromId) == 0x000008, "Wrong alignment on MatchaSnapNetGameInstance_GetGenericAudioEventFromId");
static_assert(sizeof(MatchaSnapNetGameInstance_GetGenericAudioEventFromId) == 0x000010, "Wrong size on MatchaSnapNetGameInstance_GetGenericAudioEventFromId");
static_assert(offsetof(MatchaSnapNetGameInstance_GetGenericAudioEventFromId, AudioEventId) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetGenericAudioEventFromId::AudioEventId' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetGameInstance_GetGenericAudioEventFromId, ReturnValue) == 0x000008, "Member 'MatchaSnapNetGameInstance_GetGenericAudioEventFromId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetGenericNiagaraSystemFromId
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId final
{
public:
	class FName                                   NiagaraSystemId;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId) == 0x000008, "Wrong alignment on MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId");
static_assert(sizeof(MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId) == 0x000010, "Wrong size on MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId");
static_assert(offsetof(MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId, NiagaraSystemId) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId::NiagaraSystemId' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId, ReturnValue) == 0x000008, "Member 'MatchaSnapNetGameInstance_GetGenericNiagaraSystemFromId::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetLocallySpectatedRTPC
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetGameInstance_GetLocallySpectatedRTPC final
{
public:
	const class UAkRtpc*                          ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetLocallySpectatedRTPC) == 0x000008, "Wrong alignment on MatchaSnapNetGameInstance_GetLocallySpectatedRTPC");
static_assert(sizeof(MatchaSnapNetGameInstance_GetLocallySpectatedRTPC) == 0x000008, "Wrong size on MatchaSnapNetGameInstance_GetLocallySpectatedRTPC");
static_assert(offsetof(MatchaSnapNetGameInstance_GetLocallySpectatedRTPC, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetLocallySpectatedRTPC::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetGameInstance.GetSpawnRegionsToDisplayNames
// 0x0050 (0x0050 - 0x0000)
struct MatchaSnapNetGameInstance_GetSpawnRegionsToDisplayNames final
{
public:
	TMap<ESpawnRegion, class FText>               ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetGameInstance_GetSpawnRegionsToDisplayNames) == 0x000008, "Wrong alignment on MatchaSnapNetGameInstance_GetSpawnRegionsToDisplayNames");
static_assert(sizeof(MatchaSnapNetGameInstance_GetSpawnRegionsToDisplayNames) == 0x000050, "Wrong size on MatchaSnapNetGameInstance_GetSpawnRegionsToDisplayNames");
static_assert(offsetof(MatchaSnapNetGameInstance_GetSpawnRegionsToDisplayNames, ReturnValue) == 0x000000, "Member 'MatchaSnapNetGameInstance_GetSpawnRegionsToDisplayNames::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPropertyGameplayTagFunctionLibrary.Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag
// 0x0040 (0x0040 - 0x0000)
struct MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag final
{
public:
	struct FMatchaSnapNetGameplayTagProperty      MatchaSnapNetGameplayTagProperty;                  // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0038(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag) == 0x000008, "Wrong alignment on MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag");
static_assert(sizeof(MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag) == 0x000040, "Wrong size on MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag");
static_assert(offsetof(MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag, MatchaSnapNetGameplayTagProperty) == 0x000000, "Member 'MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag::MatchaSnapNetGameplayTagProperty' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag, ReturnValue) == 0x000038, "Member 'MatchaSnapNetPropertyGameplayTagFunctionLibrary_Conv_MatchaSnapNetPropertyGameplayTagToGameplayTag::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPropertyGameplayTagFunctionLibrary.SetValue
// 0x0040 (0x0040 - 0x0000)
struct MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue final
{
public:
	struct FMatchaSnapNetGameplayTagProperty      MatchaSnapNetGameplayTagProperty;                  // 0x0000(0x0038)(Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Value;                                             // 0x0038(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue) == 0x000008, "Wrong alignment on MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue");
static_assert(sizeof(MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue) == 0x000040, "Wrong size on MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue");
static_assert(offsetof(MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue, MatchaSnapNetGameplayTagProperty) == 0x000000, "Member 'MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue::MatchaSnapNetGameplayTagProperty' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue, Value) == 0x000038, "Member 'MatchaSnapNetPropertyGameplayTagFunctionLibrary_SetValue::Value' has a wrong offset!");

// Function Matcha.MatchaFinalZone.GetLastStandBounds
// 0x0038 (0x0038 - 0x0000)
struct MatchaFinalZone_GetLastStandBounds final
{
public:
	struct FBox                                   ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaFinalZone_GetLastStandBounds) == 0x000008, "Wrong alignment on MatchaFinalZone_GetLastStandBounds");
static_assert(sizeof(MatchaFinalZone_GetLastStandBounds) == 0x000038, "Wrong size on MatchaFinalZone_GetLastStandBounds");
static_assert(offsetof(MatchaFinalZone_GetLastStandBounds, ReturnValue) == 0x000000, "Member 'MatchaFinalZone_GetLastStandBounds::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerController.RequestSelectSpawnRegion
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetPlayerController_RequestSelectSpawnRegion final
{
public:
	ESpawnRegion                                  SelectedSpawnRegion;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_RequestSelectSpawnRegion) == 0x000001, "Wrong alignment on MatchaSnapNetPlayerController_RequestSelectSpawnRegion");
static_assert(sizeof(MatchaSnapNetPlayerController_RequestSelectSpawnRegion) == 0x000001, "Wrong size on MatchaSnapNetPlayerController_RequestSelectSpawnRegion");
static_assert(offsetof(MatchaSnapNetPlayerController_RequestSelectSpawnRegion, SelectedSpawnRegion) == 0x000000, "Member 'MatchaSnapNetPlayerController_RequestSelectSpawnRegion::SelectedSpawnRegion' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerController.SetHoveredCharacter
// 0x0028 (0x0028 - 0x0000)
struct MatchaSnapNetPlayerController_SetHoveredCharacter final
{
public:
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_SetHoveredCharacter) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerController_SetHoveredCharacter");
static_assert(sizeof(MatchaSnapNetPlayerController_SetHoveredCharacter) == 0x000028, "Wrong size on MatchaSnapNetPlayerController_SetHoveredCharacter");
static_assert(offsetof(MatchaSnapNetPlayerController_SetHoveredCharacter, CharacterClass) == 0x000000, "Member 'MatchaSnapNetPlayerController_SetHoveredCharacter::CharacterClass' has a wrong offset!");

// DelegateFunction Matcha.MatchaSnapNetPlayerController.SpectatedCharacterRendererChanged__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct MatchaSnapNetPlayerController_SpectatedCharacterRendererChanged__DelegateSignature final
{
public:
	class AMatchaSnapNetCharacterRenderer*        CharacterRenderer;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_SpectatedCharacterRendererChanged__DelegateSignature) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerController_SpectatedCharacterRendererChanged__DelegateSignature");
static_assert(sizeof(MatchaSnapNetPlayerController_SpectatedCharacterRendererChanged__DelegateSignature) == 0x000008, "Wrong size on MatchaSnapNetPlayerController_SpectatedCharacterRendererChanged__DelegateSignature");
static_assert(offsetof(MatchaSnapNetPlayerController_SpectatedCharacterRendererChanged__DelegateSignature, CharacterRenderer) == 0x000000, "Member 'MatchaSnapNetPlayerController_SpectatedCharacterRendererChanged__DelegateSignature::CharacterRenderer' has a wrong offset!");

// DelegateFunction Matcha.MatchaSnapNetPlayerController.SpectatedPlayerIndexChanged__DelegateSignature
// 0x000C (0x000C - 0x0000)
struct MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature final
{
public:
	int32                                         PlayerIndexForLocalPlayer;                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousSpectatedPlayerIndex;                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewSpectatedPlayerIndex;                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature");
static_assert(sizeof(MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature) == 0x00000C, "Wrong size on MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature");
static_assert(offsetof(MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature, PlayerIndexForLocalPlayer) == 0x000000, "Member 'MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature::PlayerIndexForLocalPlayer' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature, PreviousSpectatedPlayerIndex) == 0x000004, "Member 'MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature::PreviousSpectatedPlayerIndex' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature, NewSpectatedPlayerIndex) == 0x000008, "Member 'MatchaSnapNetPlayerController_SpectatedPlayerIndexChanged__DelegateSignature::NewSpectatedPlayerIndex' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerController.DEBUG_SetPlayerName
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetPlayerController_DEBUG_SetPlayerName final
{
public:
	class FString                                 NewName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_DEBUG_SetPlayerName) == 0x000008, "Wrong alignment on MatchaSnapNetPlayerController_DEBUG_SetPlayerName");
static_assert(sizeof(MatchaSnapNetPlayerController_DEBUG_SetPlayerName) == 0x000010, "Wrong size on MatchaSnapNetPlayerController_DEBUG_SetPlayerName");
static_assert(offsetof(MatchaSnapNetPlayerController_DEBUG_SetPlayerName, NewName) == 0x000000, "Member 'MatchaSnapNetPlayerController_DEBUG_SetPlayerName::NewName' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerController.GetCameraMode
// 0x0001 (0x0001 - 0x0000)
struct MatchaSnapNetPlayerController_GetCameraMode final
{
public:
	EMatchaCameraMode                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_GetCameraMode) == 0x000001, "Wrong alignment on MatchaSnapNetPlayerController_GetCameraMode");
static_assert(sizeof(MatchaSnapNetPlayerController_GetCameraMode) == 0x000001, "Wrong size on MatchaSnapNetPlayerController_GetCameraMode");
static_assert(offsetof(MatchaSnapNetPlayerController_GetCameraMode, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerController_GetCameraMode::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerController.GetCurrentFrameInputValues
// 0x003C (0x003C - 0x0000)
struct MatchaSnapNetPlayerController_GetCurrentFrameInputValues final
{
public:
	struct FPlayerInputValues                     ReturnValue;                                       // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_GetCurrentFrameInputValues) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerController_GetCurrentFrameInputValues");
static_assert(sizeof(MatchaSnapNetPlayerController_GetCurrentFrameInputValues) == 0x00003C, "Wrong size on MatchaSnapNetPlayerController_GetCurrentFrameInputValues");
static_assert(offsetof(MatchaSnapNetPlayerController_GetCurrentFrameInputValues, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerController_GetCurrentFrameInputValues::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerController.GetLastFrameInputValues
// 0x003C (0x003C - 0x0000)
struct MatchaSnapNetPlayerController_GetLastFrameInputValues final
{
public:
	struct FPlayerInputValues                     ReturnValue;                                       // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_GetLastFrameInputValues) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerController_GetLastFrameInputValues");
static_assert(sizeof(MatchaSnapNetPlayerController_GetLastFrameInputValues) == 0x00003C, "Wrong size on MatchaSnapNetPlayerController_GetLastFrameInputValues");
static_assert(offsetof(MatchaSnapNetPlayerController_GetLastFrameInputValues, ReturnValue) == 0x000000, "Member 'MatchaSnapNetPlayerController_GetLastFrameInputValues::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayerController.SetPlayerCharacter
// 0x0004 (0x0004 - 0x0000)
struct MatchaSnapNetPlayerController_SetPlayerCharacter final
{
public:
	int32                                         CharacterIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayerController_SetPlayerCharacter) == 0x000004, "Wrong alignment on MatchaSnapNetPlayerController_SetPlayerCharacter");
static_assert(sizeof(MatchaSnapNetPlayerController_SetPlayerCharacter) == 0x000004, "Wrong size on MatchaSnapNetPlayerController_SetPlayerCharacter");
static_assert(offsetof(MatchaSnapNetPlayerController_SetPlayerCharacter, CharacterIndex) == 0x000000, "Member 'MatchaSnapNetPlayerController_SetPlayerCharacter::CharacterIndex' has a wrong offset!");

// Function Matcha.MatchaSnapNetPlayInfo.Get
// 0x0010 (0x0010 - 0x0000)
struct MatchaSnapNetPlayInfo_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetPlayInfo*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSnapNetPlayInfo_Get) == 0x000008, "Wrong alignment on MatchaSnapNetPlayInfo_Get");
static_assert(sizeof(MatchaSnapNetPlayInfo_Get) == 0x000010, "Wrong size on MatchaSnapNetPlayInfo_Get");
static_assert(offsetof(MatchaSnapNetPlayInfo_Get, WorldContextObject) == 0x000000, "Member 'MatchaSnapNetPlayInfo_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaSnapNetPlayInfo_Get, ReturnValue) == 0x000008, "Member 'MatchaSnapNetPlayInfo_Get::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaSplineTraversalEntity.GetRemainingCooldownTime
// 0x0004 (0x0004 - 0x0000)
struct MatchaSplineTraversalEntity_GetRemainingCooldownTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaSplineTraversalEntity_GetRemainingCooldownTime) == 0x000004, "Wrong alignment on MatchaSplineTraversalEntity_GetRemainingCooldownTime");
static_assert(sizeof(MatchaSplineTraversalEntity_GetRemainingCooldownTime) == 0x000004, "Wrong size on MatchaSplineTraversalEntity_GetRemainingCooldownTime");
static_assert(offsetof(MatchaSplineTraversalEntity_GetRemainingCooldownTime, ReturnValue) == 0x000000, "Member 'MatchaSplineTraversalEntity_GetRemainingCooldownTime::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaStandaloneServerProvider.OnMatchPhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct MatchaStandaloneServerProvider_OnMatchPhaseChanged final
{
public:
	EMatchaMatchPhase                             MatchPhase;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaStandaloneServerProvider_OnMatchPhaseChanged) == 0x000001, "Wrong alignment on MatchaStandaloneServerProvider_OnMatchPhaseChanged");
static_assert(sizeof(MatchaStandaloneServerProvider_OnMatchPhaseChanged) == 0x000001, "Wrong size on MatchaStandaloneServerProvider_OnMatchPhaseChanged");
static_assert(offsetof(MatchaStandaloneServerProvider_OnMatchPhaseChanged, MatchPhase) == 0x000000, "Member 'MatchaStandaloneServerProvider_OnMatchPhaseChanged::MatchPhase' has a wrong offset!");

// Function Matcha.MatchaTrapRenderer.OnTrapEntityUpdated
// 0x0010 (0x0010 - 0x0000)
struct MatchaTrapRenderer_OnTrapEntityUpdated final
{
public:
	const class AMatchaTrapEntity*                TrapEntity;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleported;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaTrapRenderer_OnTrapEntityUpdated) == 0x000008, "Wrong alignment on MatchaTrapRenderer_OnTrapEntityUpdated");
static_assert(sizeof(MatchaTrapRenderer_OnTrapEntityUpdated) == 0x000010, "Wrong size on MatchaTrapRenderer_OnTrapEntityUpdated");
static_assert(offsetof(MatchaTrapRenderer_OnTrapEntityUpdated, TrapEntity) == 0x000000, "Member 'MatchaTrapRenderer_OnTrapEntityUpdated::TrapEntity' has a wrong offset!");
static_assert(offsetof(MatchaTrapRenderer_OnTrapEntityUpdated, DeltaSeconds) == 0x000008, "Member 'MatchaTrapRenderer_OnTrapEntityUpdated::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(MatchaTrapRenderer_OnTrapEntityUpdated, bTeleported) == 0x00000C, "Member 'MatchaTrapRenderer_OnTrapEntityUpdated::bTeleported' has a wrong offset!");

// Function Matcha.MatchaUIStatics.FromStringTable
// 0x0030 (0x0030 - 0x0000)
struct MatchaUIStatics_FromStringTable final
{
public:
	class FName                                   StringTableId;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OutText;                                           // 0x0018(0x0010)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatchaUIStatics_FromStringTable) == 0x000008, "Wrong alignment on MatchaUIStatics_FromStringTable");
static_assert(sizeof(MatchaUIStatics_FromStringTable) == 0x000030, "Wrong size on MatchaUIStatics_FromStringTable");
static_assert(offsetof(MatchaUIStatics_FromStringTable, StringTableId) == 0x000000, "Member 'MatchaUIStatics_FromStringTable::StringTableId' has a wrong offset!");
static_assert(offsetof(MatchaUIStatics_FromStringTable, Key) == 0x000008, "Member 'MatchaUIStatics_FromStringTable::Key' has a wrong offset!");
static_assert(offsetof(MatchaUIStatics_FromStringTable, OutText) == 0x000018, "Member 'MatchaUIStatics_FromStringTable::OutText' has a wrong offset!");
static_assert(offsetof(MatchaUIStatics_FromStringTable, ReturnValue) == 0x000028, "Member 'MatchaUIStatics_FromStringTable::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaUIStatics.ShowErrorMessageFromResponse
// 0x0060 (0x0060 - 0x0000)
struct MatchaUIStatics_ShowErrorMessageFromResponse final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FErrorResponseV1                       Error;                                             // 0x0008(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaUIStatics_ShowErrorMessageFromResponse) == 0x000008, "Wrong alignment on MatchaUIStatics_ShowErrorMessageFromResponse");
static_assert(sizeof(MatchaUIStatics_ShowErrorMessageFromResponse) == 0x000060, "Wrong size on MatchaUIStatics_ShowErrorMessageFromResponse");
static_assert(offsetof(MatchaUIStatics_ShowErrorMessageFromResponse, WorldContextObject) == 0x000000, "Member 'MatchaUIStatics_ShowErrorMessageFromResponse::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaUIStatics_ShowErrorMessageFromResponse, Error) == 0x000008, "Member 'MatchaUIStatics_ShowErrorMessageFromResponse::Error' has a wrong offset!");

// Function Matcha.MatchaUIStatics.UTCHourToLocalWithSuffix
// 0x0018 (0x0018 - 0x0000)
struct MatchaUIStatics_UTCHourToLocalWithSuffix final
{
public:
	int32                                         UtcHour;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaUIStatics_UTCHourToLocalWithSuffix) == 0x000008, "Wrong alignment on MatchaUIStatics_UTCHourToLocalWithSuffix");
static_assert(sizeof(MatchaUIStatics_UTCHourToLocalWithSuffix) == 0x000018, "Wrong size on MatchaUIStatics_UTCHourToLocalWithSuffix");
static_assert(offsetof(MatchaUIStatics_UTCHourToLocalWithSuffix, UtcHour) == 0x000000, "Member 'MatchaUIStatics_UTCHourToLocalWithSuffix::UtcHour' has a wrong offset!");
static_assert(offsetof(MatchaUIStatics_UTCHourToLocalWithSuffix, ReturnValue) == 0x000008, "Member 'MatchaUIStatics_UTCHourToLocalWithSuffix::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaUISubsystem.GetUIDataModel
// 0x0010 (0x0010 - 0x0000)
struct MatchaUISubsystem_GetUIDataModel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaUIDataModelBase*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaUISubsystem_GetUIDataModel) == 0x000008, "Wrong alignment on MatchaUISubsystem_GetUIDataModel");
static_assert(sizeof(MatchaUISubsystem_GetUIDataModel) == 0x000010, "Wrong size on MatchaUISubsystem_GetUIDataModel");
static_assert(offsetof(MatchaUISubsystem_GetUIDataModel, WorldContextObject) == 0x000000, "Member 'MatchaUISubsystem_GetUIDataModel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaUISubsystem_GetUIDataModel, ReturnValue) == 0x000008, "Member 'MatchaUISubsystem_GetUIDataModel::ReturnValue' has a wrong offset!");

// Function Matcha.MatchaUISubsystem.GetUISubsystem
// 0x0010 (0x0010 - 0x0000)
struct MatchaUISubsystem_GetUISubsystem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatchaUISubsystem*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatchaUISubsystem_GetUISubsystem) == 0x000008, "Wrong alignment on MatchaUISubsystem_GetUISubsystem");
static_assert(sizeof(MatchaUISubsystem_GetUISubsystem) == 0x000010, "Wrong size on MatchaUISubsystem_GetUISubsystem");
static_assert(offsetof(MatchaUISubsystem_GetUISubsystem, WorldContextObject) == 0x000000, "Member 'MatchaUISubsystem_GetUISubsystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatchaUISubsystem_GetUISubsystem, ReturnValue) == 0x000008, "Member 'MatchaUISubsystem_GetUISubsystem::ReturnValue' has a wrong offset!");

}

