#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Matcha

#include "Basic.hpp"

#include "MatchaGameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "OdyServices_structs.hpp"
#include "SnapNet_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum Matcha.EMatchaCameraMode
// NumValues: 0x0003
enum class EMatchaCameraMode : uint8
{
	Combat                                   = 0,
	Explore                                  = 1,
	EMatchaCameraMode_MAX                    = 2,
};

// Enum Matcha.ESpawnRegion
// NumValues: 0x0014
enum class ESpawnRegion : uint8
{
	None                                     = 0,
	KaiTower                                 = 1,
	ClarionCorp                              = 2,
	Biosphere                                = 3,
	CoreStrikeArena                          = 4,
	ObeliskOfLight                           = 5,
	AtlasLab                                 = 6,
	ShoppingCenter                           = 7,
	Beach                                    = 8,
	ParkingGarage                            = 9,
	AhtenSewers                              = 10,
	Factory                                  = 11,
	Casino                                   = 12,
	Arcade                                   = 13,
	WaitingRoom                              = 14,
	OniMountain                              = 15,
	FloatingForest                           = 16,
	Random                                   = 17,
	Count                                    = 18,
	ESpawnRegion_MAX                         = 19,
};

// Enum Matcha.EMatchaGameplayEventType
// NumValues: 0x0004
enum class EMatchaGameplayEventType : uint8
{
	None                                     = 0,
	TimedChestSpawned                        = 1,
	TimedChestUnlockStart                    = 2,
	EMatchaGameplayEventType_MAX             = 3,
};

// Enum Matcha.EIdentityState
// NumValues: 0x0007
enum class EIdentityState : uint8
{
	Unknown                                  = 0,
	Processing                               = 1,
	Known                                    = 2,
	None                                     = 3,
	Banned                                   = 4,
	LoggedOut                                = 5,
	EIdentityState_MAX                       = 6,
};

// Enum Matcha.EMatchaMatchPhase
// NumValues: 0x0008
enum class EMatchaMatchPhase : uint8
{
	MatchPhase_NotStarted                    = 0,
	MatchPhase_SpawnInSelect                 = 1,
	MatchPhase_SpawnInSelectOutro            = 2,
	MatchPhase_InProgress                    = 3,
	MatchPhase_Completed                     = 4,
	MatchPhase_AutoStartCountdown            = 5,
	MatchPhase_ShuttingDown                  = 6,
	MatchPhase_MAX                           = 7,
};

// Enum Matcha.EAIMontageType
// NumValues: 0x0006
enum class EAIMontageType : uint8
{
	None                                     = 0,
	KnockBack                                = 1,
	Ability                                  = 2,
	Movement                                 = 3,
	Death                                    = 4,
	EAIMontageType_MAX                       = 5,
};

// Enum Matcha.EAIAbilityDirectionConstraint
// NumValues: 0x0008
enum class EAIAbilityDirectionConstraint : uint8
{
	None                                     = 0,
	Any                                      = 1,
	Above                                    = 2,
	Below                                    = 3,
	AnyLateral                               = 4,
	Front                                    = 5,
	Behind                                   = 6,
	EAIAbilityDirectionConstraint_MAX        = 7,
};

// Enum Matcha.ERootMotionForceApplicationCondition
// NumValues: 0x0003
enum class ERootMotionForceApplicationCondition : uint8
{
	None                                     = 0,
	CompanionAttached                        = 1,
	ERootMotionForceApplicationCondition_MAX = 2,
};

// Enum Matcha.EAutoTravelRootMotionType
// NumValues: 0x0004
enum class EAutoTravelRootMotionType : uint8
{
	None                                     = 0,
	Launch                                   = 1,
	TraversalEntity                          = 2,
	EAutoTravelRootMotionType_MAX            = 3,
};

// Enum Matcha.EMatchaInputAction
// NumValues: 0x001D
enum class EMatchaInputAction : uint8
{
	Invalid                                  = 0,
	MoveRight                                = 1,
	MoveLeft                                 = 2,
	MoveUp                                   = 3,
	MoveDown                                 = 4,
	MoveStick                                = 5,
	AttackStick                              = 6,
	Jump                                     = 7,
	Attack                                   = 8,
	SpecialAttack                            = 9,
	Shield                                   = 10,
	Grab                                     = 11,
	Interact                                 = 12,
	OpenMap                                  = 13,
	KeyboardForceWalkModifier                = 14,
	KeyboardHeavyAttack                      = 15,
	KeyboardHeavyAttackModifier              = 16,
	KeyboardMoveDownTap                      = 17,
	KeyboardStartDash                        = 18,
	KeyboardTeamAttack                       = 19,
	KeyboardEnergyBurst                      = 20,
	ShortJump                                = 21,
	CameraMode                               = 22,
	DPadLeft                                 = 23,
	DPadUp                                   = 24,
	DPadRight                                = 25,
	DPadDown                                 = 26,
	EnergyModifier                           = 27,
	EMatchaInputAction_MAX                   = 28,
};

// Enum Matcha.ECardinalInputDirection
// NumValues: 0x000A
enum class ECardinalInputDirection : uint8
{
	None                                     = 0,
	North                                    = 1,
	South                                    = 2,
	West                                     = 3,
	East                                     = 4,
	NorthWest                                = 5,
	NorthEast                                = 6,
	SouthWest                                = 7,
	SouthEast                                = 8,
	ECardinalInputDirection_MAX              = 9,
};

// Enum Matcha.EScheduledObjectiveType
// NumValues: 0x0004
enum class EScheduledObjectiveType : uint8
{
	None                                     = 0,
	LegendaryChest                           = 1,
	HackChest                                = 2,
	EScheduledObjectiveType_MAX              = 3,
};

// Enum Matcha.EInventoryHeldSlotStackingMode
// NumValues: 0x0003
enum class EInventoryHeldSlotStackingMode : uint8
{
	FullStack                                = 0,
	Incremental                              = 1,
	EInventoryHeldSlotStackingMode_MAX       = 2,
};

// Enum Matcha.EAttackStickMoveType
// NumValues: 0x0003
enum class EAttackStickMoveType : uint8
{
	SmashAttacks                             = 0,
	TiltAttacks                              = 1,
	EAttackStickMoveType_MAX                 = 2,
};

// Enum Matcha.EHitTargetType
// NumValues: 0x0004
enum class EHitTargetType : uint8
{
	GroundedOnly                             = 0,
	AirborneOnly                             = 1,
	Both                                     = 2,
	EHitTargetType_MAX                       = 3,
};

// Enum Matcha.EHitCollisionType
// NumValues: 0x0007
enum class EHitCollisionType : uint8
{
	Damage                                   = 0,
	Grab                                     = 1,
	Throw                                    = 2,
	Grounded                                 = 3,
	Aerial                                   = 4,
	Projectile                               = 5,
	EHitCollisionType_MAX                    = 6,
};

// Enum Matcha.EMatchaHitBoxType
// NumValues: 0x0004
enum class EMatchaHitBoxType : uint8
{
	Sphere                                   = 0,
	Box                                      = 1,
	Capsule                                  = 2,
	EMatchaHitBoxType_MAX                    = 3,
};

// Enum Matcha.EMatchaCharacterMontageType
// NumValues: 0x005C
enum class EMatchaCharacterMontageType : uint8
{
	None                                     = 0,
	GroundJump                               = 1,
	AirJump                                  = 2,
	FinalAirJump                             = 3,
	WallJump                                 = 4,
	LedgeGrab                                = 5,
	LedgeJumpGetUp                           = 6,
	LedgeJump                                = 7,
	LedgeGetUp                               = 8,
	LedgeRoll                                = 9,
	LedgeAttack                              = 10,
	LedgeSpecialAttack                       = 11,
	Landing                                  = 12,
	Counter                                  = 13,
	DiveBomb                                 = 14,
	Jab                                      = 15,
	ForwardTilt                              = 16,
	UpTilt                                   = 17,
	DownTilt                                 = 18,
	ForwardSmash                             = 19,
	UpSmash                                  = 20,
	DownSmash                                = 21,
	NeutralAir                               = 22,
	ForwardAir                               = 23,
	BackAir                                  = 24,
	UpAir                                    = 25,
	DownAir                                  = 26,
	DashStart                                = 27,
	DashAttack                               = 28,
	NeutralSpecial                           = 29,
	SideSpecial                              = 30,
	UpSpecial                                = 31,
	DownSpecial                              = 32,
	LightHurtAir                             = 33,
	LightHurtGround                          = 34,
	HurtLaunchPose                           = 35,
	HurtLaunch                               = 36,
	HurtLaunchToTumble                       = 37,
	Tumble                                   = 38,
	WallBounceHurtPose                       = 39,
	Tech                                     = 40,
	KnockDown                                = 41,
	KnockDownGetUp                           = 42,
	ShieldUp                                 = 43,
	ShieldDrop                               = 44,
	AirDodge                                 = 45,
	GroundForwardDodge                       = 46,
	GroundBackwardsDodge                     = 47,
	GroundSpotDodge                          = 48,
	Bounce                                   = 49,
	GrabBounce                               = 50,
	Grab                                     = 51,
	DashGrab                                 = 52,
	GrabLoop                                 = 53,
	Grabbed                                  = 54,
	Throw                                    = 55,
	BeingThrown                              = 56,
	ShieldBreak                              = 57,
	Dizzy                                    = 58,
	Stun                                     = 59,
	Interact                                 = 60,
	InteractCancel                           = 61,
	DropItem                                 = 62,
	ThrowItem                                = 63,
	FirePistolItem                           = 64,
	ConsumeFoodItem                          = 65,
	ConsumeDeployItem                        = 66,
	CompleteConsumeFoodItem                  = 67,
	CompleteConsumeDeployItem                = 68,
	CancelConsumeItem                        = 69,
	TeamAttack                               = 70,
	EmpoweredNeutralSpecial                  = 71,
	EmpoweredSideSpecial                     = 72,
	EmpoweredUpSpecial                       = 73,
	EmpoweredDownSpecial                     = 74,
	NeutralSpecialAerial                     = 75,
	SideSpecialAerial                        = 76,
	UpSpecialAerial                          = 77,
	DownSpecialAerial                        = 78,
	EmpoweredNeutralSpecialAerial            = 79,
	EmpoweredSideSpecialAerial               = 80,
	EmpoweredUpSpecialAerial                 = 81,
	EmpoweredDownSpecialAerial               = 82,
	EnergyBurst                              = 83,
	AirGrab                                  = 84,
	DashAirGrab                              = 85,
	Zipline                                  = 86,
	GlitchStepAttack                         = 87,
	GlitchBeam                               = 88,
	TurnAround                               = 89,
	DashTurnAround                           = 90,
	EMatchaCharacterMontageType_MAX          = 91,
};

// Enum Matcha.EMatchaRootMotionType
// NumValues: 0x002C
enum class EMatchaRootMotionType : uint8
{
	None                                     = 0,
	DashStart                                = 1,
	DashAttack                               = 2,
	GroundForwardDodge                       = 3,
	GroundBackwardsDodge                     = 4,
	AirDodge                                 = 5,
	NeutralAir                               = 6,
	ForwardAir                               = 7,
	BackAir                                  = 8,
	UpAir                                    = 9,
	DownAir                                  = 10,
	NeutralSpecial                           = 11,
	SideSpecial                              = 12,
	UpSpecial                                = 13,
	DownSpecial                              = 14,
	ForwardSmash                             = 15,
	UpSmash                                  = 16,
	DownSmash                                = 17,
	ForwardTilt                              = 18,
	UpTilt                                   = 19,
	DownTilt                                 = 20,
	KnockDownGetUpForward                    = 21,
	KnockDownGetUpBackwards                  = 22,
	TechGroundForward                        = 23,
	TechGroundBackwards                      = 24,
	TeamAttackIntro                          = 25,
	TeamAttackTeleport                       = 26,
	EmpoweredNeutralSpecial                  = 27,
	EmpoweredSideSpecial                     = 28,
	EmpoweredUpSpecial                       = 29,
	EmpoweredDownSpecial                     = 30,
	NeutralSpecialAerial                     = 31,
	SideSpecialAerial                        = 32,
	UpSpecialAerial                          = 33,
	DownSpecialAerial                        = 34,
	EmpoweredNeutralSpecialAerial            = 35,
	EmpoweredSideSpecialAerial               = 36,
	EmpoweredUpSpecialAerial                 = 37,
	EmpoweredDownSpecialAerial               = 38,
	DiveBomb                                 = 39,
	DashGrab                                 = 40,
	AirDashGrab                              = 41,
	DashTurnAround                           = 42,
	EMatchaRootMotionType_MAX                = 43,
};

// Enum Matcha.EClankResultType
// NumValues: 0x0006
enum class EClankResultType : uint8
{
	None                                     = 0,
	Continue                                 = 1,
	Bounce                                   = 2,
	GrabBounce                               = 3,
	Fizzle                                   = 4,
	EClankResultType_MAX                     = 5,
};

// Enum Matcha.EAttackDirection
// NumValues: 0x0006
enum class EAttackDirection : uint8
{
	Neutral                                  = 0,
	Up                                       = 1,
	Down                                     = 2,
	Forward                                  = 3,
	Backwards                                = 4,
	EAttackDirection_MAX                     = 5,
};

// Enum Matcha.EMatchaShieldState
// NumValues: 0x0004
enum class EMatchaShieldState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	Broken                                   = 2,
	EMatchaShieldState_MAX                   = 3,
};

// Enum Matcha.EQueuedJumpFlags
// NumValues: 0x0005
enum class EQueuedJumpFlags : uint8
{
	None                                     = 0,
	ShortGroundJump                          = 1,
	FullGroundJump                           = 2,
	LedgeJump                                = 4,
	EQueuedJumpFlags_MAX                     = 5,
};

// Enum Matcha.EAppliedHitFlags
// NumValues: 0x0007
enum class EAppliedHitFlags : uint8
{
	None                                     = 0,
	Shield                                   = 1,
	PerfectShield                            = 2,
	Counter                                  = 4,
	LethalKnockBack                          = 8,
	OwnedEntityHit                           = 16,
	EAppliedHitFlags_MAX                     = 17,
};

// Enum Matcha.ELedgePropertyFlags
// NumValues: 0x0004
enum class ELedgePropertyFlags : uint8
{
	None                                     = 0,
	GrantsIntangibility                      = 1,
	OnlyAllowsLedgeJump                      = 2,
	ELedgePropertyFlags_MAX                  = 3,
};

// Enum Matcha.EPlayerGlobalCombatStatus
// NumValues: 0x0008
enum class EPlayerGlobalCombatStatus : uint8
{
	KnockedOut                               = 0,
	Respawning                               = 1,
	InTransitionToArena                      = 2,
	InTransitionOutOfArena                   = 3,
	InOverWorld                              = 4,
	FightingInArena                          = 5,
	WaitingInArena                           = 6,
	EPlayerGlobalCombatStatus_MAX            = 7,
};

// Enum Matcha.ECompanionAttachState
// NumValues: 0x0006
enum class ECompanionAttachState : uint8
{
	None                                     = 0,
	Attached                                 = 1,
	Detached                                 = 2,
	Attaching                                = 3,
	Detaching                                = 4,
	ECompanionAttachState_MAX                = 5,
};

// Enum Matcha.EVisibilityOverrideTargetType
// NumValues: 0x0005
enum class EVisibilityOverrideTargetType : uint8
{
	MeshBone                                 = 0,
	AttachableCompanion                      = 1,
	StaticMeshAttachment                     = 2,
	SkeletalMeshAttachment                   = 3,
	EVisibilityOverrideTargetType_MAX        = 4,
};

// Enum Matcha.EGrabHeightType
// NumValues: 0x0005
enum class EGrabHeightType : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	EGrabHeightType_MAX                      = 4,
};

// Enum Matcha.EThrowDirection
// NumValues: 0x0006
enum class EThrowDirection : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Forward                                  = 3,
	Backwards                                = 4,
	EThrowDirection_MAX                      = 5,
};

// Enum Matcha.EThrowType
// NumValues: 0x0008
enum class EThrowType : uint8
{
	None                                     = 0,
	Chest                                    = 1,
	Feet                                     = 2,
	FeetBendRight                            = 3,
	Waist                                    = 4,
	WaistBendForward                         = 5,
	WaistBendBack                            = 6,
	EThrowType_MAX                           = 7,
};

// Enum Matcha.EItemDefaultNeutralThrowDirection
// NumValues: 0x0005
enum class EItemDefaultNeutralThrowDirection : uint8
{
	Facing                                   = 0,
	Up                                       = 1,
	Down                                     = 2,
	Backwards                                = 3,
	EItemDefaultNeutralThrowDirection_MAX    = 4,
};

// Enum Matcha.EItemAllowedThrowOrFireDirectionType
// NumValues: 0x0003
enum class EItemAllowedThrowOrFireDirectionType : uint8
{
	FacingOnly                               = 0,
	OmniDirection                            = 1,
	EItemAllowedThrowOrFireDirectionType_MAX = 2,
};

// Enum Matcha.EItemUsageType
// NumValues: 0x0005
enum class EItemUsageType : uint8
{
	None                                     = 0,
	Consumable                               = 1,
	Throwable                                = 2,
	Gun                                      = 3,
	EItemUsageType_MAX                       = 4,
};

// Enum Matcha.EItemConsumableType
// NumValues: 0x0005
enum class EItemConsumableType : uint8
{
	None                                     = 0,
	Edible                                   = 1,
	Trap                                     = 2,
	Tech                                     = 3,
	EItemConsumableType_MAX                  = 4,
};

// Enum Matcha.EItemConsumeAnimationType
// NumValues: 0x0005
enum class EItemConsumeAnimationType : uint8
{
	None                                     = 0,
	Food                                     = 1,
	Drink                                    = 2,
	Deploy                                   = 3,
	EItemConsumeAnimationType_MAX            = 4,
};

// Enum Matcha.ETechType
// NumValues: 0x0008
enum class ETechType : uint8
{
	None                                     = 0,
	Ceiling                                  = 1,
	Wall                                     = 2,
	WallJump                                 = 3,
	Ground                                   = 4,
	GroundForward                            = 5,
	GroundBackwards                          = 6,
	ETechType_MAX                            = 7,
};

// Enum Matcha.EKnockDownGetUpType
// NumValues: 0x0006
enum class EKnockDownGetUpType : uint8
{
	None                                     = 0,
	Front                                    = 1,
	Forward                                  = 2,
	Backwards                                = 3,
	Attack                                   = 4,
	EKnockDownGetUpType_MAX                  = 5,
};

// Enum Matcha.ESpecialAttackType
// NumValues: 0x0006
enum class ESpecialAttackType : uint8
{
	Invalid                                  = 0,
	Up                                       = 1,
	Down                                     = 2,
	Side                                     = 3,
	Neutral                                  = 4,
	ESpecialAttackType_MAX                   = 5,
};

// Enum Matcha.EAliveState
// NumValues: 0x0005
enum class EAliveState : uint8
{
	Alive                                    = 0,
	SoulComplete                             = 1,
	SoulBroken                               = 2,
	Dead                                     = 3,
	EAliveState_MAX                          = 4,
};

// Enum Matcha.EMatchaProfileType
// NumValues: 0x0006
enum class EMatchaProfileType : uint8
{
	CSV                                      = 0,
	Insights                                 = 1,
	Network                                  = 2,
	Stat                                     = 3,
	Memory                                   = 4,
	EMatchaProfileType_MAX                   = 5,
};

// Enum Matcha.EObjectRarity
// NumValues: 0x0006
enum class EObjectRarity : uint8
{
	None                                     = 0,
	Common                                   = 1,
	Rare                                     = 2,
	Epic                                     = 3,
	Legendary                                = 4,
	EObjectRarity_MAX                        = 5,
};

// Enum Matcha.EInGameCurrencyType
// NumValues: 0x0004
enum class EInGameCurrencyType : uint8
{
	None                                     = 0,
	Coins                                    = 1,
	PowerSparks                              = 2,
	EInGameCurrencyType_MAX                  = 3,
};

// Enum Matcha.EFallType
// NumValues: 0x0004
enum class EFallType : uint8
{
	Normal                                   = 0,
	Fast                                     = 1,
	DiveBomb                                 = 2,
	EFallType_MAX                            = 3,
};

// Enum Matcha.EJumpType
// NumValues: 0x0008
enum class EJumpType : uint8
{
	Invalid                                  = 0,
	GroundedShortJump                        = 1,
	GroundedFullJump                         = 2,
	AirJump                                  = 3,
	LedgeGetUpJump                           = 4,
	EnvironmentLaunch                        = 5,
	WallJump                                 = 6,
	EJumpType_MAX                            = 7,
};

// Enum Matcha.ETeleportSettingsType
// NumValues: 0x0006
enum class ETeleportSettingsType : uint8
{
	SetLocation                              = 0,
	OffsetFromCharacter                      = 1,
	DistanceTowardsInput                     = 2,
	CompanionEntity                          = 3,
	GlitchMark                               = 4,
	ETeleportSettingsType_MAX                = 5,
};

// Enum Matcha.ELaunchType
// NumValues: 0x0003
enum class ELaunchType : uint8
{
	RootMotion                               = 0,
	CharacterDefault                         = 1,
	ELaunchType_MAX                          = 2,
};

// Enum Matcha.ELaunchActionRestrictionType
// NumValues: 0x0004
enum class ELaunchActionRestrictionType : uint8
{
	None                                     = 0,
	Duration                                 = 1,
	UntilLanding                             = 2,
	ELaunchActionRestrictionType_MAX         = 3,
};

// Enum Matcha.EFrameRateCap
// NumValues: 0x0005
enum class EFrameRateCap : uint8
{
	Unlimited                                = 0,
	Sixty                                    = 1,
	HundredTwenty                            = 2,
	HundredFortyFour                         = 3,
	EFrameRateCap_MAX                        = 4,
};

// Enum Matcha.ETargetedGlitchDashFacingType
// NumValues: 0x0003
enum class ETargetedGlitchDashFacingType : uint8
{
	TowardsTarget                            = 0,
	AwayFromTarget                           = 1,
	ETargetedGlitchDashFacingType_MAX        = 2,
};

// Enum Matcha.ETargetedGlitchDashTargetType
// NumValues: 0x0005
enum class ETargetedGlitchDashTargetType : uint8
{
	GlitchMark                               = 0,
	AimiMark                                 = 1,
	Custom                                   = 2,
	TeamAttack                               = 3,
	ETargetedGlitchDashTargetType_MAX        = 4,
};

// Enum Matcha.EEntitySpawnCondition
// NumValues: 0x0004
enum class EEntitySpawnCondition : uint8
{
	None                                     = 0,
	AliveQuantityLimit                       = 1,
	DoNotSpawnThroughDoors                   = 2,
	EEntitySpawnCondition_MAX                = 3,
};

// Enum Matcha.ETeamFilter
// NumValues: 0x0004
enum class ETeamFilter : uint8
{
	None                                     = 0,
	AlliesOnly                               = 1,
	EnemiesOnly                              = 2,
	ETeamFilter_MAX                          = 3,
};

// Enum Matcha.EEffectEventType
// NumValues: 0x0004
enum class EEffectEventType : uint8
{
	Character                                = 0,
	Hit                                      = 1,
	Generic                                  = 2,
	EEffectEventType_MAX                     = 3,
};

// Enum Matcha.ECharacterKnockOutType
// NumValues: 0x0005
enum class ECharacterKnockOutType : uint8
{
	Default                                  = 0,
	KnockedIntoZone                          = 1,
	KnockedInsideZone                        = 2,
	DamagedInsideZone                        = 3,
	ECharacterKnockOutType_MAX               = 4,
};

// Enum Matcha.ETraversalEntityType
// NumValues: 0x0004
enum class ETraversalEntityType : uint8
{
	None                                     = 0,
	DataStream                               = 1,
	Zipline                                  = 2,
	ETraversalEntityType_MAX                 = 3,
};

// Enum Matcha.EHackType
// NumValues: 0x0006
enum class EHackType : uint8
{
	None                                     = 0,
	Asher                                    = 1,
	Estelle                                  = 2,
	Juliette                                 = 3,
	Luna                                     = 4,
	EHackType_MAX                            = 5,
};

// Enum Matcha.EMatchaEntityRelevanceMode
// NumValues: 0x0006
enum class EMatchaEntityRelevanceMode : uint8
{
	Always                                   = 0,
	OwnerOnly                                = 1,
	TeamOnly                                 = 2,
	Distance                                 = 3,
	Never                                    = 4,
	EMatchaEntityRelevanceMode_MAX           = 5,
};

// Enum Matcha.EMatchaInteractionTriggerMode
// NumValues: 0x0003
enum class EMatchaInteractionTriggerMode : uint8
{
	OverlapOnly                              = 0,
	RequiresInput                            = 1,
	EMatchaInteractionTriggerMode_MAX        = 2,
};

// Enum Matcha.EKnockoutProcessingMode
// NumValues: 0x0004
enum class EKnockoutProcessingMode : uint8
{
	None                                     = 0,
	Always                                   = 1,
	MinimumDamageThreshold                   = 2,
	EKnockoutProcessingMode_MAX              = 3,
};

// Enum Matcha.EMatchaClientServerConnectionTarget
// NumValues: 0x0004
enum class EMatchaClientServerConnectionTarget : uint8
{
	None                                     = 0,
	Local                                    = 1,
	Remote                                   = 2,
	EMatchaClientServerConnectionTarget_MAX  = 3,
};

// Enum Matcha.EMatchaClientRemoteConnectionStatus
// NumValues: 0x0008
enum class EMatchaClientRemoteConnectionStatus : uint8
{
	None                                     = 0,
	WaitingToConnect                         = 1,
	Connecting                               = 2,
	Joining                                  = 3,
	Joined                                   = 4,
	FailedToJoin                             = 5,
	Disconnecting                            = 6,
	EMatchaClientRemoteConnectionStatus_MAX  = 7,
};

// Enum Matcha.EMatchaSplineLoopMode
// NumValues: 0x0004
enum class EMatchaSplineLoopMode : uint8
{
	Default                                  = 0,
	AlwaysFromStart                          = 1,
	PingPong                                 = 2,
	EMatchaSplineLoopMode_MAX                = 3,
};

// Enum Matcha.EMatchaMovingPlatformPhase
// NumValues: 0x0005
enum class EMatchaMovingPlatformPhase : uint8
{
	WaitingToStart                           = 0,
	HoldingAtStart                           = 1,
	Moving                                   = 2,
	HoldingAtEnd                             = 3,
	EMatchaMovingPlatformPhase_MAX           = 4,
};

// Enum Matcha.EMatchaPlayerSlotStatus
// NumValues: 0x0004
enum class EMatchaPlayerSlotStatus : uint8
{
	Empty                                    = 0,
	Human                                    = 1,
	Bot                                      = 2,
	EMatchaPlayerSlotStatus_MAX              = 3,
};

// Enum Matcha.EFallLoopDirection
// NumValues: 0x0004
enum class EFallLoopDirection : uint8
{
	Center                                   = 0,
	Forward                                  = 1,
	Backwards                                = 2,
	EFallLoopDirection_MAX                   = 3,
};

// Enum Matcha.EBufferedInputType
// NumValues: 0x0011
enum class EBufferedInputType : uint8
{
	Invalid                                  = 0,
	MoveStickRightFlick                      = 1,
	MoveStickLeftFlick                       = 2,
	MoveStickUpFlick                         = 3,
	MoveStickDownFlick                       = 4,
	AttackStickRightFlick                    = 5,
	AttackStickLeftFlick                     = 6,
	AttackStickUpFlick                       = 7,
	AttackStickDownFlick                     = 8,
	Attack                                   = 9,
	SpecialAttack                            = 10,
	Jump                                     = 11,
	ShortJump                                = 12,
	Shield                                   = 13,
	Grab                                     = 14,
	TeamAttack                               = 15,
	EBufferedInputType_MAX                   = 16,
};

// Enum Matcha.EBasicAttackType
// NumValues: 0x0004
enum class EBasicAttackType : uint8
{
	Normal                                   = 0,
	Smash                                    = 1,
	Team                                     = 2,
	EBasicAttackType_MAX                     = 3,
};

// Enum Matcha.EHelplessConditionType
// NumValues: 0x0005
enum class EHelplessConditionType : uint8
{
	Default                                  = 0,
	AnySpecialAttackRestrictionMet           = 1,
	AllSpecialAttacksRestrictionsMet         = 2,
	None                                     = 3,
	EHelplessConditionType_MAX               = 4,
};

// Enum Matcha.ESpecialAttackRestrictionUsageType
// NumValues: 0x0004
enum class ESpecialAttackRestrictionUsageType : uint8
{
	Grounded                                 = 0,
	Aerial                                   = 1,
	Both                                     = 2,
	ESpecialAttackRestrictionUsageType_MAX   = 3,
};

// Enum Matcha.ETimedBuffApplicationSource
// NumValues: 0x0003
enum class ETimedBuffApplicationSource : uint8
{
	Thrown                                   = 0,
	Consumed                                 = 1,
	ETimedBuffApplicationSource_MAX          = 2,
};

// Enum Matcha.ETeamAttackTargetSearchType
// NumValues: 0x0004
enum class ETeamAttackTargetSearchType : uint8
{
	ClosestEnemyWithinRange                  = 0,
	ClosestAllyWithinRange                   = 1,
	ClosestEnemyWithinAllyRange              = 2,
	ETeamAttackTargetSearchType_MAX          = 3,
};

// Enum Matcha.ETeamAttackOffsetType
// NumValues: 0x0003
enum class ETeamAttackOffsetType : uint8
{
	FromEnemy                                = 0,
	FromAlly                                 = 1,
	ETeamAttackOffsetType_MAX                = 2,
};

// Enum Matcha.ETeamAttackFacingType
// NumValues: 0x0003
enum class ETeamAttackFacingType : uint8
{
	TowardsTarget                            = 0,
	AwayFromTarget                           = 1,
	ETeamAttackFacingType_MAX                = 2,
};

// Enum Matcha.ESnapNetWorldType
// NumValues: 0x0004
enum class ESnapNetWorldType : uint8
{
	Server                                   = 0,
	Client                                   = 1,
	Render                                   = 2,
	ESnapNetWorldType_MAX                    = 3,
};

// Enum Matcha.ETraversalDirectionType
// NumValues: 0x0003
enum class ETraversalDirectionType : uint8
{
	StartToEndOnly                           = 0,
	AnyDirection                             = 1,
	ETraversalDirectionType_MAX              = 2,
};

// ScriptStruct Matcha.MatchaServicesWebSocketMessageBase
// 0x0008 (0x0008 - 0x0000)
struct FMatchaServicesWebSocketMessageBase
{
public:
	class FName                                   Type;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaServicesWebSocketMessageBase) == 0x000004, "Wrong alignment on FMatchaServicesWebSocketMessageBase");
static_assert(sizeof(FMatchaServicesWebSocketMessageBase) == 0x000008, "Wrong size on FMatchaServicesWebSocketMessageBase");
static_assert(offsetof(FMatchaServicesWebSocketMessageBase, Type) == 0x000000, "Member 'FMatchaServicesWebSocketMessageBase::Type' has a wrong offset!");

// ScriptStruct Matcha.PartyMember
// 0x0008 (0x0008 - 0x0000)
struct FPartyMember final
{
public:
	class FName                                   PlayerId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartyMember) == 0x000004, "Wrong alignment on FPartyMember");
static_assert(sizeof(FPartyMember) == 0x000008, "Wrong size on FPartyMember");
static_assert(offsetof(FPartyMember, PlayerId) == 0x000000, "Member 'FPartyMember::PlayerId' has a wrong offset!");

// ScriptStruct Matcha.PlayerInputValues
// 0x003C (0x003C - 0x0000)
struct FPlayerInputValues final
{
public:
	float                                         MoveStickX;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStickY;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackStickX;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackStickY;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastMoveStickFlick;                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveStickUpFlick;                                 // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveStickDownFlick;                               // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveStickRightFlick;                              // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveStickLeftFlick;                               // 0x0017(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackStickUpFlick;                               // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackStickDownFlick;                             // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackStickRightFlick;                            // 0x001A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackStickLeftFlick;                             // 0x001B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJump;                                             // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShortJump;                                        // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttack;                                           // 0x001E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialAttack;                                    // 0x001F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnergyModifier;                                   // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShield;                                           // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGrab;                                             // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteract;                                         // 0x0023(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenMap;                                          // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraMode;                                       // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDPadLeft;                                         // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDPadUp;                                           // 0x0027(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDPadRight;                                        // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDPadDown;                                         // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDashSettingEnabled;                           // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardMostRecentVerticalMoveWasUp;              // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardMostRecentHorizontalMoveWasRight;         // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardForceWalkModifier;                        // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardHeavyAttack;                              // 0x002E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardHeavyAttackModifier;                      // 0x002F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardStartDash;                                // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardTeamAttack;                               // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardEnergyBurst;                              // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MoveRight;                                         // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MoveLeft;                                          // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MoveUp;                                            // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MoveDown;                                          // 0x0036(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardMoveDownTap;                              // 0x0037(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIncrementalHeldItemMode;                       // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackStickCastsTiltAttacks;                      // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerInputValues) == 0x000004, "Wrong alignment on FPlayerInputValues");
static_assert(sizeof(FPlayerInputValues) == 0x00003C, "Wrong size on FPlayerInputValues");
static_assert(offsetof(FPlayerInputValues, MoveStickX) == 0x000000, "Member 'FPlayerInputValues::MoveStickX' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, MoveStickY) == 0x000004, "Member 'FPlayerInputValues::MoveStickY' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, AttackStickX) == 0x000008, "Member 'FPlayerInputValues::AttackStickX' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, AttackStickY) == 0x00000C, "Member 'FPlayerInputValues::AttackStickY' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, TimeSinceLastMoveStickFlick) == 0x000010, "Member 'FPlayerInputValues::TimeSinceLastMoveStickFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bMoveStickUpFlick) == 0x000014, "Member 'FPlayerInputValues::bMoveStickUpFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bMoveStickDownFlick) == 0x000015, "Member 'FPlayerInputValues::bMoveStickDownFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bMoveStickRightFlick) == 0x000016, "Member 'FPlayerInputValues::bMoveStickRightFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bMoveStickLeftFlick) == 0x000017, "Member 'FPlayerInputValues::bMoveStickLeftFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bAttackStickUpFlick) == 0x000018, "Member 'FPlayerInputValues::bAttackStickUpFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bAttackStickDownFlick) == 0x000019, "Member 'FPlayerInputValues::bAttackStickDownFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bAttackStickRightFlick) == 0x00001A, "Member 'FPlayerInputValues::bAttackStickRightFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bAttackStickLeftFlick) == 0x00001B, "Member 'FPlayerInputValues::bAttackStickLeftFlick' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bJump) == 0x00001C, "Member 'FPlayerInputValues::bJump' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bShortJump) == 0x00001D, "Member 'FPlayerInputValues::bShortJump' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bAttack) == 0x00001E, "Member 'FPlayerInputValues::bAttack' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bSpecialAttack) == 0x00001F, "Member 'FPlayerInputValues::bSpecialAttack' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bEnergyModifier) == 0x000020, "Member 'FPlayerInputValues::bEnergyModifier' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bShield) == 0x000021, "Member 'FPlayerInputValues::bShield' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bGrab) == 0x000022, "Member 'FPlayerInputValues::bGrab' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bInteract) == 0x000023, "Member 'FPlayerInputValues::bInteract' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bOpenMap) == 0x000024, "Member 'FPlayerInputValues::bOpenMap' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bCameraMode) == 0x000025, "Member 'FPlayerInputValues::bCameraMode' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bDPadLeft) == 0x000026, "Member 'FPlayerInputValues::bDPadLeft' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bDPadUp) == 0x000027, "Member 'FPlayerInputValues::bDPadUp' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bDPadRight) == 0x000028, "Member 'FPlayerInputValues::bDPadRight' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bDPadDown) == 0x000029, "Member 'FPlayerInputValues::bDPadDown' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bAutoDashSettingEnabled) == 0x00002A, "Member 'FPlayerInputValues::bAutoDashSettingEnabled' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardMostRecentVerticalMoveWasUp) == 0x00002B, "Member 'FPlayerInputValues::bKeyboardMostRecentVerticalMoveWasUp' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardMostRecentHorizontalMoveWasRight) == 0x00002C, "Member 'FPlayerInputValues::bKeyboardMostRecentHorizontalMoveWasRight' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardForceWalkModifier) == 0x00002D, "Member 'FPlayerInputValues::bKeyboardForceWalkModifier' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardHeavyAttack) == 0x00002E, "Member 'FPlayerInputValues::bKeyboardHeavyAttack' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardHeavyAttackModifier) == 0x00002F, "Member 'FPlayerInputValues::bKeyboardHeavyAttackModifier' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardStartDash) == 0x000030, "Member 'FPlayerInputValues::bKeyboardStartDash' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardTeamAttack) == 0x000031, "Member 'FPlayerInputValues::bKeyboardTeamAttack' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardEnergyBurst) == 0x000032, "Member 'FPlayerInputValues::bKeyboardEnergyBurst' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, MoveRight) == 0x000033, "Member 'FPlayerInputValues::MoveRight' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, MoveLeft) == 0x000034, "Member 'FPlayerInputValues::MoveLeft' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, MoveUp) == 0x000035, "Member 'FPlayerInputValues::MoveUp' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, MoveDown) == 0x000036, "Member 'FPlayerInputValues::MoveDown' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bKeyboardMoveDownTap) == 0x000037, "Member 'FPlayerInputValues::bKeyboardMoveDownTap' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bUseIncrementalHeldItemMode) == 0x000038, "Member 'FPlayerInputValues::bUseIncrementalHeldItemMode' has a wrong offset!");
static_assert(offsetof(FPlayerInputValues, bAttackStickCastsTiltAttacks) == 0x000039, "Member 'FPlayerInputValues::bAttackStickCastsTiltAttacks' has a wrong offset!");

// ScriptStruct Matcha.ShieldInfo
// 0x00D8 (0x00D8 - 0x0000)
struct FShieldInfo final
{
public:
	struct FSnapNetPropertyEnum                   State;                                             // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  Health;                                            // 0x0048(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  LastInputTime;                                     // 0x0088(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bIsShieldInvincible;                               // 0x00C0(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FShieldInfo) == 0x000008, "Wrong alignment on FShieldInfo");
static_assert(sizeof(FShieldInfo) == 0x0000D8, "Wrong size on FShieldInfo");
static_assert(offsetof(FShieldInfo, State) == 0x000000, "Member 'FShieldInfo::State' has a wrong offset!");
static_assert(offsetof(FShieldInfo, Health) == 0x000048, "Member 'FShieldInfo::Health' has a wrong offset!");
static_assert(offsetof(FShieldInfo, LastInputTime) == 0x000088, "Member 'FShieldInfo::LastInputTime' has a wrong offset!");
static_assert(offsetof(FShieldInfo, bIsShieldInvincible) == 0x0000C0, "Member 'FShieldInfo::bIsShieldInvincible' has a wrong offset!");

// ScriptStruct Matcha.MatchaGameplayAnalyticsV1MontageStat
// 0x0008 (0x0008 - 0x0000)
struct FMatchaGameplayAnalyticsV1MontageStat final
{
public:
	EMatchaCharacterMontageType                   Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaGameplayAnalyticsV1MontageStat) == 0x000004, "Wrong alignment on FMatchaGameplayAnalyticsV1MontageStat");
static_assert(sizeof(FMatchaGameplayAnalyticsV1MontageStat) == 0x000008, "Wrong size on FMatchaGameplayAnalyticsV1MontageStat");
static_assert(offsetof(FMatchaGameplayAnalyticsV1MontageStat, Type) == 0x000000, "Member 'FMatchaGameplayAnalyticsV1MontageStat::Type' has a wrong offset!");
static_assert(offsetof(FMatchaGameplayAnalyticsV1MontageStat, Count) == 0x000004, "Member 'FMatchaGameplayAnalyticsV1MontageStat::Count' has a wrong offset!");

// ScriptStruct Matcha.MatchaGameplayAnalyticsV1PlayerStats
// 0x0028 (0x0028 - 0x0000)
struct FMatchaGameplayAnalyticsV1PlayerStats final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMatchaGameplayAnalyticsV1MontageStat> MontageStats;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaGameplayAnalyticsV1PlayerStats) == 0x000008, "Wrong alignment on FMatchaGameplayAnalyticsV1PlayerStats");
static_assert(sizeof(FMatchaGameplayAnalyticsV1PlayerStats) == 0x000028, "Wrong size on FMatchaGameplayAnalyticsV1PlayerStats");
static_assert(offsetof(FMatchaGameplayAnalyticsV1PlayerStats, PlayerIndex) == 0x000000, "Member 'FMatchaGameplayAnalyticsV1PlayerStats::PlayerIndex' has a wrong offset!");
static_assert(offsetof(FMatchaGameplayAnalyticsV1PlayerStats, PlayerName) == 0x000008, "Member 'FMatchaGameplayAnalyticsV1PlayerStats::PlayerName' has a wrong offset!");
static_assert(offsetof(FMatchaGameplayAnalyticsV1PlayerStats, MontageStats) == 0x000018, "Member 'FMatchaGameplayAnalyticsV1PlayerStats::MontageStats' has a wrong offset!");

// ScriptStruct Matcha.MatchaGameplayAnalyticsV1
// 0x0010 (0x0010 - 0x0000)
struct FMatchaGameplayAnalyticsV1 final
{
public:
	TArray<struct FMatchaGameplayAnalyticsV1PlayerStats> PlayerStats;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaGameplayAnalyticsV1) == 0x000008, "Wrong alignment on FMatchaGameplayAnalyticsV1");
static_assert(sizeof(FMatchaGameplayAnalyticsV1) == 0x000010, "Wrong size on FMatchaGameplayAnalyticsV1");
static_assert(offsetof(FMatchaGameplayAnalyticsV1, PlayerStats) == 0x000000, "Member 'FMatchaGameplayAnalyticsV1::PlayerStats' has a wrong offset!");

// ScriptStruct Matcha.MatchaFlickConfiguration
// 0x000C (0x000C - 0x0000)
struct FMatchaFlickConfiguration final
{
public:
	float                                         StickTravelDistance;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWindow;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNewFlickMethod;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaFlickConfiguration) == 0x000004, "Wrong alignment on FMatchaFlickConfiguration");
static_assert(sizeof(FMatchaFlickConfiguration) == 0x00000C, "Wrong size on FMatchaFlickConfiguration");
static_assert(offsetof(FMatchaFlickConfiguration, StickTravelDistance) == 0x000000, "Member 'FMatchaFlickConfiguration::StickTravelDistance' has a wrong offset!");
static_assert(offsetof(FMatchaFlickConfiguration, TimeWindow) == 0x000004, "Member 'FMatchaFlickConfiguration::TimeWindow' has a wrong offset!");
static_assert(offsetof(FMatchaFlickConfiguration, UseNewFlickMethod) == 0x000008, "Member 'FMatchaFlickConfiguration::UseNewFlickMethod' has a wrong offset!");

// ScriptStruct Matcha.PlayerPartyMatchState_GameDetails
// 0x0040 (0x0040 - 0x0000)
struct FPlayerPartyMatchState_GameDetails final
{
public:
	class FString                                 IpAddress;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Port;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerGameSessionId;                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthKey;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerPartyMatchState_GameDetails) == 0x000008, "Wrong alignment on FPlayerPartyMatchState_GameDetails");
static_assert(sizeof(FPlayerPartyMatchState_GameDetails) == 0x000040, "Wrong size on FPlayerPartyMatchState_GameDetails");
static_assert(offsetof(FPlayerPartyMatchState_GameDetails, IpAddress) == 0x000000, "Member 'FPlayerPartyMatchState_GameDetails::IpAddress' has a wrong offset!");
static_assert(offsetof(FPlayerPartyMatchState_GameDetails, Port) == 0x000010, "Member 'FPlayerPartyMatchState_GameDetails::Port' has a wrong offset!");
static_assert(offsetof(FPlayerPartyMatchState_GameDetails, PlayerGameSessionId) == 0x000020, "Member 'FPlayerPartyMatchState_GameDetails::PlayerGameSessionId' has a wrong offset!");
static_assert(offsetof(FPlayerPartyMatchState_GameDetails, AuthKey) == 0x000030, "Member 'FPlayerPartyMatchState_GameDetails::AuthKey' has a wrong offset!");

// ScriptStruct Matcha.PlayerPartyMatchState
// 0x0058 (0x0058 - 0x0000)
struct FPlayerPartyMatchState final
{
public:
	class FName                                   Status;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Timestamp;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerPartyMatchState_GameDetails     GameDetails;                                       // 0x0010(0x0040)(NativeAccessSpecifierPublic)
	class FName                                   QueueId;                                           // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerPartyMatchState) == 0x000008, "Wrong alignment on FPlayerPartyMatchState");
static_assert(sizeof(FPlayerPartyMatchState) == 0x000058, "Wrong size on FPlayerPartyMatchState");
static_assert(offsetof(FPlayerPartyMatchState, Status) == 0x000000, "Member 'FPlayerPartyMatchState::Status' has a wrong offset!");
static_assert(offsetof(FPlayerPartyMatchState, Timestamp) == 0x000008, "Member 'FPlayerPartyMatchState::Timestamp' has a wrong offset!");
static_assert(offsetof(FPlayerPartyMatchState, GameDetails) == 0x000010, "Member 'FPlayerPartyMatchState::GameDetails' has a wrong offset!");
static_assert(offsetof(FPlayerPartyMatchState, QueueId) == 0x000050, "Member 'FPlayerPartyMatchState::QueueId' has a wrong offset!");

// ScriptStruct Matcha.MatchaCharacterUIData_InitParams
// 0x0028 (0x0028 - 0x0000)
struct FMatchaCharacterUIData_InitParams final
{
public:
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0000(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaCharacterUIData_InitParams) == 0x000008, "Wrong alignment on FMatchaCharacterUIData_InitParams");
static_assert(sizeof(FMatchaCharacterUIData_InitParams) == 0x000028, "Wrong size on FMatchaCharacterUIData_InitParams");
static_assert(offsetof(FMatchaCharacterUIData_InitParams, CharacterClass) == 0x000000, "Member 'FMatchaCharacterUIData_InitParams::CharacterClass' has a wrong offset!");

// ScriptStruct Matcha.MatchaGameplayEvent
// 0x0014 (0x0014 - 0x0000)
struct FMatchaGameplayEvent final
{
public:
	struct FGameplayTag                           Channel;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 Context;                                           // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnRegion                                  EventRegion;                                       // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaGameplayEventType                      EventType;                                         // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaGameplayEvent) == 0x000004, "Wrong alignment on FMatchaGameplayEvent");
static_assert(sizeof(FMatchaGameplayEvent) == 0x000014, "Wrong size on FMatchaGameplayEvent");
static_assert(offsetof(FMatchaGameplayEvent, Channel) == 0x000000, "Member 'FMatchaGameplayEvent::Channel' has a wrong offset!");
static_assert(offsetof(FMatchaGameplayEvent, Context) == 0x000008, "Member 'FMatchaGameplayEvent::Context' has a wrong offset!");
static_assert(offsetof(FMatchaGameplayEvent, EventRegion) == 0x000010, "Member 'FMatchaGameplayEvent::EventRegion' has a wrong offset!");
static_assert(offsetof(FMatchaGameplayEvent, EventType) == 0x000011, "Member 'FMatchaGameplayEvent::EventType' has a wrong offset!");

// ScriptStruct Matcha.ActorFilterInfo
// 0x0006 (0x0006 - 0x0000)
struct FActorFilterInfo final
{
public:
	EAliveState                                   AliveStateFilter;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamFilter                                   TeamFilter;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseShieldStateFilter;                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaShieldState                            ShieldStateFilter;                                 // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilterNotIntangible;                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorFilterInfo) == 0x000001, "Wrong alignment on FActorFilterInfo");
static_assert(sizeof(FActorFilterInfo) == 0x000006, "Wrong size on FActorFilterInfo");
static_assert(offsetof(FActorFilterInfo, AliveStateFilter) == 0x000000, "Member 'FActorFilterInfo::AliveStateFilter' has a wrong offset!");
static_assert(offsetof(FActorFilterInfo, TeamFilter) == 0x000001, "Member 'FActorFilterInfo::TeamFilter' has a wrong offset!");
static_assert(offsetof(FActorFilterInfo, bShouldUseShieldStateFilter) == 0x000002, "Member 'FActorFilterInfo::bShouldUseShieldStateFilter' has a wrong offset!");
static_assert(offsetof(FActorFilterInfo, ShieldStateFilter) == 0x000003, "Member 'FActorFilterInfo::ShieldStateFilter' has a wrong offset!");
static_assert(offsetof(FActorFilterInfo, bFilterNotIntangible) == 0x000004, "Member 'FActorFilterInfo::bFilterNotIntangible' has a wrong offset!");
static_assert(offsetof(FActorFilterInfo, bIncludeSelf) == 0x000005, "Member 'FActorFilterInfo::bIncludeSelf' has a wrong offset!");

// ScriptStruct Matcha.SendInviteResponse
// 0x0008 (0x0008 - 0x0000)
struct FSendInviteResponse final
{
public:
	class FName                                   ReceivingPlayerId;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSendInviteResponse) == 0x000004, "Wrong alignment on FSendInviteResponse");
static_assert(sizeof(FSendInviteResponse) == 0x000008, "Wrong size on FSendInviteResponse");
static_assert(offsetof(FSendInviteResponse, ReceivingPlayerId) == 0x000000, "Member 'FSendInviteResponse::ReceivingPlayerId' has a wrong offset!");

// ScriptStruct Matcha.PlayerParty
// 0x0088 (0x0088 - 0x0000)
struct FPlayerParty final
{
public:
	class FName                                   PartyId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeaderPlayerId;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPartyMember>                   PartyMembers;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPlayerPartyMatchState                 MatchState;                                        // 0x0020(0x0058)(NativeAccessSpecifierPublic)
	class FString                                 Timestamp;                                         // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerParty) == 0x000008, "Wrong alignment on FPlayerParty");
static_assert(sizeof(FPlayerParty) == 0x000088, "Wrong size on FPlayerParty");
static_assert(offsetof(FPlayerParty, PartyId) == 0x000000, "Member 'FPlayerParty::PartyId' has a wrong offset!");
static_assert(offsetof(FPlayerParty, LeaderPlayerId) == 0x000008, "Member 'FPlayerParty::LeaderPlayerId' has a wrong offset!");
static_assert(offsetof(FPlayerParty, PartyMembers) == 0x000010, "Member 'FPlayerParty::PartyMembers' has a wrong offset!");
static_assert(offsetof(FPlayerParty, MatchState) == 0x000020, "Member 'FPlayerParty::MatchState' has a wrong offset!");
static_assert(offsetof(FPlayerParty, Timestamp) == 0x000078, "Member 'FPlayerParty::Timestamp' has a wrong offset!");

// ScriptStruct Matcha.GetCurrentPartyResponseV1
// 0x0088 (0x0088 - 0x0000)
struct FGetCurrentPartyResponseV1 final
{
public:
	struct FPlayerParty                           CurrentParty;                                      // 0x0000(0x0088)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetCurrentPartyResponseV1) == 0x000008, "Wrong alignment on FGetCurrentPartyResponseV1");
static_assert(sizeof(FGetCurrentPartyResponseV1) == 0x000088, "Wrong size on FGetCurrentPartyResponseV1");
static_assert(offsetof(FGetCurrentPartyResponseV1, CurrentParty) == 0x000000, "Member 'FGetCurrentPartyResponseV1::CurrentParty' has a wrong offset!");

// ScriptStruct Matcha.WallClingStateInfo
// 0x00E8 (0x00E8 - 0x0000)
struct FWallClingStateInfo final
{
public:
	struct FSnapNetPropertyBoolean                bEnabled;                                          // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bAlreadyUsedBeforeLanding;                         // 0x0018(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector                 WallNormal;                                        // 0x0030(0x0080)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTime;                                         // 0x00B0(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWallClingStateInfo) == 0x000008, "Wrong alignment on FWallClingStateInfo");
static_assert(sizeof(FWallClingStateInfo) == 0x0000E8, "Wrong size on FWallClingStateInfo");
static_assert(offsetof(FWallClingStateInfo, bEnabled) == 0x000000, "Member 'FWallClingStateInfo::bEnabled' has a wrong offset!");
static_assert(offsetof(FWallClingStateInfo, bAlreadyUsedBeforeLanding) == 0x000018, "Member 'FWallClingStateInfo::bAlreadyUsedBeforeLanding' has a wrong offset!");
static_assert(offsetof(FWallClingStateInfo, WallNormal) == 0x000030, "Member 'FWallClingStateInfo::WallNormal' has a wrong offset!");
static_assert(offsetof(FWallClingStateInfo, StartTime) == 0x0000B0, "Member 'FWallClingStateInfo::StartTime' has a wrong offset!");

// ScriptStruct Matcha.MatchaHitData
// 0x0078 (0x0078 - 0x0000)
struct FMatchaHitData final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldDamage;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitStunDurationOverride;                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseKnockBack;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBackGrowth;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSetKnockBack;                                  // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockBackAngle;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFreezeScale;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyGenerationMultiplier;                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunTime;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitTargetType                                AffectedTargetType;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitCollisionType                             CollisionType;                                     // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitId;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MultiHitFrames;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanHitInstigator;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanClank;                                         // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProjectileClankPriority;                           // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HitTags;                                           // 0x0040(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   HitIdVFXOverride;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitIdAudioOverride;                                // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaHitData) == 0x000008, "Wrong alignment on FMatchaHitData");
static_assert(sizeof(FMatchaHitData) == 0x000078, "Wrong size on FMatchaHitData");
static_assert(offsetof(FMatchaHitData, Damage) == 0x000000, "Member 'FMatchaHitData::Damage' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, ShieldDamage) == 0x000004, "Member 'FMatchaHitData::ShieldDamage' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, HitStunDurationOverride) == 0x000008, "Member 'FMatchaHitData::HitStunDurationOverride' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, BaseKnockBack) == 0x00000C, "Member 'FMatchaHitData::BaseKnockBack' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, KnockBackGrowth) == 0x000010, "Member 'FMatchaHitData::KnockBackGrowth' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, bUseSetKnockBack) == 0x000014, "Member 'FMatchaHitData::bUseSetKnockBack' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, KnockBackAngle) == 0x000018, "Member 'FMatchaHitData::KnockBackAngle' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, HitFreezeScale) == 0x00001C, "Member 'FMatchaHitData::HitFreezeScale' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, EnergyGenerationMultiplier) == 0x000020, "Member 'FMatchaHitData::EnergyGenerationMultiplier' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, StunTime) == 0x000024, "Member 'FMatchaHitData::StunTime' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, AffectedTargetType) == 0x000028, "Member 'FMatchaHitData::AffectedTargetType' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, CollisionType) == 0x000029, "Member 'FMatchaHitData::CollisionType' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, Priority) == 0x00002C, "Member 'FMatchaHitData::Priority' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, HitId) == 0x000030, "Member 'FMatchaHitData::HitId' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, MultiHitFrames) == 0x000034, "Member 'FMatchaHitData::MultiHitFrames' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, bCanHitInstigator) == 0x000038, "Member 'FMatchaHitData::bCanHitInstigator' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, bCanClank) == 0x000039, "Member 'FMatchaHitData::bCanClank' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, ProjectileClankPriority) == 0x00003C, "Member 'FMatchaHitData::ProjectileClankPriority' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, HitTags) == 0x000040, "Member 'FMatchaHitData::HitTags' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, HitIdVFXOverride) == 0x000060, "Member 'FMatchaHitData::HitIdVFXOverride' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, HitIdAudioOverride) == 0x000068, "Member 'FMatchaHitData::HitIdAudioOverride' has a wrong offset!");
static_assert(offsetof(FMatchaHitData, Direction) == 0x000070, "Member 'FMatchaHitData::Direction' has a wrong offset!");

// ScriptStruct Matcha.MatchaPlayerProfileV1
// 0x0018 (0x0018 - 0x0000)
struct FMatchaPlayerProfileV1 final
{
public:
	class FName                                   PlayerId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaPlayerProfileV1) == 0x000008, "Wrong alignment on FMatchaPlayerProfileV1");
static_assert(sizeof(FMatchaPlayerProfileV1) == 0x000018, "Wrong size on FMatchaPlayerProfileV1");
static_assert(offsetof(FMatchaPlayerProfileV1, PlayerId) == 0x000000, "Member 'FMatchaPlayerProfileV1::PlayerId' has a wrong offset!");
static_assert(offsetof(FMatchaPlayerProfileV1, DisplayName) == 0x000008, "Member 'FMatchaPlayerProfileV1::DisplayName' has a wrong offset!");

// ScriptStruct Matcha.MatchaSnapnetAttributeData
// 0x0080 (0x0088 - 0x0008)
struct FMatchaSnapnetAttributeData final : public FMatchaGameplayAttributeData
{
public:
	struct FSnapNetPropertyFloat                  CurrentValue;                                      // 0x0008(0x0040)(Protected, NativeAccessSpecifierProtected)
	struct FSnapNetPropertyFloat                  BaseValue;                                         // 0x0048(0x0040)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMatchaSnapnetAttributeData) == 0x000008, "Wrong alignment on FMatchaSnapnetAttributeData");
static_assert(sizeof(FMatchaSnapnetAttributeData) == 0x000088, "Wrong size on FMatchaSnapnetAttributeData");
static_assert(offsetof(FMatchaSnapnetAttributeData, CurrentValue) == 0x000008, "Member 'FMatchaSnapnetAttributeData::CurrentValue' has a wrong offset!");
static_assert(offsetof(FMatchaSnapnetAttributeData, BaseValue) == 0x000048, "Member 'FMatchaSnapnetAttributeData::BaseValue' has a wrong offset!");

// ScriptStruct Matcha.ReceivedHitInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FReceivedHitInfo final
{
public:
	struct FSnapNetPropertyInt32                  HitFlags;                                          // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            HitEntityIndex;                                    // 0x0038(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  HitFreezeSeconds;                                  // 0x00A0(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FReceivedHitInfo) == 0x000008, "Wrong alignment on FReceivedHitInfo");
static_assert(sizeof(FReceivedHitInfo) == 0x0000E0, "Wrong size on FReceivedHitInfo");
static_assert(offsetof(FReceivedHitInfo, HitFlags) == 0x000000, "Member 'FReceivedHitInfo::HitFlags' has a wrong offset!");
static_assert(offsetof(FReceivedHitInfo, HitEntityIndex) == 0x000038, "Member 'FReceivedHitInfo::HitEntityIndex' has a wrong offset!");
static_assert(offsetof(FReceivedHitInfo, HitFreezeSeconds) == 0x0000A0, "Member 'FReceivedHitInfo::HitFreezeSeconds' has a wrong offset!");

// ScriptStruct Matcha.NetworkStatistics
// 0x0018 (0x0018 - 0x0000)
struct FNetworkStatistics final
{
public:
	float                                         IncomingPacketLossPercentage;                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncomingPacketLossAveragePercentage;               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutgoingPacketLossPercentage;                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutgoingPacketLossAveragePercentage;               // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageJitterInMS;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageLag;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetworkStatistics) == 0x000004, "Wrong alignment on FNetworkStatistics");
static_assert(sizeof(FNetworkStatistics) == 0x000018, "Wrong size on FNetworkStatistics");
static_assert(offsetof(FNetworkStatistics, IncomingPacketLossPercentage) == 0x000000, "Member 'FNetworkStatistics::IncomingPacketLossPercentage' has a wrong offset!");
static_assert(offsetof(FNetworkStatistics, IncomingPacketLossAveragePercentage) == 0x000004, "Member 'FNetworkStatistics::IncomingPacketLossAveragePercentage' has a wrong offset!");
static_assert(offsetof(FNetworkStatistics, OutgoingPacketLossPercentage) == 0x000008, "Member 'FNetworkStatistics::OutgoingPacketLossPercentage' has a wrong offset!");
static_assert(offsetof(FNetworkStatistics, OutgoingPacketLossAveragePercentage) == 0x00000C, "Member 'FNetworkStatistics::OutgoingPacketLossAveragePercentage' has a wrong offset!");
static_assert(offsetof(FNetworkStatistics, AverageJitterInMS) == 0x000010, "Member 'FNetworkStatistics::AverageJitterInMS' has a wrong offset!");
static_assert(offsetof(FNetworkStatistics, AverageLag) == 0x000014, "Member 'FNetworkStatistics::AverageLag' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventoryItemUIData_UpdateParams_InteractionRenderer
// 0x0008 (0x0008 - 0x0000)
struct FMatchaInventoryItemUIData_UpdateParams_InteractionRenderer final
{
public:
	TWeakObjectPtr<class AActor>                  InteractionRenderer;                               // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInventoryItemUIData_UpdateParams_InteractionRenderer) == 0x000004, "Wrong alignment on FMatchaInventoryItemUIData_UpdateParams_InteractionRenderer");
static_assert(sizeof(FMatchaInventoryItemUIData_UpdateParams_InteractionRenderer) == 0x000008, "Wrong size on FMatchaInventoryItemUIData_UpdateParams_InteractionRenderer");
static_assert(offsetof(FMatchaInventoryItemUIData_UpdateParams_InteractionRenderer, InteractionRenderer) == 0x000000, "Member 'FMatchaInventoryItemUIData_UpdateParams_InteractionRenderer::InteractionRenderer' has a wrong offset!");

// ScriptStruct Matcha.LoginResponseErrorV1
// 0x0018 (0x0070 - 0x0058)
struct FLoginResponseErrorV1 final : public FErrorResponseContainerV1
{
public:
	class FString                                 BanExpiration;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BanReason;                                         // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginResponseErrorV1) == 0x000008, "Wrong alignment on FLoginResponseErrorV1");
static_assert(sizeof(FLoginResponseErrorV1) == 0x000070, "Wrong size on FLoginResponseErrorV1");
static_assert(offsetof(FLoginResponseErrorV1, BanExpiration) == 0x000058, "Member 'FLoginResponseErrorV1::BanExpiration' has a wrong offset!");
static_assert(offsetof(FLoginResponseErrorV1, BanReason) == 0x000068, "Member 'FLoginResponseErrorV1::BanReason' has a wrong offset!");

// ScriptStruct Matcha.AIRootMotionForceData
// 0x0050 (0x0050 - 0x0000)
struct FAIRootMotionForceData final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleDirection;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CustomSpeedOverTimeCurve;                          // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionFinishVelocityMode                 FinishVelocityMode;                                // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SetVelocity;                                       // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClampVelocity;                                     // 0x0038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIRootMotionForceData) == 0x000008, "Wrong alignment on FAIRootMotionForceData");
static_assert(sizeof(FAIRootMotionForceData) == 0x000050, "Wrong size on FAIRootMotionForceData");
static_assert(offsetof(FAIRootMotionForceData, Duration) == 0x000000, "Member 'FAIRootMotionForceData::Duration' has a wrong offset!");
static_assert(offsetof(FAIRootMotionForceData, Speed) == 0x000004, "Member 'FAIRootMotionForceData::Speed' has a wrong offset!");
static_assert(offsetof(FAIRootMotionForceData, AngleDirection) == 0x000008, "Member 'FAIRootMotionForceData::AngleDirection' has a wrong offset!");
static_assert(offsetof(FAIRootMotionForceData, CustomSpeedOverTimeCurve) == 0x000010, "Member 'FAIRootMotionForceData::CustomSpeedOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FAIRootMotionForceData, FinishVelocityMode) == 0x000018, "Member 'FAIRootMotionForceData::FinishVelocityMode' has a wrong offset!");
static_assert(offsetof(FAIRootMotionForceData, SetVelocity) == 0x000020, "Member 'FAIRootMotionForceData::SetVelocity' has a wrong offset!");
static_assert(offsetof(FAIRootMotionForceData, ClampVelocity) == 0x000038, "Member 'FAIRootMotionForceData::ClampVelocity' has a wrong offset!");

// ScriptStruct Matcha.AIAbilityData
// 0x0010 (0x0010 - 0x0000)
struct FAIAbilityData final
{
public:
	float                                         MinRange;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIAbilityDirectionConstraint                 AbilityDirectionConstraint;                        // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAbilityData) == 0x000004, "Wrong alignment on FAIAbilityData");
static_assert(sizeof(FAIAbilityData) == 0x000010, "Wrong size on FAIAbilityData");
static_assert(offsetof(FAIAbilityData, MinRange) == 0x000000, "Member 'FAIAbilityData::MinRange' has a wrong offset!");
static_assert(offsetof(FAIAbilityData, MaxRange) == 0x000004, "Member 'FAIAbilityData::MaxRange' has a wrong offset!");
static_assert(offsetof(FAIAbilityData, Weight) == 0x000008, "Member 'FAIAbilityData::Weight' has a wrong offset!");
static_assert(offsetof(FAIAbilityData, AbilityDirectionConstraint) == 0x00000C, "Member 'FAIAbilityData::AbilityDirectionConstraint' has a wrong offset!");

// ScriptStruct Matcha.AIAnimationInfo
// 0x0080 (0x0080 - 0x0000)
struct FAIAnimationInfo final
{
public:
	EAIMontageType                                MontageType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRootMotionForceData;                           // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIRootMotionForceData                 RootMotionForceData;                               // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanUseInBehaviorTree;                             // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAbilityData                         AIAbilityData;                                     // 0x006C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAnimationInfo) == 0x000008, "Wrong alignment on FAIAnimationInfo");
static_assert(sizeof(FAIAnimationInfo) == 0x000080, "Wrong size on FAIAnimationInfo");
static_assert(offsetof(FAIAnimationInfo, MontageType) == 0x000000, "Member 'FAIAnimationInfo::MontageType' has a wrong offset!");
static_assert(offsetof(FAIAnimationInfo, Montage) == 0x000008, "Member 'FAIAnimationInfo::Montage' has a wrong offset!");
static_assert(offsetof(FAIAnimationInfo, bHasRootMotionForceData) == 0x000010, "Member 'FAIAnimationInfo::bHasRootMotionForceData' has a wrong offset!");
static_assert(offsetof(FAIAnimationInfo, RootMotionForceData) == 0x000018, "Member 'FAIAnimationInfo::RootMotionForceData' has a wrong offset!");
static_assert(offsetof(FAIAnimationInfo, bCanUseInBehaviorTree) == 0x000068, "Member 'FAIAnimationInfo::bCanUseInBehaviorTree' has a wrong offset!");
static_assert(offsetof(FAIAnimationInfo, AIAbilityData) == 0x00006C, "Member 'FAIAnimationInfo::AIAbilityData' has a wrong offset!");

// ScriptStruct Matcha.LoginResponseV1
// 0x0058 (0x0058 - 0x0000)
struct FLoginResponseV1 final
{
public:
	class FString                                 Jwt;                                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RefreshToken;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerId;                                          // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Timestamp;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayNameStatus;                                 // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAdmin;                                           // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoginResponseV1) == 0x000008, "Wrong alignment on FLoginResponseV1");
static_assert(sizeof(FLoginResponseV1) == 0x000058, "Wrong size on FLoginResponseV1");
static_assert(offsetof(FLoginResponseV1, Jwt) == 0x000000, "Member 'FLoginResponseV1::Jwt' has a wrong offset!");
static_assert(offsetof(FLoginResponseV1, RefreshToken) == 0x000010, "Member 'FLoginResponseV1::RefreshToken' has a wrong offset!");
static_assert(offsetof(FLoginResponseV1, PlayerId) == 0x000020, "Member 'FLoginResponseV1::PlayerId' has a wrong offset!");
static_assert(offsetof(FLoginResponseV1, Timestamp) == 0x000028, "Member 'FLoginResponseV1::Timestamp' has a wrong offset!");
static_assert(offsetof(FLoginResponseV1, DisplayName) == 0x000038, "Member 'FLoginResponseV1::DisplayName' has a wrong offset!");
static_assert(offsetof(FLoginResponseV1, DisplayNameStatus) == 0x000048, "Member 'FLoginResponseV1::DisplayNameStatus' has a wrong offset!");
static_assert(offsetof(FLoginResponseV1, IsAdmin) == 0x000050, "Member 'FLoginResponseV1::IsAdmin' has a wrong offset!");

// ScriptStruct Matcha.SetNameResponse
// 0x0030 (0x0030 - 0x0000)
struct FSetNameResponse final
{
public:
	class FString                                 Timestamp;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerId;                                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayNameStatus;                                 // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetNameResponse) == 0x000008, "Wrong alignment on FSetNameResponse");
static_assert(sizeof(FSetNameResponse) == 0x000030, "Wrong size on FSetNameResponse");
static_assert(offsetof(FSetNameResponse, Timestamp) == 0x000000, "Member 'FSetNameResponse::Timestamp' has a wrong offset!");
static_assert(offsetof(FSetNameResponse, PlayerId) == 0x000010, "Member 'FSetNameResponse::PlayerId' has a wrong offset!");
static_assert(offsetof(FSetNameResponse, DisplayName) == 0x000018, "Member 'FSetNameResponse::DisplayName' has a wrong offset!");
static_assert(offsetof(FSetNameResponse, DisplayNameStatus) == 0x000028, "Member 'FSetNameResponse::DisplayNameStatus' has a wrong offset!");

// ScriptStruct Matcha.LeavePartyRequest
// 0x0001 (0x0001 - 0x0000)
struct FLeavePartyRequest final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeavePartyRequest) == 0x000001, "Wrong alignment on FLeavePartyRequest");
static_assert(sizeof(FLeavePartyRequest) == 0x000001, "Wrong size on FLeavePartyRequest");

// ScriptStruct Matcha.MatchaInventoryItem
// 0x0058 (0x0058 - 0x0000)
struct FMatchaInventoryItem final
{
public:
	struct FSnapNetPropertyPrimaryAsset           ItemAssetId;                                       // 0x0000(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInventoryItem) == 0x000008, "Wrong alignment on FMatchaInventoryItem");
static_assert(sizeof(FMatchaInventoryItem) == 0x000058, "Wrong size on FMatchaInventoryItem");
static_assert(offsetof(FMatchaInventoryItem, ItemAssetId) == 0x000000, "Member 'FMatchaInventoryItem::ItemAssetId' has a wrong offset!");

// ScriptStruct Matcha.MatchaSnapNetGameplayTagProperty
// 0x0020 (0x0038 - 0x0018)
struct FMatchaSnapNetGameplayTagProperty final : public FSnapNetPropertyStringBase
{
public:
	class FName                                   StringPoolName;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Value;                                             // 0x0020(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaSnapNetGameplayTagProperty) == 0x000008, "Wrong alignment on FMatchaSnapNetGameplayTagProperty");
static_assert(sizeof(FMatchaSnapNetGameplayTagProperty) == 0x000038, "Wrong size on FMatchaSnapNetGameplayTagProperty");
static_assert(offsetof(FMatchaSnapNetGameplayTagProperty, StringPoolName) == 0x000018, "Member 'FMatchaSnapNetGameplayTagProperty::StringPoolName' has a wrong offset!");
static_assert(offsetof(FMatchaSnapNetGameplayTagProperty, Value) == 0x000020, "Member 'FMatchaSnapNetGameplayTagProperty::Value' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventorySlot
// 0x0100 (0x0100 - 0x0000)
struct FMatchaInventorySlot final
{
public:
	struct FMatchaInventoryItem                   Item;                                              // 0x0000(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  ItemCount;                                         // 0x0058(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bEnergized;                                        // 0x0090(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bIsHeld;                                           // 0x00A8(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapNetGameplayTagProperty      SlotType;                                          // 0x00C0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaInventorySlot) == 0x000008, "Wrong alignment on FMatchaInventorySlot");
static_assert(sizeof(FMatchaInventorySlot) == 0x000100, "Wrong size on FMatchaInventorySlot");
static_assert(offsetof(FMatchaInventorySlot, Item) == 0x000000, "Member 'FMatchaInventorySlot::Item' has a wrong offset!");
static_assert(offsetof(FMatchaInventorySlot, ItemCount) == 0x000058, "Member 'FMatchaInventorySlot::ItemCount' has a wrong offset!");
static_assert(offsetof(FMatchaInventorySlot, bEnergized) == 0x000090, "Member 'FMatchaInventorySlot::bEnergized' has a wrong offset!");
static_assert(offsetof(FMatchaInventorySlot, bIsHeld) == 0x0000A8, "Member 'FMatchaInventorySlot::bIsHeld' has a wrong offset!");
static_assert(offsetof(FMatchaInventorySlot, SlotType) == 0x0000C0, "Member 'FMatchaInventorySlot::SlotType' has a wrong offset!");

// ScriptStruct Matcha.AIAppliedRootMotionInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FAIAppliedRootMotionInfo final
{
public:
	struct FSnapNetPropertyInt32                  Index;                                             // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector2D               UnitDirection;                                     // 0x0038(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  RemainingTime;                                     // 0x00A0(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAppliedRootMotionInfo) == 0x000008, "Wrong alignment on FAIAppliedRootMotionInfo");
static_assert(sizeof(FAIAppliedRootMotionInfo) == 0x0000E0, "Wrong size on FAIAppliedRootMotionInfo");
static_assert(offsetof(FAIAppliedRootMotionInfo, Index) == 0x000000, "Member 'FAIAppliedRootMotionInfo::Index' has a wrong offset!");
static_assert(offsetof(FAIAppliedRootMotionInfo, UnitDirection) == 0x000038, "Member 'FAIAppliedRootMotionInfo::UnitDirection' has a wrong offset!");
static_assert(offsetof(FAIAppliedRootMotionInfo, RemainingTime) == 0x0000A0, "Member 'FAIAppliedRootMotionInfo::RemainingTime' has a wrong offset!");

// ScriptStruct Matcha.InstigatedGlitchMarkInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FInstigatedGlitchMarkInfo final
{
public:
	struct FSnapNetPropertyEntityIndex            MarkedEntityIndex;                                 // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  GlitchMarkExpirationTime;                          // 0x0068(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bIsMarkFromItem;                                   // 0x00A0(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstigatedGlitchMarkInfo) == 0x000008, "Wrong alignment on FInstigatedGlitchMarkInfo");
static_assert(sizeof(FInstigatedGlitchMarkInfo) == 0x0000B8, "Wrong size on FInstigatedGlitchMarkInfo");
static_assert(offsetof(FInstigatedGlitchMarkInfo, MarkedEntityIndex) == 0x000000, "Member 'FInstigatedGlitchMarkInfo::MarkedEntityIndex' has a wrong offset!");
static_assert(offsetof(FInstigatedGlitchMarkInfo, GlitchMarkExpirationTime) == 0x000068, "Member 'FInstigatedGlitchMarkInfo::GlitchMarkExpirationTime' has a wrong offset!");
static_assert(offsetof(FInstigatedGlitchMarkInfo, bIsMarkFromItem) == 0x0000A0, "Member 'FInstigatedGlitchMarkInfo::bIsMarkFromItem' has a wrong offset!");

// ScriptStruct Matcha.SkeletalMeshInfo
// 0x0028 (0x0028 - 0x0000)
struct FSkeletalMeshInfo final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshInfo) == 0x000008, "Wrong alignment on FSkeletalMeshInfo");
static_assert(sizeof(FSkeletalMeshInfo) == 0x000028, "Wrong size on FSkeletalMeshInfo");
static_assert(offsetof(FSkeletalMeshInfo, Mesh) == 0x000000, "Member 'FSkeletalMeshInfo::Mesh' has a wrong offset!");

// ScriptStruct Matcha.EnhancedAirDodgeInfo
// 0x0030 (0x0030 - 0x0000)
struct FEnhancedAirDodgeInfo final
{
public:
	struct FSnapNetPropertyBoolean                bEnabled;                                          // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bCastEnhancedAirDodgeThisAirTime;                  // 0x0018(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnhancedAirDodgeInfo) == 0x000008, "Wrong alignment on FEnhancedAirDodgeInfo");
static_assert(sizeof(FEnhancedAirDodgeInfo) == 0x000030, "Wrong size on FEnhancedAirDodgeInfo");
static_assert(offsetof(FEnhancedAirDodgeInfo, bEnabled) == 0x000000, "Member 'FEnhancedAirDodgeInfo::bEnabled' has a wrong offset!");
static_assert(offsetof(FEnhancedAirDodgeInfo, bCastEnhancedAirDodgeThisAirTime) == 0x000018, "Member 'FEnhancedAirDodgeInfo::bCastEnhancedAirDodgeThisAirTime' has a wrong offset!");

// ScriptStruct Matcha.InProgressInteraction
// 0x0140 (0x0140 - 0x0000)
struct FInProgressInteraction final
{
public:
	struct FSnapNetPropertyInt32                  InitiateTimeMilliseconds;                          // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  ExpectedEndTimeMilliseconds;                       // 0x0038(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            InstigatorEntityIndex;                             // 0x0070(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            TargetEntityIndex;                                 // 0x00D8(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FInProgressInteraction) == 0x000008, "Wrong alignment on FInProgressInteraction");
static_assert(sizeof(FInProgressInteraction) == 0x000140, "Wrong size on FInProgressInteraction");
static_assert(offsetof(FInProgressInteraction, InitiateTimeMilliseconds) == 0x000000, "Member 'FInProgressInteraction::InitiateTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FInProgressInteraction, ExpectedEndTimeMilliseconds) == 0x000038, "Member 'FInProgressInteraction::ExpectedEndTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FInProgressInteraction, InstigatorEntityIndex) == 0x000070, "Member 'FInProgressInteraction::InstigatorEntityIndex' has a wrong offset!");
static_assert(offsetof(FInProgressInteraction, TargetEntityIndex) == 0x0000D8, "Member 'FInProgressInteraction::TargetEntityIndex' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventorySlotContainer
// 0x0048 (0x0048 - 0x0000)
struct FMatchaInventorySlotContainer final
{
public:
	struct FMatchaSnapNetGameplayTagProperty      SlotType;                                          // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMatchaInventorySlot>           Slots;                                             // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInventorySlotContainer) == 0x000008, "Wrong alignment on FMatchaInventorySlotContainer");
static_assert(sizeof(FMatchaInventorySlotContainer) == 0x000048, "Wrong size on FMatchaInventorySlotContainer");
static_assert(offsetof(FMatchaInventorySlotContainer, SlotType) == 0x000000, "Member 'FMatchaInventorySlotContainer::SlotType' has a wrong offset!");
static_assert(offsetof(FMatchaInventorySlotContainer, Slots) == 0x000038, "Member 'FMatchaInventorySlotContainer::Slots' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventorySlotCategory
// 0x0010 (0x0010 - 0x0000)
struct FMatchaInventorySlotCategory final
{
public:
	struct FGameplayTag                           SlotType;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfSlots;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInternalOnlySlot;                                 // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaInventorySlotCategory) == 0x000004, "Wrong alignment on FMatchaInventorySlotCategory");
static_assert(sizeof(FMatchaInventorySlotCategory) == 0x000010, "Wrong size on FMatchaInventorySlotCategory");
static_assert(offsetof(FMatchaInventorySlotCategory, SlotType) == 0x000000, "Member 'FMatchaInventorySlotCategory::SlotType' has a wrong offset!");
static_assert(offsetof(FMatchaInventorySlotCategory, NumberOfSlots) == 0x000008, "Member 'FMatchaInventorySlotCategory::NumberOfSlots' has a wrong offset!");
static_assert(offsetof(FMatchaInventorySlotCategory, bInternalOnlySlot) == 0x00000C, "Member 'FMatchaInventorySlotCategory::bInternalOnlySlot' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventory
// 0x0020 (0x0020 - 0x0000)
struct FMatchaInventory final
{
public:
	TArray<struct FMatchaInventorySlotContainer>  InventoryCategories;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatchaInventorySlotCategory>   InventoryCategoryDefinitions;                      // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInventory) == 0x000008, "Wrong alignment on FMatchaInventory");
static_assert(sizeof(FMatchaInventory) == 0x000020, "Wrong size on FMatchaInventory");
static_assert(offsetof(FMatchaInventory, InventoryCategories) == 0x000000, "Member 'FMatchaInventory::InventoryCategories' has a wrong offset!");
static_assert(offsetof(FMatchaInventory, InventoryCategoryDefinitions) == 0x000010, "Member 'FMatchaInventory::InventoryCategoryDefinitions' has a wrong offset!");

// ScriptStruct Matcha.TeamAttackInfo
// 0x0138 (0x0138 - 0x0000)
struct FTeamAttackInfo final
{
public:
	struct FSnapNetPropertyEntityIndex            Target;                                            // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            AllyTarget;                                        // 0x0068(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            Instigator;                                        // 0x00D0(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamAttackInfo) == 0x000008, "Wrong alignment on FTeamAttackInfo");
static_assert(sizeof(FTeamAttackInfo) == 0x000138, "Wrong size on FTeamAttackInfo");
static_assert(offsetof(FTeamAttackInfo, Target) == 0x000000, "Member 'FTeamAttackInfo::Target' has a wrong offset!");
static_assert(offsetof(FTeamAttackInfo, AllyTarget) == 0x000068, "Member 'FTeamAttackInfo::AllyTarget' has a wrong offset!");
static_assert(offsetof(FTeamAttackInfo, Instigator) == 0x0000D0, "Member 'FTeamAttackInfo::Instigator' has a wrong offset!");

// ScriptStruct Matcha.HitFreezeStateInfo
// 0x0068 (0x0068 - 0x0000)
struct FHitFreezeStateInfo final
{
public:
	struct FSnapNetPropertyInt32                  RemainingTimeMilliseconds;                         // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldShake;                                      // 0x0038(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldPetrify;                                    // 0x0050(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitFreezeStateInfo) == 0x000008, "Wrong alignment on FHitFreezeStateInfo");
static_assert(sizeof(FHitFreezeStateInfo) == 0x000068, "Wrong size on FHitFreezeStateInfo");
static_assert(offsetof(FHitFreezeStateInfo, RemainingTimeMilliseconds) == 0x000000, "Member 'FHitFreezeStateInfo::RemainingTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FHitFreezeStateInfo, bShouldShake) == 0x000038, "Member 'FHitFreezeStateInfo::bShouldShake' has a wrong offset!");
static_assert(offsetof(FHitFreezeStateInfo, bShouldPetrify) == 0x000050, "Member 'FHitFreezeStateInfo::bShouldPetrify' has a wrong offset!");

// ScriptStruct Matcha.VisibilityOverride
// 0x000C (0x000C - 0x0000)
struct FVisibilityOverride final
{
public:
	class FName                                   Identifier;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisibilityOverrideTargetType                 VisibilityTargetType;                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBeVisible;                                  // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisibilityOverride) == 0x000004, "Wrong alignment on FVisibilityOverride");
static_assert(sizeof(FVisibilityOverride) == 0x00000C, "Wrong size on FVisibilityOverride");
static_assert(offsetof(FVisibilityOverride, Identifier) == 0x000000, "Member 'FVisibilityOverride::Identifier' has a wrong offset!");
static_assert(offsetof(FVisibilityOverride, VisibilityTargetType) == 0x000008, "Member 'FVisibilityOverride::VisibilityTargetType' has a wrong offset!");
static_assert(offsetof(FVisibilityOverride, bShouldBeVisible) == 0x000009, "Member 'FVisibilityOverride::bShouldBeVisible' has a wrong offset!");

// ScriptStruct Matcha.ActiveItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FActiveItemInfo final
{
public:
	class UMatchaItemAsset*                       ItemAsset;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnergizedSlot;                                    // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveItemInfo) == 0x000008, "Wrong alignment on FActiveItemInfo");
static_assert(sizeof(FActiveItemInfo) == 0x000010, "Wrong size on FActiveItemInfo");
static_assert(offsetof(FActiveItemInfo, ItemAsset) == 0x000000, "Member 'FActiveItemInfo::ItemAsset' has a wrong offset!");
static_assert(offsetof(FActiveItemInfo, bEnergizedSlot) == 0x000008, "Member 'FActiveItemInfo::bEnergizedSlot' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketPlayerProfileMessageData
// 0x0030 (0x0030 - 0x0000)
struct FMatchaWebSocketPlayerProfileMessageData final
{
public:
	class FString                                 Timestamp;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerId;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketPlayerProfileMessageData) == 0x000008, "Wrong alignment on FMatchaWebSocketPlayerProfileMessageData");
static_assert(sizeof(FMatchaWebSocketPlayerProfileMessageData) == 0x000030, "Wrong size on FMatchaWebSocketPlayerProfileMessageData");
static_assert(offsetof(FMatchaWebSocketPlayerProfileMessageData, Timestamp) == 0x000000, "Member 'FMatchaWebSocketPlayerProfileMessageData::Timestamp' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketPlayerProfileMessageData, PlayerId) == 0x000010, "Member 'FMatchaWebSocketPlayerProfileMessageData::PlayerId' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketPlayerProfileMessageData, DisplayName) == 0x000020, "Member 'FMatchaWebSocketPlayerProfileMessageData::DisplayName' has a wrong offset!");

// ScriptStruct Matcha.AIPlayingMontageInfo
// 0x0110 (0x0110 - 0x0000)
struct FAIPlayingMontageInfo final
{
public:
	struct FSnapNetPropertyInt32                  Index;                                             // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTime;                                         // 0x0038(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  RemainingTime;                                     // 0x0070(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bUsingRootMotionRotation;                          // 0x00B0(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapNetPropertyQuaternion             RootMotionRotation;                                // 0x00D0(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIPlayingMontageInfo) == 0x000010, "Wrong alignment on FAIPlayingMontageInfo");
static_assert(sizeof(FAIPlayingMontageInfo) == 0x000110, "Wrong size on FAIPlayingMontageInfo");
static_assert(offsetof(FAIPlayingMontageInfo, Index) == 0x000000, "Member 'FAIPlayingMontageInfo::Index' has a wrong offset!");
static_assert(offsetof(FAIPlayingMontageInfo, StartTime) == 0x000038, "Member 'FAIPlayingMontageInfo::StartTime' has a wrong offset!");
static_assert(offsetof(FAIPlayingMontageInfo, RemainingTime) == 0x000070, "Member 'FAIPlayingMontageInfo::RemainingTime' has a wrong offset!");
static_assert(offsetof(FAIPlayingMontageInfo, bUsingRootMotionRotation) == 0x0000B0, "Member 'FAIPlayingMontageInfo::bUsingRootMotionRotation' has a wrong offset!");
static_assert(offsetof(FAIPlayingMontageInfo, RootMotionRotation) == 0x0000D0, "Member 'FAIPlayingMontageInfo::RootMotionRotation' has a wrong offset!");

// ScriptStruct Matcha.MatchaPlayerUIData_InitParams
// 0x0008 (0x0008 - 0x0000)
struct FMatchaPlayerUIData_InitParams final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackHoveredCharacter;                            // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackInteractableItem;                            // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaPlayerUIData_InitParams) == 0x000004, "Wrong alignment on FMatchaPlayerUIData_InitParams");
static_assert(sizeof(FMatchaPlayerUIData_InitParams) == 0x000008, "Wrong size on FMatchaPlayerUIData_InitParams");
static_assert(offsetof(FMatchaPlayerUIData_InitParams, PlayerIndex) == 0x000000, "Member 'FMatchaPlayerUIData_InitParams::PlayerIndex' has a wrong offset!");
static_assert(offsetof(FMatchaPlayerUIData_InitParams, bTrackHoveredCharacter) == 0x000004, "Member 'FMatchaPlayerUIData_InitParams::bTrackHoveredCharacter' has a wrong offset!");
static_assert(offsetof(FMatchaPlayerUIData_InitParams, bTrackInteractableItem) == 0x000005, "Member 'FMatchaPlayerUIData_InitParams::bTrackInteractableItem' has a wrong offset!");

// ScriptStruct Matcha.PathList
// 0x0010 (0x0010 - 0x0000)
struct FPathList final
{
public:
	TArray<class FString>                         Paths;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathList) == 0x000008, "Wrong alignment on FPathList");
static_assert(sizeof(FPathList) == 0x000010, "Wrong size on FPathList");
static_assert(offsetof(FPathList, Paths) == 0x000000, "Member 'FPathList::Paths' has a wrong offset!");

// ScriptStruct Matcha.RegionUrlV1
// 0x0020 (0x0020 - 0x0000)
struct FRegionUrlV1 final
{
public:
	class FString                                 Region;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegionUrlV1) == 0x000008, "Wrong alignment on FRegionUrlV1");
static_assert(sizeof(FRegionUrlV1) == 0x000020, "Wrong size on FRegionUrlV1");
static_assert(offsetof(FRegionUrlV1, Region) == 0x000000, "Member 'FRegionUrlV1::Region' has a wrong offset!");
static_assert(offsetof(FRegionUrlV1, URL) == 0x000010, "Member 'FRegionUrlV1::URL' has a wrong offset!");

// ScriptStruct Matcha.SupportedRegionV1
// 0x0018 (0x0018 - 0x0000)
struct FSupportedRegionV1 final
{
public:
	class FName                                   RegionName;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRegionUrlV1>                   DataCenters;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportedRegionV1) == 0x000008, "Wrong alignment on FSupportedRegionV1");
static_assert(sizeof(FSupportedRegionV1) == 0x000018, "Wrong size on FSupportedRegionV1");
static_assert(offsetof(FSupportedRegionV1, RegionName) == 0x000000, "Member 'FSupportedRegionV1::RegionName' has a wrong offset!");
static_assert(offsetof(FSupportedRegionV1, DataCenters) == 0x000008, "Member 'FSupportedRegionV1::DataCenters' has a wrong offset!");

// ScriptStruct Matcha.SupportedRegionsV1ResponseBody
// 0x0010 (0x0010 - 0x0000)
struct FSupportedRegionsV1ResponseBody final
{
public:
	TArray<struct FSupportedRegionV1>             Regions;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportedRegionsV1ResponseBody) == 0x000008, "Wrong alignment on FSupportedRegionsV1ResponseBody");
static_assert(sizeof(FSupportedRegionsV1ResponseBody) == 0x000010, "Wrong size on FSupportedRegionsV1ResponseBody");
static_assert(offsetof(FSupportedRegionsV1ResponseBody, Regions) == 0x000000, "Member 'FSupportedRegionsV1ResponseBody::Regions' has a wrong offset!");

// ScriptStruct Matcha.CompanionAttachInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FCompanionAttachInfo final
{
public:
	struct FSnapNetPropertyEnum                   AttachState;                                       // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  ReturnEndTime;                                     // 0x0048(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyPosition               SourceLocation;                                    // 0x0080(0x0048)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompanionAttachInfo) == 0x000008, "Wrong alignment on FCompanionAttachInfo");
static_assert(sizeof(FCompanionAttachInfo) == 0x0000C8, "Wrong size on FCompanionAttachInfo");
static_assert(offsetof(FCompanionAttachInfo, AttachState) == 0x000000, "Member 'FCompanionAttachInfo::AttachState' has a wrong offset!");
static_assert(offsetof(FCompanionAttachInfo, ReturnEndTime) == 0x000048, "Member 'FCompanionAttachInfo::ReturnEndTime' has a wrong offset!");
static_assert(offsetof(FCompanionAttachInfo, SourceLocation) == 0x000080, "Member 'FCompanionAttachInfo::SourceLocation' has a wrong offset!");

// ScriptStruct Matcha.MatchaCharacterAttributeSet
// 0x0990 (0x09A8 - 0x0018)
struct FMatchaCharacterAttributeSet final : public FMatchaAttributeSet
{
public:
	struct FMatchaSnapnetAttributeData            StartingDamage;                                    // 0x0018(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            Damage;                                            // 0x00A0(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            MaxShieldHealth;                                   // 0x0128(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            VampStat;                                          // 0x01B0(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            JuiceStat;                                         // 0x0238(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            JumpVerticalAmpStat;                               // 0x02C0(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            MaxAirJumps;                                       // 0x0348(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            Energy;                                            // 0x03D0(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            MaxEnergy;                                         // 0x0458(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            EnergyGenerationRatio;                             // 0x04E0(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            AirDodgeRootMotionSpeedAmp;                        // 0x0568(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            DashGrabRootMotionSpeedAmp;                        // 0x05F0(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            ExtraUpSpecialCasts;                               // 0x0678(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            RareItemMaxStackAmp;                               // 0x0700(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            LegendaryItemMaxStackAmp;                          // 0x0788(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            SlowAmount;                                        // 0x0810(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            SlowResistance;                                    // 0x0898(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchaSnapnetAttributeData            InteractionSpeed;                                  // 0x0920(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaCharacterAttributeSet) == 0x000008, "Wrong alignment on FMatchaCharacterAttributeSet");
static_assert(sizeof(FMatchaCharacterAttributeSet) == 0x0009A8, "Wrong size on FMatchaCharacterAttributeSet");
static_assert(offsetof(FMatchaCharacterAttributeSet, StartingDamage) == 0x000018, "Member 'FMatchaCharacterAttributeSet::StartingDamage' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, Damage) == 0x0000A0, "Member 'FMatchaCharacterAttributeSet::Damage' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, MaxShieldHealth) == 0x000128, "Member 'FMatchaCharacterAttributeSet::MaxShieldHealth' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, VampStat) == 0x0001B0, "Member 'FMatchaCharacterAttributeSet::VampStat' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, JuiceStat) == 0x000238, "Member 'FMatchaCharacterAttributeSet::JuiceStat' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, JumpVerticalAmpStat) == 0x0002C0, "Member 'FMatchaCharacterAttributeSet::JumpVerticalAmpStat' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, MaxAirJumps) == 0x000348, "Member 'FMatchaCharacterAttributeSet::MaxAirJumps' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, Energy) == 0x0003D0, "Member 'FMatchaCharacterAttributeSet::Energy' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, MaxEnergy) == 0x000458, "Member 'FMatchaCharacterAttributeSet::MaxEnergy' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, EnergyGenerationRatio) == 0x0004E0, "Member 'FMatchaCharacterAttributeSet::EnergyGenerationRatio' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, AirDodgeRootMotionSpeedAmp) == 0x000568, "Member 'FMatchaCharacterAttributeSet::AirDodgeRootMotionSpeedAmp' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, DashGrabRootMotionSpeedAmp) == 0x0005F0, "Member 'FMatchaCharacterAttributeSet::DashGrabRootMotionSpeedAmp' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, ExtraUpSpecialCasts) == 0x000678, "Member 'FMatchaCharacterAttributeSet::ExtraUpSpecialCasts' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, RareItemMaxStackAmp) == 0x000700, "Member 'FMatchaCharacterAttributeSet::RareItemMaxStackAmp' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, LegendaryItemMaxStackAmp) == 0x000788, "Member 'FMatchaCharacterAttributeSet::LegendaryItemMaxStackAmp' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, SlowAmount) == 0x000810, "Member 'FMatchaCharacterAttributeSet::SlowAmount' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, SlowResistance) == 0x000898, "Member 'FMatchaCharacterAttributeSet::SlowResistance' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterAttributeSet, InteractionSpeed) == 0x000920, "Member 'FMatchaCharacterAttributeSet::InteractionSpeed' has a wrong offset!");

// ScriptStruct Matcha.RootMotionForceData
// 0x0060 (0x0060 - 0x0000)
struct FRootMotionForceData final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleDirection;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesMoveInputForDirection;                        // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotatesDirectionTowardsHorizontalInput;           // 0x0011(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangesFacingTowardsHorizontalInput;              // 0x0012(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldClearMontageOnEnd;                          // 0x0013(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CustomSpeedOverTimeCurve;                          // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionFinishVelocityMode                 FinishVelocityMode;                                // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SetVelocity;                                       // 0x0028(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClampVelocity;                                     // 0x0040(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionForceApplicationCondition          ApplicationCondition;                              // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionForceData) == 0x000008, "Wrong alignment on FRootMotionForceData");
static_assert(sizeof(FRootMotionForceData) == 0x000060, "Wrong size on FRootMotionForceData");
static_assert(offsetof(FRootMotionForceData, Duration) == 0x000000, "Member 'FRootMotionForceData::Duration' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, StartTime) == 0x000004, "Member 'FRootMotionForceData::StartTime' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, Speed) == 0x000008, "Member 'FRootMotionForceData::Speed' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, AngleDirection) == 0x00000C, "Member 'FRootMotionForceData::AngleDirection' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, bUsesMoveInputForDirection) == 0x000010, "Member 'FRootMotionForceData::bUsesMoveInputForDirection' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, bRotatesDirectionTowardsHorizontalInput) == 0x000011, "Member 'FRootMotionForceData::bRotatesDirectionTowardsHorizontalInput' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, bChangesFacingTowardsHorizontalInput) == 0x000012, "Member 'FRootMotionForceData::bChangesFacingTowardsHorizontalInput' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, bShouldClearMontageOnEnd) == 0x000013, "Member 'FRootMotionForceData::bShouldClearMontageOnEnd' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, CustomSpeedOverTimeCurve) == 0x000018, "Member 'FRootMotionForceData::CustomSpeedOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, FinishVelocityMode) == 0x000020, "Member 'FRootMotionForceData::FinishVelocityMode' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, SetVelocity) == 0x000028, "Member 'FRootMotionForceData::SetVelocity' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, ClampVelocity) == 0x000040, "Member 'FRootMotionForceData::ClampVelocity' has a wrong offset!");
static_assert(offsetof(FRootMotionForceData, ApplicationCondition) == 0x000058, "Member 'FRootMotionForceData::ApplicationCondition' has a wrong offset!");

// ScriptStruct Matcha.MatchaApiV1GamesInfoPlayerData
// 0x0020 (0x0020 - 0x0000)
struct FMatchaApiV1GamesInfoPlayerData final
{
public:
	class FName                                   PlayerId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAdmin;                                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaApiV1GamesInfoPlayerData) == 0x000008, "Wrong alignment on FMatchaApiV1GamesInfoPlayerData");
static_assert(sizeof(FMatchaApiV1GamesInfoPlayerData) == 0x000020, "Wrong size on FMatchaApiV1GamesInfoPlayerData");
static_assert(offsetof(FMatchaApiV1GamesInfoPlayerData, PlayerId) == 0x000000, "Member 'FMatchaApiV1GamesInfoPlayerData::PlayerId' has a wrong offset!");
static_assert(offsetof(FMatchaApiV1GamesInfoPlayerData, PlayerName) == 0x000008, "Member 'FMatchaApiV1GamesInfoPlayerData::PlayerName' has a wrong offset!");
static_assert(offsetof(FMatchaApiV1GamesInfoPlayerData, IsAdmin) == 0x000018, "Member 'FMatchaApiV1GamesInfoPlayerData::IsAdmin' has a wrong offset!");

// ScriptStruct Matcha.MatchaApiV1GamesInfoPartyData
// 0x0018 (0x0018 - 0x0000)
struct FMatchaApiV1GamesInfoPartyData final
{
public:
	class FName                                   PartyId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMatchaApiV1GamesInfoPlayerData> Players;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaApiV1GamesInfoPartyData) == 0x000008, "Wrong alignment on FMatchaApiV1GamesInfoPartyData");
static_assert(sizeof(FMatchaApiV1GamesInfoPartyData) == 0x000018, "Wrong size on FMatchaApiV1GamesInfoPartyData");
static_assert(offsetof(FMatchaApiV1GamesInfoPartyData, PartyId) == 0x000000, "Member 'FMatchaApiV1GamesInfoPartyData::PartyId' has a wrong offset!");
static_assert(offsetof(FMatchaApiV1GamesInfoPartyData, Players) == 0x000008, "Member 'FMatchaApiV1GamesInfoPartyData::Players' has a wrong offset!");

// ScriptStruct Matcha.AppliedRootMotionInfo
// 0x0108 (0x0108 - 0x0000)
struct FAppliedRootMotionInfo final
{
public:
	struct FSnapNetPropertyEnum                   Type;                                              // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector2D               UnitDirection;                                     // 0x0048(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  RemainingTime;                                     // 0x00B0(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldClearMontageOnEnd;                          // 0x00F0(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppliedRootMotionInfo) == 0x000008, "Wrong alignment on FAppliedRootMotionInfo");
static_assert(sizeof(FAppliedRootMotionInfo) == 0x000108, "Wrong size on FAppliedRootMotionInfo");
static_assert(offsetof(FAppliedRootMotionInfo, Type) == 0x000000, "Member 'FAppliedRootMotionInfo::Type' has a wrong offset!");
static_assert(offsetof(FAppliedRootMotionInfo, UnitDirection) == 0x000048, "Member 'FAppliedRootMotionInfo::UnitDirection' has a wrong offset!");
static_assert(offsetof(FAppliedRootMotionInfo, RemainingTime) == 0x0000B0, "Member 'FAppliedRootMotionInfo::RemainingTime' has a wrong offset!");
static_assert(offsetof(FAppliedRootMotionInfo, bShouldClearMontageOnEnd) == 0x0000F0, "Member 'FAppliedRootMotionInfo::bShouldClearMontageOnEnd' has a wrong offset!");

// ScriptStruct Matcha.AutoTravelRootMotionInfo
// 0x02A8 (0x02A8 - 0x0000)
struct FAutoTravelRootMotionInfo final
{
public:
	struct FSnapNetPropertyEnum                   Type;                                              // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector2D               InitialVelocity;                                   // 0x0048(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  Deceleration;                                      // 0x00B0(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  Gravity;                                           // 0x00F0(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            TraversalEntityIndex;                              // 0x0130(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   TraversalEntityType;                               // 0x0198(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  ElapsedTime;                                       // 0x01E0(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  Direction;                                         // 0x0220(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bRequestedIntangibilty;                            // 0x0260(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bRequestedDisable;                                 // 0x0278(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bDisableCapsuleCollision;                          // 0x0290(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoTravelRootMotionInfo) == 0x000008, "Wrong alignment on FAutoTravelRootMotionInfo");
static_assert(sizeof(FAutoTravelRootMotionInfo) == 0x0002A8, "Wrong size on FAutoTravelRootMotionInfo");
static_assert(offsetof(FAutoTravelRootMotionInfo, Type) == 0x000000, "Member 'FAutoTravelRootMotionInfo::Type' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, InitialVelocity) == 0x000048, "Member 'FAutoTravelRootMotionInfo::InitialVelocity' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, Deceleration) == 0x0000B0, "Member 'FAutoTravelRootMotionInfo::Deceleration' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, Gravity) == 0x0000F0, "Member 'FAutoTravelRootMotionInfo::Gravity' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, TraversalEntityIndex) == 0x000130, "Member 'FAutoTravelRootMotionInfo::TraversalEntityIndex' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, TraversalEntityType) == 0x000198, "Member 'FAutoTravelRootMotionInfo::TraversalEntityType' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, ElapsedTime) == 0x0001E0, "Member 'FAutoTravelRootMotionInfo::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, Direction) == 0x000220, "Member 'FAutoTravelRootMotionInfo::Direction' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, bRequestedIntangibilty) == 0x000260, "Member 'FAutoTravelRootMotionInfo::bRequestedIntangibilty' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, bRequestedDisable) == 0x000278, "Member 'FAutoTravelRootMotionInfo::bRequestedDisable' has a wrong offset!");
static_assert(offsetof(FAutoTravelRootMotionInfo, bDisableCapsuleCollision) == 0x000290, "Member 'FAutoTravelRootMotionInfo::bDisableCapsuleCollision' has a wrong offset!");

// ScriptStruct Matcha.SoulStateInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FSoulStateInfo final
{
public:
	struct FSnapNetPropertyEntityIndex            TeamMateEntityIndex;                               // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyPosition               TargetLocation;                                    // 0x0068(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoulStateInfo) == 0x000008, "Wrong alignment on FSoulStateInfo");
static_assert(sizeof(FSoulStateInfo) == 0x0000B0, "Wrong size on FSoulStateInfo");
static_assert(offsetof(FSoulStateInfo, TeamMateEntityIndex) == 0x000000, "Member 'FSoulStateInfo::TeamMateEntityIndex' has a wrong offset!");
static_assert(offsetof(FSoulStateInfo, TargetLocation) == 0x000068, "Member 'FSoulStateInfo::TargetLocation' has a wrong offset!");

// ScriptStruct Matcha.TargetedGlitchDashInfo
// 0x0140 (0x0140 - 0x0000)
struct FTargetedGlitchDashInfo final
{
public:
	struct FSnapNetPropertyEntityIndex            TargetEntityIndex;                                 // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyPosition               StartTravelLocation;                               // 0x0068(0x0048)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  AirStallEndTimeBeforeTravel;                       // 0x00B0(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  TravelEndTime;                                     // 0x00E8(0x0038)(NativeAccessSpecifierPublic)
	int32                                         TravelTimeToArriveMilliseconds;                    // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TargetOffset;                                      // 0x0128(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetedGlitchDashFacingType                 FacingType;                                        // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   OnRequestMontageToPlay;                            // 0x0139(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   PostTravelMontageToPlay;                           // 0x013A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaRootMotionType                         PostTravelRootMotionToRequest;                     // 0x013B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetedGlitchDashInfo) == 0x000008, "Wrong alignment on FTargetedGlitchDashInfo");
static_assert(sizeof(FTargetedGlitchDashInfo) == 0x000140, "Wrong size on FTargetedGlitchDashInfo");
static_assert(offsetof(FTargetedGlitchDashInfo, TargetEntityIndex) == 0x000000, "Member 'FTargetedGlitchDashInfo::TargetEntityIndex' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, StartTravelLocation) == 0x000068, "Member 'FTargetedGlitchDashInfo::StartTravelLocation' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, AirStallEndTimeBeforeTravel) == 0x0000B0, "Member 'FTargetedGlitchDashInfo::AirStallEndTimeBeforeTravel' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, TravelEndTime) == 0x0000E8, "Member 'FTargetedGlitchDashInfo::TravelEndTime' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, TravelTimeToArriveMilliseconds) == 0x000120, "Member 'FTargetedGlitchDashInfo::TravelTimeToArriveMilliseconds' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, TargetOffset) == 0x000128, "Member 'FTargetedGlitchDashInfo::TargetOffset' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, FacingType) == 0x000138, "Member 'FTargetedGlitchDashInfo::FacingType' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, OnRequestMontageToPlay) == 0x000139, "Member 'FTargetedGlitchDashInfo::OnRequestMontageToPlay' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, PostTravelMontageToPlay) == 0x00013A, "Member 'FTargetedGlitchDashInfo::PostTravelMontageToPlay' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashInfo, PostTravelRootMotionToRequest) == 0x00013B, "Member 'FTargetedGlitchDashInfo::PostTravelRootMotionToRequest' has a wrong offset!");

// ScriptStruct Matcha.PlayingMontageInfo
// 0x0160 (0x0160 - 0x0000)
struct FPlayingMontageInfo final
{
public:
	struct FSnapNetPropertyEnum                   Type;                                              // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  RemainingTime;                                     // 0x0048(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bUsingRootMotionRotation;                          // 0x0088(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyQuaternion             RootMotionRotation;                                // 0x00A0(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   CompanionAttachStateForMontage;                    // 0x00E0(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  HitBoxCount;                                       // 0x0128(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayingMontageInfo) == 0x000010, "Wrong alignment on FPlayingMontageInfo");
static_assert(sizeof(FPlayingMontageInfo) == 0x000160, "Wrong size on FPlayingMontageInfo");
static_assert(offsetof(FPlayingMontageInfo, Type) == 0x000000, "Member 'FPlayingMontageInfo::Type' has a wrong offset!");
static_assert(offsetof(FPlayingMontageInfo, RemainingTime) == 0x000048, "Member 'FPlayingMontageInfo::RemainingTime' has a wrong offset!");
static_assert(offsetof(FPlayingMontageInfo, bUsingRootMotionRotation) == 0x000088, "Member 'FPlayingMontageInfo::bUsingRootMotionRotation' has a wrong offset!");
static_assert(offsetof(FPlayingMontageInfo, RootMotionRotation) == 0x0000A0, "Member 'FPlayingMontageInfo::RootMotionRotation' has a wrong offset!");
static_assert(offsetof(FPlayingMontageInfo, CompanionAttachStateForMontage) == 0x0000E0, "Member 'FPlayingMontageInfo::CompanionAttachStateForMontage' has a wrong offset!");
static_assert(offsetof(FPlayingMontageInfo, HitBoxCount) == 0x000128, "Member 'FPlayingMontageInfo::HitBoxCount' has a wrong offset!");

// ScriptStruct Matcha.MatchaApiV1GameFailedRequestBody
// 0x0020 (0x0020 - 0x0000)
struct FMatchaApiV1GameFailedRequestBody final
{
public:
	class FString                                 GameId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaApiV1GameFailedRequestBody) == 0x000008, "Wrong alignment on FMatchaApiV1GameFailedRequestBody");
static_assert(sizeof(FMatchaApiV1GameFailedRequestBody) == 0x000020, "Wrong size on FMatchaApiV1GameFailedRequestBody");
static_assert(offsetof(FMatchaApiV1GameFailedRequestBody, GameId) == 0x000000, "Member 'FMatchaApiV1GameFailedRequestBody::GameId' has a wrong offset!");
static_assert(offsetof(FMatchaApiV1GameFailedRequestBody, Reason) == 0x000010, "Member 'FMatchaApiV1GameFailedRequestBody::Reason' has a wrong offset!");

// ScriptStruct Matcha.JumpNetworkData
// 0x0100 (0x0100 - 0x0000)
struct FJumpNetworkData final
{
public:
	struct FSnapNetPropertyFloat                  Duration;                                          // 0x0000(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  RemainingTime;                                     // 0x0040(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTime;                                         // 0x0080(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   JumpType;                                          // 0x00B8(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FJumpNetworkData) == 0x000008, "Wrong alignment on FJumpNetworkData");
static_assert(sizeof(FJumpNetworkData) == 0x000100, "Wrong size on FJumpNetworkData");
static_assert(offsetof(FJumpNetworkData, Duration) == 0x000000, "Member 'FJumpNetworkData::Duration' has a wrong offset!");
static_assert(offsetof(FJumpNetworkData, RemainingTime) == 0x000040, "Member 'FJumpNetworkData::RemainingTime' has a wrong offset!");
static_assert(offsetof(FJumpNetworkData, StartTime) == 0x000080, "Member 'FJumpNetworkData::StartTime' has a wrong offset!");
static_assert(offsetof(FJumpNetworkData, JumpType) == 0x0000B8, "Member 'FJumpNetworkData::JumpType' has a wrong offset!");

// ScriptStruct Matcha.TrackedEntityData
// 0x00A0 (0x00A0 - 0x0000)
struct FTrackedEntityData final
{
public:
	struct FMatchaSnapNetGameplayTagProperty      Tag;                                               // 0x0000(0x0038)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            EntityIndex;                                       // 0x0038(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackedEntityData) == 0x000008, "Wrong alignment on FTrackedEntityData");
static_assert(sizeof(FTrackedEntityData) == 0x0000A0, "Wrong size on FTrackedEntityData");
static_assert(offsetof(FTrackedEntityData, Tag) == 0x000000, "Member 'FTrackedEntityData::Tag' has a wrong offset!");
static_assert(offsetof(FTrackedEntityData, EntityIndex) == 0x000038, "Member 'FTrackedEntityData::EntityIndex' has a wrong offset!");

// ScriptStruct Matcha.MatchTeamMatchStats
// 0x000C (0x000C - 0x0000)
struct FMatchTeamMatchStats final
{
public:
	int32                                         TeamNumber;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Placement;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalSeconds;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchTeamMatchStats) == 0x000004, "Wrong alignment on FMatchTeamMatchStats");
static_assert(sizeof(FMatchTeamMatchStats) == 0x00000C, "Wrong size on FMatchTeamMatchStats");
static_assert(offsetof(FMatchTeamMatchStats, TeamNumber) == 0x000000, "Member 'FMatchTeamMatchStats::TeamNumber' has a wrong offset!");
static_assert(offsetof(FMatchTeamMatchStats, Placement) == 0x000004, "Member 'FMatchTeamMatchStats::Placement' has a wrong offset!");
static_assert(offsetof(FMatchTeamMatchStats, SurvivalSeconds) == 0x000008, "Member 'FMatchTeamMatchStats::SurvivalSeconds' has a wrong offset!");

// ScriptStruct Matcha.MatchPlayerMatchStats
// 0x0040 (0x0040 - 0x0000)
struct FMatchPlayerMatchStats final
{
public:
	class FName                                   PlayerId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamNumber;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Knockouts;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDealt;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageHealed;                                      // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Revives;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchPlayerMatchStats) == 0x000008, "Wrong alignment on FMatchPlayerMatchStats");
static_assert(sizeof(FMatchPlayerMatchStats) == 0x000040, "Wrong size on FMatchPlayerMatchStats");
static_assert(offsetof(FMatchPlayerMatchStats, PlayerId) == 0x000000, "Member 'FMatchPlayerMatchStats::PlayerId' has a wrong offset!");
static_assert(offsetof(FMatchPlayerMatchStats, PlayerName) == 0x000008, "Member 'FMatchPlayerMatchStats::PlayerName' has a wrong offset!");
static_assert(offsetof(FMatchPlayerMatchStats, CharacterName) == 0x000018, "Member 'FMatchPlayerMatchStats::CharacterName' has a wrong offset!");
static_assert(offsetof(FMatchPlayerMatchStats, TeamNumber) == 0x000028, "Member 'FMatchPlayerMatchStats::TeamNumber' has a wrong offset!");
static_assert(offsetof(FMatchPlayerMatchStats, Knockouts) == 0x00002C, "Member 'FMatchPlayerMatchStats::Knockouts' has a wrong offset!");
static_assert(offsetof(FMatchPlayerMatchStats, DamageDealt) == 0x000030, "Member 'FMatchPlayerMatchStats::DamageDealt' has a wrong offset!");
static_assert(offsetof(FMatchPlayerMatchStats, DamageHealed) == 0x000034, "Member 'FMatchPlayerMatchStats::DamageHealed' has a wrong offset!");
static_assert(offsetof(FMatchPlayerMatchStats, Revives) == 0x000038, "Member 'FMatchPlayerMatchStats::Revives' has a wrong offset!");

// ScriptStruct Matcha.MatchaMatchSummary
// 0x0050 (0x0050 - 0x0000)
struct FMatchaMatchSummary final
{
public:
	class FString                                 GameId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameVersion;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameFormat;                                        // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchDurationSeconds;                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchTeamMatchStats>           TeamStats;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatchPlayerMatchStats>         PlayerStats;                                       // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaMatchSummary) == 0x000008, "Wrong alignment on FMatchaMatchSummary");
static_assert(sizeof(FMatchaMatchSummary) == 0x000050, "Wrong size on FMatchaMatchSummary");
static_assert(offsetof(FMatchaMatchSummary, GameId) == 0x000000, "Member 'FMatchaMatchSummary::GameId' has a wrong offset!");
static_assert(offsetof(FMatchaMatchSummary, GameVersion) == 0x000010, "Member 'FMatchaMatchSummary::GameVersion' has a wrong offset!");
static_assert(offsetof(FMatchaMatchSummary, GameFormat) == 0x000018, "Member 'FMatchaMatchSummary::GameFormat' has a wrong offset!");
static_assert(offsetof(FMatchaMatchSummary, MatchDurationSeconds) == 0x000028, "Member 'FMatchaMatchSummary::MatchDurationSeconds' has a wrong offset!");
static_assert(offsetof(FMatchaMatchSummary, TeamStats) == 0x000030, "Member 'FMatchaMatchSummary::TeamStats' has a wrong offset!");
static_assert(offsetof(FMatchaMatchSummary, PlayerStats) == 0x000040, "Member 'FMatchaMatchSummary::PlayerStats' has a wrong offset!");

// ScriptStruct Matcha.TriggeredOneShotNotifyInfo
// 0x0070 (0x0070 - 0x0000)
struct FTriggeredOneShotNotifyInfo final
{
public:
	struct FSnapNetPropertyInt32                  NotifyHash;                                        // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  MontageFrame;                                      // 0x0038(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriggeredOneShotNotifyInfo) == 0x000008, "Wrong alignment on FTriggeredOneShotNotifyInfo");
static_assert(sizeof(FTriggeredOneShotNotifyInfo) == 0x000070, "Wrong size on FTriggeredOneShotNotifyInfo");
static_assert(offsetof(FTriggeredOneShotNotifyInfo, NotifyHash) == 0x000000, "Member 'FTriggeredOneShotNotifyInfo::NotifyHash' has a wrong offset!");
static_assert(offsetof(FTriggeredOneShotNotifyInfo, MontageFrame) == 0x000038, "Member 'FTriggeredOneShotNotifyInfo::MontageFrame' has a wrong offset!");

// ScriptStruct Matcha.SpecialAttackRestrictionInfo
// 0x0020 (0x0020 - 0x0000)
struct FSpecialAttackRestrictionInfo final
{
public:
	int32                                         MaxUsesBeforeLanding;                              // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DoNotResetTags;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESpecialAttackRestrictionUsageType            RestrictionUsageType;                              // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialAttackRestrictionInfo) == 0x000008, "Wrong alignment on FSpecialAttackRestrictionInfo");
static_assert(sizeof(FSpecialAttackRestrictionInfo) == 0x000020, "Wrong size on FSpecialAttackRestrictionInfo");
static_assert(offsetof(FSpecialAttackRestrictionInfo, MaxUsesBeforeLanding) == 0x000000, "Member 'FSpecialAttackRestrictionInfo::MaxUsesBeforeLanding' has a wrong offset!");
static_assert(offsetof(FSpecialAttackRestrictionInfo, DoNotResetTags) == 0x000008, "Member 'FSpecialAttackRestrictionInfo::DoNotResetTags' has a wrong offset!");
static_assert(offsetof(FSpecialAttackRestrictionInfo, RestrictionUsageType) == 0x000018, "Member 'FSpecialAttackRestrictionInfo::RestrictionUsageType' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketLivenessMessageData
// 0x0020 (0x0020 - 0x0000)
struct FMatchaWebSocketLivenessMessageData final
{
public:
	class FString                                 Timestamp;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastNotificationTimestamp;                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketLivenessMessageData) == 0x000008, "Wrong alignment on FMatchaWebSocketLivenessMessageData");
static_assert(sizeof(FMatchaWebSocketLivenessMessageData) == 0x000020, "Wrong size on FMatchaWebSocketLivenessMessageData");
static_assert(offsetof(FMatchaWebSocketLivenessMessageData, Timestamp) == 0x000000, "Member 'FMatchaWebSocketLivenessMessageData::Timestamp' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketLivenessMessageData, LastNotificationTimestamp) == 0x000010, "Member 'FMatchaWebSocketLivenessMessageData::LastNotificationTimestamp' has a wrong offset!");

// ScriptStruct Matcha.KOZoneInfo
// 0x0098 (0x0098 - 0x0000)
struct FKOZoneInfo final
{
public:
	struct FSnapNetPropertyBoolean                bInsideZone;                                       // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  DamagePerTick;                                     // 0x0018(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  DamageTickRate;                                    // 0x0058(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FKOZoneInfo) == 0x000008, "Wrong alignment on FKOZoneInfo");
static_assert(sizeof(FKOZoneInfo) == 0x000098, "Wrong size on FKOZoneInfo");
static_assert(offsetof(FKOZoneInfo, bInsideZone) == 0x000000, "Member 'FKOZoneInfo::bInsideZone' has a wrong offset!");
static_assert(offsetof(FKOZoneInfo, DamagePerTick) == 0x000018, "Member 'FKOZoneInfo::DamagePerTick' has a wrong offset!");
static_assert(offsetof(FKOZoneInfo, DamageTickRate) == 0x000058, "Member 'FKOZoneInfo::DamageTickRate' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketLivenessMessage
// 0x0020 (0x0028 - 0x0008)
struct FMatchaWebSocketLivenessMessage final : public FMatchaServicesWebSocketMessageBase
{
public:
	struct FMatchaWebSocketLivenessMessageData    Data;                                              // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketLivenessMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketLivenessMessage");
static_assert(sizeof(FMatchaWebSocketLivenessMessage) == 0x000028, "Wrong size on FMatchaWebSocketLivenessMessage");
static_assert(offsetof(FMatchaWebSocketLivenessMessage, Data) == 0x000008, "Member 'FMatchaWebSocketLivenessMessage::Data' has a wrong offset!");

// ScriptStruct Matcha.PropertyEntityIndexWrapper
// 0x0068 (0x0068 - 0x0000)
struct FPropertyEntityIndexWrapper final
{
public:
	struct FSnapNetPropertyEntityIndex            EntityIndex;                                       // 0x0000(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropertyEntityIndexWrapper) == 0x000008, "Wrong alignment on FPropertyEntityIndexWrapper");
static_assert(sizeof(FPropertyEntityIndexWrapper) == 0x000068, "Wrong size on FPropertyEntityIndexWrapper");
static_assert(offsetof(FPropertyEntityIndexWrapper, EntityIndex) == 0x000000, "Member 'FPropertyEntityIndexWrapper::EntityIndex' has a wrong offset!");

// ScriptStruct Matcha.MatchaHitBoxData
// 0x00A8 (0x00A8 - 0x0000)
struct FMatchaHitBoxData
{
public:
	EMatchaHitBoxType                             Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereRadius;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BoxSize;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachBone;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaHitData                         HitData;                                           // 0x0030(0x0078)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaHitBoxData) == 0x000008, "Wrong alignment on FMatchaHitBoxData");
static_assert(sizeof(FMatchaHitBoxData) == 0x0000A8, "Wrong size on FMatchaHitBoxData");
static_assert(offsetof(FMatchaHitBoxData, Type) == 0x000000, "Member 'FMatchaHitBoxData::Type' has a wrong offset!");
static_assert(offsetof(FMatchaHitBoxData, SphereRadius) == 0x000004, "Member 'FMatchaHitBoxData::SphereRadius' has a wrong offset!");
static_assert(offsetof(FMatchaHitBoxData, BoxSize) == 0x000008, "Member 'FMatchaHitBoxData::BoxSize' has a wrong offset!");
static_assert(offsetof(FMatchaHitBoxData, AttachBone) == 0x000018, "Member 'FMatchaHitBoxData::AttachBone' has a wrong offset!");
static_assert(offsetof(FMatchaHitBoxData, Offset) == 0x000020, "Member 'FMatchaHitBoxData::Offset' has a wrong offset!");
static_assert(offsetof(FMatchaHitBoxData, HitData) == 0x000030, "Member 'FMatchaHitBoxData::HitData' has a wrong offset!");

// ScriptStruct Matcha.GrabTargetInfo
// 0x0130 (0x0130 - 0x0000)
struct FGrabTargetInfo final
{
public:
	struct FSnapNetPropertyEntityIndex            InstigatorIndex;                                   // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTime;                                         // 0x0068(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   GrabHeightType;                                    // 0x00A0(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   ThrowType;                                         // 0x00E8(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrabTargetInfo) == 0x000008, "Wrong alignment on FGrabTargetInfo");
static_assert(sizeof(FGrabTargetInfo) == 0x000130, "Wrong size on FGrabTargetInfo");
static_assert(offsetof(FGrabTargetInfo, InstigatorIndex) == 0x000000, "Member 'FGrabTargetInfo::InstigatorIndex' has a wrong offset!");
static_assert(offsetof(FGrabTargetInfo, StartTime) == 0x000068, "Member 'FGrabTargetInfo::StartTime' has a wrong offset!");
static_assert(offsetof(FGrabTargetInfo, GrabHeightType) == 0x0000A0, "Member 'FGrabTargetInfo::GrabHeightType' has a wrong offset!");
static_assert(offsetof(FGrabTargetInfo, ThrowType) == 0x0000E8, "Member 'FGrabTargetInfo::ThrowType' has a wrong offset!");

// ScriptStruct Matcha.UnprocessedHitBoxData
// 0x00F0 (0x00F0 - 0x0000)
struct FUnprocessedHitBoxData final
{
public:
	struct FMatchaHitBoxData                      HitBoxData;                                        // 0x0000(0x00A8)(NativeAccessSpecifierPublic)
	class UObject*                                HitSource;                                         // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceId;                                          // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PreviousModifiedHitCenter;                         // 0x00B8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ModifiedHitCenter;                                 // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToKeepInPreviousHitsList;                      // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnprocessedHitBoxData) == 0x000008, "Wrong alignment on FUnprocessedHitBoxData");
static_assert(sizeof(FUnprocessedHitBoxData) == 0x0000F0, "Wrong size on FUnprocessedHitBoxData");
static_assert(offsetof(FUnprocessedHitBoxData, HitBoxData) == 0x000000, "Member 'FUnprocessedHitBoxData::HitBoxData' has a wrong offset!");
static_assert(offsetof(FUnprocessedHitBoxData, HitSource) == 0x0000A8, "Member 'FUnprocessedHitBoxData::HitSource' has a wrong offset!");
static_assert(offsetof(FUnprocessedHitBoxData, SourceId) == 0x0000B0, "Member 'FUnprocessedHitBoxData::SourceId' has a wrong offset!");
static_assert(offsetof(FUnprocessedHitBoxData, PreviousModifiedHitCenter) == 0x0000B8, "Member 'FUnprocessedHitBoxData::PreviousModifiedHitCenter' has a wrong offset!");
static_assert(offsetof(FUnprocessedHitBoxData, ModifiedHitCenter) == 0x0000D0, "Member 'FUnprocessedHitBoxData::ModifiedHitCenter' has a wrong offset!");
static_assert(offsetof(FUnprocessedHitBoxData, TimeToKeepInPreviousHitsList) == 0x0000E8, "Member 'FUnprocessedHitBoxData::TimeToKeepInPreviousHitsList' has a wrong offset!");

// ScriptStruct Matcha.FacingInfo
// 0x0078 (0x0078 - 0x0000)
struct FFacingInfo final
{
public:
	struct FSnapNetPropertyFloat                  Facing;                                            // 0x0000(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTime;                                         // 0x0040(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacingInfo) == 0x000008, "Wrong alignment on FFacingInfo");
static_assert(sizeof(FFacingInfo) == 0x000078, "Wrong size on FFacingInfo");
static_assert(offsetof(FFacingInfo, Facing) == 0x000000, "Member 'FFacingInfo::Facing' has a wrong offset!");
static_assert(offsetof(FFacingInfo, StartTime) == 0x000040, "Member 'FFacingInfo::StartTime' has a wrong offset!");

// ScriptStruct Matcha.AppliedHitInfo
// 0x0038 (0x0038 - 0x0000)
struct FAppliedHitInfo final
{
public:
	int32                                         StartTime;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitId;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceId;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MultiHitFrames;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  HitActor;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 HitSource;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AddedFrames;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppliedHitInfo) == 0x000008, "Wrong alignment on FAppliedHitInfo");
static_assert(sizeof(FAppliedHitInfo) == 0x000038, "Wrong size on FAppliedHitInfo");
static_assert(offsetof(FAppliedHitInfo, StartTime) == 0x000000, "Member 'FAppliedHitInfo::StartTime' has a wrong offset!");
static_assert(offsetof(FAppliedHitInfo, HitId) == 0x000004, "Member 'FAppliedHitInfo::HitId' has a wrong offset!");
static_assert(offsetof(FAppliedHitInfo, SourceId) == 0x000008, "Member 'FAppliedHitInfo::SourceId' has a wrong offset!");
static_assert(offsetof(FAppliedHitInfo, MultiHitFrames) == 0x00000C, "Member 'FAppliedHitInfo::MultiHitFrames' has a wrong offset!");
static_assert(offsetof(FAppliedHitInfo, HitActor) == 0x000010, "Member 'FAppliedHitInfo::HitActor' has a wrong offset!");
static_assert(offsetof(FAppliedHitInfo, HitSource) == 0x000018, "Member 'FAppliedHitInfo::HitSource' has a wrong offset!");
static_assert(offsetof(FAppliedHitInfo, RemainingTime) == 0x000020, "Member 'FAppliedHitInfo::RemainingTime' has a wrong offset!");
static_assert(offsetof(FAppliedHitInfo, AddedFrames) == 0x000028, "Member 'FAppliedHitInfo::AddedFrames' has a wrong offset!");

// ScriptStruct Matcha.MatchaPlayerIndex
// 0x0030 (0x0030 - 0x0000)
struct FMatchaPlayerIndex final
{
public:
	struct FSnapNetPropertyPlayerIndex            PlayerIndex;                                       // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaPlayerIndex) == 0x000008, "Wrong alignment on FMatchaPlayerIndex");
static_assert(sizeof(FMatchaPlayerIndex) == 0x000030, "Wrong size on FMatchaPlayerIndex");
static_assert(offsetof(FMatchaPlayerIndex, PlayerIndex) == 0x000000, "Member 'FMatchaPlayerIndex::PlayerIndex' has a wrong offset!");

// ScriptStruct Matcha.MatchaTeamNetworkState
// 0x00C0 (0x00C0 - 0x0000)
struct FMatchaTeamNetworkState final
{
public:
	struct FSnapNetPropertyInt32                  TeamNumber;                                        // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	TArray<struct FMatchaPlayerIndex>             PlayerIndices;                                     // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  FinishPlace;                                       // 0x0048(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  SurvivalSeconds;                                   // 0x0080(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaTeamNetworkState) == 0x000008, "Wrong alignment on FMatchaTeamNetworkState");
static_assert(sizeof(FMatchaTeamNetworkState) == 0x0000C0, "Wrong size on FMatchaTeamNetworkState");
static_assert(offsetof(FMatchaTeamNetworkState, TeamNumber) == 0x000000, "Member 'FMatchaTeamNetworkState::TeamNumber' has a wrong offset!");
static_assert(offsetof(FMatchaTeamNetworkState, PlayerIndices) == 0x000038, "Member 'FMatchaTeamNetworkState::PlayerIndices' has a wrong offset!");
static_assert(offsetof(FMatchaTeamNetworkState, FinishPlace) == 0x000048, "Member 'FMatchaTeamNetworkState::FinishPlace' has a wrong offset!");
static_assert(offsetof(FMatchaTeamNetworkState, SurvivalSeconds) == 0x000080, "Member 'FMatchaTeamNetworkState::SurvivalSeconds' has a wrong offset!");

// ScriptStruct Matcha.MatchaCharacterFlags
// 0x0018 (0x0018 - 0x0000)
struct FMatchaCharacterFlags final
{
public:
	bool                                          bMovementDisabled;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionsDisabled;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCancelMontageWhenLanding;                   // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIntangible;                                     // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSuperArmor;                                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPawnCollisionDisabled;                            // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGravityDisabled;                                  // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStartDash;                                     // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanWalkOffLedge;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanGrabLedge;                                     // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CounterAnimationId;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotatesTowardsHitOnCounter;                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LandingAnimationId;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaCharacterFlags) == 0x000004, "Wrong alignment on FMatchaCharacterFlags");
static_assert(sizeof(FMatchaCharacterFlags) == 0x000018, "Wrong size on FMatchaCharacterFlags");
static_assert(offsetof(FMatchaCharacterFlags, bMovementDisabled) == 0x000000, "Member 'FMatchaCharacterFlags::bMovementDisabled' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bActionsDisabled) == 0x000001, "Member 'FMatchaCharacterFlags::bActionsDisabled' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bShouldCancelMontageWhenLanding) == 0x000002, "Member 'FMatchaCharacterFlags::bShouldCancelMontageWhenLanding' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bIsIntangible) == 0x000003, "Member 'FMatchaCharacterFlags::bIsIntangible' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bEnableSuperArmor) == 0x000004, "Member 'FMatchaCharacterFlags::bEnableSuperArmor' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bPawnCollisionDisabled) == 0x000005, "Member 'FMatchaCharacterFlags::bPawnCollisionDisabled' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bGravityDisabled) == 0x000006, "Member 'FMatchaCharacterFlags::bGravityDisabled' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bCanStartDash) == 0x000007, "Member 'FMatchaCharacterFlags::bCanStartDash' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bCanWalkOffLedge) == 0x000008, "Member 'FMatchaCharacterFlags::bCanWalkOffLedge' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bCanGrabLedge) == 0x000009, "Member 'FMatchaCharacterFlags::bCanGrabLedge' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, CounterAnimationId) == 0x00000C, "Member 'FMatchaCharacterFlags::CounterAnimationId' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, bRotatesTowardsHitOnCounter) == 0x000010, "Member 'FMatchaCharacterFlags::bRotatesTowardsHitOnCounter' has a wrong offset!");
static_assert(offsetof(FMatchaCharacterFlags, LandingAnimationId) == 0x000014, "Member 'FMatchaCharacterFlags::LandingAnimationId' has a wrong offset!");

// ScriptStruct Matcha.CombinedFXInfo
// 0x0088 (0x0088 - 0x0000)
struct FCombinedFXInfo final
{
public:
	class FName                                   NiagaraSystemId;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttached;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTrackAttachedVFX;                           // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDestroyOnCancel;                            // 0x005D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AudioEventId;                                      // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFollowCharacter;                                  // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachName;                                        // 0x0074(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldStopOnCancel;                               // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CancelTransitionTimeMilliseconds;                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTrackAttachedSFX;                           // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCombinedFXInfo) == 0x000008, "Wrong alignment on FCombinedFXInfo");
static_assert(sizeof(FCombinedFXInfo) == 0x000088, "Wrong size on FCombinedFXInfo");
static_assert(offsetof(FCombinedFXInfo, NiagaraSystemId) == 0x000000, "Member 'FCombinedFXInfo::NiagaraSystemId' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, LocationOffset) == 0x000008, "Member 'FCombinedFXInfo::LocationOffset' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, RotationOffset) == 0x000020, "Member 'FCombinedFXInfo::RotationOffset' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, Scale) == 0x000038, "Member 'FCombinedFXInfo::Scale' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, bIsAttached) == 0x000050, "Member 'FCombinedFXInfo::bIsAttached' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, bAbsoluteScale) == 0x000051, "Member 'FCombinedFXInfo::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, SocketName) == 0x000054, "Member 'FCombinedFXInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, bShouldTrackAttachedVFX) == 0x00005C, "Member 'FCombinedFXInfo::bShouldTrackAttachedVFX' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, bShouldDestroyOnCancel) == 0x00005D, "Member 'FCombinedFXInfo::bShouldDestroyOnCancel' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, AudioEventId) == 0x000060, "Member 'FCombinedFXInfo::AudioEventId' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, Volume) == 0x000068, "Member 'FCombinedFXInfo::Volume' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, Pitch) == 0x00006C, "Member 'FCombinedFXInfo::Pitch' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, bFollowCharacter) == 0x000070, "Member 'FCombinedFXInfo::bFollowCharacter' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, AttachName) == 0x000074, "Member 'FCombinedFXInfo::AttachName' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, bShouldStopOnCancel) == 0x00007C, "Member 'FCombinedFXInfo::bShouldStopOnCancel' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, CancelTransitionTimeMilliseconds) == 0x000080, "Member 'FCombinedFXInfo::CancelTransitionTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FCombinedFXInfo, bShouldTrackAttachedSFX) == 0x000084, "Member 'FCombinedFXInfo::bShouldTrackAttachedSFX' has a wrong offset!");

// ScriptStruct Matcha.OverlappedEnvironmentHazard
// 0x0068 (0x0068 - 0x0000)
struct FOverlappedEnvironmentHazard final
{
public:
	struct FSnapNetPropertyEntityIndex            EnvironmentHazardEntityIndex;                      // 0x0000(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverlappedEnvironmentHazard) == 0x000008, "Wrong alignment on FOverlappedEnvironmentHazard");
static_assert(sizeof(FOverlappedEnvironmentHazard) == 0x000068, "Wrong size on FOverlappedEnvironmentHazard");
static_assert(offsetof(FOverlappedEnvironmentHazard, EnvironmentHazardEntityIndex) == 0x000000, "Member 'FOverlappedEnvironmentHazard::EnvironmentHazardEntityIndex' has a wrong offset!");

// ScriptStruct Matcha.DamageZoneCharacterTracking
// 0x0008 (0x0008 - 0x0000)
struct FDamageZoneCharacterTracking final
{
public:
	int32                                         CharacterEntityIndex;                              // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInZone;                                        // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageZoneCharacterTracking) == 0x000004, "Wrong alignment on FDamageZoneCharacterTracking");
static_assert(sizeof(FDamageZoneCharacterTracking) == 0x000008, "Wrong size on FDamageZoneCharacterTracking");
static_assert(offsetof(FDamageZoneCharacterTracking, CharacterEntityIndex) == 0x000000, "Member 'FDamageZoneCharacterTracking::CharacterEntityIndex' has a wrong offset!");
static_assert(offsetof(FDamageZoneCharacterTracking, TimeInZone) == 0x000004, "Member 'FDamageZoneCharacterTracking::TimeInZone' has a wrong offset!");

// ScriptStruct Matcha.TargetedGlitchDashSettings
// 0x0038 (0x0038 - 0x0000)
struct FTargetedGlitchDashSettings final
{
public:
	ETargetedGlitchDashTargetType                 TargetingType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CustomTarget;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetedGlitchDashFacingType                 TargetFacingType;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OffsetLocation;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirStallFramesBeforeTravel;                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FramesToReachTarget;                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageToPlayOnRequest;                            // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaCharacterMontageType                   MontageToPlayUponArrival;                          // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchaRootMotionType                         RootMotionToRequestUponArrival;                    // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetedGlitchDashSettings) == 0x000008, "Wrong alignment on FTargetedGlitchDashSettings");
static_assert(sizeof(FTargetedGlitchDashSettings) == 0x000038, "Wrong size on FTargetedGlitchDashSettings");
static_assert(offsetof(FTargetedGlitchDashSettings, TargetingType) == 0x000000, "Member 'FTargetedGlitchDashSettings::TargetingType' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashSettings, CustomTarget) == 0x000008, "Member 'FTargetedGlitchDashSettings::CustomTarget' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashSettings, TargetFacingType) == 0x000010, "Member 'FTargetedGlitchDashSettings::TargetFacingType' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashSettings, OffsetLocation) == 0x000018, "Member 'FTargetedGlitchDashSettings::OffsetLocation' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashSettings, AirStallFramesBeforeTravel) == 0x000028, "Member 'FTargetedGlitchDashSettings::AirStallFramesBeforeTravel' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashSettings, FramesToReachTarget) == 0x00002C, "Member 'FTargetedGlitchDashSettings::FramesToReachTarget' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashSettings, MontageToPlayOnRequest) == 0x000030, "Member 'FTargetedGlitchDashSettings::MontageToPlayOnRequest' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashSettings, MontageToPlayUponArrival) == 0x000031, "Member 'FTargetedGlitchDashSettings::MontageToPlayUponArrival' has a wrong offset!");
static_assert(offsetof(FTargetedGlitchDashSettings, RootMotionToRequestUponArrival) == 0x000032, "Member 'FTargetedGlitchDashSettings::RootMotionToRequestUponArrival' has a wrong offset!");

// ScriptStruct Matcha.SkeletalMeshAttachmentInfo
// 0x0028 (0x0028 - 0x0000)
struct FSkeletalMeshAttachmentInfo final
{
public:
	struct FSkeletalMeshInfo                      MeshInfo;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshAttachmentInfo) == 0x000008, "Wrong alignment on FSkeletalMeshAttachmentInfo");
static_assert(sizeof(FSkeletalMeshAttachmentInfo) == 0x000028, "Wrong size on FSkeletalMeshAttachmentInfo");
static_assert(offsetof(FSkeletalMeshAttachmentInfo, MeshInfo) == 0x000000, "Member 'FSkeletalMeshAttachmentInfo::MeshInfo' has a wrong offset!");

// ScriptStruct Matcha.SpecialTeleportSettings
// 0x0058 (0x0058 - 0x0000)
struct FSpecialTeleportSettings final
{
public:
	ETeleportSettingsType                         Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SetLocation;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetLocation;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCrossThroughBlocking;                          // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustDirectionAlongCloseSurfaces;                // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustmentCheckMinNormalAngle;                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldGrabLedgeIfOnTheWay;                        // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LedgeGrabExtentsMultiplier;                        // 0x0038(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleportsOthers;                                  // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TakenRadius;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTakePlayers;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTakeTeamMates;                                // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGlitchMarkFromItem;                             // 0x0052(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialTeleportSettings) == 0x000008, "Wrong alignment on FSpecialTeleportSettings");
static_assert(sizeof(FSpecialTeleportSettings) == 0x000058, "Wrong size on FSpecialTeleportSettings");
static_assert(offsetof(FSpecialTeleportSettings, Type) == 0x000000, "Member 'FSpecialTeleportSettings::Type' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, SetLocation) == 0x000008, "Member 'FSpecialTeleportSettings::SetLocation' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, OffsetLocation) == 0x000018, "Member 'FSpecialTeleportSettings::OffsetLocation' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, Distance) == 0x000028, "Member 'FSpecialTeleportSettings::Distance' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, bCanCrossThroughBlocking) == 0x00002C, "Member 'FSpecialTeleportSettings::bCanCrossThroughBlocking' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, bAdjustDirectionAlongCloseSurfaces) == 0x00002D, "Member 'FSpecialTeleportSettings::bAdjustDirectionAlongCloseSurfaces' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, AdjustmentCheckMinNormalAngle) == 0x000030, "Member 'FSpecialTeleportSettings::AdjustmentCheckMinNormalAngle' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, bShouldGrabLedgeIfOnTheWay) == 0x000034, "Member 'FSpecialTeleportSettings::bShouldGrabLedgeIfOnTheWay' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, LedgeGrabExtentsMultiplier) == 0x000038, "Member 'FSpecialTeleportSettings::LedgeGrabExtentsMultiplier' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, bTeleportsOthers) == 0x000048, "Member 'FSpecialTeleportSettings::bTeleportsOthers' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, TakenRadius) == 0x00004C, "Member 'FSpecialTeleportSettings::TakenRadius' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, bOnlyTakePlayers) == 0x000050, "Member 'FSpecialTeleportSettings::bOnlyTakePlayers' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, bOnlyTakeTeamMates) == 0x000051, "Member 'FSpecialTeleportSettings::bOnlyTakeTeamMates' has a wrong offset!");
static_assert(offsetof(FSpecialTeleportSettings, bIsGlitchMarkFromItem) == 0x000052, "Member 'FSpecialTeleportSettings::bIsGlitchMarkFromItem' has a wrong offset!");

// ScriptStruct Matcha.InteractionData
// 0x00A8 (0x00A8 - 0x0000)
struct FInteractionData final
{
public:
	struct FSnapNetPropertyEntityIndex            EntityIndex;                                       // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  InteractionProgress;                               // 0x0068(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionData) == 0x000008, "Wrong alignment on FInteractionData");
static_assert(sizeof(FInteractionData) == 0x0000A8, "Wrong size on FInteractionData");
static_assert(offsetof(FInteractionData, EntityIndex) == 0x000000, "Member 'FInteractionData::EntityIndex' has a wrong offset!");
static_assert(offsetof(FInteractionData, InteractionProgress) == 0x000068, "Member 'FInteractionData::InteractionProgress' has a wrong offset!");

// ScriptStruct Matcha.ItemGunAttributesInfo
// 0x0048 (0x0048 - 0x0000)
struct FItemGunAttributesInfo final
{
public:
	int32                                         FireRateInFrames;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnPositionOffset;                               // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DeployedEntity;                                    // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemGunAttributesInfo) == 0x000008, "Wrong alignment on FItemGunAttributesInfo");
static_assert(sizeof(FItemGunAttributesInfo) == 0x000048, "Wrong size on FItemGunAttributesInfo");
static_assert(offsetof(FItemGunAttributesInfo, FireRateInFrames) == 0x000000, "Member 'FItemGunAttributesInfo::FireRateInFrames' has a wrong offset!");
static_assert(offsetof(FItemGunAttributesInfo, SpawnPositionOffset) == 0x000008, "Member 'FItemGunAttributesInfo::SpawnPositionOffset' has a wrong offset!");
static_assert(offsetof(FItemGunAttributesInfo, DeployedEntity) == 0x000020, "Member 'FItemGunAttributesInfo::DeployedEntity' has a wrong offset!");

// ScriptStruct Matcha.ItemDeployEntityInfo
// 0x0048 (0x0048 - 0x0000)
struct FItemDeployEntityInfo final
{
public:
	bool                                          bSpawnAtFeet;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnPositionOffset;                               // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DeployedEntity;                                    // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDeployEntityInfo) == 0x000008, "Wrong alignment on FItemDeployEntityInfo");
static_assert(sizeof(FItemDeployEntityInfo) == 0x000048, "Wrong size on FItemDeployEntityInfo");
static_assert(offsetof(FItemDeployEntityInfo, bSpawnAtFeet) == 0x000000, "Member 'FItemDeployEntityInfo::bSpawnAtFeet' has a wrong offset!");
static_assert(offsetof(FItemDeployEntityInfo, SpawnPositionOffset) == 0x000008, "Member 'FItemDeployEntityInfo::SpawnPositionOffset' has a wrong offset!");
static_assert(offsetof(FItemDeployEntityInfo, DeployedEntity) == 0x000020, "Member 'FItemDeployEntityInfo::DeployedEntity' has a wrong offset!");

// ScriptStruct Matcha.MatchaKillFeedEntryNetworkState
// 0x0108 (0x0108 - 0x0000)
struct FMatchaKillFeedEntryNetworkState final
{
public:
	struct FSnapNetPropertyInt32                  KillFeedIndex;                                     // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyPlayerIndex            InstigatorPlayerIndex;                             // 0x0038(0x0030)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  InstigatorCharacterIndex;                          // 0x0068(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyPlayerIndex            TargetPlayerIndex;                                 // 0x00A0(0x0030)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  TargetCharacterIndex;                              // 0x00D0(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaKillFeedEntryNetworkState) == 0x000008, "Wrong alignment on FMatchaKillFeedEntryNetworkState");
static_assert(sizeof(FMatchaKillFeedEntryNetworkState) == 0x000108, "Wrong size on FMatchaKillFeedEntryNetworkState");
static_assert(offsetof(FMatchaKillFeedEntryNetworkState, KillFeedIndex) == 0x000000, "Member 'FMatchaKillFeedEntryNetworkState::KillFeedIndex' has a wrong offset!");
static_assert(offsetof(FMatchaKillFeedEntryNetworkState, InstigatorPlayerIndex) == 0x000038, "Member 'FMatchaKillFeedEntryNetworkState::InstigatorPlayerIndex' has a wrong offset!");
static_assert(offsetof(FMatchaKillFeedEntryNetworkState, InstigatorCharacterIndex) == 0x000068, "Member 'FMatchaKillFeedEntryNetworkState::InstigatorCharacterIndex' has a wrong offset!");
static_assert(offsetof(FMatchaKillFeedEntryNetworkState, TargetPlayerIndex) == 0x0000A0, "Member 'FMatchaKillFeedEntryNetworkState::TargetPlayerIndex' has a wrong offset!");
static_assert(offsetof(FMatchaKillFeedEntryNetworkState, TargetCharacterIndex) == 0x0000D0, "Member 'FMatchaKillFeedEntryNetworkState::TargetCharacterIndex' has a wrong offset!");

// ScriptStruct Matcha.MatchaKillFeedNetworkState
// 0x0010 (0x0010 - 0x0000)
struct FMatchaKillFeedNetworkState final
{
public:
	TArray<struct FMatchaKillFeedEntryNetworkState> Entries;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaKillFeedNetworkState) == 0x000008, "Wrong alignment on FMatchaKillFeedNetworkState");
static_assert(sizeof(FMatchaKillFeedNetworkState) == 0x000010, "Wrong size on FMatchaKillFeedNetworkState");
static_assert(offsetof(FMatchaKillFeedNetworkState, Entries) == 0x000000, "Member 'FMatchaKillFeedNetworkState::Entries' has a wrong offset!");

// ScriptStruct Matcha.BuffInfo
// 0x0010 (0x0010 - 0x0000)
struct FBuffInfo final
{
public:
	struct FGameplayTag                           BuffTag;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuffDurationInSeconds;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshDurationOnApplication;                     // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBuffInfo) == 0x000004, "Wrong alignment on FBuffInfo");
static_assert(sizeof(FBuffInfo) == 0x000010, "Wrong size on FBuffInfo");
static_assert(offsetof(FBuffInfo, BuffTag) == 0x000000, "Member 'FBuffInfo::BuffTag' has a wrong offset!");
static_assert(offsetof(FBuffInfo, BuffDurationInSeconds) == 0x000008, "Member 'FBuffInfo::BuffDurationInSeconds' has a wrong offset!");
static_assert(offsetof(FBuffInfo, bRefreshDurationOnApplication) == 0x00000C, "Member 'FBuffInfo::bRefreshDurationOnApplication' has a wrong offset!");

// ScriptStruct Matcha.StaticMeshAttachmentInfo
// 0x0028 (0x0028 - 0x0000)
struct FStaticMeshAttachmentInfo final
{
public:
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticMeshAttachmentInfo) == 0x000008, "Wrong alignment on FStaticMeshAttachmentInfo");
static_assert(sizeof(FStaticMeshAttachmentInfo) == 0x000028, "Wrong size on FStaticMeshAttachmentInfo");
static_assert(offsetof(FStaticMeshAttachmentInfo, Mesh) == 0x000000, "Member 'FStaticMeshAttachmentInfo::Mesh' has a wrong offset!");

// ScriptStruct Matcha.ReflectData
// 0x000C (0x000C - 0x0000)
struct FReflectData final
{
public:
	float                                         ReflectAngle;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplier;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReflectData) == 0x000004, "Wrong alignment on FReflectData");
static_assert(sizeof(FReflectData) == 0x00000C, "Wrong size on FReflectData");
static_assert(offsetof(FReflectData, ReflectAngle) == 0x000000, "Member 'FReflectData::ReflectAngle' has a wrong offset!");
static_assert(offsetof(FReflectData, SpeedMultiplier) == 0x000004, "Member 'FReflectData::SpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FReflectData, DamageMultiplier) == 0x000008, "Member 'FReflectData::DamageMultiplier' has a wrong offset!");

// ScriptStruct Matcha.SpawnEntityData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FSpawnEntityData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnEntityData) == 0x000008, "Wrong alignment on FSpawnEntityData");
static_assert(sizeof(FSpawnEntityData) == 0x000038, "Wrong size on FSpawnEntityData");

// ScriptStruct Matcha.WeakActorArray
// 0x0010 (0x0010 - 0x0000)
struct FWeakActorArray final
{
public:
	TArray<TWeakObjectPtr<class AActor>>          ActorArray;                                        // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeakActorArray) == 0x000008, "Wrong alignment on FWeakActorArray");
static_assert(sizeof(FWeakActorArray) == 0x000010, "Wrong size on FWeakActorArray");
static_assert(offsetof(FWeakActorArray, ActorArray) == 0x000000, "Member 'FWeakActorArray::ActorArray' has a wrong offset!");

// ScriptStruct Matcha.VFXInfo
// 0x01F8 (0x01F8 - 0x0000)
struct FVFXInfo final
{
public:
	struct FSnapNetPropertyString                 NiagaraSystemId;                                   // 0x0000(0x0030)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector                 LocationOffset;                                    // 0x0030(0x0080)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyRotator                RotationOffset;                                    // 0x00B0(0x0038)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector                 Scale;                                             // 0x00E8(0x0080)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bIsAttached;                                       // 0x0168(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bAbsoluteScale;                                    // 0x0180(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyString                 SocketName;                                        // 0x0198(0x0030)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldDestroyOnCancel;                            // 0x01C8(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldTrackAttachedVFX;                           // 0x01E0(0x0018)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVFXInfo) == 0x000008, "Wrong alignment on FVFXInfo");
static_assert(sizeof(FVFXInfo) == 0x0001F8, "Wrong size on FVFXInfo");
static_assert(offsetof(FVFXInfo, NiagaraSystemId) == 0x000000, "Member 'FVFXInfo::NiagaraSystemId' has a wrong offset!");
static_assert(offsetof(FVFXInfo, LocationOffset) == 0x000030, "Member 'FVFXInfo::LocationOffset' has a wrong offset!");
static_assert(offsetof(FVFXInfo, RotationOffset) == 0x0000B0, "Member 'FVFXInfo::RotationOffset' has a wrong offset!");
static_assert(offsetof(FVFXInfo, Scale) == 0x0000E8, "Member 'FVFXInfo::Scale' has a wrong offset!");
static_assert(offsetof(FVFXInfo, bIsAttached) == 0x000168, "Member 'FVFXInfo::bIsAttached' has a wrong offset!");
static_assert(offsetof(FVFXInfo, bAbsoluteScale) == 0x000180, "Member 'FVFXInfo::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(FVFXInfo, SocketName) == 0x000198, "Member 'FVFXInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FVFXInfo, bShouldDestroyOnCancel) == 0x0001C8, "Member 'FVFXInfo::bShouldDestroyOnCancel' has a wrong offset!");
static_assert(offsetof(FVFXInfo, bShouldTrackAttachedVFX) == 0x0001E0, "Member 'FVFXInfo::bShouldTrackAttachedVFX' has a wrong offset!");

// ScriptStruct Matcha.SFXInfo
// 0x0160 (0x0160 - 0x0000)
struct FSFXInfo final
{
public:
	struct FSnapNetPropertyString                 AudioEventId;                                      // 0x0000(0x0030)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  VolumeMultiplier;                                  // 0x0030(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  PitchMultiplier;                                   // 0x0070(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bFollow;                                           // 0x00B0(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyString                 SocketName;                                        // 0x00C8(0x0030)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldStopOnCancel;                               // 0x00F8(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  CancelTransitionTimeMilliseconds;                  // 0x0110(0x0038)(Transient, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldTrackAttachedSFX;                           // 0x0148(0x0018)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSFXInfo) == 0x000008, "Wrong alignment on FSFXInfo");
static_assert(sizeof(FSFXInfo) == 0x000160, "Wrong size on FSFXInfo");
static_assert(offsetof(FSFXInfo, AudioEventId) == 0x000000, "Member 'FSFXInfo::AudioEventId' has a wrong offset!");
static_assert(offsetof(FSFXInfo, VolumeMultiplier) == 0x000030, "Member 'FSFXInfo::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(FSFXInfo, PitchMultiplier) == 0x000070, "Member 'FSFXInfo::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(FSFXInfo, bFollow) == 0x0000B0, "Member 'FSFXInfo::bFollow' has a wrong offset!");
static_assert(offsetof(FSFXInfo, SocketName) == 0x0000C8, "Member 'FSFXInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FSFXInfo, bShouldStopOnCancel) == 0x0000F8, "Member 'FSFXInfo::bShouldStopOnCancel' has a wrong offset!");
static_assert(offsetof(FSFXInfo, CancelTransitionTimeMilliseconds) == 0x000110, "Member 'FSFXInfo::CancelTransitionTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FSFXInfo, bShouldTrackAttachedSFX) == 0x000148, "Member 'FSFXInfo::bShouldTrackAttachedSFX' has a wrong offset!");

// ScriptStruct Matcha.MatchaHitTrackingEntry
// 0x0008 (0x0008 - 0x0000)
struct FMatchaHitTrackingEntry final
{
public:
	int32                                         EntityIndexLastKnockBack;                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastKnockServerTimeSeconds;                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaHitTrackingEntry) == 0x000004, "Wrong alignment on FMatchaHitTrackingEntry");
static_assert(sizeof(FMatchaHitTrackingEntry) == 0x000008, "Wrong size on FMatchaHitTrackingEntry");
static_assert(offsetof(FMatchaHitTrackingEntry, EntityIndexLastKnockBack) == 0x000000, "Member 'FMatchaHitTrackingEntry::EntityIndexLastKnockBack' has a wrong offset!");
static_assert(offsetof(FMatchaHitTrackingEntry, LastKnockServerTimeSeconds) == 0x000004, "Member 'FMatchaHitTrackingEntry::LastKnockServerTimeSeconds' has a wrong offset!");

// ScriptStruct Matcha.MatchaServerCharacterSelectPlayerData
// 0x0078 (0x0078 - 0x0000)
struct FMatchaServerCharacterSelectPlayerData final
{
public:
	TSoftClassPtr<class UClass>                   CharacterEntityClass;                              // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HoveredCharacterEntityClass;                       // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PreferredCharacterEntityClass;                     // 0x0050(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaServerCharacterSelectPlayerData) == 0x000008, "Wrong alignment on FMatchaServerCharacterSelectPlayerData");
static_assert(sizeof(FMatchaServerCharacterSelectPlayerData) == 0x000078, "Wrong size on FMatchaServerCharacterSelectPlayerData");
static_assert(offsetof(FMatchaServerCharacterSelectPlayerData, CharacterEntityClass) == 0x000000, "Member 'FMatchaServerCharacterSelectPlayerData::CharacterEntityClass' has a wrong offset!");
static_assert(offsetof(FMatchaServerCharacterSelectPlayerData, HoveredCharacterEntityClass) == 0x000028, "Member 'FMatchaServerCharacterSelectPlayerData::HoveredCharacterEntityClass' has a wrong offset!");
static_assert(offsetof(FMatchaServerCharacterSelectPlayerData, PreferredCharacterEntityClass) == 0x000050, "Member 'FMatchaServerCharacterSelectPlayerData::PreferredCharacterEntityClass' has a wrong offset!");

// ScriptStruct Matcha.MatchaServerPlayerData
// 0x00D8 (0x00D8 - 0x0000)
struct FMatchaServerPlayerData final
{
public:
	class FName                                   PlayerId;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x2C];                                       // 0x000C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class AMatchaSnapNetPlayerEntity*             PlayerEntity;                                      // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMatchaSnapNetCharacterEntity*          CharacterEntity;                                   // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaServerCharacterSelectPlayerData CharacterSelectData;                               // 0x0048(0x0078)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FMatchaHitTrackingEntry>        HitHistory;                                        // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaServerPlayerData) == 0x000008, "Wrong alignment on FMatchaServerPlayerData");
static_assert(sizeof(FMatchaServerPlayerData) == 0x0000D8, "Wrong size on FMatchaServerPlayerData");
static_assert(offsetof(FMatchaServerPlayerData, PlayerId) == 0x000000, "Member 'FMatchaServerPlayerData::PlayerId' has a wrong offset!");
static_assert(offsetof(FMatchaServerPlayerData, PlayerIndex) == 0x000008, "Member 'FMatchaServerPlayerData::PlayerIndex' has a wrong offset!");
static_assert(offsetof(FMatchaServerPlayerData, PlayerEntity) == 0x000038, "Member 'FMatchaServerPlayerData::PlayerEntity' has a wrong offset!");
static_assert(offsetof(FMatchaServerPlayerData, CharacterEntity) == 0x000040, "Member 'FMatchaServerPlayerData::CharacterEntity' has a wrong offset!");
static_assert(offsetof(FMatchaServerPlayerData, CharacterSelectData) == 0x000048, "Member 'FMatchaServerPlayerData::CharacterSelectData' has a wrong offset!");
static_assert(offsetof(FMatchaServerPlayerData, HitHistory) == 0x0000C0, "Member 'FMatchaServerPlayerData::HitHistory' has a wrong offset!");

// ScriptStruct Matcha.MatchaGameLiftServerData
// 0x0030 (0x0030 - 0x0000)
struct FMatchaGameLiftServerData final
{
public:
	class FString                                 ServerAuthKey;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameId;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServicesHostname;                                  // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaGameLiftServerData) == 0x000008, "Wrong alignment on FMatchaGameLiftServerData");
static_assert(sizeof(FMatchaGameLiftServerData) == 0x000030, "Wrong size on FMatchaGameLiftServerData");
static_assert(offsetof(FMatchaGameLiftServerData, ServerAuthKey) == 0x000000, "Member 'FMatchaGameLiftServerData::ServerAuthKey' has a wrong offset!");
static_assert(offsetof(FMatchaGameLiftServerData, GameId) == 0x000010, "Member 'FMatchaGameLiftServerData::GameId' has a wrong offset!");
static_assert(offsetof(FMatchaGameLiftServerData, ServicesHostname) == 0x000020, "Member 'FMatchaGameLiftServerData::ServicesHostname' has a wrong offset!");

// ScriptStruct Matcha.MatchaProcessedHitInfo
// 0x00C8 (0x00C8 - 0x0000)
struct alignas(0x08) FMatchaProcessedHitInfo final
{
public:
	uint8                                         Pad_0[0xC8];                                       // 0x0000(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaProcessedHitInfo) == 0x000008, "Wrong alignment on FMatchaProcessedHitInfo");
static_assert(sizeof(FMatchaProcessedHitInfo) == 0x0000C8, "Wrong size on FMatchaProcessedHitInfo");

// ScriptStruct Matcha.MatchaInteractionRequirements
// 0x0008 (0x0008 - 0x0000)
struct FMatchaInteractionRequirements final
{
public:
	EMatchaInteractionTriggerMode                 TriggerMode;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationSeconds;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInteractionRequirements) == 0x000004, "Wrong alignment on FMatchaInteractionRequirements");
static_assert(sizeof(FMatchaInteractionRequirements) == 0x000008, "Wrong size on FMatchaInteractionRequirements");
static_assert(offsetof(FMatchaInteractionRequirements, TriggerMode) == 0x000000, "Member 'FMatchaInteractionRequirements::TriggerMode' has a wrong offset!");
static_assert(offsetof(FMatchaInteractionRequirements, DurationSeconds) == 0x000004, "Member 'FMatchaInteractionRequirements::DurationSeconds' has a wrong offset!");

// ScriptStruct Matcha.InteractionProgressData
// 0x0018 (0x0018 - 0x0000)
struct FInteractionProgressData final
{
public:
	struct FVector                                PromptLocation;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionProgressData) == 0x000008, "Wrong alignment on FInteractionProgressData");
static_assert(sizeof(FInteractionProgressData) == 0x000018, "Wrong size on FInteractionProgressData");
static_assert(offsetof(FInteractionProgressData, PromptLocation) == 0x000000, "Member 'FInteractionProgressData::PromptLocation' has a wrong offset!");

// ScriptStruct Matcha.EnvironmentOverlapResult
// 0x0010 (0x0010 - 0x0000)
struct FEnvironmentOverlapResult final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    Component;                                         // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentOverlapResult) == 0x000008, "Wrong alignment on FEnvironmentOverlapResult");
static_assert(sizeof(FEnvironmentOverlapResult) == 0x000010, "Wrong size on FEnvironmentOverlapResult");
static_assert(offsetof(FEnvironmentOverlapResult, Actor) == 0x000000, "Member 'FEnvironmentOverlapResult::Actor' has a wrong offset!");
static_assert(offsetof(FEnvironmentOverlapResult, Component) == 0x000008, "Member 'FEnvironmentOverlapResult::Component' has a wrong offset!");

// ScriptStruct Matcha.MatchaServerLatency
// 0x0028 (0x0028 - 0x0000)
struct FMatchaServerLatency final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Address;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTripSeconds;                                  // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaServerLatency) == 0x000008, "Wrong alignment on FMatchaServerLatency");
static_assert(sizeof(FMatchaServerLatency) == 0x000028, "Wrong size on FMatchaServerLatency");
static_assert(offsetof(FMatchaServerLatency, Name) == 0x000000, "Member 'FMatchaServerLatency::Name' has a wrong offset!");
static_assert(offsetof(FMatchaServerLatency, Address) == 0x000010, "Member 'FMatchaServerLatency::Address' has a wrong offset!");
static_assert(offsetof(FMatchaServerLatency, RoundTripSeconds) == 0x000020, "Member 'FMatchaServerLatency::RoundTripSeconds' has a wrong offset!");

// ScriptStruct Matcha.MatchaPingServersResult
// 0x0010 (0x0010 - 0x0000)
struct FMatchaPingServersResult final
{
public:
	TArray<struct FMatchaServerLatency>           ServerLatencies;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaPingServersResult) == 0x000008, "Wrong alignment on FMatchaPingServersResult");
static_assert(sizeof(FMatchaPingServersResult) == 0x000010, "Wrong size on FMatchaPingServersResult");
static_assert(offsetof(FMatchaPingServersResult, ServerLatencies) == 0x000000, "Member 'FMatchaPingServersResult::ServerLatencies' has a wrong offset!");

// ScriptStruct Matcha.MatchaKnockoutHitEntry
// 0x0010 (0x0010 - 0x0000)
struct FMatchaKnockoutHitEntry final
{
public:
	class AActor*                                 HitInstigator;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsSinceHit;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaKnockoutHitEntry) == 0x000008, "Wrong alignment on FMatchaKnockoutHitEntry");
static_assert(sizeof(FMatchaKnockoutHitEntry) == 0x000010, "Wrong size on FMatchaKnockoutHitEntry");
static_assert(offsetof(FMatchaKnockoutHitEntry, HitInstigator) == 0x000000, "Member 'FMatchaKnockoutHitEntry::HitInstigator' has a wrong offset!");
static_assert(offsetof(FMatchaKnockoutHitEntry, SecondsSinceHit) == 0x000008, "Member 'FMatchaKnockoutHitEntry::SecondsSinceHit' has a wrong offset!");

// ScriptStruct Matcha.MatchaKnockoutData
// 0x0010 (0x0010 - 0x0000)
struct FMatchaKnockoutData final
{
public:
	TArray<struct FMatchaKnockoutHitEntry>        HitHistory;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaKnockoutData) == 0x000008, "Wrong alignment on FMatchaKnockoutData");
static_assert(sizeof(FMatchaKnockoutData) == 0x000010, "Wrong size on FMatchaKnockoutData");
static_assert(offsetof(FMatchaKnockoutData, HitHistory) == 0x000000, "Member 'FMatchaKnockoutData::HitHistory' has a wrong offset!");

// ScriptStruct Matcha.MatchaTeamAssignment
// 0x0018 (0x0018 - 0x0000)
struct FMatchaTeamAssignment final
{
public:
	int32                                         TeamNumber;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PlayerIds;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaTeamAssignment) == 0x000008, "Wrong alignment on FMatchaTeamAssignment");
static_assert(sizeof(FMatchaTeamAssignment) == 0x000018, "Wrong size on FMatchaTeamAssignment");
static_assert(offsetof(FMatchaTeamAssignment, TeamNumber) == 0x000000, "Member 'FMatchaTeamAssignment::TeamNumber' has a wrong offset!");
static_assert(offsetof(FMatchaTeamAssignment, PlayerIds) == 0x000008, "Member 'FMatchaTeamAssignment::PlayerIds' has a wrong offset!");

// ScriptStruct Matcha.MatchaGameInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FMatchaGameInfo final
{
public:
	TArray<struct FMatchaTeamAssignment>          TeamAssignments;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MinimumPlayersToStart;                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FString>              PlayerNamesByPlayerId;                             // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	TSet<class FName>                             AdminPlayerIds;                                    // 0x0068(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaGameInfo) == 0x000008, "Wrong alignment on FMatchaGameInfo");
static_assert(sizeof(FMatchaGameInfo) == 0x0000B8, "Wrong size on FMatchaGameInfo");
static_assert(offsetof(FMatchaGameInfo, TeamAssignments) == 0x000000, "Member 'FMatchaGameInfo::TeamAssignments' has a wrong offset!");
static_assert(offsetof(FMatchaGameInfo, MinimumPlayersToStart) == 0x000010, "Member 'FMatchaGameInfo::MinimumPlayersToStart' has a wrong offset!");
static_assert(offsetof(FMatchaGameInfo, PlayerNamesByPlayerId) == 0x000018, "Member 'FMatchaGameInfo::PlayerNamesByPlayerId' has a wrong offset!");
static_assert(offsetof(FMatchaGameInfo, AdminPlayerIds) == 0x000068, "Member 'FMatchaGameInfo::AdminPlayerIds' has a wrong offset!");

// ScriptStruct Matcha.MatchaServerDebugOptions
// 0x000C (0x000C - 0x0000)
struct FMatchaServerDebugOptions final
{
public:
	bool                                          bAutoShuffleTeams;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayersPerTeam;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipSpawnSelection;                               // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaServerDebugOptions) == 0x000004, "Wrong alignment on FMatchaServerDebugOptions");
static_assert(sizeof(FMatchaServerDebugOptions) == 0x00000C, "Wrong size on FMatchaServerDebugOptions");
static_assert(offsetof(FMatchaServerDebugOptions, bAutoShuffleTeams) == 0x000000, "Member 'FMatchaServerDebugOptions::bAutoShuffleTeams' has a wrong offset!");
static_assert(offsetof(FMatchaServerDebugOptions, PlayersPerTeam) == 0x000004, "Member 'FMatchaServerDebugOptions::PlayersPerTeam' has a wrong offset!");
static_assert(offsetof(FMatchaServerDebugOptions, bSkipSpawnSelection) == 0x000008, "Member 'FMatchaServerDebugOptions::bSkipSpawnSelection' has a wrong offset!");

// ScriptStruct Matcha.MatchaApiV1GamesInfoTeamData
// 0x0018 (0x0018 - 0x0000)
struct FMatchaApiV1GamesInfoTeamData final
{
public:
	class FName                                   TeamID;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMatchaApiV1GamesInfoPartyData> Parties;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaApiV1GamesInfoTeamData) == 0x000008, "Wrong alignment on FMatchaApiV1GamesInfoTeamData");
static_assert(sizeof(FMatchaApiV1GamesInfoTeamData) == 0x000018, "Wrong size on FMatchaApiV1GamesInfoTeamData");
static_assert(offsetof(FMatchaApiV1GamesInfoTeamData, TeamID) == 0x000000, "Member 'FMatchaApiV1GamesInfoTeamData::TeamID' has a wrong offset!");
static_assert(offsetof(FMatchaApiV1GamesInfoTeamData, Parties) == 0x000008, "Member 'FMatchaApiV1GamesInfoTeamData::Parties' has a wrong offset!");

// ScriptStruct Matcha.MatchaApiV1GamesInfoGameSettings
// 0x0004 (0x0004 - 0x0000)
struct FMatchaApiV1GamesInfoGameSettings final
{
public:
	int32                                         MinimumPlayers;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaApiV1GamesInfoGameSettings) == 0x000004, "Wrong alignment on FMatchaApiV1GamesInfoGameSettings");
static_assert(sizeof(FMatchaApiV1GamesInfoGameSettings) == 0x000004, "Wrong size on FMatchaApiV1GamesInfoGameSettings");
static_assert(offsetof(FMatchaApiV1GamesInfoGameSettings, MinimumPlayers) == 0x000000, "Member 'FMatchaApiV1GamesInfoGameSettings::MinimumPlayers' has a wrong offset!");

// ScriptStruct Matcha.MatchaApiV1GamesInfoResponse
// 0x0030 (0x0030 - 0x0000)
struct FMatchaApiV1GamesInfoResponse final
{
public:
	class FString                                 GameId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Status;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaApiV1GamesInfoGameSettings      Settings;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchaApiV1GamesInfoTeamData>  Teams;                                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaApiV1GamesInfoResponse) == 0x000008, "Wrong alignment on FMatchaApiV1GamesInfoResponse");
static_assert(sizeof(FMatchaApiV1GamesInfoResponse) == 0x000030, "Wrong size on FMatchaApiV1GamesInfoResponse");
static_assert(offsetof(FMatchaApiV1GamesInfoResponse, GameId) == 0x000000, "Member 'FMatchaApiV1GamesInfoResponse::GameId' has a wrong offset!");
static_assert(offsetof(FMatchaApiV1GamesInfoResponse, Status) == 0x000010, "Member 'FMatchaApiV1GamesInfoResponse::Status' has a wrong offset!");
static_assert(offsetof(FMatchaApiV1GamesInfoResponse, Settings) == 0x000018, "Member 'FMatchaApiV1GamesInfoResponse::Settings' has a wrong offset!");
static_assert(offsetof(FMatchaApiV1GamesInfoResponse, Teams) == 0x000020, "Member 'FMatchaApiV1GamesInfoResponse::Teams' has a wrong offset!");

// ScriptStruct Matcha.MatchApiV1GameTeamEliminatedRequestBody
// 0x0020 (0x0020 - 0x0000)
struct FMatchApiV1GameTeamEliminatedRequestBody final
{
public:
	class FString                                 GameId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TeamNumber;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchApiV1GameTeamEliminatedRequestBody) == 0x000008, "Wrong alignment on FMatchApiV1GameTeamEliminatedRequestBody");
static_assert(sizeof(FMatchApiV1GameTeamEliminatedRequestBody) == 0x000020, "Wrong size on FMatchApiV1GameTeamEliminatedRequestBody");
static_assert(offsetof(FMatchApiV1GameTeamEliminatedRequestBody, GameId) == 0x000000, "Member 'FMatchApiV1GameTeamEliminatedRequestBody::GameId' has a wrong offset!");
static_assert(offsetof(FMatchApiV1GameTeamEliminatedRequestBody, TeamNumber) == 0x000010, "Member 'FMatchApiV1GameTeamEliminatedRequestBody::TeamNumber' has a wrong offset!");

// ScriptStruct Matcha.MatchApiV1GameTeamEliminatedResponseBody
// 0x0001 (0x0001 - 0x0000)
struct FMatchApiV1GameTeamEliminatedResponseBody final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchApiV1GameTeamEliminatedResponseBody) == 0x000001, "Wrong alignment on FMatchApiV1GameTeamEliminatedResponseBody");
static_assert(sizeof(FMatchApiV1GameTeamEliminatedResponseBody) == 0x000001, "Wrong size on FMatchApiV1GameTeamEliminatedResponseBody");

// ScriptStruct Matcha.HitEntityHitData
// 0x0008 (0x00B0 - 0x00A8)
struct FHitEntityHitData final : public FMatchaHitBoxData
{
public:
	int32                                         FramesUntilActivation;                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitEntityHitData) == 0x000008, "Wrong alignment on FHitEntityHitData");
static_assert(sizeof(FHitEntityHitData) == 0x0000B0, "Wrong size on FHitEntityHitData");
static_assert(offsetof(FHitEntityHitData, FramesUntilActivation) == 0x0000A8, "Member 'FHitEntityHitData::FramesUntilActivation' has a wrong offset!");

// ScriptStruct Matcha.AccessTokens
// 0x0020 (0x0020 - 0x0000)
struct FAccessTokens final
{
public:
	class FString                                 Jwt;                                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RefreshToken;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessTokens) == 0x000008, "Wrong alignment on FAccessTokens");
static_assert(sizeof(FAccessTokens) == 0x000020, "Wrong size on FAccessTokens");
static_assert(offsetof(FAccessTokens, Jwt) == 0x000000, "Member 'FAccessTokens::Jwt' has a wrong offset!");
static_assert(offsetof(FAccessTokens, RefreshToken) == 0x000010, "Member 'FAccessTokens::RefreshToken' has a wrong offset!");

// ScriptStruct Matcha.NativePlatformUserInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FNativePlatformUserInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNativePlatformUserInfo) == 0x000008, "Wrong alignment on FNativePlatformUserInfo");
static_assert(sizeof(FNativePlatformUserInfo) == 0x000020, "Wrong size on FNativePlatformUserInfo");

// ScriptStruct Matcha.LoginSteamRequestV1
// 0x0030 (0x0030 - 0x0000)
struct FLoginSteamRequestV1 final
{
public:
	class FString                                 AuthSessionTicket;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentGameLanguage;                               // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginSteamRequestV1) == 0x000008, "Wrong alignment on FLoginSteamRequestV1");
static_assert(sizeof(FLoginSteamRequestV1) == 0x000030, "Wrong size on FLoginSteamRequestV1");
static_assert(offsetof(FLoginSteamRequestV1, AuthSessionTicket) == 0x000000, "Member 'FLoginSteamRequestV1::AuthSessionTicket' has a wrong offset!");
static_assert(offsetof(FLoginSteamRequestV1, CurrentGameLanguage) == 0x000010, "Member 'FLoginSteamRequestV1::CurrentGameLanguage' has a wrong offset!");
static_assert(offsetof(FLoginSteamRequestV1, DisplayName) == 0x000020, "Member 'FLoginSteamRequestV1::DisplayName' has a wrong offset!");

// ScriptStruct Matcha.LoginTokenRequestV1
// 0x0010 (0x0010 - 0x0000)
struct FLoginTokenRequestV1 final
{
public:
	class FString                                 Token;                                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginTokenRequestV1) == 0x000008, "Wrong alignment on FLoginTokenRequestV1");
static_assert(sizeof(FLoginTokenRequestV1) == 0x000010, "Wrong size on FLoginTokenRequestV1");
static_assert(offsetof(FLoginTokenRequestV1, Token) == 0x000000, "Member 'FLoginTokenRequestV1::Token' has a wrong offset!");

// ScriptStruct Matcha.GetNameResponse
// 0x0010 (0x0010 - 0x0000)
struct FGetNameResponse final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetNameResponse) == 0x000008, "Wrong alignment on FGetNameResponse");
static_assert(sizeof(FGetNameResponse) == 0x000010, "Wrong size on FGetNameResponse");
static_assert(offsetof(FGetNameResponse, DisplayName) == 0x000000, "Member 'FGetNameResponse::DisplayName' has a wrong offset!");

// ScriptStruct Matcha.SetNameRequest
// 0x0010 (0x0010 - 0x0000)
struct FSetNameRequest final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetNameRequest) == 0x000008, "Wrong alignment on FSetNameRequest");
static_assert(sizeof(FSetNameRequest) == 0x000010, "Wrong size on FSetNameRequest");
static_assert(offsetof(FSetNameRequest, DisplayName) == 0x000000, "Member 'FSetNameRequest::DisplayName' has a wrong offset!");

// ScriptStruct Matcha.RegisterPlayerRequest
// 0x0020 (0x0020 - 0x0000)
struct FRegisterPlayerRequest final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelfRatingLevel;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegisterPlayerRequest) == 0x000008, "Wrong alignment on FRegisterPlayerRequest");
static_assert(sizeof(FRegisterPlayerRequest) == 0x000020, "Wrong size on FRegisterPlayerRequest");
static_assert(offsetof(FRegisterPlayerRequest, DisplayName) == 0x000000, "Member 'FRegisterPlayerRequest::DisplayName' has a wrong offset!");
static_assert(offsetof(FRegisterPlayerRequest, SelfRatingLevel) == 0x000010, "Member 'FRegisterPlayerRequest::SelfRatingLevel' has a wrong offset!");

// ScriptStruct Matcha.HelloWorldRequestBody
// 0x0010 (0x0010 - 0x0000)
struct FHelloWorldRequestBody final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHelloWorldRequestBody) == 0x000008, "Wrong alignment on FHelloWorldRequestBody");
static_assert(sizeof(FHelloWorldRequestBody) == 0x000010, "Wrong size on FHelloWorldRequestBody");
static_assert(offsetof(FHelloWorldRequestBody, Name) == 0x000000, "Member 'FHelloWorldRequestBody::Name' has a wrong offset!");

// ScriptStruct Matcha.HelloWorldResponseBody
// 0x0001 (0x0001 - 0x0000)
struct FHelloWorldResponseBody final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHelloWorldResponseBody) == 0x000001, "Wrong alignment on FHelloWorldResponseBody");
static_assert(sizeof(FHelloWorldResponseBody) == 0x000001, "Wrong size on FHelloWorldResponseBody");

// ScriptStruct Matcha.MatchaInventoryCategoryUIData_InitParams
// 0x0008 (0x0008 - 0x0000)
struct FMatchaInventoryCategoryUIData_InitParams final
{
public:
	struct FGameplayTag                           TypeTag;                                           // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInventoryCategoryUIData_InitParams) == 0x000004, "Wrong alignment on FMatchaInventoryCategoryUIData_InitParams");
static_assert(sizeof(FMatchaInventoryCategoryUIData_InitParams) == 0x000008, "Wrong size on FMatchaInventoryCategoryUIData_InitParams");
static_assert(offsetof(FMatchaInventoryCategoryUIData_InitParams, TypeTag) == 0x000000, "Member 'FMatchaInventoryCategoryUIData_InitParams::TypeTag' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventoryItemUIData_InitParams
// 0x0060 (0x0060 - 0x0000)
struct FMatchaInventoryItemUIData_InitParams final
{
public:
	class UMatchaInventoryUIData*                 PlayerInventoryUIData;                             // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchaInventoryItem                   InventoryItem;                                     // 0x0008(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInventoryItemUIData_InitParams) == 0x000008, "Wrong alignment on FMatchaInventoryItemUIData_InitParams");
static_assert(sizeof(FMatchaInventoryItemUIData_InitParams) == 0x000060, "Wrong size on FMatchaInventoryItemUIData_InitParams");
static_assert(offsetof(FMatchaInventoryItemUIData_InitParams, PlayerInventoryUIData) == 0x000000, "Member 'FMatchaInventoryItemUIData_InitParams::PlayerInventoryUIData' has a wrong offset!");
static_assert(offsetof(FMatchaInventoryItemUIData_InitParams, InventoryItem) == 0x000008, "Member 'FMatchaInventoryItemUIData_InitParams::InventoryItem' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventoryItemUIData_UpdateParams
// 0x0058 (0x0058 - 0x0000)
struct FMatchaInventoryItemUIData_UpdateParams final
{
public:
	struct FMatchaInventoryItem                   InventoryItem;                                     // 0x0000(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInventoryItemUIData_UpdateParams) == 0x000008, "Wrong alignment on FMatchaInventoryItemUIData_UpdateParams");
static_assert(sizeof(FMatchaInventoryItemUIData_UpdateParams) == 0x000058, "Wrong size on FMatchaInventoryItemUIData_UpdateParams");
static_assert(offsetof(FMatchaInventoryItemUIData_UpdateParams, InventoryItem) == 0x000000, "Member 'FMatchaInventoryItemUIData_UpdateParams::InventoryItem' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventorySlotUIData_InitParams
// 0x0100 (0x0100 - 0x0000)
struct FMatchaInventorySlotUIData_InitParams final
{
public:
	struct FMatchaInventorySlot                   InventorySlot;                                     // 0x0000(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaInventorySlotUIData_InitParams) == 0x000008, "Wrong alignment on FMatchaInventorySlotUIData_InitParams");
static_assert(sizeof(FMatchaInventorySlotUIData_InitParams) == 0x000100, "Wrong size on FMatchaInventorySlotUIData_InitParams");
static_assert(offsetof(FMatchaInventorySlotUIData_InitParams, InventorySlot) == 0x000000, "Member 'FMatchaInventorySlotUIData_InitParams::InventorySlot' has a wrong offset!");

// ScriptStruct Matcha.MatchaInventoryTransaction
// 0x0058 (0x0058 - 0x0000)
struct FMatchaInventoryTransaction final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaInventoryComponent*              InventoryComponent;                                // 0x0020(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorMessage;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaInventoryTransaction) == 0x000008, "Wrong alignment on FMatchaInventoryTransaction");
static_assert(sizeof(FMatchaInventoryTransaction) == 0x000058, "Wrong size on FMatchaInventoryTransaction");
static_assert(offsetof(FMatchaInventoryTransaction, InventoryComponent) == 0x000020, "Member 'FMatchaInventoryTransaction::InventoryComponent' has a wrong offset!");
static_assert(offsetof(FMatchaInventoryTransaction, ErrorMessage) == 0x000028, "Member 'FMatchaInventoryTransaction::ErrorMessage' has a wrong offset!");

// ScriptStruct Matcha.GetGameLeaderboardV1Response_Paging
// 0x000C (0x000C - 0x0000)
struct FGetGameLeaderboardV1Response_Paging final
{
public:
	int32                                         StartRank;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageSize;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalItems;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetGameLeaderboardV1Response_Paging) == 0x000004, "Wrong alignment on FGetGameLeaderboardV1Response_Paging");
static_assert(sizeof(FGetGameLeaderboardV1Response_Paging) == 0x00000C, "Wrong size on FGetGameLeaderboardV1Response_Paging");
static_assert(offsetof(FGetGameLeaderboardV1Response_Paging, StartRank) == 0x000000, "Member 'FGetGameLeaderboardV1Response_Paging::StartRank' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response_Paging, PageSize) == 0x000004, "Member 'FGetGameLeaderboardV1Response_Paging::PageSize' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response_Paging, TotalItems) == 0x000008, "Member 'FGetGameLeaderboardV1Response_Paging::TotalItems' has a wrong offset!");

// ScriptStruct Matcha.GetGameLeaderboardV1Response_Entry
// 0x0040 (0x0040 - 0x0000)
struct FGetGameLeaderboardV1Response_Entry final
{
public:
	int32                                         Rank;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerId;                                          // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Points;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Knockouts;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wins;                                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetGameLeaderboardV1Response_Entry) == 0x000008, "Wrong alignment on FGetGameLeaderboardV1Response_Entry");
static_assert(sizeof(FGetGameLeaderboardV1Response_Entry) == 0x000040, "Wrong size on FGetGameLeaderboardV1Response_Entry");
static_assert(offsetof(FGetGameLeaderboardV1Response_Entry, Rank) == 0x000000, "Member 'FGetGameLeaderboardV1Response_Entry::Rank' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response_Entry, PlayerId) == 0x000004, "Member 'FGetGameLeaderboardV1Response_Entry::PlayerId' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response_Entry, PlayerName) == 0x000010, "Member 'FGetGameLeaderboardV1Response_Entry::PlayerName' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response_Entry, CharacterId) == 0x000020, "Member 'FGetGameLeaderboardV1Response_Entry::CharacterId' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response_Entry, Points) == 0x000030, "Member 'FGetGameLeaderboardV1Response_Entry::Points' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response_Entry, Knockouts) == 0x000034, "Member 'FGetGameLeaderboardV1Response_Entry::Knockouts' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response_Entry, Wins) == 0x000038, "Member 'FGetGameLeaderboardV1Response_Entry::Wins' has a wrong offset!");

// ScriptStruct Matcha.GetGameLeaderboardV1Response
// 0x0020 (0x0020 - 0x0000)
struct FGetGameLeaderboardV1Response final
{
public:
	TArray<struct FGetGameLeaderboardV1Response_Entry> Entries;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGetGameLeaderboardV1Response_Paging   Paging;                                            // 0x0010(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetGameLeaderboardV1Response) == 0x000008, "Wrong alignment on FGetGameLeaderboardV1Response");
static_assert(sizeof(FGetGameLeaderboardV1Response) == 0x000020, "Wrong size on FGetGameLeaderboardV1Response");
static_assert(offsetof(FGetGameLeaderboardV1Response, Entries) == 0x000000, "Member 'FGetGameLeaderboardV1Response::Entries' has a wrong offset!");
static_assert(offsetof(FGetGameLeaderboardV1Response, Paging) == 0x000010, "Member 'FGetGameLeaderboardV1Response::Paging' has a wrong offset!");

// ScriptStruct Matcha.CategoryLootTableItem
// 0x0038 (0x0038 - 0x0000)
struct FCategoryLootTableItem final
{
public:
	bool                                          bIsNoDrop;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchaItemAsset*                       ItemDataAsset;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EstimatedDropChance;                               // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            DropAmountRange;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCategoryLootTableItem) == 0x000008, "Wrong alignment on FCategoryLootTableItem");
static_assert(sizeof(FCategoryLootTableItem) == 0x000038, "Wrong size on FCategoryLootTableItem");
static_assert(offsetof(FCategoryLootTableItem, bIsNoDrop) == 0x000000, "Member 'FCategoryLootTableItem::bIsNoDrop' has a wrong offset!");
static_assert(offsetof(FCategoryLootTableItem, ItemDataAsset) == 0x000008, "Member 'FCategoryLootTableItem::ItemDataAsset' has a wrong offset!");
static_assert(offsetof(FCategoryLootTableItem, Weight) == 0x000010, "Member 'FCategoryLootTableItem::Weight' has a wrong offset!");
static_assert(offsetof(FCategoryLootTableItem, EstimatedDropChance) == 0x000018, "Member 'FCategoryLootTableItem::EstimatedDropChance' has a wrong offset!");
static_assert(offsetof(FCategoryLootTableItem, DropAmountRange) == 0x000028, "Member 'FCategoryLootTableItem::DropAmountRange' has a wrong offset!");

// ScriptStruct Matcha.CategoryLootTable
// 0x0020 (0x0020 - 0x0000)
struct FCategoryLootTable final
{
public:
	struct FGameplayTag                           ItemCategory;                                      // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalWeight;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCategoryLootTableItem>         Items;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCategoryLootTable) == 0x000008, "Wrong alignment on FCategoryLootTable");
static_assert(sizeof(FCategoryLootTable) == 0x000020, "Wrong size on FCategoryLootTable");
static_assert(offsetof(FCategoryLootTable, ItemCategory) == 0x000000, "Member 'FCategoryLootTable::ItemCategory' has a wrong offset!");
static_assert(offsetof(FCategoryLootTable, TotalWeight) == 0x000008, "Member 'FCategoryLootTable::TotalWeight' has a wrong offset!");
static_assert(offsetof(FCategoryLootTable, Items) == 0x000010, "Member 'FCategoryLootTable::Items' has a wrong offset!");

// ScriptStruct Matcha.ReceivedPartyInvite
// 0x0010 (0x0010 - 0x0000)
struct FReceivedPartyInvite final
{
public:
	class FName                                   SendingPlayerId;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PartyId;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReceivedPartyInvite) == 0x000004, "Wrong alignment on FReceivedPartyInvite");
static_assert(sizeof(FReceivedPartyInvite) == 0x000010, "Wrong size on FReceivedPartyInvite");
static_assert(offsetof(FReceivedPartyInvite, SendingPlayerId) == 0x000000, "Member 'FReceivedPartyInvite::SendingPlayerId' has a wrong offset!");
static_assert(offsetof(FReceivedPartyInvite, PartyId) == 0x000008, "Member 'FReceivedPartyInvite::PartyId' has a wrong offset!");

// ScriptStruct Matcha.SentPartyInvite
// 0x0008 (0x0008 - 0x0000)
struct FSentPartyInvite final
{
public:
	class FName                                   ReceivingPlayerId;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSentPartyInvite) == 0x000004, "Wrong alignment on FSentPartyInvite");
static_assert(sizeof(FSentPartyInvite) == 0x000008, "Wrong size on FSentPartyInvite");
static_assert(offsetof(FSentPartyInvite, ReceivingPlayerId) == 0x000000, "Member 'FSentPartyInvite::ReceivingPlayerId' has a wrong offset!");

// ScriptStruct Matcha.PartyInvite
// 0x0018 (0x0018 - 0x0000)
struct FPartyInvite final
{
public:
	class FName                                   PartyId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SendingPlayerId;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReceivingPlayerId;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartyInvite) == 0x000004, "Wrong alignment on FPartyInvite");
static_assert(sizeof(FPartyInvite) == 0x000018, "Wrong size on FPartyInvite");
static_assert(offsetof(FPartyInvite, PartyId) == 0x000000, "Member 'FPartyInvite::PartyId' has a wrong offset!");
static_assert(offsetof(FPartyInvite, SendingPlayerId) == 0x000008, "Member 'FPartyInvite::SendingPlayerId' has a wrong offset!");
static_assert(offsetof(FPartyInvite, ReceivingPlayerId) == 0x000010, "Member 'FPartyInvite::ReceivingPlayerId' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketServicesPartyStateMessage
// 0x0088 (0x0090 - 0x0008)
struct FMatchaWebSocketServicesPartyStateMessage final : public FMatchaServicesWebSocketMessageBase
{
public:
	struct FPlayerParty                           Data;                                              // 0x0008(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketServicesPartyStateMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketServicesPartyStateMessage");
static_assert(sizeof(FMatchaWebSocketServicesPartyStateMessage) == 0x000090, "Wrong size on FMatchaWebSocketServicesPartyStateMessage");
static_assert(offsetof(FMatchaWebSocketServicesPartyStateMessage, Data) == 0x000008, "Member 'FMatchaWebSocketServicesPartyStateMessage::Data' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketSentInvitesMessageData
// 0x0020 (0x0020 - 0x0000)
struct FMatchaWebSocketSentInvitesMessageData final
{
public:
	class FString                                 Timestamp;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPartyInvite>                   Invites;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketSentInvitesMessageData) == 0x000008, "Wrong alignment on FMatchaWebSocketSentInvitesMessageData");
static_assert(sizeof(FMatchaWebSocketSentInvitesMessageData) == 0x000020, "Wrong size on FMatchaWebSocketSentInvitesMessageData");
static_assert(offsetof(FMatchaWebSocketSentInvitesMessageData, Timestamp) == 0x000000, "Member 'FMatchaWebSocketSentInvitesMessageData::Timestamp' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketSentInvitesMessageData, Invites) == 0x000010, "Member 'FMatchaWebSocketSentInvitesMessageData::Invites' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketReceivedInvitesMessageData
// 0x0020 (0x0020 - 0x0000)
struct FMatchaWebSocketReceivedInvitesMessageData final
{
public:
	class FString                                 Timestamp;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FReceivedPartyInvite>           Invites;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketReceivedInvitesMessageData) == 0x000008, "Wrong alignment on FMatchaWebSocketReceivedInvitesMessageData");
static_assert(sizeof(FMatchaWebSocketReceivedInvitesMessageData) == 0x000020, "Wrong size on FMatchaWebSocketReceivedInvitesMessageData");
static_assert(offsetof(FMatchaWebSocketReceivedInvitesMessageData, Timestamp) == 0x000000, "Member 'FMatchaWebSocketReceivedInvitesMessageData::Timestamp' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketReceivedInvitesMessageData, Invites) == 0x000010, "Member 'FMatchaWebSocketReceivedInvitesMessageData::Invites' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketServicesReceivedInvitesMessage
// 0x0020 (0x0028 - 0x0008)
struct FMatchaWebSocketServicesReceivedInvitesMessage final : public FMatchaServicesWebSocketMessageBase
{
public:
	struct FMatchaWebSocketReceivedInvitesMessageData Data;                                              // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketServicesReceivedInvitesMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketServicesReceivedInvitesMessage");
static_assert(sizeof(FMatchaWebSocketServicesReceivedInvitesMessage) == 0x000028, "Wrong size on FMatchaWebSocketServicesReceivedInvitesMessage");
static_assert(offsetof(FMatchaWebSocketServicesReceivedInvitesMessage, Data) == 0x000008, "Member 'FMatchaWebSocketServicesReceivedInvitesMessage::Data' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketServicesSentInvitesMessage
// 0x0020 (0x0028 - 0x0008)
struct FMatchaWebSocketServicesSentInvitesMessage final : public FMatchaServicesWebSocketMessageBase
{
public:
	struct FMatchaWebSocketSentInvitesMessageData Data;                                              // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketServicesSentInvitesMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketServicesSentInvitesMessage");
static_assert(sizeof(FMatchaWebSocketServicesSentInvitesMessage) == 0x000028, "Wrong size on FMatchaWebSocketServicesSentInvitesMessage");
static_assert(offsetof(FMatchaWebSocketServicesSentInvitesMessage, Data) == 0x000008, "Member 'FMatchaWebSocketServicesSentInvitesMessage::Data' has a wrong offset!");

// ScriptStruct Matcha.GetSentInvitesResponse
// 0x0010 (0x0010 - 0x0000)
struct FGetSentInvitesResponse final
{
public:
	TArray<struct FSentPartyInvite>               Invites;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetSentInvitesResponse) == 0x000008, "Wrong alignment on FGetSentInvitesResponse");
static_assert(sizeof(FGetSentInvitesResponse) == 0x000010, "Wrong size on FGetSentInvitesResponse");
static_assert(offsetof(FGetSentInvitesResponse, Invites) == 0x000000, "Member 'FGetSentInvitesResponse::Invites' has a wrong offset!");

// ScriptStruct Matcha.GetReceivedInvitesResponse
// 0x0010 (0x0010 - 0x0000)
struct FGetReceivedInvitesResponse final
{
public:
	TArray<struct FReceivedPartyInvite>           Invites;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetReceivedInvitesResponse) == 0x000008, "Wrong alignment on FGetReceivedInvitesResponse");
static_assert(sizeof(FGetReceivedInvitesResponse) == 0x000010, "Wrong size on FGetReceivedInvitesResponse");
static_assert(offsetof(FGetReceivedInvitesResponse, Invites) == 0x000000, "Member 'FGetReceivedInvitesResponse::Invites' has a wrong offset!");

// ScriptStruct Matcha.AcceptInviteRequest
// 0x0018 (0x0018 - 0x0000)
struct FAcceptInviteRequest final
{
public:
	class FName                                   SendingPlayerId;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SendingPlayerName;                                 // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAcceptInviteRequest) == 0x000008, "Wrong alignment on FAcceptInviteRequest");
static_assert(sizeof(FAcceptInviteRequest) == 0x000018, "Wrong size on FAcceptInviteRequest");
static_assert(offsetof(FAcceptInviteRequest, SendingPlayerId) == 0x000000, "Member 'FAcceptInviteRequest::SendingPlayerId' has a wrong offset!");
static_assert(offsetof(FAcceptInviteRequest, SendingPlayerName) == 0x000008, "Member 'FAcceptInviteRequest::SendingPlayerName' has a wrong offset!");

// ScriptStruct Matcha.AcceptInviteResponse
// 0x0001 (0x0001 - 0x0000)
struct FAcceptInviteResponse final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAcceptInviteResponse) == 0x000001, "Wrong alignment on FAcceptInviteResponse");
static_assert(sizeof(FAcceptInviteResponse) == 0x000001, "Wrong size on FAcceptInviteResponse");

// ScriptStruct Matcha.RejectInviteRequest
// 0x0008 (0x0008 - 0x0000)
struct FRejectInviteRequest final
{
public:
	class FName                                   SendingPlayerId;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRejectInviteRequest) == 0x000004, "Wrong alignment on FRejectInviteRequest");
static_assert(sizeof(FRejectInviteRequest) == 0x000008, "Wrong size on FRejectInviteRequest");
static_assert(offsetof(FRejectInviteRequest, SendingPlayerId) == 0x000000, "Member 'FRejectInviteRequest::SendingPlayerId' has a wrong offset!");

// ScriptStruct Matcha.RejectInviteResponse
// 0x0001 (0x0001 - 0x0000)
struct FRejectInviteResponse final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRejectInviteResponse) == 0x000001, "Wrong alignment on FRejectInviteResponse");
static_assert(sizeof(FRejectInviteResponse) == 0x000001, "Wrong size on FRejectInviteResponse");

// ScriptStruct Matcha.SendInviteRequest
// 0x0010 (0x0010 - 0x0000)
struct FSendInviteRequest final
{
public:
	class FString                                 ReceivingPlayerName;                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSendInviteRequest) == 0x000008, "Wrong alignment on FSendInviteRequest");
static_assert(sizeof(FSendInviteRequest) == 0x000010, "Wrong size on FSendInviteRequest");
static_assert(offsetof(FSendInviteRequest, ReceivingPlayerName) == 0x000000, "Member 'FSendInviteRequest::ReceivingPlayerName' has a wrong offset!");

// ScriptStruct Matcha.CancelInviteRequest
// 0x0008 (0x0008 - 0x0000)
struct FCancelInviteRequest final
{
public:
	class FName                                   ReceivingPlayerId;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCancelInviteRequest) == 0x000004, "Wrong alignment on FCancelInviteRequest");
static_assert(sizeof(FCancelInviteRequest) == 0x000008, "Wrong size on FCancelInviteRequest");
static_assert(offsetof(FCancelInviteRequest, ReceivingPlayerId) == 0x000000, "Member 'FCancelInviteRequest::ReceivingPlayerId' has a wrong offset!");

// ScriptStruct Matcha.CancelInviteResponse
// 0x0001 (0x0001 - 0x0000)
struct FCancelInviteResponse final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCancelInviteResponse) == 0x000001, "Wrong alignment on FCancelInviteResponse");
static_assert(sizeof(FCancelInviteResponse) == 0x000001, "Wrong size on FCancelInviteResponse");

// ScriptStruct Matcha.LeavePartyResponseV1
// 0x0088 (0x0088 - 0x0000)
struct FLeavePartyResponseV1 final
{
public:
	struct FPlayerParty                           NewParty;                                          // 0x0000(0x0088)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeavePartyResponseV1) == 0x000008, "Wrong alignment on FLeavePartyResponseV1");
static_assert(sizeof(FLeavePartyResponseV1) == 0x000088, "Wrong size on FLeavePartyResponseV1");
static_assert(offsetof(FLeavePartyResponseV1, NewParty) == 0x000000, "Member 'FLeavePartyResponseV1::NewParty' has a wrong offset!");

// ScriptStruct Matcha.PartyQueueRequestV1
// 0x0008 (0x0008 - 0x0000)
struct FPartyQueueRequestV1 final
{
public:
	class FName                                   QueueId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartyQueueRequestV1) == 0x000004, "Wrong alignment on FPartyQueueRequestV1");
static_assert(sizeof(FPartyQueueRequestV1) == 0x000008, "Wrong size on FPartyQueueRequestV1");
static_assert(offsetof(FPartyQueueRequestV1, QueueId) == 0x000000, "Member 'FPartyQueueRequestV1::QueueId' has a wrong offset!");

// ScriptStruct Matcha.QueuesAvailableResponseV1Entry
// 0x0018 (0x0018 - 0x0000)
struct FQueuesAvailableResponseV1Entry final
{
public:
	class FName                                   QueueId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueuesAvailableResponseV1Entry) == 0x000008, "Wrong alignment on FQueuesAvailableResponseV1Entry");
static_assert(sizeof(FQueuesAvailableResponseV1Entry) == 0x000018, "Wrong size on FQueuesAvailableResponseV1Entry");
static_assert(offsetof(FQueuesAvailableResponseV1Entry, QueueId) == 0x000000, "Member 'FQueuesAvailableResponseV1Entry::QueueId' has a wrong offset!");
static_assert(offsetof(FQueuesAvailableResponseV1Entry, Name) == 0x000008, "Member 'FQueuesAvailableResponseV1Entry::Name' has a wrong offset!");

// ScriptStruct Matcha.QueuesAvailableResponseV1
// 0x0010 (0x0010 - 0x0000)
struct FQueuesAvailableResponseV1 final
{
public:
	TArray<struct FQueuesAvailableResponseV1Entry> Queues;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueuesAvailableResponseV1) == 0x000008, "Wrong alignment on FQueuesAvailableResponseV1");
static_assert(sizeof(FQueuesAvailableResponseV1) == 0x000010, "Wrong size on FQueuesAvailableResponseV1");
static_assert(offsetof(FQueuesAvailableResponseV1, Queues) == 0x000000, "Member 'FQueuesAvailableResponseV1::Queues' has a wrong offset!");

// ScriptStruct Matcha.MatchaPlayerProfileUIData_InitParams
// 0x0008 (0x0008 - 0x0000)
struct FMatchaPlayerProfileUIData_InitParams final
{
public:
	class FName                                   PlayerId;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaPlayerProfileUIData_InitParams) == 0x000004, "Wrong alignment on FMatchaPlayerProfileUIData_InitParams");
static_assert(sizeof(FMatchaPlayerProfileUIData_InitParams) == 0x000008, "Wrong size on FMatchaPlayerProfileUIData_InitParams");
static_assert(offsetof(FMatchaPlayerProfileUIData_InitParams, PlayerId) == 0x000000, "Member 'FMatchaPlayerProfileUIData_InitParams::PlayerId' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketServicesPlayerProfileMessage
// 0x0030 (0x0038 - 0x0008)
struct FMatchaWebSocketServicesPlayerProfileMessage final : public FMatchaServicesWebSocketMessageBase
{
public:
	struct FMatchaWebSocketPlayerProfileMessageData Data;                                              // 0x0008(0x0030)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketServicesPlayerProfileMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketServicesPlayerProfileMessage");
static_assert(sizeof(FMatchaWebSocketServicesPlayerProfileMessage) == 0x000038, "Wrong size on FMatchaWebSocketServicesPlayerProfileMessage");
static_assert(offsetof(FMatchaWebSocketServicesPlayerProfileMessage, Data) == 0x000008, "Member 'FMatchaWebSocketServicesPlayerProfileMessage::Data' has a wrong offset!");

// ScriptStruct Matcha.MatchaPlayerProfilesV1ResponseBody
// 0x0010 (0x0010 - 0x0000)
struct FMatchaPlayerProfilesV1ResponseBody final
{
public:
	TArray<struct FMatchaPlayerProfileV1>         PlayerProfiles;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaPlayerProfilesV1ResponseBody) == 0x000008, "Wrong alignment on FMatchaPlayerProfilesV1ResponseBody");
static_assert(sizeof(FMatchaPlayerProfilesV1ResponseBody) == 0x000010, "Wrong size on FMatchaPlayerProfilesV1ResponseBody");
static_assert(offsetof(FMatchaPlayerProfilesV1ResponseBody, PlayerProfiles) == 0x000000, "Member 'FMatchaPlayerProfilesV1ResponseBody::PlayerProfiles' has a wrong offset!");

// ScriptStruct Matcha.RegionLatencyV1
// 0x0018 (0x0018 - 0x0000)
struct FRegionLatencyV1 final
{
public:
	class FString                                 Region;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Latency;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegionLatencyV1) == 0x000008, "Wrong alignment on FRegionLatencyV1");
static_assert(sizeof(FRegionLatencyV1) == 0x000018, "Wrong size on FRegionLatencyV1");
static_assert(offsetof(FRegionLatencyV1, Region) == 0x000000, "Member 'FRegionLatencyV1::Region' has a wrong offset!");
static_assert(offsetof(FRegionLatencyV1, Latency) == 0x000010, "Member 'FRegionLatencyV1::Latency' has a wrong offset!");

// ScriptStruct Matcha.UpdateLatenciesV1RequestBody
// 0x0010 (0x0010 - 0x0000)
struct FUpdateLatenciesV1RequestBody final
{
public:
	TArray<struct FRegionLatencyV1>               Latencies;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpdateLatenciesV1RequestBody) == 0x000008, "Wrong alignment on FUpdateLatenciesV1RequestBody");
static_assert(sizeof(FUpdateLatenciesV1RequestBody) == 0x000010, "Wrong size on FUpdateLatenciesV1RequestBody");
static_assert(offsetof(FUpdateLatenciesV1RequestBody, Latencies) == 0x000000, "Member 'FUpdateLatenciesV1RequestBody::Latencies' has a wrong offset!");

// ScriptStruct Matcha.AppliedKnockBackInfo
// 0x0260 (0x0260 - 0x0000)
struct FAppliedKnockBackInfo final
{
public:
	struct FSnapNetPropertyPosition               InitialLocation;                                   // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVelocity               InitialVelocity;                                   // 0x0048(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  Acceleration;                                      // 0x0080(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  Gravity;                                           // 0x00C0(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  GravityLerpRatio;                                  // 0x0100(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  RootMotionDuration;                                // 0x0140(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  RootMotionRemainingTime;                           // 0x0180(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  HitStunDuration;                                   // 0x01C0(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldTumble;                                     // 0x0200(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldSpike;                                      // 0x0218(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bShouldBalloon;                                    // 0x0230(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bIsLethal;                                         // 0x0248(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppliedKnockBackInfo) == 0x000008, "Wrong alignment on FAppliedKnockBackInfo");
static_assert(sizeof(FAppliedKnockBackInfo) == 0x000260, "Wrong size on FAppliedKnockBackInfo");
static_assert(offsetof(FAppliedKnockBackInfo, InitialLocation) == 0x000000, "Member 'FAppliedKnockBackInfo::InitialLocation' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, InitialVelocity) == 0x000048, "Member 'FAppliedKnockBackInfo::InitialVelocity' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, Acceleration) == 0x000080, "Member 'FAppliedKnockBackInfo::Acceleration' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, Gravity) == 0x0000C0, "Member 'FAppliedKnockBackInfo::Gravity' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, GravityLerpRatio) == 0x000100, "Member 'FAppliedKnockBackInfo::GravityLerpRatio' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, RootMotionDuration) == 0x000140, "Member 'FAppliedKnockBackInfo::RootMotionDuration' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, RootMotionRemainingTime) == 0x000180, "Member 'FAppliedKnockBackInfo::RootMotionRemainingTime' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, HitStunDuration) == 0x0001C0, "Member 'FAppliedKnockBackInfo::HitStunDuration' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, bShouldTumble) == 0x000200, "Member 'FAppliedKnockBackInfo::bShouldTumble' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, bShouldSpike) == 0x000218, "Member 'FAppliedKnockBackInfo::bShouldSpike' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, bShouldBalloon) == 0x000230, "Member 'FAppliedKnockBackInfo::bShouldBalloon' has a wrong offset!");
static_assert(offsetof(FAppliedKnockBackInfo, bIsLethal) == 0x000248, "Member 'FAppliedKnockBackInfo::bIsLethal' has a wrong offset!");

// ScriptStruct Matcha.ActiveBuffInfoNetworked
// 0x0128 (0x0128 - 0x0000)
struct FActiveBuffInfoNetworked final
{
public:
	struct FMatchaSnapNetGameplayTagProperty      BuffTag;                                           // 0x0000(0x0038)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTimeMilliseconds;                             // 0x0038(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  DurationMilliseconds;                              // 0x0070(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  LastRefreshTimeMilliseconds;                       // 0x00A8(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   ObjectRarity;                                      // 0x00E0(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveBuffInfoNetworked) == 0x000008, "Wrong alignment on FActiveBuffInfoNetworked");
static_assert(sizeof(FActiveBuffInfoNetworked) == 0x000128, "Wrong size on FActiveBuffInfoNetworked");
static_assert(offsetof(FActiveBuffInfoNetworked, BuffTag) == 0x000000, "Member 'FActiveBuffInfoNetworked::BuffTag' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoNetworked, StartTimeMilliseconds) == 0x000038, "Member 'FActiveBuffInfoNetworked::StartTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoNetworked, DurationMilliseconds) == 0x000070, "Member 'FActiveBuffInfoNetworked::DurationMilliseconds' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoNetworked, LastRefreshTimeMilliseconds) == 0x0000A8, "Member 'FActiveBuffInfoNetworked::LastRefreshTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoNetworked, ObjectRarity) == 0x0000E0, "Member 'FActiveBuffInfoNetworked::ObjectRarity' has a wrong offset!");

// ScriptStruct Matcha.ActiveBuffInfoLocal
// 0x0020 (0x0020 - 0x0000)
struct FActiveBuffInfoLocal final
{
public:
	struct FGameplayTag                           BuffTag;                                           // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartTimeMilliseconds;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurationMilliseconds;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastRefreshTimeMilliseconds;                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMatchaCharacterBuff>    BuffCDO;                                           // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectRarity                                 ObjectRarity;                                      // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveBuffInfoLocal) == 0x000004, "Wrong alignment on FActiveBuffInfoLocal");
static_assert(sizeof(FActiveBuffInfoLocal) == 0x000020, "Wrong size on FActiveBuffInfoLocal");
static_assert(offsetof(FActiveBuffInfoLocal, BuffTag) == 0x000000, "Member 'FActiveBuffInfoLocal::BuffTag' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoLocal, StartTimeMilliseconds) == 0x000008, "Member 'FActiveBuffInfoLocal::StartTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoLocal, DurationMilliseconds) == 0x00000C, "Member 'FActiveBuffInfoLocal::DurationMilliseconds' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoLocal, LastRefreshTimeMilliseconds) == 0x000010, "Member 'FActiveBuffInfoLocal::LastRefreshTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoLocal, BuffCDO) == 0x000014, "Member 'FActiveBuffInfoLocal::BuffCDO' has a wrong offset!");
static_assert(offsetof(FActiveBuffInfoLocal, ObjectRarity) == 0x00001C, "Member 'FActiveBuffInfoLocal::ObjectRarity' has a wrong offset!");

// ScriptStruct Matcha.BufferedInputInfo
// 0x0148 (0x0148 - 0x0000)
struct FBufferedInputInfo final
{
public:
	struct FSnapNetPropertyEnum                   InputType;                                         // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  MoveStickX;                                        // 0x0048(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  MoveStickY;                                        // 0x0088(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   AttackType;                                        // 0x00C8(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTime;                                         // 0x0110(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBufferedInputInfo) == 0x000008, "Wrong alignment on FBufferedInputInfo");
static_assert(sizeof(FBufferedInputInfo) == 0x000148, "Wrong size on FBufferedInputInfo");
static_assert(offsetof(FBufferedInputInfo, InputType) == 0x000000, "Member 'FBufferedInputInfo::InputType' has a wrong offset!");
static_assert(offsetof(FBufferedInputInfo, MoveStickX) == 0x000048, "Member 'FBufferedInputInfo::MoveStickX' has a wrong offset!");
static_assert(offsetof(FBufferedInputInfo, MoveStickY) == 0x000088, "Member 'FBufferedInputInfo::MoveStickY' has a wrong offset!");
static_assert(offsetof(FBufferedInputInfo, AttackType) == 0x0000C8, "Member 'FBufferedInputInfo::AttackType' has a wrong offset!");
static_assert(offsetof(FBufferedInputInfo, StartTime) == 0x000110, "Member 'FBufferedInputInfo::StartTime' has a wrong offset!");

// ScriptStruct Matcha.QueuedJumpInfo
// 0x0078 (0x0078 - 0x0000)
struct FQueuedJumpInfo final
{
public:
	struct FSnapNetPropertyFloat                  HorizontalJumpVelocity;                            // 0x0000(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  QueuedJumpFlags;                                   // 0x0040(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueuedJumpInfo) == 0x000008, "Wrong alignment on FQueuedJumpInfo");
static_assert(sizeof(FQueuedJumpInfo) == 0x000078, "Wrong size on FQueuedJumpInfo");
static_assert(offsetof(FQueuedJumpInfo, HorizontalJumpVelocity) == 0x000000, "Member 'FQueuedJumpInfo::HorizontalJumpVelocity' has a wrong offset!");
static_assert(offsetof(FQueuedJumpInfo, QueuedJumpFlags) == 0x000040, "Member 'FQueuedJumpInfo::QueuedJumpFlags' has a wrong offset!");

// ScriptStruct Matcha.HangingStateInfo
// 0x0088 (0x0088 - 0x0000)
struct FHangingStateInfo final
{
public:
	struct FSnapNetPropertyBoolean                bIsHanging;                                        // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  LedgePropertyFlags;                                // 0x0018(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTime;                                         // 0x0050(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHangingStateInfo) == 0x000008, "Wrong alignment on FHangingStateInfo");
static_assert(sizeof(FHangingStateInfo) == 0x000088, "Wrong size on FHangingStateInfo");
static_assert(offsetof(FHangingStateInfo, bIsHanging) == 0x000000, "Member 'FHangingStateInfo::bIsHanging' has a wrong offset!");
static_assert(offsetof(FHangingStateInfo, LedgePropertyFlags) == 0x000018, "Member 'FHangingStateInfo::LedgePropertyFlags' has a wrong offset!");
static_assert(offsetof(FHangingStateInfo, StartTime) == 0x000050, "Member 'FHangingStateInfo::StartTime' has a wrong offset!");

// ScriptStruct Matcha.GrabInstigatorInfo
// 0x00E8 (0x00E8 - 0x0000)
struct FGrabInstigatorInfo final
{
public:
	struct FSnapNetPropertyEntityIndex            TargetIndex;                                       // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTime;                                         // 0x0068(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   ThrowDirection;                                    // 0x00A0(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrabInstigatorInfo) == 0x000008, "Wrong alignment on FGrabInstigatorInfo");
static_assert(sizeof(FGrabInstigatorInfo) == 0x0000E8, "Wrong size on FGrabInstigatorInfo");
static_assert(offsetof(FGrabInstigatorInfo, TargetIndex) == 0x000000, "Member 'FGrabInstigatorInfo::TargetIndex' has a wrong offset!");
static_assert(offsetof(FGrabInstigatorInfo, StartTime) == 0x000068, "Member 'FGrabInstigatorInfo::StartTime' has a wrong offset!");
static_assert(offsetof(FGrabInstigatorInfo, ThrowDirection) == 0x0000A0, "Member 'FGrabInstigatorInfo::ThrowDirection' has a wrong offset!");

// ScriptStruct Matcha.HurtStateInfo
// 0x0118 (0x0118 - 0x0000)
struct FHurtStateInfo final
{
public:
	struct FSnapNetPropertyBoolean                bFront;                                            // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  ChosenHurtLaunchPoseId;                            // 0x0018(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  ChosenHurtLaunchId;                                // 0x0050(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   TechType;                                          // 0x0088(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   KnockDownGetUpType;                                // 0x00D0(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHurtStateInfo) == 0x000008, "Wrong alignment on FHurtStateInfo");
static_assert(sizeof(FHurtStateInfo) == 0x000118, "Wrong size on FHurtStateInfo");
static_assert(offsetof(FHurtStateInfo, bFront) == 0x000000, "Member 'FHurtStateInfo::bFront' has a wrong offset!");
static_assert(offsetof(FHurtStateInfo, ChosenHurtLaunchPoseId) == 0x000018, "Member 'FHurtStateInfo::ChosenHurtLaunchPoseId' has a wrong offset!");
static_assert(offsetof(FHurtStateInfo, ChosenHurtLaunchId) == 0x000050, "Member 'FHurtStateInfo::ChosenHurtLaunchId' has a wrong offset!");
static_assert(offsetof(FHurtStateInfo, TechType) == 0x000088, "Member 'FHurtStateInfo::TechType' has a wrong offset!");
static_assert(offsetof(FHurtStateInfo, KnockDownGetUpType) == 0x0000D0, "Member 'FHurtStateInfo::KnockDownGetUpType' has a wrong offset!");

// ScriptStruct Matcha.ActiveSpecialAttackRestriction
// 0x0080 (0x0080 - 0x0000)
struct FActiveSpecialAttackRestriction final
{
public:
	struct FSnapNetPropertyEnum                   SpecialAttackType;                                 // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  RemainingUses;                                     // 0x0048(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveSpecialAttackRestriction) == 0x000008, "Wrong alignment on FActiveSpecialAttackRestriction");
static_assert(sizeof(FActiveSpecialAttackRestriction) == 0x000080, "Wrong size on FActiveSpecialAttackRestriction");
static_assert(offsetof(FActiveSpecialAttackRestriction, SpecialAttackType) == 0x000000, "Member 'FActiveSpecialAttackRestriction::SpecialAttackType' has a wrong offset!");
static_assert(offsetof(FActiveSpecialAttackRestriction, RemainingUses) == 0x000048, "Member 'FActiveSpecialAttackRestriction::RemainingUses' has a wrong offset!");

// ScriptStruct Matcha.WallRunStateInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FWallRunStateInfo final
{
public:
	struct FSnapNetPropertyBoolean                bEnabled;                                          // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bAlreadyUsedBeforeLanding;                         // 0x0018(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bIsWallRunning;                                    // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector                 WallNormal;                                        // 0x0048(0x0080)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWallRunStateInfo) == 0x000008, "Wrong alignment on FWallRunStateInfo");
static_assert(sizeof(FWallRunStateInfo) == 0x0000C8, "Wrong size on FWallRunStateInfo");
static_assert(offsetof(FWallRunStateInfo, bEnabled) == 0x000000, "Member 'FWallRunStateInfo::bEnabled' has a wrong offset!");
static_assert(offsetof(FWallRunStateInfo, bAlreadyUsedBeforeLanding) == 0x000018, "Member 'FWallRunStateInfo::bAlreadyUsedBeforeLanding' has a wrong offset!");
static_assert(offsetof(FWallRunStateInfo, bIsWallRunning) == 0x000030, "Member 'FWallRunStateInfo::bIsWallRunning' has a wrong offset!");
static_assert(offsetof(FWallRunStateInfo, WallNormal) == 0x000048, "Member 'FWallRunStateInfo::WallNormal' has a wrong offset!");

// ScriptStruct Matcha.ZAirGrabInfo
// 0x0048 (0x0048 - 0x0000)
struct FZAirGrabInfo final
{
public:
	struct FSnapNetPropertyBoolean                bEnabled;                                          // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bDashGrabEnabled;                                  // 0x0018(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                bCastDashGrabThisAirTime;                          // 0x0030(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FZAirGrabInfo) == 0x000008, "Wrong alignment on FZAirGrabInfo");
static_assert(sizeof(FZAirGrabInfo) == 0x000048, "Wrong size on FZAirGrabInfo");
static_assert(offsetof(FZAirGrabInfo, bEnabled) == 0x000000, "Member 'FZAirGrabInfo::bEnabled' has a wrong offset!");
static_assert(offsetof(FZAirGrabInfo, bDashGrabEnabled) == 0x000018, "Member 'FZAirGrabInfo::bDashGrabEnabled' has a wrong offset!");
static_assert(offsetof(FZAirGrabInfo, bCastDashGrabThisAirTime) == 0x000030, "Member 'FZAirGrabInfo::bCastDashGrabThisAirTime' has a wrong offset!");

// ScriptStruct Matcha.DisguiseInfo
// 0x0090 (0x0090 - 0x0000)
struct FDisguiseInfo final
{
public:
	struct FSnapNetPropertyBoolean                bEnabled;                                          // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  ChosenId;                                          // 0x0018(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  ElapsedTime;                                       // 0x0050(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDisguiseInfo) == 0x000008, "Wrong alignment on FDisguiseInfo");
static_assert(sizeof(FDisguiseInfo) == 0x000090, "Wrong size on FDisguiseInfo");
static_assert(offsetof(FDisguiseInfo, bEnabled) == 0x000000, "Member 'FDisguiseInfo::bEnabled' has a wrong offset!");
static_assert(offsetof(FDisguiseInfo, ChosenId) == 0x000018, "Member 'FDisguiseInfo::ChosenId' has a wrong offset!");
static_assert(offsetof(FDisguiseInfo, ElapsedTime) == 0x000050, "Member 'FDisguiseInfo::ElapsedTime' has a wrong offset!");

// ScriptStruct Matcha.TeamAttackSettings
// 0x0028 (0x0028 - 0x0000)
struct FTeamAttackSettings final
{
public:
	ETeamAttackTargetSearchType                   SearchType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnemyToAllyMaxRange;                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSearchMaxRange;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttackOffsetType                         OffsetType;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttackFacingType                         FacingType;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamAttackSettings) == 0x000008, "Wrong alignment on FTeamAttackSettings");
static_assert(sizeof(FTeamAttackSettings) == 0x000028, "Wrong size on FTeamAttackSettings");
static_assert(offsetof(FTeamAttackSettings, SearchType) == 0x000000, "Member 'FTeamAttackSettings::SearchType' has a wrong offset!");
static_assert(offsetof(FTeamAttackSettings, EnemyToAllyMaxRange) == 0x000004, "Member 'FTeamAttackSettings::EnemyToAllyMaxRange' has a wrong offset!");
static_assert(offsetof(FTeamAttackSettings, InitialSearchMaxRange) == 0x000008, "Member 'FTeamAttackSettings::InitialSearchMaxRange' has a wrong offset!");
static_assert(offsetof(FTeamAttackSettings, OffsetType) == 0x00000C, "Member 'FTeamAttackSettings::OffsetType' has a wrong offset!");
static_assert(offsetof(FTeamAttackSettings, Offset) == 0x000010, "Member 'FTeamAttackSettings::Offset' has a wrong offset!");
static_assert(offsetof(FTeamAttackSettings, FacingType) == 0x000020, "Member 'FTeamAttackSettings::FacingType' has a wrong offset!");

// ScriptStruct Matcha.InstigatedHitInfo
// 0x0148 (0x0148 - 0x0000)
struct FInstigatedHitInfo final
{
public:
	struct FSnapNetPropertyInt32                  HitFlags;                                          // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            ReceiverEntityIndex;                               // 0x0038(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            HitEntityIndex;                                    // 0x00A0(0x0068)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  HitFreezeSeconds;                                  // 0x0108(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstigatedHitInfo) == 0x000008, "Wrong alignment on FInstigatedHitInfo");
static_assert(sizeof(FInstigatedHitInfo) == 0x000148, "Wrong size on FInstigatedHitInfo");
static_assert(offsetof(FInstigatedHitInfo, HitFlags) == 0x000000, "Member 'FInstigatedHitInfo::HitFlags' has a wrong offset!");
static_assert(offsetof(FInstigatedHitInfo, ReceiverEntityIndex) == 0x000038, "Member 'FInstigatedHitInfo::ReceiverEntityIndex' has a wrong offset!");
static_assert(offsetof(FInstigatedHitInfo, HitEntityIndex) == 0x0000A0, "Member 'FInstigatedHitInfo::HitEntityIndex' has a wrong offset!");
static_assert(offsetof(FInstigatedHitInfo, HitFreezeSeconds) == 0x000108, "Member 'FInstigatedHitInfo::HitFreezeSeconds' has a wrong offset!");

// ScriptStruct Matcha.PeriodicDamageEffectInfo
// 0x0188 (0x0188 - 0x0000)
struct FPeriodicDamageEffectInfo final
{
public:
	struct FSnapNetPropertyFloat                  Damage;                                            // 0x0000(0x0040)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  PeriodicDamageIntervalMilliseconds;                // 0x0040(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  StartTimeMilliseconds;                             // 0x0078(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  DurationMilliseconds;                              // 0x00B0(0x0038)(NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEntityIndex            InstigatorEntityIndex;                             // 0x00E8(0x0068)(NativeAccessSpecifierPublic)
	struct FMatchaSnapNetGameplayTagProperty      Tag;                                               // 0x0150(0x0038)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPeriodicDamageEffectInfo) == 0x000008, "Wrong alignment on FPeriodicDamageEffectInfo");
static_assert(sizeof(FPeriodicDamageEffectInfo) == 0x000188, "Wrong size on FPeriodicDamageEffectInfo");
static_assert(offsetof(FPeriodicDamageEffectInfo, Damage) == 0x000000, "Member 'FPeriodicDamageEffectInfo::Damage' has a wrong offset!");
static_assert(offsetof(FPeriodicDamageEffectInfo, PeriodicDamageIntervalMilliseconds) == 0x000040, "Member 'FPeriodicDamageEffectInfo::PeriodicDamageIntervalMilliseconds' has a wrong offset!");
static_assert(offsetof(FPeriodicDamageEffectInfo, StartTimeMilliseconds) == 0x000078, "Member 'FPeriodicDamageEffectInfo::StartTimeMilliseconds' has a wrong offset!");
static_assert(offsetof(FPeriodicDamageEffectInfo, DurationMilliseconds) == 0x0000B0, "Member 'FPeriodicDamageEffectInfo::DurationMilliseconds' has a wrong offset!");
static_assert(offsetof(FPeriodicDamageEffectInfo, InstigatorEntityIndex) == 0x0000E8, "Member 'FPeriodicDamageEffectInfo::InstigatorEntityIndex' has a wrong offset!");
static_assert(offsetof(FPeriodicDamageEffectInfo, Tag) == 0x000150, "Member 'FPeriodicDamageEffectInfo::Tag' has a wrong offset!");

// ScriptStruct Matcha.AudioTrackingInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FAudioTrackingInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioTrackingInfo) == 0x000004, "Wrong alignment on FAudioTrackingInfo");
static_assert(sizeof(FAudioTrackingInfo) == 0x000008, "Wrong size on FAudioTrackingInfo");

// ScriptStruct Matcha.MatchaGameplayEventNotificationData
// 0x00C8 (0x00C8 - 0x0000)
struct FMatchaGameplayEventNotificationData final
{
public:
	struct FSnapNetPropertyEnum                   EventRegion;                                       // 0x0000(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyEnum                   EventType;                                         // 0x0048(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyInt32                  EventId;                                           // 0x0090(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaGameplayEventNotificationData) == 0x000008, "Wrong alignment on FMatchaGameplayEventNotificationData");
static_assert(sizeof(FMatchaGameplayEventNotificationData) == 0x0000C8, "Wrong size on FMatchaGameplayEventNotificationData");
static_assert(offsetof(FMatchaGameplayEventNotificationData, EventRegion) == 0x000000, "Member 'FMatchaGameplayEventNotificationData::EventRegion' has a wrong offset!");
static_assert(offsetof(FMatchaGameplayEventNotificationData, EventType) == 0x000048, "Member 'FMatchaGameplayEventNotificationData::EventType' has a wrong offset!");
static_assert(offsetof(FMatchaGameplayEventNotificationData, EventId) == 0x000090, "Member 'FMatchaGameplayEventNotificationData::EventId' has a wrong offset!");

// ScriptStruct Matcha.ActiveKOZone
// 0x0438 (0x0438 - 0x0000)
struct FActiveKOZone final
{
public:
	struct FSnapNetPropertyFloat                  ShrinkTime;                                        // 0x0000(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyFloat                  WarningTime;                                       // 0x0040(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector                 OriginalMin;                                       // 0x0080(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector                 OriginalMax;                                       // 0x0100(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector2D               StartingMin;                                       // 0x0180(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector2D               StartingMax;                                       // 0x01E8(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector2D               EndingMin;                                         // 0x0250(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector2D               EndingMax;                                         // 0x02B8(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyBoolean                IsLastStand;                                       // 0x0320(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector                 FinalZoneCenter;                                   // 0x0338(0x0080)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSnapNetPropertyVector                 FinalZoneExtent;                                   // 0x03B8(0x0080)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveKOZone) == 0x000008, "Wrong alignment on FActiveKOZone");
static_assert(sizeof(FActiveKOZone) == 0x000438, "Wrong size on FActiveKOZone");
static_assert(offsetof(FActiveKOZone, ShrinkTime) == 0x000000, "Member 'FActiveKOZone::ShrinkTime' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, WarningTime) == 0x000040, "Member 'FActiveKOZone::WarningTime' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, OriginalMin) == 0x000080, "Member 'FActiveKOZone::OriginalMin' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, OriginalMax) == 0x000100, "Member 'FActiveKOZone::OriginalMax' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, StartingMin) == 0x000180, "Member 'FActiveKOZone::StartingMin' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, StartingMax) == 0x0001E8, "Member 'FActiveKOZone::StartingMax' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, EndingMin) == 0x000250, "Member 'FActiveKOZone::EndingMin' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, EndingMax) == 0x0002B8, "Member 'FActiveKOZone::EndingMax' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, IsLastStand) == 0x000320, "Member 'FActiveKOZone::IsLastStand' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, FinalZoneCenter) == 0x000338, "Member 'FActiveKOZone::FinalZoneCenter' has a wrong offset!");
static_assert(offsetof(FActiveKOZone, FinalZoneExtent) == 0x0003B8, "Member 'FActiveKOZone::FinalZoneExtent' has a wrong offset!");

// ScriptStruct Matcha.KOZoneCycleConfiguration
// 0x0070 (0x0070 - 0x0000)
struct FKOZoneCycleConfiguration final
{
public:
	float                                         ShrinkTime;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePerTick;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTickRate;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EScheduledObjectiveType, int32>          ObjectivesToStart;                                 // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector2D                              AbsoluteExtents;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKOZoneCycleConfiguration) == 0x000008, "Wrong alignment on FKOZoneCycleConfiguration");
static_assert(sizeof(FKOZoneCycleConfiguration) == 0x000070, "Wrong size on FKOZoneCycleConfiguration");
static_assert(offsetof(FKOZoneCycleConfiguration, ShrinkTime) == 0x000000, "Member 'FKOZoneCycleConfiguration::ShrinkTime' has a wrong offset!");
static_assert(offsetof(FKOZoneCycleConfiguration, WarningTime) == 0x000004, "Member 'FKOZoneCycleConfiguration::WarningTime' has a wrong offset!");
static_assert(offsetof(FKOZoneCycleConfiguration, DamagePerTick) == 0x000008, "Member 'FKOZoneCycleConfiguration::DamagePerTick' has a wrong offset!");
static_assert(offsetof(FKOZoneCycleConfiguration, DamageTickRate) == 0x00000C, "Member 'FKOZoneCycleConfiguration::DamageTickRate' has a wrong offset!");
static_assert(offsetof(FKOZoneCycleConfiguration, ObjectivesToStart) == 0x000010, "Member 'FKOZoneCycleConfiguration::ObjectivesToStart' has a wrong offset!");
static_assert(offsetof(FKOZoneCycleConfiguration, AbsoluteExtents) == 0x000060, "Member 'FKOZoneCycleConfiguration::AbsoluteExtents' has a wrong offset!");

// ScriptStruct Matcha.KOZoneConfiguration
// 0x0048 (0x0048 - 0x0000)
struct FKOZoneConfiguration final
{
public:
	TArray<struct FKOZoneCycleConfiguration>      CycleConfigurations;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                WorldCenter;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventDoubleBackingZones;                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldExtents;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKOZoneConfiguration) == 0x000008, "Wrong alignment on FKOZoneConfiguration");
static_assert(sizeof(FKOZoneConfiguration) == 0x000048, "Wrong size on FKOZoneConfiguration");
static_assert(offsetof(FKOZoneConfiguration, CycleConfigurations) == 0x000000, "Member 'FKOZoneConfiguration::CycleConfigurations' has a wrong offset!");
static_assert(offsetof(FKOZoneConfiguration, WorldCenter) == 0x000010, "Member 'FKOZoneConfiguration::WorldCenter' has a wrong offset!");
static_assert(offsetof(FKOZoneConfiguration, bPreventDoubleBackingZones) == 0x000028, "Member 'FKOZoneConfiguration::bPreventDoubleBackingZones' has a wrong offset!");
static_assert(offsetof(FKOZoneConfiguration, WorldExtents) == 0x000030, "Member 'FKOZoneConfiguration::WorldExtents' has a wrong offset!");

// ScriptStruct Matcha.SplineTravelStartData
// 0x0008 (0x0008 - 0x0000)
struct FSplineTravelStartData final
{
public:
	float                                         StartElapsedTime;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelDirection;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineTravelStartData) == 0x000004, "Wrong alignment on FSplineTravelStartData");
static_assert(sizeof(FSplineTravelStartData) == 0x000008, "Wrong size on FSplineTravelStartData");
static_assert(offsetof(FSplineTravelStartData, StartElapsedTime) == 0x000000, "Member 'FSplineTravelStartData::StartElapsedTime' has a wrong offset!");
static_assert(offsetof(FSplineTravelStartData, TravelDirection) == 0x000004, "Member 'FSplineTravelStartData::TravelDirection' has a wrong offset!");

// ScriptStruct Matcha.MatchaTeamUIData_InitParams
// 0x0004 (0x0004 - 0x0000)
struct FMatchaTeamUIData_InitParams final
{
public:
	int32                                         TeamNumber;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaTeamUIData_InitParams) == 0x000004, "Wrong alignment on FMatchaTeamUIData_InitParams");
static_assert(sizeof(FMatchaTeamUIData_InitParams) == 0x000004, "Wrong size on FMatchaTeamUIData_InitParams");
static_assert(offsetof(FMatchaTeamUIData_InitParams, TeamNumber) == 0x000000, "Member 'FMatchaTeamUIData_InitParams::TeamNumber' has a wrong offset!");

// ScriptStruct Matcha.OverlappedCharacterInfo
// 0x0008 (0x0008 - 0x0000)
struct FOverlappedCharacterInfo final
{
public:
	int32                                         CharacterEntityIndex;                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedOverlapTime;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverlappedCharacterInfo) == 0x000004, "Wrong alignment on FOverlappedCharacterInfo");
static_assert(sizeof(FOverlappedCharacterInfo) == 0x000008, "Wrong size on FOverlappedCharacterInfo");
static_assert(offsetof(FOverlappedCharacterInfo, CharacterEntityIndex) == 0x000000, "Member 'FOverlappedCharacterInfo::CharacterEntityIndex' has a wrong offset!");
static_assert(offsetof(FOverlappedCharacterInfo, ElapsedOverlapTime) == 0x000004, "Member 'FOverlappedCharacterInfo::ElapsedOverlapTime' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketMessageBase
// 0x0008 (0x0008 - 0x0000)
struct FMatchaWebSocketMessageBase
{
public:
	class FName                                   Type;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketMessageBase) == 0x000004, "Wrong alignment on FMatchaWebSocketMessageBase");
static_assert(sizeof(FMatchaWebSocketMessageBase) == 0x000008, "Wrong size on FMatchaWebSocketMessageBase");
static_assert(offsetof(FMatchaWebSocketMessageBase, Type) == 0x000000, "Member 'FMatchaWebSocketMessageBase::Type' has a wrong offset!");

// ScriptStruct Matcha.MatchaServicesPlayerProfile
// 0x0020 (0x0020 - 0x0000)
struct FMatchaServicesPlayerProfile final
{
public:
	class FString                                 PlayerId;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaServicesPlayerProfile) == 0x000008, "Wrong alignment on FMatchaServicesPlayerProfile");
static_assert(sizeof(FMatchaServicesPlayerProfile) == 0x000020, "Wrong size on FMatchaServicesPlayerProfile");
static_assert(offsetof(FMatchaServicesPlayerProfile, PlayerId) == 0x000000, "Member 'FMatchaServicesPlayerProfile::PlayerId' has a wrong offset!");
static_assert(offsetof(FMatchaServicesPlayerProfile, PlayerName) == 0x000010, "Member 'FMatchaServicesPlayerProfile::PlayerName' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketSetNameMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketSetNameMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketSetNameMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketSetNameMessage");
static_assert(sizeof(FMatchaWebSocketSetNameMessage) == 0x000018, "Wrong size on FMatchaWebSocketSetNameMessage");
static_assert(offsetof(FMatchaWebSocketSetNameMessage, Name) == 0x000008, "Member 'FMatchaWebSocketSetNameMessage::Name' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketGetNameMessage
// 0x0000 (0x0008 - 0x0008)
struct FMatchaWebSocketGetNameMessage final : public FMatchaWebSocketMessageBase
{
};
static_assert(alignof(FMatchaWebSocketGetNameMessage) == 0x000004, "Wrong alignment on FMatchaWebSocketGetNameMessage");
static_assert(sizeof(FMatchaWebSocketGetNameMessage) == 0x000008, "Wrong size on FMatchaWebSocketGetNameMessage");

// ScriptStruct Matcha.MatchaWebSocketSendInviteMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketSendInviteMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 InviteTarget;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketSendInviteMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketSendInviteMessage");
static_assert(sizeof(FMatchaWebSocketSendInviteMessage) == 0x000018, "Wrong size on FMatchaWebSocketSendInviteMessage");
static_assert(offsetof(FMatchaWebSocketSendInviteMessage, InviteTarget) == 0x000008, "Member 'FMatchaWebSocketSendInviteMessage::InviteTarget' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketAcceptInviteMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketAcceptInviteMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 AcceptTarget;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketAcceptInviteMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketAcceptInviteMessage");
static_assert(sizeof(FMatchaWebSocketAcceptInviteMessage) == 0x000018, "Wrong size on FMatchaWebSocketAcceptInviteMessage");
static_assert(offsetof(FMatchaWebSocketAcceptInviteMessage, AcceptTarget) == 0x000008, "Member 'FMatchaWebSocketAcceptInviteMessage::AcceptTarget' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketRejectInviteMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketRejectInviteMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 RejectTarget;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketRejectInviteMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketRejectInviteMessage");
static_assert(sizeof(FMatchaWebSocketRejectInviteMessage) == 0x000018, "Wrong size on FMatchaWebSocketRejectInviteMessage");
static_assert(offsetof(FMatchaWebSocketRejectInviteMessage, RejectTarget) == 0x000008, "Member 'FMatchaWebSocketRejectInviteMessage::RejectTarget' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketCancelInviteMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketCancelInviteMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 CancelTarget;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketCancelInviteMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketCancelInviteMessage");
static_assert(sizeof(FMatchaWebSocketCancelInviteMessage) == 0x000018, "Wrong size on FMatchaWebSocketCancelInviteMessage");
static_assert(offsetof(FMatchaWebSocketCancelInviteMessage, CancelTarget) == 0x000008, "Member 'FMatchaWebSocketCancelInviteMessage::CancelTarget' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketLeaveTeamMessage
// 0x0000 (0x0008 - 0x0008)
struct FMatchaWebSocketLeaveTeamMessage final : public FMatchaWebSocketMessageBase
{
};
static_assert(alignof(FMatchaWebSocketLeaveTeamMessage) == 0x000004, "Wrong alignment on FMatchaWebSocketLeaveTeamMessage");
static_assert(sizeof(FMatchaWebSocketLeaveTeamMessage) == 0x000008, "Wrong size on FMatchaWebSocketLeaveTeamMessage");

// ScriptStruct Matcha.MatchaWebSocketBeginQueueMessage
// 0x0000 (0x0008 - 0x0008)
struct FMatchaWebSocketBeginQueueMessage final : public FMatchaWebSocketMessageBase
{
};
static_assert(alignof(FMatchaWebSocketBeginQueueMessage) == 0x000004, "Wrong alignment on FMatchaWebSocketBeginQueueMessage");
static_assert(sizeof(FMatchaWebSocketBeginQueueMessage) == 0x000008, "Wrong size on FMatchaWebSocketBeginQueueMessage");

// ScriptStruct Matcha.MatchaWebSocketEndQueueMessage
// 0x0000 (0x0008 - 0x0008)
struct FMatchaWebSocketEndQueueMessage final : public FMatchaWebSocketMessageBase
{
};
static_assert(alignof(FMatchaWebSocketEndQueueMessage) == 0x000004, "Wrong alignment on FMatchaWebSocketEndQueueMessage");
static_assert(sizeof(FMatchaWebSocketEndQueueMessage) == 0x000008, "Wrong size on FMatchaWebSocketEndQueueMessage");

// ScriptStruct Matcha.MatchaWebSocketJoinDropInMessage
// 0x0000 (0x0008 - 0x0008)
struct FMatchaWebSocketJoinDropInMessage final : public FMatchaWebSocketMessageBase
{
};
static_assert(alignof(FMatchaWebSocketJoinDropInMessage) == 0x000004, "Wrong alignment on FMatchaWebSocketJoinDropInMessage");
static_assert(sizeof(FMatchaWebSocketJoinDropInMessage) == 0x000008, "Wrong size on FMatchaWebSocketJoinDropInMessage");

// ScriptStruct Matcha.MatchaWebSocketPingMessage
// 0x0000 (0x0008 - 0x0008)
struct FMatchaWebSocketPingMessage final : public FMatchaWebSocketMessageBase
{
};
static_assert(alignof(FMatchaWebSocketPingMessage) == 0x000004, "Wrong alignment on FMatchaWebSocketPingMessage");
static_assert(sizeof(FMatchaWebSocketPingMessage) == 0x000008, "Wrong size on FMatchaWebSocketPingMessage");

// ScriptStruct Matcha.MatchaWebSocketServerSetIdentificationMessage
// 0x0028 (0x0030 - 0x0008)
struct FMatchaWebSocketServerSetIdentificationMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConnectString;                                     // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMatchServer;                                     // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaWebSocketServerSetIdentificationMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketServerSetIdentificationMessage");
static_assert(sizeof(FMatchaWebSocketServerSetIdentificationMessage) == 0x000030, "Wrong size on FMatchaWebSocketServerSetIdentificationMessage");
static_assert(offsetof(FMatchaWebSocketServerSetIdentificationMessage, Name) == 0x000008, "Member 'FMatchaWebSocketServerSetIdentificationMessage::Name' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketServerSetIdentificationMessage, ConnectString) == 0x000018, "Member 'FMatchaWebSocketServerSetIdentificationMessage::ConnectString' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketServerSetIdentificationMessage, IsMatchServer) == 0x000028, "Member 'FMatchaWebSocketServerSetIdentificationMessage::IsMatchServer' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketServerSetMatchPhaseMessage
// 0x0004 (0x000C - 0x0008)
struct FMatchaWebSocketServerSetMatchPhaseMessage final : public FMatchaWebSocketMessageBase
{
public:
	EMatchaMatchPhase                             MatchPhase;                                        // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchaWebSocketServerSetMatchPhaseMessage) == 0x000004, "Wrong alignment on FMatchaWebSocketServerSetMatchPhaseMessage");
static_assert(sizeof(FMatchaWebSocketServerSetMatchPhaseMessage) == 0x00000C, "Wrong size on FMatchaWebSocketServerSetMatchPhaseMessage");
static_assert(offsetof(FMatchaWebSocketServerSetMatchPhaseMessage, MatchPhase) == 0x000008, "Member 'FMatchaWebSocketServerSetMatchPhaseMessage::MatchPhase' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketServerSetConnectedPlayersMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketServerSetConnectedPlayersMessage final : public FMatchaWebSocketMessageBase
{
public:
	TArray<class FName>                           PlayerIds;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketServerSetConnectedPlayersMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketServerSetConnectedPlayersMessage");
static_assert(sizeof(FMatchaWebSocketServerSetConnectedPlayersMessage) == 0x000018, "Wrong size on FMatchaWebSocketServerSetConnectedPlayersMessage");
static_assert(offsetof(FMatchaWebSocketServerSetConnectedPlayersMessage, PlayerIds) == 0x000008, "Member 'FMatchaWebSocketServerSetConnectedPlayersMessage::PlayerIds' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketNameMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketNameMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketNameMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketNameMessage");
static_assert(sizeof(FMatchaWebSocketNameMessage) == 0x000018, "Wrong size on FMatchaWebSocketNameMessage");
static_assert(offsetof(FMatchaWebSocketNameMessage, Name) == 0x000008, "Member 'FMatchaWebSocketNameMessage::Name' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketTeamMembersMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketTeamMembersMessage final : public FMatchaWebSocketMessageBase
{
public:
	TArray<struct FMatchaServicesPlayerProfile>   Members;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketTeamMembersMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketTeamMembersMessage");
static_assert(sizeof(FMatchaWebSocketTeamMembersMessage) == 0x000018, "Wrong size on FMatchaWebSocketTeamMembersMessage");
static_assert(offsetof(FMatchaWebSocketTeamMembersMessage, Members) == 0x000008, "Member 'FMatchaWebSocketTeamMembersMessage::Members' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketUnknownInviteTargetMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketUnknownInviteTargetMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 Target;                                            // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketUnknownInviteTargetMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketUnknownInviteTargetMessage");
static_assert(sizeof(FMatchaWebSocketUnknownInviteTargetMessage) == 0x000018, "Wrong size on FMatchaWebSocketUnknownInviteTargetMessage");
static_assert(offsetof(FMatchaWebSocketUnknownInviteTargetMessage, Target) == 0x000008, "Member 'FMatchaWebSocketUnknownInviteTargetMessage::Target' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketSentInvitesMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketSentInvitesMessage final : public FMatchaWebSocketMessageBase
{
public:
	TArray<struct FMatchaServicesPlayerProfile>   Targets;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketSentInvitesMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketSentInvitesMessage");
static_assert(sizeof(FMatchaWebSocketSentInvitesMessage) == 0x000018, "Wrong size on FMatchaWebSocketSentInvitesMessage");
static_assert(offsetof(FMatchaWebSocketSentInvitesMessage, Targets) == 0x000008, "Member 'FMatchaWebSocketSentInvitesMessage::Targets' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketReceivedInvitesMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketReceivedInvitesMessage final : public FMatchaWebSocketMessageBase
{
public:
	TArray<struct FMatchaServicesPlayerProfile>   Targets;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketReceivedInvitesMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketReceivedInvitesMessage");
static_assert(sizeof(FMatchaWebSocketReceivedInvitesMessage) == 0x000018, "Wrong size on FMatchaWebSocketReceivedInvitesMessage");
static_assert(offsetof(FMatchaWebSocketReceivedInvitesMessage, Targets) == 0x000008, "Member 'FMatchaWebSocketReceivedInvitesMessage::Targets' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketQueueStateMessage
// 0x0004 (0x000C - 0x0008)
struct FMatchaWebSocketQueueStateMessage final : public FMatchaWebSocketMessageBase
{
public:
	int32                                         QueueStartTimeSeconds;                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketQueueStateMessage) == 0x000004, "Wrong alignment on FMatchaWebSocketQueueStateMessage");
static_assert(sizeof(FMatchaWebSocketQueueStateMessage) == 0x00000C, "Wrong size on FMatchaWebSocketQueueStateMessage");
static_assert(offsetof(FMatchaWebSocketQueueStateMessage, QueueStartTimeSeconds) == 0x000008, "Member 'FMatchaWebSocketQueueStateMessage::QueueStartTimeSeconds' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketJoinServerMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketJoinServerMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 ConnectString;                                     // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketJoinServerMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketJoinServerMessage");
static_assert(sizeof(FMatchaWebSocketJoinServerMessage) == 0x000018, "Wrong size on FMatchaWebSocketJoinServerMessage");
static_assert(offsetof(FMatchaWebSocketJoinServerMessage, ConnectString) == 0x000008, "Member 'FMatchaWebSocketJoinServerMessage::ConnectString' has a wrong offset!");

// ScriptStruct Matcha.MatchaMatchTeam
// 0x0018 (0x0018 - 0x0000)
struct FMatchaMatchTeam final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PlayerIds;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaMatchTeam) == 0x000008, "Wrong alignment on FMatchaMatchTeam");
static_assert(sizeof(FMatchaMatchTeam) == 0x000018, "Wrong size on FMatchaMatchTeam");
static_assert(offsetof(FMatchaMatchTeam, TeamIndex) == 0x000000, "Member 'FMatchaMatchTeam::TeamIndex' has a wrong offset!");
static_assert(offsetof(FMatchaMatchTeam, PlayerIds) == 0x000008, "Member 'FMatchaMatchTeam::PlayerIds' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketMatchInfoMessage
// 0x0028 (0x0030 - 0x0008)
struct FMatchaWebSocketMatchInfoMessage final : public FMatchaWebSocketMessageBase
{
public:
	class FString                                 GameId;                                            // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamSize;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchaMatchTeam>               Teams;                                             // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketMatchInfoMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketMatchInfoMessage");
static_assert(sizeof(FMatchaWebSocketMatchInfoMessage) == 0x000030, "Wrong size on FMatchaWebSocketMatchInfoMessage");
static_assert(offsetof(FMatchaWebSocketMatchInfoMessage, GameId) == 0x000008, "Member 'FMatchaWebSocketMatchInfoMessage::GameId' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketMatchInfoMessage, TeamSize) == 0x000018, "Member 'FMatchaWebSocketMatchInfoMessage::TeamSize' has a wrong offset!");
static_assert(offsetof(FMatchaWebSocketMatchInfoMessage, Teams) == 0x000020, "Member 'FMatchaWebSocketMatchInfoMessage::Teams' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketPlayerParty
// 0x0010 (0x0010 - 0x0000)
struct FMatchaWebSocketPlayerParty final
{
public:
	TArray<class FName>                           PlayerIds;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketPlayerParty) == 0x000008, "Wrong alignment on FMatchaWebSocketPlayerParty");
static_assert(sizeof(FMatchaWebSocketPlayerParty) == 0x000010, "Wrong size on FMatchaWebSocketPlayerParty");
static_assert(offsetof(FMatchaWebSocketPlayerParty, PlayerIds) == 0x000000, "Member 'FMatchaWebSocketPlayerParty::PlayerIds' has a wrong offset!");

// ScriptStruct Matcha.MatchaWebSocketPlayerPartiesMessage
// 0x0010 (0x0018 - 0x0008)
struct FMatchaWebSocketPlayerPartiesMessage final : public FMatchaWebSocketMessageBase
{
public:
	TArray<struct FMatchaWebSocketPlayerParty>    Parties;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchaWebSocketPlayerPartiesMessage) == 0x000008, "Wrong alignment on FMatchaWebSocketPlayerPartiesMessage");
static_assert(sizeof(FMatchaWebSocketPlayerPartiesMessage) == 0x000018, "Wrong size on FMatchaWebSocketPlayerPartiesMessage");
static_assert(offsetof(FMatchaWebSocketPlayerPartiesMessage, Parties) == 0x000008, "Member 'FMatchaWebSocketPlayerPartiesMessage::Parties' has a wrong offset!");

}

