#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OdyUI

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "OdyUI_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "Slate_structs.hpp"
#include "Engine_classes.hpp"
#include "InputCore_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "SlateCore_structs.hpp"
#include "OdyUtils_structs.hpp"


namespace SDK
{

// Class OdyUI.OdyWidget
// 0x00B8 (0x0398 - 0x02E0)
class UOdyWidget : public UUserWidget
{
public:
	EOdyWidgetDisplayState                        DisplayState;                                      // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOdyWidgetBindDataOn                          BindDataOn;                                        // 0x02E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DisplayStateChanged;                               // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UInputMappingContext*>           InputContexts;                                     // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bApplyInputContextsOnHover;                        // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidgetToFocusName;                                 // 0x030C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                WidgetToFocus;                                     // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestoreFocus;                                     // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCustomIsInteractable;                             // 0x0321(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickWhenOffscreen;                                // 0x0322(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_323[0x15];                                     // 0x0323(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	EOdyInputContextPriority                      InputContextPriority;                              // 0x0338(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOdyUIData*                             UIData;                                            // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           BindingContextStack;                               // 0x0348(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x40];                                     // 0x0358(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDataBindingContext(class FName ContextName);
	void AddInputMappingContext(class UInputMappingContext* InputContext);
	void AnimateIn();
	void AnimateInComplete();
	void AnimateOut();
	void AnimateOutComplete();
	void BindData(class UOdyUIData* NewUIData);
	void CheckForLocalPlayerStateAndGameState();
	void ClearAllBindings();
	void ClearBindingsWithContext(class FName BindingContext);
	void ClearLastFocusedWidget();
	class UWidget* GetWidgetToFocus();
	void Hide();
	void OnLocalBasePlayerStateAndGameStateReady(class APlayerState* PlayerState, class AGameStateBase* GameState);
	void OnNetOwnerBasePlayerStateSet(class APlayerState* PlayerState);
	void OnUIDataSet(class UOdyUIData* NewUIData);
	void RemoveInputMappingContext(class UInputMappingContext* InputContext);
	void RemoveLatestDataBindingContext(class FName ContextName);
	void SetInputContextPriority(EOdyInputContextPriority InInputContextPriority);
	void SetNetOwnerPlayerState(class APlayerState* PlayerState);
	void SetTickWhenOffscreen(bool bInTickWhenOffscreen);
	void SetUIData(class UOdyUIData* InUIData);
	void Show();
	void UnbindData(class UOdyUIData* OldUIData);

	class FName GetCurrentDataBindingContext() const;
	class APlayerState* GetNetOwnerBasePlayerState() const;
	class UOdyUIData* GetUIData() const;
	TArray<class FString> GetWidgetToFocusNames() const;
	bool HasOwnerFocus(bool bIncludingDescendants) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyWidget">();
	}
	static class UOdyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyWidget>();
	}
};
static_assert(alignof(UOdyWidget) == 0x000008, "Wrong alignment on UOdyWidget");
static_assert(sizeof(UOdyWidget) == 0x000398, "Wrong size on UOdyWidget");
static_assert(offsetof(UOdyWidget, DisplayState) == 0x0002E0, "Member 'UOdyWidget::DisplayState' has a wrong offset!");
static_assert(offsetof(UOdyWidget, BindDataOn) == 0x0002E1, "Member 'UOdyWidget::BindDataOn' has a wrong offset!");
static_assert(offsetof(UOdyWidget, DisplayStateChanged) == 0x0002E8, "Member 'UOdyWidget::DisplayStateChanged' has a wrong offset!");
static_assert(offsetof(UOdyWidget, InputContexts) == 0x0002F8, "Member 'UOdyWidget::InputContexts' has a wrong offset!");
static_assert(offsetof(UOdyWidget, bApplyInputContextsOnHover) == 0x000308, "Member 'UOdyWidget::bApplyInputContextsOnHover' has a wrong offset!");
static_assert(offsetof(UOdyWidget, WidgetToFocusName) == 0x00030C, "Member 'UOdyWidget::WidgetToFocusName' has a wrong offset!");
static_assert(offsetof(UOdyWidget, WidgetToFocus) == 0x000318, "Member 'UOdyWidget::WidgetToFocus' has a wrong offset!");
static_assert(offsetof(UOdyWidget, bRestoreFocus) == 0x000320, "Member 'UOdyWidget::bRestoreFocus' has a wrong offset!");
static_assert(offsetof(UOdyWidget, bCustomIsInteractable) == 0x000321, "Member 'UOdyWidget::bCustomIsInteractable' has a wrong offset!");
static_assert(offsetof(UOdyWidget, bTickWhenOffscreen) == 0x000322, "Member 'UOdyWidget::bTickWhenOffscreen' has a wrong offset!");
static_assert(offsetof(UOdyWidget, InputContextPriority) == 0x000338, "Member 'UOdyWidget::InputContextPriority' has a wrong offset!");
static_assert(offsetof(UOdyWidget, UIData) == 0x000340, "Member 'UOdyWidget::UIData' has a wrong offset!");
static_assert(offsetof(UOdyWidget, BindingContextStack) == 0x000348, "Member 'UOdyWidget::BindingContextStack' has a wrong offset!");

// Class OdyUI.OdyMenu
// 0x00B0 (0x0448 - 0x0398)
class UOdyMenu : public UOdyWidget
{
public:
	EOdyAnalogCursorSetting                       WantsAnalogCursor;                                 // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOdyAnalogCursorSetting                       WantsAnalogCursorHidden;                           // 0x0399(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOdyAnalogCursorSetting                       WantsAnalogCursorLocked;                           // 0x039A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUserClosable;                                   // 0x039B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritRouterGlobalInputContexts;                 // 0x039C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsModal;                                          // 0x039D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPoolForReuse;                                     // 0x039E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39F[0x1];                                      // 0x039F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnchors                               Anchors;                                           // 0x03A0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Alignment;                                         // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOdyModalPriority                             ModalPriority;                                     // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERouterSettingBool                            RouterFocusable;                                   // 0x03E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMenuInputModeSetting                  InputModeSetting;                                  // 0x03E2(0x0005)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMenuMouseClickActionSetting           MouseClickActionSetting;                           // 0x03E7(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CameraId;                                          // 0x03EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOdyUIRouter>            SourceUIRouter;                                    // 0x03F4(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RouterAssignedMenuId;                              // 0x03FC(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RouterAssignedDisplayName;                         // 0x0408(0x0010)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMenuNavigatedAway;                               // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UOdyMenu>>        ModalsHiddenUntilClosed;                           // 0x0430(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bConsumedMouseDown;                                // 0x0440(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearInputModeOverride();
	void CloseSelf();
	void DisableConsumeMouseDownEvents();
	void HideOtherModalUntilClosed(class UOdyMenu* OtherMenu);
	void OnNavBack();
	void OnNavigatedAway(EOdyNavigationDirection NavDirection);
	void OnNavigatedTo(const TMap<class FString, class FString>& Args, const class FString& Action, EOdyNavigationDirection NavDirection);
	void SetInputModeOverride(EMenuInputMode InputMode);
	void SetModalPriorityOverride(EOdyModalPriority ModalPri);
	void SetNeverWantsInput(bool bNeverWantsInput);
	void SetupToConsumeMouseDownEvents();
	void SetWantsAnalogCursor(EOdyAnalogCursorSetting InWantsAnalogCursor);
	void SetWantsAnalogCursorHidden(EOdyAnalogCursorSetting InWantsAnalogCursorHidden);
	void SetWantsAnalogCursorLocked(EOdyAnalogCursorSetting InWantsAnalogCursorLocked);

	EMenuInputMode GetInputMode() const;
	EOdyModalPriority GetModalPriority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyMenu">();
	}
	static class UOdyMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyMenu>();
	}
};
static_assert(alignof(UOdyMenu) == 0x000008, "Wrong alignment on UOdyMenu");
static_assert(sizeof(UOdyMenu) == 0x000448, "Wrong size on UOdyMenu");
static_assert(offsetof(UOdyMenu, WantsAnalogCursor) == 0x000398, "Member 'UOdyMenu::WantsAnalogCursor' has a wrong offset!");
static_assert(offsetof(UOdyMenu, WantsAnalogCursorHidden) == 0x000399, "Member 'UOdyMenu::WantsAnalogCursorHidden' has a wrong offset!");
static_assert(offsetof(UOdyMenu, WantsAnalogCursorLocked) == 0x00039A, "Member 'UOdyMenu::WantsAnalogCursorLocked' has a wrong offset!");
static_assert(offsetof(UOdyMenu, bIsUserClosable) == 0x00039B, "Member 'UOdyMenu::bIsUserClosable' has a wrong offset!");
static_assert(offsetof(UOdyMenu, bInheritRouterGlobalInputContexts) == 0x00039C, "Member 'UOdyMenu::bInheritRouterGlobalInputContexts' has a wrong offset!");
static_assert(offsetof(UOdyMenu, bIsModal) == 0x00039D, "Member 'UOdyMenu::bIsModal' has a wrong offset!");
static_assert(offsetof(UOdyMenu, bPoolForReuse) == 0x00039E, "Member 'UOdyMenu::bPoolForReuse' has a wrong offset!");
static_assert(offsetof(UOdyMenu, Anchors) == 0x0003A0, "Member 'UOdyMenu::Anchors' has a wrong offset!");
static_assert(offsetof(UOdyMenu, Position) == 0x0003C0, "Member 'UOdyMenu::Position' has a wrong offset!");
static_assert(offsetof(UOdyMenu, Alignment) == 0x0003D0, "Member 'UOdyMenu::Alignment' has a wrong offset!");
static_assert(offsetof(UOdyMenu, ModalPriority) == 0x0003E0, "Member 'UOdyMenu::ModalPriority' has a wrong offset!");
static_assert(offsetof(UOdyMenu, RouterFocusable) == 0x0003E1, "Member 'UOdyMenu::RouterFocusable' has a wrong offset!");
static_assert(offsetof(UOdyMenu, InputModeSetting) == 0x0003E2, "Member 'UOdyMenu::InputModeSetting' has a wrong offset!");
static_assert(offsetof(UOdyMenu, MouseClickActionSetting) == 0x0003E7, "Member 'UOdyMenu::MouseClickActionSetting' has a wrong offset!");
static_assert(offsetof(UOdyMenu, CameraId) == 0x0003EC, "Member 'UOdyMenu::CameraId' has a wrong offset!");
static_assert(offsetof(UOdyMenu, SourceUIRouter) == 0x0003F4, "Member 'UOdyMenu::SourceUIRouter' has a wrong offset!");
static_assert(offsetof(UOdyMenu, RouterAssignedMenuId) == 0x0003FC, "Member 'UOdyMenu::RouterAssignedMenuId' has a wrong offset!");
static_assert(offsetof(UOdyMenu, RouterAssignedDisplayName) == 0x000408, "Member 'UOdyMenu::RouterAssignedDisplayName' has a wrong offset!");
static_assert(offsetof(UOdyMenu, OnMenuNavigatedAway) == 0x000418, "Member 'UOdyMenu::OnMenuNavigatedAway' has a wrong offset!");
static_assert(offsetof(UOdyMenu, ModalsHiddenUntilClosed) == 0x000430, "Member 'UOdyMenu::ModalsHiddenUntilClosed' has a wrong offset!");
static_assert(offsetof(UOdyMenu, bConsumedMouseDown) == 0x000440, "Member 'UOdyMenu::bConsumedMouseDown' has a wrong offset!");

// Class OdyUI.OdyConfirmationModal
// 0x00B0 (0x04F8 - 0x0448)
class UOdyConfirmationModal final : public UOdyMenu
{
public:
	struct FOdyUITextBinding                      Title;                                             // 0x0448(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FOdyUITextBinding                      Message;                                           // 0x0470(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FOdyUITextBinding                      ConfirmText;                                       // 0x0498(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FOdyUITextBinding                      CancelText;                                        // 0x04C0(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(bool bConfirmed)>              OnDismissed;                                       // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCanceled();
	void OnConfirmed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyConfirmationModal">();
	}
	static class UOdyConfirmationModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyConfirmationModal>();
	}
};
static_assert(alignof(UOdyConfirmationModal) == 0x000008, "Wrong alignment on UOdyConfirmationModal");
static_assert(sizeof(UOdyConfirmationModal) == 0x0004F8, "Wrong size on UOdyConfirmationModal");
static_assert(offsetof(UOdyConfirmationModal, Title) == 0x000448, "Member 'UOdyConfirmationModal::Title' has a wrong offset!");
static_assert(offsetof(UOdyConfirmationModal, Message) == 0x000470, "Member 'UOdyConfirmationModal::Message' has a wrong offset!");
static_assert(offsetof(UOdyConfirmationModal, ConfirmText) == 0x000498, "Member 'UOdyConfirmationModal::ConfirmText' has a wrong offset!");
static_assert(offsetof(UOdyConfirmationModal, CancelText) == 0x0004C0, "Member 'UOdyConfirmationModal::CancelText' has a wrong offset!");
static_assert(offsetof(UOdyConfirmationModal, OnDismissed) == 0x0004E8, "Member 'UOdyConfirmationModal::OnDismissed' has a wrong offset!");

// Class OdyUI.OdyDeferredPainter
// 0x0018 (0x01A8 - 0x0190)
class UOdyDeferredPainter final : public UContentWidget
{
public:
	bool                                          bEnableDeferPaint;                                 // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x17];                                     // 0x0191(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnableDeferPaint(bool bInEnableDeferPaint);

	bool GetEnableDeferPaint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyDeferredPainter">();
	}
	static class UOdyDeferredPainter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyDeferredPainter>();
	}
};
static_assert(alignof(UOdyDeferredPainter) == 0x000008, "Wrong alignment on UOdyDeferredPainter");
static_assert(sizeof(UOdyDeferredPainter) == 0x0001A8, "Wrong size on UOdyDeferredPainter");
static_assert(offsetof(UOdyDeferredPainter, bEnableDeferPaint) == 0x000190, "Member 'UOdyDeferredPainter::bEnableDeferPaint' has a wrong offset!");

// Class OdyUI.OdyEnhancedInputPlatformData
// 0x0058 (0x00D0 - 0x0078)
class UOdyEnhancedInputPlatformData : public UEnhancedInputPlatformData
{
public:
	TMap<class UInputMappingContext*, class UInputMappingContext*> ConditionalMappingContextRedirects;                // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ContextTag;                                        // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateMappingContextRedirects(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyEnhancedInputPlatformData">();
	}
	static class UOdyEnhancedInputPlatformData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyEnhancedInputPlatformData>();
	}
};
static_assert(alignof(UOdyEnhancedInputPlatformData) == 0x000008, "Wrong alignment on UOdyEnhancedInputPlatformData");
static_assert(sizeof(UOdyEnhancedInputPlatformData) == 0x0000D0, "Wrong size on UOdyEnhancedInputPlatformData");
static_assert(offsetof(UOdyEnhancedInputPlatformData, ConditionalMappingContextRedirects) == 0x000078, "Member 'UOdyEnhancedInputPlatformData::ConditionalMappingContextRedirects' has a wrong offset!");
static_assert(offsetof(UOdyEnhancedInputPlatformData, ContextTag) == 0x0000C8, "Member 'UOdyEnhancedInputPlatformData::ContextTag' has a wrong offset!");

// Class OdyUI.OdyGameViewportClient
// 0x0030 (0x03E0 - 0x03B0)
class UOdyGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_3B0[0x30];                                     // 0x03B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyGameViewportClient">();
	}
	static class UOdyGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyGameViewportClient>();
	}
};
static_assert(alignof(UOdyGameViewportClient) == 0x000008, "Wrong alignment on UOdyGameViewportClient");
static_assert(sizeof(UOdyGameViewportClient) == 0x0003E0, "Wrong size on UOdyGameViewportClient");

// Class OdyUI.OdyHUD
// 0x0028 (0x03A8 - 0x0380)
class AOdyHUD : public AHUD
{
public:
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOdyUIRouter>               RouterClass;                                       // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RouterZOrder;                                      // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoadingScreenTeardownDelaySeconds;                 // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOdyUIRouter*                           UIRouter;                                          // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUIRouterCreated();
	void ShowUIRouter();

	class UOdyUIRouter* GetUIRouter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyHUD">();
	}
	static class AOdyHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOdyHUD>();
	}
};
static_assert(alignof(AOdyHUD) == 0x000008, "Wrong alignment on AOdyHUD");
static_assert(sizeof(AOdyHUD) == 0x0003A8, "Wrong size on AOdyHUD");
static_assert(offsetof(AOdyHUD, RouterClass) == 0x000388, "Member 'AOdyHUD::RouterClass' has a wrong offset!");
static_assert(offsetof(AOdyHUD, RouterZOrder) == 0x000390, "Member 'AOdyHUD::RouterZOrder' has a wrong offset!");
static_assert(offsetof(AOdyHUD, LoadingScreenTeardownDelaySeconds) == 0x000394, "Member 'AOdyHUD::LoadingScreenTeardownDelaySeconds' has a wrong offset!");
static_assert(offsetof(AOdyHUD, UIRouter) == 0x000398, "Member 'AOdyHUD::UIRouter' has a wrong offset!");

// Class OdyUI.OdyInputRichTextBlockDecorator
// 0x0148 (0x0170 - 0x0028)
class UOdyInputRichTextBlockDecorator : public URichTextBlockDecorator
{
public:
	TMap<struct FGameplayTag, class UDataTable*>  InputDeviceKeyImageDataTables;                     // 0x0028(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            ChordSeparatorBrush;                               // 0x0080(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x20];                                     // 0x0150(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnControlMappingsRebuilt();
	void OnInputDeviceChanged(const struct FGameplayTag& InputDeviceTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyInputRichTextBlockDecorator">();
	}
	static class UOdyInputRichTextBlockDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyInputRichTextBlockDecorator>();
	}
};
static_assert(alignof(UOdyInputRichTextBlockDecorator) == 0x000010, "Wrong alignment on UOdyInputRichTextBlockDecorator");
static_assert(sizeof(UOdyInputRichTextBlockDecorator) == 0x000170, "Wrong size on UOdyInputRichTextBlockDecorator");
static_assert(offsetof(UOdyInputRichTextBlockDecorator, InputDeviceKeyImageDataTables) == 0x000028, "Member 'UOdyInputRichTextBlockDecorator::InputDeviceKeyImageDataTables' has a wrong offset!");
static_assert(offsetof(UOdyInputRichTextBlockDecorator, ChordSeparatorBrush) == 0x000080, "Member 'UOdyInputRichTextBlockDecorator::ChordSeparatorBrush' has a wrong offset!");

// Class OdyUI.OdyListView
// 0x0000 (0x0C80 - 0x0C80)
class UOdyListView final : public UListView
{
public:
	void SetEntryWidgetClass(TSubclassOf<class UUserWidget> InEntryWidgetClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyListView">();
	}
	static class UOdyListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyListView>();
	}
};
static_assert(alignof(UOdyListView) == 0x000010, "Wrong alignment on UOdyListView");
static_assert(sizeof(UOdyListView) == 0x000C80, "Wrong size on UOdyListView");

// Class OdyUI.OdyMenuData
// 0x0070 (0x00A0 - 0x0030)
class UOdyMenuData final : public UDataAsset
{
public:
	struct FGameplayTag                           MenuId;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MenuDisplayName;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MenuClass;                                         // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MobileMenuClass;                                   // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AsyncLoadPriority;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSoftClassPtr<class UClass> GetMenuClass(EPlatformType Platform) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyMenuData">();
	}
	static class UOdyMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyMenuData>();
	}
};
static_assert(alignof(UOdyMenuData) == 0x000008, "Wrong alignment on UOdyMenuData");
static_assert(sizeof(UOdyMenuData) == 0x0000A0, "Wrong size on UOdyMenuData");
static_assert(offsetof(UOdyMenuData, MenuId) == 0x000030, "Member 'UOdyMenuData::MenuId' has a wrong offset!");
static_assert(offsetof(UOdyMenuData, MenuDisplayName) == 0x000038, "Member 'UOdyMenuData::MenuDisplayName' has a wrong offset!");
static_assert(offsetof(UOdyMenuData, MenuClass) == 0x000048, "Member 'UOdyMenuData::MenuClass' has a wrong offset!");
static_assert(offsetof(UOdyMenuData, MobileMenuClass) == 0x000070, "Member 'UOdyMenuData::MobileMenuClass' has a wrong offset!");
static_assert(offsetof(UOdyMenuData, AsyncLoadPriority) == 0x000098, "Member 'UOdyMenuData::AsyncLoadPriority' has a wrong offset!");

// Class OdyUI.OdyNavButton
// 0x0060 (0x0670 - 0x0610)
class UOdyNavButton final : public UButton
{
public:
	struct FOdyMenuNavData                        MenuNavData;                                       // 0x0608(0x0068)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	void Navigate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyNavButton">();
	}
	static class UOdyNavButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyNavButton>();
	}
};
static_assert(alignof(UOdyNavButton) == 0x000010, "Wrong alignment on UOdyNavButton");
static_assert(sizeof(UOdyNavButton) == 0x000670, "Wrong size on UOdyNavButton");
static_assert(offsetof(UOdyNavButton, MenuNavData) == 0x000608, "Member 'UOdyNavButton::MenuNavData' has a wrong offset!");

// Class OdyUI.OdyNavCheckboxGroup
// 0x0020 (0x0048 - 0x0028)
class UOdyNavCheckboxGroup final : public UObject
{
public:
	class FName                                   GroupId;                                           // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UWidgetTree>             ParentWidgetTree;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOdyNavCheckbox*>                Checkboxes;                                        // 0x0038(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyNavCheckboxGroup">();
	}
	static class UOdyNavCheckboxGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyNavCheckboxGroup>();
	}
};
static_assert(alignof(UOdyNavCheckboxGroup) == 0x000008, "Wrong alignment on UOdyNavCheckboxGroup");
static_assert(sizeof(UOdyNavCheckboxGroup) == 0x000048, "Wrong size on UOdyNavCheckboxGroup");
static_assert(offsetof(UOdyNavCheckboxGroup, GroupId) == 0x000028, "Member 'UOdyNavCheckboxGroup::GroupId' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckboxGroup, ParentWidgetTree) == 0x000030, "Member 'UOdyNavCheckboxGroup::ParentWidgetTree' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckboxGroup, Checkboxes) == 0x000038, "Member 'UOdyNavCheckboxGroup::Checkboxes' has a wrong offset!");

// Class OdyUI.OdyNavCheckbox
// 0x00C0 (0x0D70 - 0x0CB0)
class UOdyNavCheckbox final : public UCheckBox
{
public:
	struct FOdyMenuNavData                        MenuNavData;                                       // 0x0CA8(0x0068)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class FName                                   GroupId;                                           // 0x0D10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOdyNavCheckboxGroup*                   CheckboxGroup;                                     // 0x0D18(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanUserUncheck;                                   // 0x0D20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D21[0x7];                                      // 0x0D21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHovered;                                         // 0x0D28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnUnhovered;                                       // 0x0D38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPressed;                                         // 0x0D48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnReleased;                                        // 0x0D58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D68[0x8];                                      // 0x0D68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Navigate();
	void SetGroupId(class FName InGroupId);
	void SetIsCheckedWithCallback(bool InIsChecked, bool bAllowNavigate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyNavCheckbox">();
	}
	static class UOdyNavCheckbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyNavCheckbox>();
	}
};
static_assert(alignof(UOdyNavCheckbox) == 0x000010, "Wrong alignment on UOdyNavCheckbox");
static_assert(sizeof(UOdyNavCheckbox) == 0x000D70, "Wrong size on UOdyNavCheckbox");
static_assert(offsetof(UOdyNavCheckbox, MenuNavData) == 0x000CA8, "Member 'UOdyNavCheckbox::MenuNavData' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckbox, GroupId) == 0x000D10, "Member 'UOdyNavCheckbox::GroupId' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckbox, CheckboxGroup) == 0x000D18, "Member 'UOdyNavCheckbox::CheckboxGroup' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckbox, bCanUserUncheck) == 0x000D20, "Member 'UOdyNavCheckbox::bCanUserUncheck' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckbox, OnHovered) == 0x000D28, "Member 'UOdyNavCheckbox::OnHovered' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckbox, OnUnhovered) == 0x000D38, "Member 'UOdyNavCheckbox::OnUnhovered' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckbox, OnPressed) == 0x000D48, "Member 'UOdyNavCheckbox::OnPressed' has a wrong offset!");
static_assert(offsetof(UOdyNavCheckbox, OnReleased) == 0x000D58, "Member 'UOdyNavCheckbox::OnReleased' has a wrong offset!");

// Class OdyUI.OdySpringStatics
// 0x0000 (0x0028 - 0x0028)
class UOdySpringStatics final : public UObject
{
public:
	static float AdvanceSpringFloat(const float DeltaTime, const struct FOdySpringConfiguration& SpringConfiguration, struct FOdySpringStateFloat& SpringState, const float From, const float To);
	static float AdvanceSpringFloatAngle(const float DeltaTime, const struct FOdySpringConfiguration& SpringConfiguration, struct FOdySpringStateFloat& SpringState, const float From, const float To);
	static struct FRotator AdvanceSpringRotator(const float DeltaTime, const struct FOdySpringConfiguration& SpringConfiguration, struct FOdySpringStateRotator& SpringState, const struct FRotator& From, const struct FRotator& To);
	static struct FVector AdvanceSpringVector(const float DeltaTime, const struct FOdySpringConfiguration& SpringConfiguration, struct FOdySpringStateVector& SpringState, const struct FVector& From, const struct FVector& To);
	static struct FVector2D AdvanceSpringVector2D(const float DeltaTime, const struct FOdySpringConfiguration& SpringConfiguration, struct FOdySpringStateVector2D& SpringState, const struct FVector2D& From, const struct FVector2D& To);
	static struct FOdySpringConfiguration GetSpringPreset(const EOdySpringPreset Preset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdySpringStatics">();
	}
	static class UOdySpringStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdySpringStatics>();
	}
};
static_assert(alignof(UOdySpringStatics) == 0x000008, "Wrong alignment on UOdySpringStatics");
static_assert(sizeof(UOdySpringStatics) == 0x000028, "Wrong size on UOdySpringStatics");

// Class OdyUI.OdyTextBlock
// 0x0000 (0x0370 - 0x0370)
class UOdyTextBlock final : public UTextBlock
{
public:
	void SetWrapTextAt(float InWrapTextAt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyTextBlock">();
	}
	static class UOdyTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyTextBlock>();
	}
};
static_assert(alignof(UOdyTextBlock) == 0x000010, "Wrong alignment on UOdyTextBlock");
static_assert(sizeof(UOdyTextBlock) == 0x000370, "Wrong size on UOdyTextBlock");

// Class OdyUI.OdyTileView
// 0x0000 (0x0CB0 - 0x0CB0)
class UOdyTileView final : public UTileView
{
public:
	void SetEntryWidgetClass(TSubclassOf<class UUserWidget> InEntryWidgetClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyTileView">();
	}
	static class UOdyTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyTileView>();
	}
};
static_assert(alignof(UOdyTileView) == 0x000010, "Wrong alignment on UOdyTileView");
static_assert(sizeof(UOdyTileView) == 0x000CB0, "Wrong size on UOdyTileView");

// Class OdyUI.OdyUIAssetData
// 0x0000 (0x0030 - 0x0030)
class UOdyUIAssetData : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIAssetData">();
	}
	static class UOdyUIAssetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIAssetData>();
	}
};
static_assert(alignof(UOdyUIAssetData) == 0x000008, "Wrong alignment on UOdyUIAssetData");
static_assert(sizeof(UOdyUIAssetData) == 0x000030, "Wrong size on UOdyUIAssetData");

// Class OdyUI.OdyUIBoolBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUIBoolBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BoolBinding_AddDelegate(struct FOdyUIBoolBinding& BoolBinding, TDelegate<void(bool OldValue, bool NewValue)> Delegate, bool bExecuteNow);
	static void BoolBinding_BindWidgetIsEnabled(struct FOdyUIBoolBinding& BoolBinding, class UWidget* Widget, bool bInvert);
	static void BoolBinding_BindWidgetVisibility(struct FOdyUIBoolBinding& BoolBinding, class UWidget* Widget, ESlateVisibility FalseVisibility, ESlateVisibility TrueVisibility);
	static bool BoolBinding_GetValue(const struct FOdyUIBoolBinding& BoolBinding);
	static void BoolBinding_RemoveDelegate(struct FOdyUIBoolBinding& BoolBinding, TDelegate<void(bool OldValue, bool NewValue)> Delegate);
	static void BoolBinding_SetValue(struct FOdyUIBoolBinding& BoolBinding, bool Bool);
	static void BoolBinding_Unbind(struct FOdyUIBoolBinding& BoolBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIBoolBindingFunctionLibrary">();
	}
	static class UOdyUIBoolBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIBoolBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUIBoolBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUIBoolBindingFunctionLibrary");
static_assert(sizeof(UOdyUIBoolBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUIBoolBindingFunctionLibrary");

// Class OdyUI.OdyUIColorBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUIColorBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ColorBinding_AddDelegate(struct FOdyUIColorBinding& ColorBinding, TDelegate<void(const struct FLinearColor& OldValue, const struct FLinearColor& NewValue)> Delegate, bool bExecuteNow);
	static void ColorBinding_BindBorderBrushColorAndOpacity(struct FOdyUIColorBinding& ColorBinding, class UBorder* Border);
	static void ColorBinding_BindBorderContentColorAndOpacity(struct FOdyUIColorBinding& ColorBinding, class UBorder* Border);
	static void ColorBinding_BindButtonColorAndOpacity(struct FOdyUIColorBinding& ColorBinding, class UButton* Button);
	static void ColorBinding_BindImageColorAndOpacity(struct FOdyUIColorBinding& ColorBinding, class UImage* Image);
	static void ColorBinding_BindTextBlockColorAndOpacity(struct FOdyUIColorBinding& ColorBinding, class UTextBlock* TextBlock);
	static void ColorBinding_BindUserWidgetColorAndOpacity(struct FOdyUIColorBinding& ColorBinding, class UUserWidget* Widget);
	static struct FLinearColor ColorBinding_GetValue(const struct FOdyUIColorBinding& ColorBinding);
	static void ColorBinding_RemoveDelegate(struct FOdyUIColorBinding& ColorBinding, TDelegate<void(const struct FLinearColor& OldValue, const struct FLinearColor& NewValue)> Delegate);
	static void ColorBinding_SetValue(struct FOdyUIColorBinding& ColorBinding, const struct FLinearColor& Color);
	static void ColorBinding_Unbind(struct FOdyUIColorBinding& ColorBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIColorBindingFunctionLibrary">();
	}
	static class UOdyUIColorBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIColorBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUIColorBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUIColorBindingFunctionLibrary");
static_assert(sizeof(UOdyUIColorBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUIColorBindingFunctionLibrary");

// Class OdyUI.OdyUIData
// 0x0040 (0x0068 - 0x0028)
class UOdyUIData : public UObject
{
public:
	bool                                          bIsLoaded;                                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3F];                                      // 0x0029(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(const struct FInstancedStruct& InitParams);
	void OnInit(const struct FInstancedStruct& InitParams);
	void OnShutdown();
	void OnUpdateData(const struct FInstancedStruct& UpdateParams);
	void Shutdown();
	void UpdateData(const struct FInstancedStruct& UpdateParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIData">();
	}
	static class UOdyUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIData>();
	}
};
static_assert(alignof(UOdyUIData) == 0x000008, "Wrong alignment on UOdyUIData");
static_assert(sizeof(UOdyUIData) == 0x000068, "Wrong size on UOdyUIData");
static_assert(offsetof(UOdyUIData, bIsLoaded) == 0x000028, "Member 'UOdyUIData::bIsLoaded' has a wrong offset!");

// Class OdyUI.OdyUIDataModelBase
// 0x0018 (0x0040 - 0x0028)
class UOdyUIDataModelBase : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIDataModelBase">();
	}
	static class UOdyUIDataModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIDataModelBase>();
	}
};
static_assert(alignof(UOdyUIDataModelBase) == 0x000008, "Wrong alignment on UOdyUIDataModelBase");
static_assert(sizeof(UOdyUIDataModelBase) == 0x000040, "Wrong size on UOdyUIDataModelBase");

// Class OdyUI.OdyUIDateTimeBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUIDateTimeBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DateTimeBinding_AddDelegate(struct FOdyUIDateTimeBinding& DateTimeBinding, TDelegate<void(const struct FDateTime& OldValue, const struct FDateTime& NewValue)> Delegate, bool bExecuteNow);
	static struct FDateTime DateTimeBinding_GetValue(const struct FOdyUIDateTimeBinding& DateTimeBinding);
	static void DateTimeBinding_RemoveDelegate(struct FOdyUIDateTimeBinding& DateTimeBinding, TDelegate<void(const struct FDateTime& OldValue, const struct FDateTime& NewValue)> Delegate);
	static void DateTimeBinding_SetValue(struct FOdyUIDateTimeBinding& DateTimeBinding, const struct FDateTime& DateTime);
	static void DateTimeBinding_Unbind(struct FOdyUIDateTimeBinding& DateTimeBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIDateTimeBindingFunctionLibrary">();
	}
	static class UOdyUIDateTimeBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIDateTimeBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUIDateTimeBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUIDateTimeBindingFunctionLibrary");
static_assert(sizeof(UOdyUIDateTimeBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUIDateTimeBindingFunctionLibrary");

// Class OdyUI.OdyUIDPIScalingRule
// 0x00E0 (0x0108 - 0x0028)
class UOdyUIDPIScalingRule final : public UDPICustomScalingRule
{
public:
	struct FOdyUIDPIScalingSettings               DefaultDPISettings;                                // 0x0028(0x0090)(Edit, NativeAccessSpecifierPrivate)
	TMap<EPlatformType, struct FOdyUIDPIScalingSettings> PlatformDPISettings;                               // 0x00B8(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIDPIScalingRule">();
	}
	static class UOdyUIDPIScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIDPIScalingRule>();
	}
};
static_assert(alignof(UOdyUIDPIScalingRule) == 0x000008, "Wrong alignment on UOdyUIDPIScalingRule");
static_assert(sizeof(UOdyUIDPIScalingRule) == 0x000108, "Wrong size on UOdyUIDPIScalingRule");
static_assert(offsetof(UOdyUIDPIScalingRule, DefaultDPISettings) == 0x000028, "Member 'UOdyUIDPIScalingRule::DefaultDPISettings' has a wrong offset!");
static_assert(offsetof(UOdyUIDPIScalingRule, PlatformDPISettings) == 0x0000B8, "Member 'UOdyUIDPIScalingRule::PlatformDPISettings' has a wrong offset!");

// Class OdyUI.OdyUIFloatBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUIFloatBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void FloatBinding_AddDelegate(struct FOdyUIFloatBinding& FloatBinding, TDelegate<void(float OldValue, float NewValue)> Delegate, bool bExecuteNow);
	static void FloatBinding_BindImageMaterialScalarParam(struct FOdyUIFloatBinding& FloatBinding, class UImage* Image, class FName ParamName);
	static void FloatBinding_BindMaterialScalarParam(struct FOdyUIFloatBinding& FloatBinding, class UMaterialInstanceDynamic* Mid, class FName ParamName);
	static float FloatBinding_GetValue(const struct FOdyUIFloatBinding& FloatBinding);
	static void FloatBinding_RemoveDelegate(struct FOdyUIFloatBinding& FloatBinding, TDelegate<void(float OldValue, float NewValue)> Delegate);
	static void FloatBinding_SetValue(struct FOdyUIFloatBinding& FloatBinding, float Float);
	static void FloatBinding_Unbind(struct FOdyUIFloatBinding& FloatBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIFloatBindingFunctionLibrary">();
	}
	static class UOdyUIFloatBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIFloatBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUIFloatBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUIFloatBindingFunctionLibrary");
static_assert(sizeof(UOdyUIFloatBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUIFloatBindingFunctionLibrary");

// Class OdyUI.OdyUIGameplayTagBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUIGameplayTagBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GameplayTagBinding_AddDelegate(struct FOdyUIGameplayTagBinding& GameplayTagBinding, TDelegate<void(const struct FGameplayTag& OldValue, const struct FGameplayTag& NewValue)> Delegate, bool bExecuteNow);
	static struct FGameplayTag GameplayTagBinding_GetValue(const struct FOdyUIGameplayTagBinding& GameplayTagBinding);
	static void GameplayTagBinding_RemoveDelegate(struct FOdyUIGameplayTagBinding& GameplayTagBinding, TDelegate<void(const struct FGameplayTag& OldValue, const struct FGameplayTag& NewValue)> Delegate);
	static void GameplayTagBinding_SetValue(struct FOdyUIGameplayTagBinding& GameplayTagBinding, const struct FGameplayTag& GameplayTag);
	static void GameplayTagBinding_Unbind(struct FOdyUIGameplayTagBinding& GameplayTagBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIGameplayTagBindingFunctionLibrary">();
	}
	static class UOdyUIGameplayTagBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIGameplayTagBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUIGameplayTagBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUIGameplayTagBindingFunctionLibrary");
static_assert(sizeof(UOdyUIGameplayTagBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUIGameplayTagBindingFunctionLibrary");

// Class OdyUI.OdyUIIntBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUIIntBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void IntBinding_AddDelegate(struct FOdyUIIntBinding& IntBinding, TDelegate<void(int32 OldValue, int32 NewValue)> Delegate, bool bExecuteNow);
	static void IntBinding_BindTextBlockFontSize(struct FOdyUIIntBinding& IntBinding, class UTextBlock* TextBlock);
	static void IntBinding_BindTextBlockText(struct FOdyUIIntBinding& IntBinding, class UTextBlock* TextBlock, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits);
	static void IntBinding_BindTextBlockTextToFormat(struct FOdyUIIntBinding& IntBinding, const class FText& Pattern, class UTextBlock* TextBlock, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits);
	static void IntBinding_BindWidgetVisibility(struct FOdyUIIntBinding& IntBinding, class UWidget* Widget, int32 ComparisonValue, ESlateVisibility WhenGreater, ESlateVisibility WhenEqual, ESlateVisibility WhenLess);
	static int32 IntBinding_GetValue(const struct FOdyUIIntBinding& IntBinding);
	static void IntBinding_RemoveDelegate(struct FOdyUIIntBinding& IntBinding, TDelegate<void(int32 OldValue, int32 NewValue)> Delegate);
	static void IntBinding_SetValue(struct FOdyUIIntBinding& IntBinding, int32 Int);
	static void IntBinding_Unbind(struct FOdyUIIntBinding& IntBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIIntBindingFunctionLibrary">();
	}
	static class UOdyUIIntBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIIntBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUIIntBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUIIntBindingFunctionLibrary");
static_assert(sizeof(UOdyUIIntBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUIIntBindingFunctionLibrary");

// Class OdyUI.OdyUIMaterialBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUIMaterialBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MaterialBinding_AddDelegate(struct FOdyUIMaterialBinding& MaterialBinding, TDelegate<void(class UMaterialInterface* OldValue, class UMaterialInterface* NewValue)> Delegate, bool bExecuteNow);
	static void MaterialBinding_BindImage(struct FOdyUIMaterialBinding& MaterialBinding, class UImage* Image, bool bBindVisibility);
	static void MaterialBinding_BindImageWithFallback(struct FOdyUIMaterialBinding& MaterialBinding, class UImage* Image, class UMaterialInterface* FallbackMaterial);
	static class UMaterialInterface* MaterialBinding_GetMaterialValue(const struct FOdyUIMaterialBinding& MaterialBinding);
	static TSoftObjectPtr<class UMaterialInterface> MaterialBinding_GetSoftValue(struct FOdyUIMaterialBinding& MaterialBinding);
	static bool MaterialBinding_HasMaterial(struct FOdyUIMaterialBinding& MaterialBinding);
	static void MaterialBinding_RemoveDelegate(struct FOdyUIMaterialBinding& MaterialBinding, TDelegate<void(class UMaterialInterface* OldValue, class UMaterialInterface* NewValue)> Delegate);
	static void MaterialBinding_SetMaterialValue(struct FOdyUIMaterialBinding& MaterialBinding, class UMaterialInterface* Material);
	static void MaterialBinding_SetSoftValue(struct FOdyUIMaterialBinding& MaterialBinding, TSoftObjectPtr<class UMaterialInterface> SoftMaterial);
	static void MaterialBinding_Unbind(struct FOdyUIMaterialBinding& MaterialBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIMaterialBindingFunctionLibrary">();
	}
	static class UOdyUIMaterialBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIMaterialBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUIMaterialBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUIMaterialBindingFunctionLibrary");
static_assert(sizeof(UOdyUIMaterialBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUIMaterialBindingFunctionLibrary");

// Class OdyUI.OdyUINameBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUINameBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void NameBinding_AddDelegate(struct FOdyUINameBinding& NameBinding, TDelegate<void(class FName OldValue, class FName NewValue)> Delegate, bool bExecuteNow);
	static class FName NameBinding_GetValue(const struct FOdyUINameBinding& NameBinding);
	static void NameBinding_RemoveDelegate(struct FOdyUINameBinding& NameBinding, TDelegate<void(class FName OldValue, class FName NewValue)> Delegate);
	static void NameBinding_SetValue(struct FOdyUINameBinding& NameBinding, class FName Name_0);
	static void NameBinding_Unbind(struct FOdyUINameBinding& NameBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUINameBindingFunctionLibrary">();
	}
	static class UOdyUINameBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUINameBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUINameBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUINameBindingFunctionLibrary");
static_assert(sizeof(UOdyUINameBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUINameBindingFunctionLibrary");

// Class OdyUI.OdyUIObjectBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUIObjectBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ObjectBinding_AddDelegate(struct FOdyUIObjectBinding& ObjectBinding, TDelegate<void(class UObject* OldValue, class UObject* NewValue)> Delegate, bool bExecuteNow);
	static class UObject* ObjectBinding_GetValue(const struct FOdyUIObjectBinding& ObjectBinding);
	static void ObjectBinding_RemoveDelegate(struct FOdyUIObjectBinding& ObjectBinding, TDelegate<void(class UObject* OldValue, class UObject* NewValue)> Delegate);
	static void ObjectBinding_SetValue(struct FOdyUIObjectBinding& ObjectBinding, class UObject* Object);
	static void ObjectBinding_Unbind(struct FOdyUIObjectBinding& ObjectBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIObjectBindingFunctionLibrary">();
	}
	static class UOdyUIObjectBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIObjectBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUIObjectBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUIObjectBindingFunctionLibrary");
static_assert(sizeof(UOdyUIObjectBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUIObjectBindingFunctionLibrary");

// Class OdyUI.OdyUIRouter
// 0x0218 (0x04F8 - 0x02E0)
class UOdyUIRouter : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnMenuStackChanged;                                // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMenuInputModeChanged;                            // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadingScreenVisibilityChanged;                  // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCloseAllMenusRequested;                          // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MenuPanel;                                         // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ModalPanel;                                        // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UOdyMenuData*>                   RoutableMenus;                                     // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UOdyMenuData*> RoutableMenuNamesToData;                           // 0x0340(0x0050)(Edit, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	class UOdyMenuData*                           ResolvedDefaultMenu;                               // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOdyMenuData*                           ConfirmationModalMenuData;                         // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UOdyMenuData*>                   MenusToRetainOnReturnToDefault;                    // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         BaseAsyncLoadPriorityForMenus;                     // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputMappingContext*>           GlobalInputContexts;                               // 0x03B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bMenusAreDefaultFocusable;                         // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMenuInputMode                                DefaultInputMode;                                  // 0x03C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOdyAnalogCursorSetting                       MenusWantAnalogCursorByDefault;                    // 0x03CA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOdyAnalogCursorSetting                       MenusWantAnalogCursorHiddenByDefault;              // 0x03CB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOdyAnalogCursorSetting                       MenusWantAnalogCursorLockedByDefault;              // 0x03CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMenuMouseClickAction                         ModalsDefaultMouseClickAction;                     // 0x03CD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CE[0x2];                                      // 0x03CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultMenuCameraId;                               // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowsEmptyMenuStack;                             // 0x03D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UOdyMenu>>           LoadedMenuClasses;                                 // 0x03E0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UOdyMenu*>    MenuPool;                                          // 0x03F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FOdyMenuStack                          MenuStack;                                         // 0x0440(0x0030)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FOdyMenuStack                          ModalStack;                                        // 0x0470(0x0030)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EMenuInputMode                                LastInputModeApplied;                              // 0x04A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoringGameInput;                                // 0x04A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A2[0x56];                                     // 0x04A2(0x0056)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FKey GetPlatformUniversalAccept();
	static const struct FKey GetPlatformUniversalBack();
	static class UOdyUIRouter* GetUIRouter(const class UObject* WorldContextObject);

	void CloseAllUserClosableMenus();
	void CloseMenu(class UOdyMenu* Menu);
	class UOdyMenu* CreateMenu(class UOdyMenuData* MenuAsset);
	void NavigateToDefaultMenu(const TMap<class FString, class FString>& Args, const class FString& Action);
	void NavigateToMenu(class UOdyMenu* Menu, const TMap<class FString, class FString>& Args, const class FString& Action, int32 NavigationOptions, EMenuInputMode InputModeOverride, EOdyModalPriority ModalPriorityOverride);
	void NavigateToPath(const class FString& Path);
	void OnGameStateReady(class AGameStateBase* GameState);
	void OnInputMethodChanged(EInputMethod InputMethod);
	void OnMenuDisplayStateChanged(class UOdyWidget* MenuWidget, EOdyWidgetDisplayState OldState, EOdyWidgetDisplayState NewState);
	void PopInputContext(class UInputComponent* Requester, class UInputMappingContext* InputContext);
	void PushInputContext(class UInputComponent* Requester, class UInputMappingContext* InputContext, EOdyInputContextPriority InputContextPriority);
	void ReturnToDefaultMenu();
	void SetMenuNeverWantsInput(class UOdyMenu* Menu, bool bNeverWantsInput);
	void SetViewTargetForMenu(class UOdyMenu* Menu, class FName CameraId, bool bOnlyLatestOnStack);
	void ShowConfirmationModal(const class FText& Title, const class FText& Message, const class FText& ConfirmText, const class FText& CancelText, const TDelegate<void(bool bConfirmed)>& OnDismissed, class UOdyMenuData* CustomConfirmationMenuData);
	void UpdateInputModeAndFocus();
	void UpdateModalZOrders();

	TArray<class UOdyMenu*> FindAllMenus(const struct FGameplayTag& MenuId, bool bModal) const;
	TArray<class UOdyMenu*> FindAllMenusByData(class UOdyMenuData* MenuData) const;
	class UOdyMenu* FindMenu(const struct FGameplayTag& MenuId, bool bModal) const;
	class UOdyMenu* FindMenuByData(class UOdyMenuData* MenuData) const;
	TArray<class UOdyMenu*> GetStack(bool bModal) const;
	class UOdyMenu* GetTopMenu(int32 SearchOptions) const;
	class UOdyMenu* GetTopOfStack(bool bModal) const;
	int32 IndexOfOnStack(class UOdyMenu* Menu, bool bSearchFromEnd) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIRouter">();
	}
	static class UOdyUIRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIRouter>();
	}
};
static_assert(alignof(UOdyUIRouter) == 0x000008, "Wrong alignment on UOdyUIRouter");
static_assert(sizeof(UOdyUIRouter) == 0x0004F8, "Wrong size on UOdyUIRouter");
static_assert(offsetof(UOdyUIRouter, OnMenuStackChanged) == 0x0002E0, "Member 'UOdyUIRouter::OnMenuStackChanged' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, OnMenuInputModeChanged) == 0x0002F0, "Member 'UOdyUIRouter::OnMenuInputModeChanged' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, OnLoadingScreenVisibilityChanged) == 0x000300, "Member 'UOdyUIRouter::OnLoadingScreenVisibilityChanged' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, OnCloseAllMenusRequested) == 0x000310, "Member 'UOdyUIRouter::OnCloseAllMenusRequested' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, MenuPanel) == 0x000320, "Member 'UOdyUIRouter::MenuPanel' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, ModalPanel) == 0x000328, "Member 'UOdyUIRouter::ModalPanel' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, RoutableMenus) == 0x000330, "Member 'UOdyUIRouter::RoutableMenus' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, RoutableMenuNamesToData) == 0x000340, "Member 'UOdyUIRouter::RoutableMenuNamesToData' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, ResolvedDefaultMenu) == 0x000390, "Member 'UOdyUIRouter::ResolvedDefaultMenu' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, ConfirmationModalMenuData) == 0x000398, "Member 'UOdyUIRouter::ConfirmationModalMenuData' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, MenusToRetainOnReturnToDefault) == 0x0003A0, "Member 'UOdyUIRouter::MenusToRetainOnReturnToDefault' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, BaseAsyncLoadPriorityForMenus) == 0x0003B0, "Member 'UOdyUIRouter::BaseAsyncLoadPriorityForMenus' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, GlobalInputContexts) == 0x0003B8, "Member 'UOdyUIRouter::GlobalInputContexts' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, bMenusAreDefaultFocusable) == 0x0003C8, "Member 'UOdyUIRouter::bMenusAreDefaultFocusable' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, DefaultInputMode) == 0x0003C9, "Member 'UOdyUIRouter::DefaultInputMode' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, MenusWantAnalogCursorByDefault) == 0x0003CA, "Member 'UOdyUIRouter::MenusWantAnalogCursorByDefault' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, MenusWantAnalogCursorHiddenByDefault) == 0x0003CB, "Member 'UOdyUIRouter::MenusWantAnalogCursorHiddenByDefault' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, MenusWantAnalogCursorLockedByDefault) == 0x0003CC, "Member 'UOdyUIRouter::MenusWantAnalogCursorLockedByDefault' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, ModalsDefaultMouseClickAction) == 0x0003CD, "Member 'UOdyUIRouter::ModalsDefaultMouseClickAction' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, DefaultMenuCameraId) == 0x0003D0, "Member 'UOdyUIRouter::DefaultMenuCameraId' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, bAllowsEmptyMenuStack) == 0x0003D8, "Member 'UOdyUIRouter::bAllowsEmptyMenuStack' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, LoadedMenuClasses) == 0x0003E0, "Member 'UOdyUIRouter::LoadedMenuClasses' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, MenuPool) == 0x0003F0, "Member 'UOdyUIRouter::MenuPool' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, MenuStack) == 0x000440, "Member 'UOdyUIRouter::MenuStack' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, ModalStack) == 0x000470, "Member 'UOdyUIRouter::ModalStack' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, LastInputModeApplied) == 0x0004A0, "Member 'UOdyUIRouter::LastInputModeApplied' has a wrong offset!");
static_assert(offsetof(UOdyUIRouter, bIgnoringGameInput) == 0x0004A1, "Member 'UOdyUIRouter::bIgnoringGameInput' has a wrong offset!");

// Class OdyUI.OdyUIStatics
// 0x0000 (0x0028 - 0x0028)
class UOdyUIStatics final : public UBlueprintFunctionLibrary
{
public:
	static void CenterCursor(class UObject* WorldContext);
	static class UOdyUIData* CreateUIData(class UObject* Outer_0, TSubclassOf<class UOdyUIData> UIDataType, const struct FInstancedStruct& InitParams);
	static void DateTime_ToFormattedString(const struct FDateTime& DateTime, class FString* String, const class FString& Format);
	static class UOdyMenu* FindOuterMenu(const class UWidget* Widget);
	static class ULocalPlayer* GetCursorLocalPlayer(class UObject* WorldContextObject);
	static class UUserWidget* GetEntryWidgetFromListViewItem(class UListView* ListView, class UObject* Item);
	static void Integer_ToTextPadded(class FText* OutText, int32 Integer, int32 Width, const class FString& Padding);
	static bool IsConstructed(class UWidget* Widget);
	static struct FTimespan MakeTimespan(const struct FDateTime& A, const struct FDateTime& B);
	static void SetCheckboxBorderBackgroundColor(class UCheckBox* CheckBox, const struct FLinearColor& Color);
	static void SetClearKeyboardFocusOnCommit(class UEditableTextBox* TextBox, bool bClearKeyboardFocusOnCommit);
	static void SetDefaultFontSize(class URichTextBlock* RichTextBlock, int32 FontSize);
	static void SetFlowDirectionPreference(class UWidget* Widget, EFlowDirectionPreference FlowDirection);
	static void SetFontOutlineColor(class UTextBlock* TextBlock, const struct FLinearColor& Color);
	static void SetFontSize(class UTextBlock* TextBlock, int32 FontSize);
	static void SetImageCornerRadius(class UImage* Image, const struct FVector4& CornerRadius);
	static void SetJustification(class UTextBlock* TextBlock, ETextJustify Justify);
	static void SetRichTextJustification(class URichTextBlock* RichTextBlock, ETextJustify Justify);
	static void UpdateOdyPlatformInputData(const struct FGameplayTag& ContextTag, bool bInEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUIStatics">();
	}
	static class UOdyUIStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUIStatics>();
	}
};
static_assert(alignof(UOdyUIStatics) == 0x000008, "Wrong alignment on UOdyUIStatics");
static_assert(sizeof(UOdyUIStatics) == 0x000028, "Wrong size on UOdyUIStatics");

// Class OdyUI.OdyUISubsystemBase
// 0x01A0 (0x01D0 - 0x0030)
class UOdyUISubsystemBase : public UGameInstanceSubsystem
{
public:
	class UInputMappingContext*                   ClosableMenuInputContext;                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     DevicesThatSwapVirtualAcceptAndBack;               // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputMethodChanged;                              // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSubInputMethodChanged;                           // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputDeviceChanged;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameViewportClientReceivedFocus;                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameViewportClientLostFocus;                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x38];                                      // 0x00D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOdyAnalogCursorSettings               AnalogCursorSettings;                              // 0x0110(0x0058)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         InputPreprocessorIndex;                            // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C[0x64];                                     // 0x016C(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOdyUISubsystemBase* GetUISubsystemBase(const class UObject* WorldContextObject);

	void SetAnalogCursorGamepadVirtualAccept(bool bEnabled);

	EOdyAnalogCursorMode GetCursorMode() const;
	struct FGameplayTag GetInputDeviceTag() const;
	EInputMethod GetInputMethod() const;
	ESubInputMethod GetSubInputMethod() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUISubsystemBase">();
	}
	static class UOdyUISubsystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUISubsystemBase>();
	}
};
static_assert(alignof(UOdyUISubsystemBase) == 0x000008, "Wrong alignment on UOdyUISubsystemBase");
static_assert(sizeof(UOdyUISubsystemBase) == 0x0001D0, "Wrong size on UOdyUISubsystemBase");
static_assert(offsetof(UOdyUISubsystemBase, ClosableMenuInputContext) == 0x000030, "Member 'UOdyUISubsystemBase::ClosableMenuInputContext' has a wrong offset!");
static_assert(offsetof(UOdyUISubsystemBase, DevicesThatSwapVirtualAcceptAndBack) == 0x000038, "Member 'UOdyUISubsystemBase::DevicesThatSwapVirtualAcceptAndBack' has a wrong offset!");
static_assert(offsetof(UOdyUISubsystemBase, OnInputMethodChanged) == 0x000088, "Member 'UOdyUISubsystemBase::OnInputMethodChanged' has a wrong offset!");
static_assert(offsetof(UOdyUISubsystemBase, OnSubInputMethodChanged) == 0x000098, "Member 'UOdyUISubsystemBase::OnSubInputMethodChanged' has a wrong offset!");
static_assert(offsetof(UOdyUISubsystemBase, OnInputDeviceChanged) == 0x0000A8, "Member 'UOdyUISubsystemBase::OnInputDeviceChanged' has a wrong offset!");
static_assert(offsetof(UOdyUISubsystemBase, OnGameViewportClientReceivedFocus) == 0x0000B8, "Member 'UOdyUISubsystemBase::OnGameViewportClientReceivedFocus' has a wrong offset!");
static_assert(offsetof(UOdyUISubsystemBase, OnGameViewportClientLostFocus) == 0x0000C8, "Member 'UOdyUISubsystemBase::OnGameViewportClientLostFocus' has a wrong offset!");
static_assert(offsetof(UOdyUISubsystemBase, AnalogCursorSettings) == 0x000110, "Member 'UOdyUISubsystemBase::AnalogCursorSettings' has a wrong offset!");
static_assert(offsetof(UOdyUISubsystemBase, InputPreprocessorIndex) == 0x000168, "Member 'UOdyUISubsystemBase::InputPreprocessorIndex' has a wrong offset!");

// Class OdyUI.OdyUITextBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUITextBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void TextBinding_AddDelegate(struct FOdyUITextBinding& TextBinding, TDelegate<void(class FText OldValue, class FText NewValue)> Delegate, bool bExecuteNow);
	static void TextBinding_BindRichTextBlockText(struct FOdyUITextBinding& TextBinding, class URichTextBlock* RichTextBlock);
	static void TextBinding_BindRichTextBlockTextToFormat(struct FOdyUITextBinding& TextBinding, class URichTextBlock* RichTextBlock, const class FText& FormatText);
	static void TextBinding_BindTextBlockText(struct FOdyUITextBinding& TextBinding, class UTextBlock* TextBlock);
	static void TextBinding_BindTextBlockTextToFormat(struct FOdyUITextBinding& TextBinding, class UTextBlock* TextBlock, const class FText& FormatText);
	static class FText TextBinding_GetValue(const struct FOdyUITextBinding& TextBinding);
	static void TextBinding_RemoveDelegate(struct FOdyUITextBinding& TextBinding, TDelegate<void(class FText OldValue, class FText NewValue)> Delegate);
	static void TextBinding_SetValue(struct FOdyUITextBinding& TextBinding, const class FText& Text);
	static void TextBinding_Unbind(struct FOdyUITextBinding& TextBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUITextBindingFunctionLibrary">();
	}
	static class UOdyUITextBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUITextBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUITextBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUITextBindingFunctionLibrary");
static_assert(sizeof(UOdyUITextBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUITextBindingFunctionLibrary");

// Class OdyUI.OdyUITextureBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUITextureBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void TextureBinding_AddDelegate(struct FOdyUITextureBinding& TextureBinding, TDelegate<void(class UTexture* OldValue, class UTexture* NewValue)> Delegate, bool bExecuteNow);
	static void TextureBinding_BindImage(struct FOdyUITextureBinding& TextureBinding, class UImage* Image, bool bMatchSize, bool bBindVisibility);
	static void TextureBinding_BindImageMaterialTextureParam(struct FOdyUITextureBinding& TextureBinding, class UImage* Image, class FName ParamName, class FName BindAlphaParamName);
	static void TextureBinding_BindImageWithFallback(struct FOdyUITextureBinding& TextureBinding, class UImage* Image, bool bMatchSize, class UTexture2D* FallbackTexture);
	static void TextureBinding_BindImageWithFallbackBrush(struct FOdyUITextureBinding& TextureBinding, class UImage* Image, bool bMatchSize, const struct FSlateBrush& Brush, const struct FSlateBrush& FallbackBrush);
	static void TextureBinding_BindMaterialTextureParam(struct FOdyUITextureBinding& TextureBinding, class UMaterialInstanceDynamic* Mid, class FName ParamName);
	static TSoftObjectPtr<class UTexture> TextureBinding_GetSoftValue(struct FOdyUITextureBinding& TextureBinding);
	static class UTexture2D* TextureBinding_GetTexture2DValue(struct FOdyUITextureBinding& TextureBinding);
	static class UTexture* TextureBinding_GetTextureValue(const struct FOdyUITextureBinding& TextureBinding);
	static class FString TextureBinding_GetUrlValue(struct FOdyUITextureBinding& TextureBinding);
	static bool TextureBinding_HasTexture(struct FOdyUITextureBinding& TextureBinding);
	static void TextureBinding_RemoveDelegate(struct FOdyUITextureBinding& TextureBinding, TDelegate<void(class UTexture* OldValue, class UTexture* NewValue)> Delegate);
	static void TextureBinding_SetSoftValue(struct FOdyUITextureBinding& TextureBinding, TSoftObjectPtr<class UTexture> SoftTexture);
	static void TextureBinding_SetTexture2DValue(struct FOdyUITextureBinding& TextureBinding, class UTexture2D* Texture);
	static void TextureBinding_SetTextureValue(struct FOdyUITextureBinding& TextureBinding, class UTexture* Texture);
	static void TextureBinding_SetUrlValue(struct FOdyUITextureBinding& TextureBinding, const class FString& URL);
	static void TextureBinding_Unbind(struct FOdyUITextureBinding& TextureBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUITextureBindingFunctionLibrary">();
	}
	static class UOdyUITextureBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUITextureBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUITextureBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUITextureBindingFunctionLibrary");
static_assert(sizeof(UOdyUITextureBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUITextureBindingFunctionLibrary");

// Class OdyUI.OdyUITimespanBindingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOdyUITimespanBindingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void TimespanBinding_AddDelegate(struct FOdyUITimespanBinding& TimespanBinding, TDelegate<void(const struct FTimespan& OldValue, const struct FTimespan& NewValue)> Delegate, bool bExecuteNow);
	static void TimespanBinding_BindRichTextBlockText(struct FOdyUITimespanBinding& TimespanBinding, class URichTextBlock* RichTextBlock, const TMap<ETimespanBindingDisplayOption, class FText>& TextFormats);
	static void TimespanBinding_BindTextBlockText(struct FOdyUITimespanBinding& TimespanBinding, class UTextBlock* TextBlock, const TMap<ETimespanBindingDisplayOption, class FText>& TextFormats);
	static struct FTimespan TimespanBinding_GetValue(const struct FOdyUITimespanBinding& TimespanBinding);
	static bool TimespanBinding_IsInitialized(struct FOdyUITimespanBinding& TimespanBinding);
	static void TimespanBinding_RemoveDelegate(struct FOdyUITimespanBinding& TimespanBinding, TDelegate<void(const struct FTimespan& OldValue, const struct FTimespan& NewValue)> Delegate);
	static void TimespanBinding_SetValue(struct FOdyUITimespanBinding& TimespanBinding, const struct FTimespan& Timespan);
	static void TimespanBinding_Unbind(struct FOdyUITimespanBinding& TimespanBinding, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyUITimespanBindingFunctionLibrary">();
	}
	static class UOdyUITimespanBindingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyUITimespanBindingFunctionLibrary>();
	}
};
static_assert(alignof(UOdyUITimespanBindingFunctionLibrary) == 0x000008, "Wrong alignment on UOdyUITimespanBindingFunctionLibrary");
static_assert(sizeof(UOdyUITimespanBindingFunctionLibrary) == 0x000028, "Wrong size on UOdyUITimespanBindingFunctionLibrary");

// Class OdyUI.UIWidget_InputKeySelector
// 0x0008 (0x02E8 - 0x02E0)
class UUIWidget_InputKeySelector : public UUserWidget
{
public:
	class UOdyInputKeySelector*                   InputKeySelector;                                  // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidget_InputKeySelector">();
	}
	static class UUIWidget_InputKeySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWidget_InputKeySelector>();
	}
};
static_assert(alignof(UUIWidget_InputKeySelector) == 0x000008, "Wrong alignment on UUIWidget_InputKeySelector");
static_assert(sizeof(UUIWidget_InputKeySelector) == 0x0002E8, "Wrong size on UUIWidget_InputKeySelector");
static_assert(offsetof(UUIWidget_InputKeySelector, InputKeySelector) == 0x0002E0, "Member 'UUIWidget_InputKeySelector::InputKeySelector' has a wrong offset!");

// Class OdyUI.UIWidget_SoftwareCursor
// 0x0018 (0x02F8 - 0x02E0)
class UUIWidget_SoftwareCursor : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClicked();
	void OnEnterInteractableWidget();
	void OnLeaveInteractableWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidget_SoftwareCursor">();
	}
	static class UUIWidget_SoftwareCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWidget_SoftwareCursor>();
	}
};
static_assert(alignof(UUIWidget_SoftwareCursor) == 0x000008, "Wrong alignment on UUIWidget_SoftwareCursor");
static_assert(sizeof(UUIWidget_SoftwareCursor) == 0x0002F8, "Wrong size on UUIWidget_SoftwareCursor");

// Class OdyUI.OdyInputKeySelector
// 0x07E8 (0x0960 - 0x0178)
class UOdyInputKeySelector final : public UWidget
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           WidgetStyle;                                       // 0x0180(0x03F0)(Edit, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        TextStyle;                                         // 0x0570(0x0340)(Edit, NativeAccessSpecifierPublic)
	struct FInputChord                            SelectedKey;                                       // 0x08B0(0x0020)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Margin;                                            // 0x08D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   KeySelectionText;                                  // 0x08E0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   NoKeySpecifiedText;                                // 0x08F0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAllowModifierKeys;                                // 0x0900(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowGamepadKeys;                                 // 0x0901(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_902[0x6];                                      // 0x0902(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           EscapeKeys;                                        // 0x0908(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           ClearSelectedKeys;                                 // 0x0918(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeySelected;                                     // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsSelectingKeyChanged;                           // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_948[0x18];                                     // 0x0948(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Click();
	void OnIsSelectingKeyChanged__DelegateSignature();
	void OnKeySelected__DelegateSignature(const struct FInputChord& SelectedKey_0);
	void SetAllowGamepadKeys(bool bInAllowGamepadKeys);
	void SetAllowModifierKeys(bool bInAllowModifierKeys);
	void SetClearSelectedKeys(const TArray<struct FKey>& InKeys);
	void SetEscapeKeys(const TArray<struct FKey>& InKeys);
	void SetKeySelectionText(const class FText& InKeySelectionText);
	void SetNoKeySpecifiedText(const class FText& InNoKeySpecifiedText);
	void SetSelectedKey(const struct FInputChord& InSelectedKey);
	void SetTextBlockVisibility(const ESlateVisibility InVisibility);

	bool GetIsSelectingKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdyInputKeySelector">();
	}
	static class UOdyInputKeySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOdyInputKeySelector>();
	}
};
static_assert(alignof(UOdyInputKeySelector) == 0x000010, "Wrong alignment on UOdyInputKeySelector");
static_assert(sizeof(UOdyInputKeySelector) == 0x000960, "Wrong size on UOdyInputKeySelector");
static_assert(offsetof(UOdyInputKeySelector, WidgetStyle) == 0x000180, "Member 'UOdyInputKeySelector::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, TextStyle) == 0x000570, "Member 'UOdyInputKeySelector::TextStyle' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, SelectedKey) == 0x0008B0, "Member 'UOdyInputKeySelector::SelectedKey' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, Margin) == 0x0008D0, "Member 'UOdyInputKeySelector::Margin' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, KeySelectionText) == 0x0008E0, "Member 'UOdyInputKeySelector::KeySelectionText' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, NoKeySpecifiedText) == 0x0008F0, "Member 'UOdyInputKeySelector::NoKeySpecifiedText' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, bAllowModifierKeys) == 0x000900, "Member 'UOdyInputKeySelector::bAllowModifierKeys' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, bAllowGamepadKeys) == 0x000901, "Member 'UOdyInputKeySelector::bAllowGamepadKeys' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, EscapeKeys) == 0x000908, "Member 'UOdyInputKeySelector::EscapeKeys' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, ClearSelectedKeys) == 0x000918, "Member 'UOdyInputKeySelector::ClearSelectedKeys' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, OnKeySelected) == 0x000928, "Member 'UOdyInputKeySelector::OnKeySelected' has a wrong offset!");
static_assert(offsetof(UOdyInputKeySelector, OnIsSelectingKeyChanged) == 0x000938, "Member 'UOdyInputKeySelector::OnIsSelectingKeyChanged' has a wrong offset!");

}

